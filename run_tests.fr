TARGET: Backend : .Aarch64;

fn driver(vtable: *ImportVTable) void #export = {
    c := cli_args();
    start := false;
    did := 0;
    for c {s: CStr|
        s : Str = s.str();
        continue :: local_return;
        if not(start) {|
            if(!(s == "--"), => { continue(); });
            start = true;
        };
        did += 1;
        @switch(s) {
            @case("--") => ();
            @case("arm") => {
                println("=== Aarch64 Jit ===");
                run_jit(vtable, .Aarch64);
            };
            @case("cl") => {
                println("=== Cranelift Jit ===");
                run_jit(vtable, .Cranelift);
            };
            @case("llvm") => run_llvm(vtable);
            @case("examples") => run_examples(vtable);
            @default fn(_: Str)=> {
                @println("Unknown argument '%'", s);
                println(HELP);
            };
        };
    };
    
    if(did <= 1, => println(HELP));
    HELP :: "start with \"-- \" to seperate from compiler args, then any of [arm, cl, llvm, examples]";

    // TODO: do this in the loop
    //__temp_alloc.reset_retaining_capacity();
    // TODO: see if it breaks if you run new ones in thier own namespaces in the same compiler instance as ^ 
}

fn run_examples(vtable: *ImportVTable) void = {
    fork_run_main(vtable, "examples/bf.fr");
    fork_run_main(vtable, "examples/hello.fr");
    
    // These ones I don't run because they're interactive but just make sure it compiles so it doesn't rot
    check_main_compiles(vtable, "examples/raw_terminal.fr");
    check_driver_compiles(vtable, "examples/farm_game.fr");  // the game runs in the driver 
    
    // TODO: #import_std uses relative paths. 
    chdir("examples/lox".maybe_borrow_cstr(temp()));
    fork_run_main(vtable, "main.fr");
    chdir("../../".maybe_borrow_cstr(temp()));
    
    __temp_alloc.reset_retaining_capacity();
     
    // TODO: #import_std uses relative paths. 
    chdir("compiler".maybe_borrow_cstr(temp()));
    check_driver_compiles(vtable, "first.fr");
    s__ := fork_and_catch(temp()) {|
        src := "#include_std(\"core.fr\");".clone(temp());
        src&.read_and_push("main.fr");
        comp := vtable.new_with_src(src.items(), TARGET);
        run_tests(vtable, comp);
    };
    // TODO: @assert
    //println(s__._1.items());
    //println(s__._2.items());
    assert(s__._0, "compiler tests failed");
    println("- ran compiler tests");
    chdir("../".maybe_borrow_cstr(temp()));
    
    mandelbrot(vtable);
    set_colour(250, 150, 200);
    println("ALL EXAMPLES PASSED!");
    unset_colour();
}

fn run_jit(vtable: *ImportVTable, kind: Backend) void = {
    comp := {vtable.init_compiler}(kind);
    // TODO: (before fn with) can't inline the arg without an extra @as, because it thinks you're passing named args. 
    c := vtable.with(comp);
    load_lang_tests(c);
    run_sequential(c) {c, tests|
        for(tests) {fid|
            ptr := c.get_jitted(fid);
            f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
            f();
        };
    };
}

// TODO: this is a dumb way to do this, when they're failing, ReportCrash pegs a core. 
fn run_llvm(vtable: *ImportVTable) void = {
    println("=== Llvm Aot ===");
    comp := {vtable.init_compiler}(.Aarch64);
    c := vtable.with(comp);
    load_lang_tests(c);
    run_sequential(c) {c, tests|
        ir_text := {c.vtable.emit_llvm}(c, temp(), tests, .TestRunnerMain);
        out := open_temp_file();
        for(ir_text&){bucket|
            out.fd&.write(bucket);
        };
        @println("Write llvm ir to %", out&.s_name());
        
        args: List(Str) = list(temp());
        args&.push("-x");
        args&.push("ir");
        //args&.push("-O2");
        args&.push(out&.s_name());
        success := run_cmd_blocking(CLANG_PATH, args.items()); 
        assert(success, "opt failed");
        
        args: List(Str) = list(temp());
        success := run_cmd_blocking("a.out", args.items()); 
        assert(success, "test failed");
        
        out.remove();
    };
}

NO_FORK :: false;

fn run_sequential(c: CompCtx, const inner_run: @Fn(c: CompCtx, fns: Slice(FuncId)) void) void = {
    run :: fn(ff: Slice(FuncId)) bool => {
        if NO_FORK {|
            inner_run(c, ff);
            true
        }{|
            s__ := fork_and_catch(temp(), => inner_run(c, ff));
            if ff.len.eq(1).and(not(s__._0)) {|
                println(s__._1.items());
                println(s__._2.items());
            };
            s__._0
        }
    };
    start := timestamp();
    
    tests := c.get_tagged("test");
    
    chunk_size :: 10;
    failing: List(FuncId) = list(temp());
    i := 0;
    while(=> i.lt(tests.len)) {|
        end := i.add(chunk_size).min(tests.len);
        fns := tests.slice(i, end);
        i += chunk_size;
        if(run(fns)) {|
            set_colour(0, 200, 0);  
            for(fns){fid|
                name := {c.vtable.get_string}(c.data, {c.vtable.get_function_name}(c.data, fid));
                @print("%, ", name);
            };
            unset_colour();
        }{|
            failing&.push_all(fns);
        };
    };
    
    fails := 0;
    for(failing.items()) {fid|
        s: Slice(FuncId) = (ptr = fid&, len = 1);
        if(run(s), => set_colour(0, 200, 0)){|
            fails += 1;
            set_colour(250, 0, 0);
        };
        name := {c.vtable.get_string}(c.data, {c.vtable.get_function_name}(c.data, fid));
        @print("%, ", name);
        unset_colour();
    };
    
    end := timestamp();
    
    set_colour(250, 150, 200);
    if(fails.eq(0)) {|
        @println( "\nPASSED ALL % tests. % ms.", tests.len, end.sub(start));
    } {|
        @println("\nFailed %/% tests. % ms.", fails, tests.len, end.sub(start));
    };
    unset_colour();
}

fn load_lang_tests(comp: CompCtx) void = {
    path := "tests".maybe_borrow_cstr(temp());
    found: List(List(u8)) = list(20, temp()); // LEAK
    walk_directory(path) {entry|
        // TODO: recurse with another list if .Directory
        if(eq(@as(u8) entry.d_type, @as(u8) DirEntType.File)) {|
            p := @format("%/%", path, entry.name()) temp();
            found&.push(p);
        };
    };
    
    file := {comp.vtable.add_file}(comp.data, "lib", "#include_std(\"core.fr\");");
    all_stmts := {comp.vtable.parse_stmts}(comp.data, file&).unwrap();
    ::List(FatStmt);
    all_stmts := all_stmts.clone(temp());
    
    each(found){name|
        continue :: local_return;
        if(not(name.items().ends_with(".fr")), => continue());
        
        src := temp().read_to_string(name.items());
        file := {comp.vtable.add_file}(comp.data, name.items(), src.items());
        stmts := {comp.vtable.parse_stmts}(comp.data, file&).unwrap();
        all_stmts&.push_all(stmts);
    };
    {comp.vtable.make_and_resolve_and_compile_top_level}(comp.data, all_stmts.items()).unwrap();
}

fn run_tests(vtable: *ImportVTable, comp: Compiler) i64 = {
    c := vtable.with(comp);
    tests := c.get_tagged("test");
    
    for(tests) {fid|
        func := {vtable.get_function}(comp, fid);
        name := {vtable.get_string}(comp, {vtable.get_function_name}(comp, fid));
        @print("%, ", name);
        ptr := c.get_jitted(fid);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
    };
    println("");
    tests.len
    
}

fn mandelbrot(vtable: *ImportVTable) void = {
    // Note: can't import core at the end because you need slice type to be shared with the compiler 
    //       before '::' blocks in the program try to run because they might use !slice. 
    src := "#include_std(\"core.fr\");".clone(temp());
    src&.read_and_push("examples/mandelbrot.fr");
    f := jit_from_source(vtable, src&.items(), "render");
    f := assume_types_fn(Arg = void, Ret = List(u8), ptr = f);
    mandelbrot := f();
    
    pass_out_err := fork_and_catch(temp()) {|
        arg := "util/mandelbrot.lua";
        HACK_LUA_PATH :: "/usr/local/bin/luajit";
        exec_cmd(HACK_LUA_PATH, (ptr = arg&, len = 1));
    };
    assert(pass_out_err._0, "lua failed");
    assert_eq(mandelbrot.items(), pass_out_err._1.items());
    println("- mandelbrot.fr == mandelbrot.lua");
}

fn fork_run_main(vtable: *ImportVTable, filepath: Str) void = {
    s__ := fork_and_catch(temp()) {|
        src := "#include_std(\"core.fr\");".clone(temp());
        src&.read_and_push(filepath);
        f := jit_from_source(vtable, src&.items(), "main");
        f := assume_types_fn(Arg = void, Ret = void, ptr = f);
        f();
    };
    // TODO: @assert
    assert(s__._0) {() List(u8)|
        s: List(u8) = list(0, temp());
        println(s__._1.items());
        println(s__._2.items());
        @fmt(s&, "failed to compile %", filepath);
        s
    };
    @println("- ran %:main", filepath);
}

fn check_main_compiles(vtable: *ImportVTable, filepath: Str) void = {
    src := "#include_std(\"core.fr\");".clone(temp());
    src&.read_and_push(filepath);
    f := jit_from_source(vtable, src&.items(), "main");
    @println("- compiled %:main", filepath);
}

fn check_driver_compiles(vtable: *ImportVTable, filepath: Str) void = {
    src := "#include_std(\"core.fr\");".clone(temp());
    src&.read_and_push(filepath);
    f := jit_from_source(vtable, src&.items(), "driver");
    @println("- compiled %:driver", filepath);
}

fn jit_from_source(vtable: *ImportVTable, src: Str, function_name: Str) rawptr #leak = {
    comp := vtable.new_with_src(src, TARGET);
    name := {vtable.intern_string}(comp, function_name);
    fid := {vtable.find_unique_func}(comp, name).unwrap();
    ptr := vtable.with(comp).get_jitted(fid);
    ptr
}
