HUSH :: @static(bool) false;

S :: const_slice;

bins :: @S(
    ("examples/import_c/cc.fr",     "target/cc.out"),
    ("backend/meta/qbe_frontend.fr", "target/q.out"),
    ("backend/meta/test.fr",         "target/r.out"),
    ("examples/import_wasm/run.fr",  "target/w.out"),
);

// TODO: pass in ./cc.out and ./w.out instead of assuming
test_cmds :: @S(
    @S("./target/f.out", "compiler/test.fr"),
    @S("./target/r.out", "all", "-bin", "./target/q.out", "-jit"),
    @S("./target/r.out", "all", "-bin", "./target/q.out", "-w"),
    @S("./target/r.out", "all", "-bin", "./target/q.out", "-frc"),
    @S("./target/r.out", "all", "-bin", "./target/q.out", "-frc_inlinable"),
    @S("./target/f.out", "backend/test/folding.fr"),
    @S("./target/f.out", "tests/exe/sys.fr"),
    @S("./target/f.out", "examples/default_driver.fr", "build", "examples/60fps.fr", "-dynamiclib"),
    @S("./target/f.out", "examples/import_c/test/test.fr", "-w", "target/w.out"),
    @S("./target/f.out", "examples/chess/perft.fr", "-fast", "-hush"),
    @S("./target/f.out", "examples/os/build.fr"),
    @S("./target/f.out", "tests/exe/cli_args.fr", "a", "b", "c", "d"),
    @S("./target/f.out", "examples/import_c/test/ffi.fr"),
    @S("./target/f.out", "examples/import_c/test/test.fr"),
);

with_deps :: @S(
    @S("./target/r.out", "all", "-bin", "./target/q.out", "-cc", "-force_linker"), // dep:clang
    @S("./target/r.out", "all", "-bin", "./target/q.out"),  // dep:clang
    @S("./target/f.out", "examples/lox/test.fr", "-pass", "-hush"), // dep:lox
    @S("./target/f.out", "examples/import_wuffs/test.fr"),
    @S("./target/f.out", "backend/test/generate.fr"),
);

with_deps_macos_arm_only :: @S(
    // TODO: linux: need to transcribe signal.h
    @S("./target/f.out", "tests/external/lua.fr"),  // dep:lua
    // TODO: need to write config.h for non-macos-arm
    @S("./target/f.out", "tests/external/tcc.fr", "-ddc"),  // dep:tcc dep:clang
);

with_deps_skip_rv :: @S(
    // TODO: rv: lzip, lzma, xz: Expected (RTmp:31 != RTmp:31
    //       rv: json: FAIL test_wuffs_strconv_parse_number_f64_options
    @S("./target/f.out", "tests/external/wuffs.fr"),  // dep:wuffs
    @S("./target/f.out", "tests/exe/wasm.fr"),
);

fn driver(vtable: *ImportVTable) void = {
    c := cli_args();
    for c {s: CStr|
        do_it(vtable, s.str());
    };
}

do_it :: fn(vtable: *ImportVTable, s: Str) void = {
    #use("@/lib/sys/process.fr");
    #use("@/lib/sys/fs.fr");
    driver_path := "examples/default_driver.fr";
    franca_path := get_executable_path(temp());  // TODO: cli arg to set this 
        @switch(s) {
            @case("--") => ();
            @case("strap") => {
                if IS_BOOTSTRAPPING {
                    run_boot(vtable);
                    franca_path = "./target/franca.out";
                };
                sh(@slice(franca_path, "run_tests.fr", "boot2"));  // note: re-exec not recurse until :updateboot
                sh(@slice("./target/f.out", driver_path, "build", "compiler/main.fr", "-o", "target/release/f.out", 
                    "-unsafe", "-keep-names", "-debug-info"));
            };
            @case("-hush") => {
                HUSH[] = true;
            };
            @case("boot") => run_boot(vtable);
            @case("github") => {
                make_dirs_or_crash("target/release");
                run_boot(vtable);
                sh(@slice("./target/franca.out", "run_tests.fr", "core"));
            };
            @case("boot2") => {
                make_dirs_or_crash("target/release");
                // f0 - new source built by old compiler
                // f  - new source built by new compiler
                sh(@slice(franca_path, driver_path, "build", "compiler/main.fr", "-o", "./target/f0.out"));
                sh(@slice("./target/f0.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f1.out"));
                // TODO: f1 is an extra layer that started being required when i did staticmemmove
                //       should debug why and get rid of it if possible 
                // TODO: now ./boot/temporary/macos-amd64.sh crashes if you don't -keep-names here ?? but everything else is fine. 
                sh(@slice("./target/f1.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f.out", "-keep-names"));
                // one more to bump __driver_abi_version and stop emitting for old tls abi
                sh(@slice("./target/f.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f.out", "-keep-names"));
            };
            @case("core") => {
                sh(@slice(franca_path, "run_tests.fr", "boot2"));
                println("=== re-exec ===");
                sh(@slice("./target/f.out", "run_tests.fr", "run"));
            };
            @case("release") => build_release(vtable);
            @case("run") => {
                // TODO: instead of hardcoding ./target/f.out use get_executable_path so you can run this directly without rebootstrapping
                //       tho then its a source of confusion if you run with the release binary and the nrewrite it have way through whe nit build_release
                for bins { code, dest |
                    sh(@slice("./target/f.out", driver_path, "build", code, "-o", dest, "-keep-names"));
                };
                
                make_dirs_or_crash("examples/web/target");
                
                for test_cmds { cmd | 
                    sh(cmd);
                };
                
                ::import("@/examples/testing.fr");
                // TODO: aoc/2025 too
                files := collect_with_extension("examples/aoc/2024", ".fr").unwrap();
                run_tests_main_threaded(Ty(Str, Str), Str, (franca_path, driver_path), files.items(), fn(_, a) = a[], fn(ctx, file) = {
                    franca_path, driver_path := ctx;
                    ok, out, err := exec_and_catch(franca_path, @slice(driver_path, "build", @tfmt("examples/aoc/2024/%", file[]), "-o", "/dev/null"), temp());
                    (ok, out, err, "")
                });
                
                do_it(vtable, "release");
                
                for with_deps { cmd | 
                    sh(cmd);
                };
                ci := get_environment_variable("GITHUB_REPOSITORY").is_some();

                if query_current_arch() != .rv64 {
                    for(with_deps_skip_rv, fn(it) => sh(it));
                };
                if query_current_os() == .macos && query_current_arch() == .aarch64 {
                    for(with_deps_macos_arm_only, fn(it) => sh(it));
                };
                
                // If running linux with libc, can still run the compiler built without libc and make sure it repros. 
                @if(!IS_BOOTSTRAPPING)
                if current_os() == .linux && is_linking_libc() {
                    // TODO: have default_driver do -syscalls the same way as build_release so sta0==target/release/franca-linux-x-x-sta
                    sta0, sta1 := ("target/sta0.out", "target/sta1.out");
                    sh(@slice("./target/f.out", "examples/default_driver.fr", "build", "compiler/main.fr", "-unsafe", "-syscalls", "-o", sta0));
                    _ := Syscall'remove(sta1.as_cstr());
                    sh(@slice(sta0, "examples/default_driver.fr", "build", "compiler/main.fr", "-unsafe", "-syscalls", "-o", sta1));
                    diff(sta0, sta1);
                    println("OK: linux_native_no_libc");
                } else {
                    println("SKIP: linux_native_no_libc(): native target is not linux+libc");
                };
                
                    if current_os() == .linux {
                        sh(@slice("./target/f.out", "tests/external/hare.fr"));
                    };
                if !ci {
                    // TODO: this hangs occasionally :(
                    //if query_current_os() == .macos && query_current_arch() == .aarch64 {
                    //    sh(@slice("./target/f.out", "examples/os/build.fr", "-vzf", "-smp", "2", "-append", "sudoku;quit;"));
                    //};
                };
            };
            @default => @eprintln("IGNORE: %", s);
        };
};

build_release :: fn(vtable: *ImportVTable) void = {
    @if(IS_BOOTSTRAPPING) return();
    make_dirs_or_crash("target/release");
    
    unsafe := true;
    keep_names := false;
    
    opts := vtable.default_build_options();
    if unsafe {
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    opts.retain_function_names = keep_names;
    opts.debug_info = false;  // TODO: this being true breaks repro because it embeds source with #comptime_addr
    c := new_with_src(vtable, """#include_std("lib/core.fr");#include_std("compiler/main.fr");""", opts);
    c := vtable.with(c);
    m := @ref zeroed(Qbe.Module);
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, c.vtable, (
        arch = .aarch64, os = .macos, type = .CachedEarly, 
        exe_debug_symbol_table = opts.retain_function_names, 
    ));
    fid := c.get_unique_named("main").expect("'main' when building the compiler");
    chunks := {c.vtable.emit_qbe_included}(QbeModule.raw_from_ptr(m), c&, @slice(fid), .WrapMain);
    bytes := concat(chunks&, temp());
    c'vtable'drop_qbe_module(QbeModule.raw_from_ptr(m));
    
    ;{
        // don't have to do this. just a little test that dump doesn't crash on nontrivial program.
        out := u8.list(bytes.len, temp());
        import("@/backend/meta/dump_bin.fr")'dump(out&, bytes);
    };

    targets := @S((Os.macos, Arch.aarch64), (.macos, .x86_64), (.linux, .aarch64), (.linux, .x86_64), (.linux, .rv64));
    
    // TODO: this is still takes like 200ms each. 
    //       it would be nice if i could just compile functions once per architecture if they don't depend on varargs abi. 
    for targets { os, arch |
        m := c'vtable'get_alloc(c.data).box_uninit(QbeModule);  // for good luck
        init_default_module_dyn(m, c.vtable, (
            arch = arch, os = os, type = .Exe, 
            exe_debug_symbol_table = opts.retain_function_names, 
        ));
        
        ::Result(*Incremental.Header, Str);
        header: *Incremental.Header = or check(bytes) { e |
            @panic("generated an invalid frc file: %", e)
        };
        compile_all_symbols(header, m);
        
        // TODO: this is confusing. 
        //       the module has its own debug info so need to not touch that 
        //       but do need to fill the import of base_address so franca_runtime_init can do relocations. 
        seal_debug_info(m, "", false, "");  // :AnnoyingDoubleSeal
        
        chunks := {vtable.finish_qbe_module}(QbeModule.raw_from_ptr(m));
        
        bytes := concat(chunks&, temp());
        arch := @match(arch) {
            fn x86_64() => "amd64";
            fn aarch64() => "arm64";
            @default => @tfmt("%", arch);
        };
        @println("%-%", arch, os);
        path := @tfmt("target/release/franca-%-%", os, arch);
        write_entire_file_or_crash(path, bytes);
        if os == .linux {
            import("@/backend/elf/emit.fr")'patch_out_interp_header(bytes);
            write_entire_file_or_crash(@tfmt("%-sta", path), bytes);
        };
        
        c'vtable'drop_qbe_module(QbeModule.raw_from_ptr(m));
    };
};

#use("@/backend/lib.fr");

// :UpdateBoot this can go away if i replace boot/franca-macos-arm64
fn run_boot(vtable: *ImportVTable) void = {
    make_dirs_or_crash("target/out");
    make_dirs_or_crash("target/franca");
    stage0_driver(vtable);
    rename(@as(CStr) "a.out", @as(CStr) "target/franca/b.out");
    sh(@slice("./target/franca/b.out", "examples/default_driver.fr", "build", "compiler/main.fr", "-o", "target/franca.out"));
    println("ok!");
}

fn stage0_driver(vtable: *ImportVTable) void = {
    opts := vtable.default_build_options();
    opts.safety_checks&.insert(SafetyCheck.Bounds, false);
    opts.safety_checks&.insert(SafetyCheck.DebugAssertions, false);
    
    path := "compiler/main.fr";
    src := "\n#include_std(\"lib/core.fr\");\n#include_std(\"compiler/main.fr\");";
    c := vtable.with(vtable.new_with_src(src, path, opts));
    fid := c.get_unique_named("main").expect("did not find exactly one function called 'main'");
    fid := @slice(fid);
    
    // Allocating more than size_of(QbeModule) need so it's fine that it shrank since boot was compiled (becuase we stopped using pthread_mutex_t). 
    m := u8.raw_from_ptr(page_allocator.alloc_zeroed(u8, 4096).as_ptr());
    goal: QbeTargetEnv = (os = query_current_os(), arch = query_current_arch(), type = .Exe);
    {vtable.init_default_qbe_module}(m, QbeTargetEnv.raw_from_ptr(goal&));
    
    #use("@/lib/collections/bucket_array.fr");
    F :: @FnPtr(mm: rawptr, comp: *CompCtx, fns: [] FuncId, entry: ProgramEntry) BucketArray(u8);
    emit_qbe_included_old := bit_cast_unchecked(rawptr, F, c.vtable.emit_qbe_included_old);
    
    bytes := emit_qbe_included_old(m, c&, fid, .WrapMain);
    asm_out: CStr = "a.out"; 
    ir_out := open_trunc(asm_out).unwrap(); 
    for bytes& { bucket |
        ir_out&.write(bucket) || panic("write failed");
    };
    ir_out.Syscall'close();
}

fn sh(a: []Str) void = {
    show :: fn() => {
        for a { a |
            @print("% ", a);
        };
        println("");
    };
    show();
    ok := if HUSH[] {
        ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
        if !ok {
            print(out.items());
            print(err.items());
        };
        ok
    } else {
        run_cmd_blocking(a[0], a.slice(1, a.len))
    };
    if !ok {
        print("Failed to run: ");
        show();
        panic("sh failed");
    };
}

diff :: fn(path0: Str, path1: Str) void = {
    a := read_entire_file_or_crash(temp(), path0);
    b := read_entire_file_or_crash(temp(), path1);
    @assert(a == b, "diff % %", path0, path1);
};

#use("@/lib/sys/subprocess.fr");
