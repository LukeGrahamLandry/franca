HUSH :: @static(bool) false;

fn driver(vtable: *ImportVTable) void = {
    c := cli_args();
    start := false;
    did := 0;
    franca_path := get_executable_path(temp());  // TODO: cli arg to set this 
    driver_path := "examples/default_driver.fr";
    made_test_file_this_time := false;
    made_driver_this_time    := false;
    use_x64 := false;
    for c {s: CStr|
        s : Str = s.str();
        continue :: local_return;
        if !start {
            if(!(s == "--"), => { continue(); });
            start = true;
        };
        did += 1;
        @switch(s) {
            @case("--") => ();
            @case("-hush") => {
                HUSH[] = true;
            };
            @case("-x64") => {
                use_x64 = true;
            };
            @case("gen") => print(gen_test_program(vtable));
            @case("boot") => run_boot(vtable);
            @case("github") => {
                run_boot(vtable);
                sh(@slice("mkdir", "-p", "target/release"));
                path := "target/release/franca-macos-arm64";
                sh(@slice("touch", path));
                sh(@slice("chmod", "+x", path));
                sh(@slice("./b.out", "driver.dylib", "build", "compiler/other_main.fr", "-aot", "self", "-unsafe", "-o", path, "-arch", "aarch64", "-os", "macos"));
                path := "target/release/franca-macos-amd64";
                sh(@slice("touch", path));
                sh(@slice("chmod", "+x", path));
                sh(@slice("./b.out", "driver.dylib", "build", "compiler/other_main.fr", "-aot", "self", "-unsafe", "-o", path, "-arch", "x86_64", "-os", "macos"));
            };
            @default => {
                if s.starts_with("aot-") {
                    s.ptr = s.ptr.offset(4);
                    s.len -= 4;
                    if !made_driver_this_time {
                        made_driver_this_time = true;
                        path := "driver.dylib"; // TODO: don't stomp something good
                        sh(@slice("touch", path)); // TODO: don't be garbage
                        cmd := @slice(franca_path, driver_path, "build", driver_path, "-aot", "legacy", "-dynamiclib", "-o", path);
                        sh(cmd);
                        driver_path = path;
                    };
                    
                    path := "target/franca/compiler_tests.g.fr";
                    if !made_test_file_this_time {
                        sh(@slice("touch", path)); // TODO: don't be garbage
                        write_entire_file(path, gen_test_program(vtable)) || @panic("failed to write file %", path);
                        made_test_file_this_time = true;
                    };
                    
                    cmd := Str.list(temp());
                    cmd&.push_all(@slice(franca_path, driver_path, "run", path, "-aot", s));
                    if use_x64 {
                        cmd&.push_all(@slice("-arch", "x86_64"));
                    };
                    cmd := cmd.items();
                    sh(cmd);
                    for run_main { path | 
                        cmd[3] = path;
                        sh(cmd);
                    };
                    cmd[2] = "build";
                    for compile_only { path | 
                        cmd[3] = path;
                        sh(cmd);
                    };
                    
                    cmd[3] = "backend/meta/qbe_frontend.fr";
                    sh(cmd);
                    sh(@slice("touch", "target/out/driver.c"));
                    sh(@slice(franca_path, "backend/meta/test.fr", "all", "-v", "-bin=./a.out")); // TODO: pass -x63
                } else {
                    @println("Unknown argument '%'", s);
                    println(HELP);
                };
            };
        };
    };
    
    if(did <= 1, => println(HELP));
    // TODO: have -verbose instead of -hush. 
    //       scan for - flags first so it's less annoying to toggle them. 
    HELP :: """
    > This is the build script for the Franca compiler.
    > If you are trying to run a different Franca program, see examples/default_driver.fr instead.
    
    start with '--' to seperate from compiler arguments, then any of the following:

    aot-self, aot-llvm, aot-legacy: run tests on a specific backend. 
    boot: recompile using the old version in ./boot and then run some tests. 
    gen: output the code that would run all the mini-tests. 
    -hush: later commands will not output as much logging information.
    """.undent(4, ast_alloc());

    // TODO: do this in the loop
    //reset_temporary_storage();
    // TODO: see if it breaks if you run new ones in thier own namespaces in the same compiler instance as ^ 
}

compile_only :: @const_slice(
    "examples/sudoku.fr",  // runs tests at comptime 
    "examples/raw_terminal.fr",  // interactive
    // TODO: test it
    "examples/count.fr", "examples/bloat.fr", "examples/c_bindgen.fr", 
    "examples/dump_macho.fr", "examples/macho_loader.fr", "examples/import_wasm/convert.fr",
    "examples/mandelbrot.fr", "examples/parse_dtrace.fr",
    // has deps
    //"tests/need_llvm/x64_encoding.fr",  // TODO: `non-8-aligned field _0` so can't aot
    // is driver
    // "examples/edit.fr" "examples/farm_game.fr" "examples/default_driver.fr" "examples/60fps.fr"
    // interactive at comptime
    // "examples/soft_draw.fr" 
);

run_main :: @const_slice(
    //"examples/lox/lox_main.fr", // TODO: doesn't work on llvm because of Expr:Switch extension
    "examples/toy/bf.fr", "examples/toy/hello.fr", "examples/toy/rot_cypher.fr", "examples/toy/where_am_i.fr",
);

#include_std("backend/lib.fr");
#include_std("compiler/ast_external.fr");  

// TODO: add test for repro-builds. 
fn run_boot(vtable: *ImportVTable) void = {
    arch, os := {vtable.comptime_arch}();
    assert(arch == .aarch64 && os == .macos, "expected macos-arm (TODO: run_tests:github for other targets)");
    
    sh(@slice("mkdir", "-p", "target/out"));
    sh(@slice("mkdir", "-p", "target/franca"));
    
    sh(@slice("touch", "a.out"));
    stage0_driver(vtable);
    sh(@slice("chmod", "+x", "a.out"));
    sh(@slice("cp", "a.out", "b.out"));
    sh(@slice("./b.out", "examples/default_driver.fr", "build", "compiler/other_main.fr", "-aot", "self", "-o", "b.out"));
    sh(@slice("./b.out", "run_tests.fr", "--", "-hush", "aot-self", "aot-legacy")); // , "examples-no-deps")); 
}

fn stage0_driver(vtable: *ImportVTable) void = {
    opts := vtable.default_build_options();
    opts.safety_checks&.insert(SafetyCheck.Bounds, false);
    opts.safety_checks&.insert(SafetyCheck.DebugAssertions, false);
    opts.implicit_context_runtime = true;
    
    path := "compiler/other_main.fr";
    src := "\n#include_std(\"lib/core.fr\");\n#include_std(\"compiler/other_main.fr\");";
    c := vtable.with(vtable.new_with_src(src, path, opts));
    fid := c.get_unique_named("main").expect("did not find exactly one function called 'main'");
    fid := @slice(fid);
    
    m := @uninitialized QbeModule;
    goal: QbeTargetEnv = (os = .macos, arch = .aarch64, type = .Exe);
    {vtable.init_default_qbe_module}(QbeModule.raw_from_ptr(m&), QbeTargetEnv.raw_from_ptr(goal&));
    
    bytes := {c.vtable.emit_qbe_included}(QbeModule.raw_from_ptr(m&), c&, fid, .WrapMain);
    
    asm_out := "a.out".sym().c_str(); 
    ir_out := open_trunc(asm_out).unwrap(); 
    for bytes& { bucket |
        ir_out&.write(bucket) || panic("write failed");
    };
    
    args: List(Str) = list(temp());
    ir_out.close();
    args&.push("-s");
    args&.push("-");
    args&.push("a.out");
    success := run_cmd_blocking("codesign", args.items()); 
    assert(success, "sign failed");
}

fn sh(a: []Str) void = {
    @println("%", a);
    ok, out, err := fork_and_catch(temp()) {
        exec_cmd(a[0], a.slice(1, a.len)) 
    };
    if !ok || !HUSH[] {
        print(out.items());
        print(err.items());
    };
    if !ok {
        @println("Failed to run: %", a);
        exit(1);
    };    
}

fn gen_test_program(vtable: *ImportVTable) Str = {
    src := u8.list(temp());
    push_dynamic_context {
        path := "tests".maybe_borrow_cstr(temp());
        ::List(FatStmt);
        
        src&.push_all("#include_std(\"lib/core.fr\");\n");
        walk_directory(path) {entry|
            // TODO: recurse with another list if .Directory
            is_file := (eq(@as(u8) entry.type, @as(u8) DirEntType.File));
            if is_file && entry.name.ends_with(".fr") {
                @fmt(src&, "#include_std(\"%/%\");\n", path, entry.name);
            };
        };
        
        src1 := src.items().clone(temp()).items();
        opts := vtable.default_build_options();
        c := new_with_src(vtable, src1, opts);
        c := vtable.with(c);
        
        tests := c.get_tagged("test");
        push_all(src&, """
            TestCase :: @struct(name: Str, f: @FnPtr() void);
            fn main() void = {
                each tests { t | 
                    @eprint("%, ", t.name);
                    {t.f}();
                };
                @eprintln("\nPassed all % tests!", tests.len());
            }
            
            tests :: @const_slice(@as(TestCase)
        """);
        for tests { f | 
            func := c.get_function(f);
            name := c.get_string(func.name);
            @fmt(src&, "    (name = \"%\", f = (fn() = { %(@uninitialized); })),\n", name, name);
        };
        @fmt(src&, ");\n");
    };
    src.items()
}
