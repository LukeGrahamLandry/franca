#include_std("bindings/sokol.fr");
Sdtx :: import("@/graphics/debugtext.fr");
Sgl  :: import("@/graphics/gl.fr");
Sapp :: import("@/graphics/app.fr");

#include_std("graphics/shaders.fr");
#include_std("graphics/vec.fr");

RenderBackend :: @enum(METAL_MACOS, METAL_IOS, METAL_SIM, D3D11, WGPU, GLCORE, GLES3); ::enum(RenderBackend);

SOKOL_BACKEND :: RenderBackend.METAL_MACOS; // :hardcode_os

fn is_metal(b: RenderBackend) bool #fold = 
    @is(b, .METAL_MACOS, .METAL_IOS, .METAL_SIM);

fn choose_shader_impl($backend: RenderBackend, shd_desc: *SgShaderDesc, $data: Type) void = {
    vv, ff := (shd_desc.vertex_func&, shd_desc.fragment_func&);
    @if(is_metal(backend)) {
        vv.entry = "main0";
        ff.entry = "main0";
    };
    vv.source = :: compile_to_shader_source(data.vs, backend, true).sym().c_str();
    ff.source = :: compile_to_shader_source(data.fs, backend, false).sym().c_str();
}

// TODO: unify this with #include_std so it doesn't depend on working directory. 
fn include_bytes($path: Str, $expect_len: i64) []u8 #fold = {
    b := read_to_string_or_crash(ast_alloc(), path).items();
    @assert_eq(b.len, expect_len, "update % size/offsets", expect_len);
    b
}

fn pack_rgba(r: u8, g: u8, b: u8, a: u8) u32 = 
    pack_rgba(@as(i64) r.zext(), @as(i64) g.zext(), @as(i64) b.zext(), @as(i64) a.zext());
    
fn pack_rgba(r: i64, g: i64, b: i64, a: i64) u32 = 
    a.shift_left(24).bit_or(b.shift_left(16).bit_or(g.shift_left(8).bit_or(r))).trunc();

fn pack_rgba(r: f64, g: f64, b: f64, a: f64) u32 = {
    r := int(clamp(r, 0.0, 1.0) * 255.0);
    g := int(clamp(g, 0.0, 1.0) * 255.0);
    b := int(clamp(b, 0.0, 1.0) * 255.0);
    a := int(clamp(a, 0.0, 1.0) * 255.0);
    pack_rgba(r, g, b, a)
}

fn pack_rgba(r: f32, g: f32, b: f32, a: f32) u32 = 
    pack_rgba(r.cast(), g.cast(), b.cast(), a.cast());

// TODO: more composable system for linking foreign libraries
fn build_for_graphics(vtable: *ImportVTable, input_path: Str) void = {
    #use("@/lib/sys/fs.fr");
    src := "#include_std(\"lib/core.fr\");".clone(temp());
    the_code := temp().read_to_string_or_crash(input_path);  // TODO: don't depend on cwd.
    src&.push_all(the_code.items());
    
    opts := vtable.default_build_options();
    opts.retain_function_names = true;
    
    want_jit := false;
    for cli_args() { a |
        if a == "-unsafe" {
            s := opts.safety_checks&;
            s.insert(.Bounds, false);
            s.insert(.DebugAssertions, false);
            s.insert(.InvalidTag, false);
        };
        want_jit = want_jit || a == "-jit";
    };
    
    comp := vtable.new_with_src(src.items(), input_path, opts);
    ctx := vtable.with(comp);
    
    libs := ctx.empty_libs();
    //libs&.intercept_imports();
    libs&.add_lib(sokol_macos_lib);
    
    {
        // TODO: this fucks you for cross compiling. don't do this!
        Dyn :: import("@/lib/dynamic_lib.fr");
        objc := Dyn'open("/usr/lib/libobjc.dylib").expect("open objc");
        ctx.add_comptime_library(ctx.intern_string("objc"), objc);
        cg := Dyn'open("/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics").expect("open CoreGraphics");
        ctx.add_comptime_library(ctx.intern_string("CoreGraphics"), cg);
        ak := Dyn'open("/System/Library/Frameworks/AppKit.framework/AppKit").expect("open AppKit");
        ctx.add_comptime_library(ctx.intern_string("AppKit"), ak);
        m := Dyn'open("/System/Library/Frameworks/Metal.framework/Metal").expect("open Metal");
        ctx.add_comptime_library(ctx.intern_string("Metal"), m);
        q := Dyn'open("/System/Library/Frameworks/QuartzCore.framework/QuartzCore").expect("open QuartzCore");
        ctx.add_comptime_library(ctx.intern_string("QuartzCore"), q);
    };
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    
    if want_jit {
        ptr := get_jitted(ctx, main_f);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
        exit(0);
    };
    
    #use("@/compiler/ast_external.fr", "@/lib/sys/subprocess.fr");
    m := QbeModule.zeroed();
    init_default_module_dyn(m&, vtable, (arch = query_current_arch(), os = .macos, type = .Relocatable));  // :HardcodeOs
    ir_text := emit_qbe_included_dyn(m&, ctx&, @slice(main_f), .WrapMain); 
    
    out := open_trunc("a.o").unwrap();
    for(ir_text&){bucket|
        out&.write(bucket);
    };
    out.close();
    // TODO: get these from the lib. 
    SOKOL_MACOS_LINK_ARGS :: @array("-framework", "Metal", "-framework", "MetalKit", "-framework", "Cocoa", "-framework", "QuartzCore");
    a := SOKOL_MACOS_LINK_ARGS;
    args := libs&.get_aot_objects();
    args&.push_all(a&.items());
    args&.push_all(@slice ("a.o", "-o", "a.out"));    
    args&.push_all(@slice ("-target", target_triple(m.goal.arch, m.goal.os)));   
    @println("building aot exe: %", args.items());
    success := run_cmd_blocking("clang", args.items());
    assert(success, "clang failed");
}
