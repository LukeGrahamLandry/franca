// this generates bindings to dawn (chrome's webgpu implementation)'s c api. 
//   using dawn.json instead of webgpu.h seemed better because it has extra metadata like default, jsrepr. 
//   disadvantage of doing it this way is you can't use gfx-rs/wgpu-native. 
//   but different implementations of webgpu.h don't provide a stable abi anyway 
//   so at the very least you have to generate different sets of bindings when linking to something else,
//   which annoys me so for now im just declaring a blessed one and only supporting that. 
//   none of that matters when targetting a web browser, because they have a slightly more stable js api. 

output_path :: "target/franca/webgpu.g.fr";

main :: fn() void = {
    mark := temp().mark();
    
    dawn_json := fetch_text_or_crash(
        "https://raw.githubusercontent.com/google/dawn/dfe3855e5d0b5367a598e60674766ffa1c894c71/src/dawn/dawn.json",
        177857, "bdf681b2c963d39f839b6590a25a739fa3a64f68ac9e0e8c0dc6d85f48c087ec", temp(),
    );

    json: JsonParser = new_json(dawn_json, temp());
    result := or json&.parse_dawn_api() { e |
        panic(e)
    };
    
    out := u8.list(temp()); out := out&;
    @fmt(out, "// @generated by graphics/web/webgpu_api.fr from google/dawn/src/dawn/dawn.json\n\n");
    // they use this in structs so it can't just be my `bool`
    @fmt(out, "Bool :: @enum(u32) (False = 0, True = 1);\n");
    @fmt(out, "ChainedStruct :: @rec @struct(next := zeroed(*ChainedStruct), sType := zeroed SType);\n");
    @fmt(out, "\n");
    
    each result& { name, item |
        self_name := name.camelcase(true);
        @match(item) {
            fn structure(it) => if name != "string view" {
                declare_struct(self_name, it, false, out, result&);
            }
            fn enum(it) => {
                @fmt(out, "% :: @enum(u32) (\n", self_name);
                each it.values { it |
                    @fmt(out, "    % = %,\n", it.name.camelcase(true), it.value);
                };
                @fmt(out, ");\n");
            }
            fn bitmask(it) => {
                @fmt(out, "% :: @struct {\n    _: i64;\n\n", self_name);
                each it.values { it |
                    @fmt(out, "    % :: %;\n", it.name.camelcase(true), it.value);
                };
                @fmt(out, "};\n");
            }
            fn object(it) => {
                @fmt(out, "% :: @rec @struct(_: rawptr);\n", self_name);
                @fmt(out, "wgpu%Release :: fn(self: %) void #import(\"webgpu\");\n", self_name, self_name);
                @fmt(out, "wgpu%AddRef :: fn(self: %) void #import(\"webgpu\");\n", self_name, self_name);
                each it.methods { it |
                    @fmt(out, "wgpu%% :: fn(", self_name, it.name.camelcase(true));
                    @fmt(out, "self: %, ", self_name);
                    finish_function_signeture(it.args, it.returns, out, false);
                    @fmt(out, " #import(\"webgpu\");\n");
                };
            }
            fn function(it) => {
                @fmt(out, "wgpu% :: fn(", self_name);
                finish_function_signeture(it.args, it.returns, out, false);
                @fmt(out, " #import(\"webgpu\");\n");
            }
            fn @"function pointer"(it) => {
                @fmt(out, "% :: @FnPtr(", self_name);
                finish_function_signeture(it.args, it.returns, out, false);
                @fmt(out, ";\n");
            }
            fn @"callback function"(it) => {
                @fmt(out, "% :: @FnPtr(", self_name);
                finish_function_signeture(it.args, it.returns, out, true);
                @fmt(out, ";\n");
            }
            fn @"callback info"(it) => {
                declare_struct(self_name, it, true, out, result&);
            }
            fn native() => ();
            fn constant(it) => if name != "str len" {
                value := @switch(it.value) {
                    @case("UINT64_MAX") => "bitcast(0xFFFFFFFFFFFFFFFF)";
                    @case("SIZE_MAX") => "MAX_i64";
                    @case("UINT32_MAX") => "MAX_u32";
                    @default => it.value;
                };
                @fmt(out, "% : % : %;\n", self_name, it.type.type_name(.None), value);
            };
            fn typedef(it) => @fmt(out, "% :: %;\n", self_name, it.type.type_name(.None));
        };
    };

    import("@/lib/sys/fs.fr")'write_entire_file_or_crash(output_path, out.items());
    temp().reset(mark);
}

declare_struct :: fn(self_name: Str, it: *Structure, callback: bool, out: *List(u8), all: *HashMap(Str, Item)) void = {
    @fmt(out, "% :: @rec @struct {\n", self_name);
    ::tagged(BoolOrString);
    
    if callback {
        it.extensible = (str = "in");
    };
    if it.chained { chained |
        if chained == "in" {
            @fmt(out, "    chain: ChainedStruct;\n");
        }
        if chained == "out" {
            @fmt(out, "// TODO: wtf does chained=out mean\n");
        }
    };
    if it.extensible&.is(.str) {
        if it.extensible.str == "in" || it.extensible.str == "out" {
            @fmt(out, "    nextInChain := zeroed(*ChainedStruct);\n");
        }
    };
    each it.members { it |
        type := it.type.type_name(it.annotation);
        @fmt(out, "    %", it.name.camelcase(false));
        if it.optional {
            it.default = (Some = (str = "zero"));
        };
        if it.length&.is(.str) {
            it.default = (Some = (str = "zero"));
        };
        if it.default.is_none() {
            if all.get(it.type) { item |
                @match(item) {
                    fn enum(enum) => {
                        if enum.values.len > 0 && enum.values[0].name == "undefined" {
                            it.default = (Some = (str = "undefined"));
                        }
                    }
                    fn @"callback info"() => {
                        it.default = (Some = (str = "zero"));
                    }
                    @default => ();
                }
            };
        };
        if it.default { it |
            ::tagged(NumberOrString);
            // TODO: {"name": "dst factor", "type": "blend factor", "default": "zero"}
            //       should mean the enum value .zero, but everywhere else they say default:zero they mean a struct of all zeros
            if (it&.is(.str) && (it.str == "nullptr" || it.str == "zero"))  {
                @fmt(out, " := zeroed(%)", type);
            } else {
                @fmt(out, ": %", type);
                @fmt(out, " = %", it);
            };
        } else {
            @fmt(out, ": %", type);
        };
        @fmt(out, ";\n");
    };
    if callback {
        @fmt(out, "    userdata1: rawptr;\n    userdata2 := zeroed(rawptr);\n");
    };
    @fmt(out, "};\n");
}

finish_function_signeture :: fn(args: []Member, returns: Str, out: *List(u8), callback: bool) void = {
    each args { it |
        @fmt(out, "%: %, ", it.name.snakecase(), it.type.type_name(it.annotation));
    };
    if callback {
        @fmt(out, "userdata1: rawptr, userdata2: rawptr, ");
    }
    @fmt(out, ") %", returns.type_name(.None));
}

type_name :: fn(s: Str, annotation: ?Str) Str = {
    s := @switch(s) {
        @case("uint32_t") => "u32";
        @case("int32_t") => "i32";
        @case("size_t") => "i64";
        @case("float") => "f32";
        @case("double") => "f64";
        @case("void *") => "rawptr";
        @case("void const *") => "rawptr";
        @case("uint64_t") => "i64";  // signed is less annoying for now
        @case("int") => "i32";
        @case("string view") => "[]u8";
        @case("uint16_t") => "u16";
        @case("void") => "void";
        @case("char") => "u8";
        @case("uint8_t") => "u8";
        @default => s.camelcase(true);
    };
    
    if annotation { a |
        while => a.len > 0 {
            if a.starts_with("const") {
                a = a.rest("const".len());
            };
            if a.starts_with("*") {
                s = @tfmt("*%", s);
                a = a.rest(1);
            };
        }
    };
    
    if s == "*void" {
        s = "rawptr";
    };
    
    s
}

camelcase :: fn(s: Str, first: bool) Str = {
    out := u8.list(s.len, temp());
    if s[0].is_ascii_digit() {
        out&.push_all("_");
    };
    for s { c |
        if c == " ".ascii() {
            first = true;
        } else {
            if first {
                out&.push(c.ascii_to_upper());
                first = false;
            } else {
                out&.push(c);
            }
        }
    };
    out.items()
}

snakecase :: fn(s: Str) Str = {
    s := s.shallow_copy(temp());
    each s { c |
        if c[] == " ".ascii() {
            c[] = "_".ascii();
        };
    };
    s
}

fn display(self: NumberOrString, out: *List(u8)) void = {
    @match(self) {
        fn int(it) => @fmt(out, "%", it);
        fn str(it) => @if_else {
            @if(it.starts_with("0x")) => @fmt(out, "%", it);
            @if(it.ends_with("f")) => @fmt(out, "%", it.slice(0, it.len - 1));
            @if(it == "1" || it == "0") => @fmt(out, "%", it);
            @if(it.starts_with("whole ") && it.ends_with(" size")) => @fmt(out, "%", it.camelcase(true));
            @if(it.ends_with(" undefined")) => @fmt(out, "%", it.camelcase(true));
            @else => @fmt(out, ".%", it.camelcase(true));
        };
    }
}

parse_dawn_api :: fn(json: *JsonParser) Result(HashMap(Str, Item), Str) = {
    it := @try(json.next()) return;
    ::tagged(@type it);
    @assert(it&.is(.StartDict));
    out: HashMap(Str, Item) = init(temp());
    loop {
        continue :: local_return;
        it := @try(json.next()) return;
        if it&.is(.Key) {
            item_name := it.Key;
            if item_name.starts_with("_") {
                @try(json.skip_next_value()) return;
            } else {
                // TODO: derive for internally tagged things and #use for shared fields
                mark := json.mark();
                it := @try(json.next()) return;
                @assert(it&.is(.StartDict));
                @try(json.skip_until_key("category")) return;
                it := @try(json.next()) return;
                @assert(it&.is(.StringValue));
                category := it.StringValue;
                json.reset(mark);
                
                item := zeroed Item;
                ::tagged(Item);
                ::DeriveJson(Member);
                ::DeriveJson(Object.Method);
                ::DeriveJson(Enum.Value);
                inline_for Item.get_variants() { $case |
                    name :: case._0.str();
                    if category == name {
                        tag :: Item.Tag().from_name(name).unwrap();
                        item&.tag_ptr()[] = tag;
                        data := get_variant_ptr(Item, item&, tag);
                        ::DeriveJson(@type data[]);
                        ok := parse_json(json, data);
                        @if(!ok) return(Err = @tfmt("failed to parse '%'", item_name));
                        out&.insert(item_name, item);
                        continue();
                    };
                };
                return(Err = @tfmt("unknown category '%' for '%'", category, item_name));
            };
        } else {
            @assert(it&.is(.End));
            it := @try(json.next()) return;
            @assert(it&.is(.Eof));
            return(Ok = out);
        };
    };
}

#use("@/lib/encoding/json.fr");
#use("@/lib/encoding/json_reflect.fr");
#use("@/lib/encoding/base64.fr");
#use("@/lib/collections/map.fr");
::import("@/examples/testing.fr");

Item :: @tagged(
    structure: Structure,
    native: Native,
    typedef: TypeDef,
    enum: Enum,
    bitmask: Enum,
    @"function pointer": Function,
    object: Object,
    constant: Constant,
    function: Function,
    @"callback function": Function,
    @"callback info": Structure,
);

Member :: @struct {
    name: Str;
    type: Str;
    annotation: ?Str;
    length: NumberOrString = (int = 1);
    optional := false;
    default: ?NumberOrString;
    wire_is_data_only := false;
};

Native :: @struct {
    @"wire transparent" := true;
};

TypeDef :: @struct {
    type: Str;
};

Enum :: @struct {
    values: []Value;
    emscripten_no_enum_table := false;
    
    Value :: @struct {
        name: Str;
        value: NumberOrString;
        jsrepr: ?Str;
        value := true;
    }
};

Structure :: @struct {
    members: []Member = empty();
    extensible: BoolOrString = (bool = false);  // Chained.none;
    chained: ?Str;  // = Chained.none;
    @"chain roots": []Str = empty();
    
    //Chained :: @enum(none, in, out, false);  // TODO
}

Object :: @struct {
    methods: []Method;
    @"no autolock" := false;
    
    Method :: @struct {
        name: Str;
        returns := "void";
        args: []Member = empty();
        @"no autolock" := false;
    }
}

Constant :: @struct {
    type: Str;
    value: Str;
};

Function :: @struct {
    returns := "void";
    args: []Member;
};

NumberOrString :: @tagged(int: i64, str: Str);

fn parse_json(json: *JsonParser, self: *NumberOrString) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    @match(token) {
        fn Float(n) => {
            self[] = (int = n.int());
            true
        }
        fn StringValue(s) => {
            self[] = (str = s);
            true
        }
        @default => false;
    }
}

BoolOrString :: @tagged(bool: bool, str: Str);

fn parse_json(json: *JsonParser, self: *BoolOrString) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    @match(token) {
        fn BoolValue(n) => {
            self[] = (bool = n);
            true
        }
        fn StringValue(s) => {
            self[] = (str = s);
            true
        }
        @default => false;
    }
}
