// this generates bindings to dawn (chrome's webgpu implementation)'s c api. 
//   using dawn.json instead of webgpu.h seemed better because it has extra metadata like default, jsrepr. 
//   disadvantage of doing it this way is you can't use gfx-rs/wgpu-native. 
//   but different implementations of webgpu.h don't provide a stable abi anyway 
//   so at the very least you have to generate different sets of bindings when linking to something else,
//   which annoys me so for now im just declaring a blessed one and only supporting that. 
//   none of that matters when targetting a web browser, because they have a slightly more stable js api. 

// TODO: enums are wrong. values need offsets. like the dawn special ones have some big number added i think. 
//       and there are still duplicates. whats this supposed to mean? [("buffer not used"=0), ("undefined"=0,valid=false)]

output_fr :: "target/franca/webgpu.g.fr";
output_js :: "target/franca/webgpu.g.js";

// note: this needs to run at comptime because it needs to compute field offsets. 
//       helpfully the caching sketchiness doesn't matter because the code includes the hash of the input file it reads. 
main :: fn() void = @run {
    mark := temp().mark();
    
    dawn_json := fetch_text_or_crash(
        "https://raw.githubusercontent.com/google/dawn/dfe3855e5d0b5367a598e60674766ffa1c894c71/src/dawn/dawn.json",
        177857, "bdf681b2c963d39f839b6590a25a739fa3a64f68ac9e0e8c0dc6d85f48c087ec", temp(),
    );

    json: JsonParser = new_json(dawn_json, temp());
    result := or json&.parse_dawn_api() { e |
        panic(e)
    };
    
    out := u8.list(temp()); out := out&;
    header_comment :: "// @generated by graphics/web/webgpu_api.fr from google/dawn/src/dawn/dawn.json\n\n";
    @fmt(out, header_comment);
    gen_fr(out, result&);
    import("@/lib/sys/fs.fr")'write_entire_file_or_crash(output_fr, out.items());
    WGPU := import_code(out.items());
    out.clear();
    @fmt(out, header_comment);
    gen_js(out, result&, WGPU);
    import("@/lib/sys/fs.fr")'write_entire_file_or_crash(output_js, out.items());
    
    temp().reset(mark);
}

// TODO: import() has a dumb api
import_code :: fn(s: Str) ScopeId = {
    out := u8.list(s.len+3, ast_alloc());
    out&.push_all("{");
    out&.push_all(s);
    out&.push_all("};");
    import(out.items())
}

gen_fr :: fn(out: *List(u8), all: *HashMap(Str, FullItem)) void = {
    // they use this in structs so it can't just be my `bool`
    @fmt(out, "Bool :: @enum(u32) (False = 0, True = 1);\n");
    @fmt(out, "ChainedStruct :: @rec @struct(next := zeroed(*ChainedStruct), sType := zeroed SType);\n");
    @fmt(out, "\n");
    
    each all { name, item |
        self_name := name.camelcase(true);
        @match(item.item&) {
            fn structure(it) => if name != "string view" {
                declare_struct(self_name, it, false, out, all);
            }
            fn enum(it) => {
                @fmt(out, "% :: @enum(u32) (\n", self_name);
                each it.values { it |
                    @fmt(out, "    % = %,\n", it.name.camelcase(true), it.value);
                };
                @fmt(out, ");\n");
            }
            fn bitmask(it) => {
                @fmt(out, "% :: @struct {\n    _: i64;\n\n", self_name);
                each it.values { it |
                    @fmt(out, "    % :: %;\n", it.name.camelcase(true), it.value);
                };
                @fmt(out, "};\n");
            }
            fn object(it) => {
                @fmt(out, "% :: @rec @struct(_: rawptr);\n", self_name);
                @fmt(out, "wgpu%Release :: fn(self: %) void #import(\"webgpu\");\n", self_name, self_name);
                @fmt(out, "wgpu%AddRef :: fn(self: %) void #import(\"webgpu\");\n", self_name, self_name);
                each it.methods { it |
                    @fmt(out, "wgpu%% :: fn(", self_name, it.name.camelcase(true));
                    @fmt(out, "self: %, ", self_name);
                    finish_function_signeture(it.args, it.returns, out, false);
                    @fmt(out, " #import(\"webgpu\");\n");
                };
            }
            fn function(it) => {
                @fmt(out, "wgpu% :: fn(", self_name);
                finish_function_signeture(it.args, it.returns, out, false);
                @fmt(out, " #import(\"webgpu\");\n");
            }
            fn @"function pointer"(it) => {
                @fmt(out, "% :: @FnPtr(", self_name);
                finish_function_signeture(it.args, it.returns, out, false);
                @fmt(out, ";\n");
            }
            fn @"callback function"(it) => {
                @fmt(out, "% :: @FnPtr(", self_name);
                finish_function_signeture(it.args, it.returns, out, true);
                @fmt(out, ";\n");
            }
            fn @"callback info"(it) => {
                declare_struct(self_name, it, true, out, all);
            }
            fn native() => ();
            fn constant(it) => if name != "str len" {
                value := @switch(it.value) {
                    @case("UINT64_MAX") => "bitcast(0xFFFFFFFFFFFFFFFF)";
                    @case("SIZE_MAX") => "MAX_i64";
                    @case("UINT32_MAX") => "MAX_u32";
                    @default => it.value;
                };
                @fmt(out, "% : % : %;\n", self_name, it.type.type_name(.None), value);
            };
            fn typedef(it) => @fmt(out, "% :: %;\n", self_name, it.type.type_name(.None));
        };
    };
}

declare_struct :: fn(self_name: Str, it: *Structure, callback: bool, out: *List(u8), all: *HashMap(Str, FullItem)) void = {
    @fmt(out, "% :: @rec @struct {\n", self_name);
    ::tagged(BoolOrString);
    
    if callback {
        it.extensible = (str = "in");
    };
    if it.chained { chained |
        if chained == "in" {
            @fmt(out, "    chain: ChainedStruct;\n");
        }
        if chained == "out" {
            @fmt(out, "// TODO: wtf does chained=out mean\n");
        }
    };
    if it.extensible&.is(.str) {
        if it.extensible.str == "in" || it.extensible.str == "out" {
            @fmt(out, "    nextInChain := zeroed(*ChainedStruct);\n");
        }
    };
    each it.members { it |
        type := it.type.type_name(it.annotation);
        @fmt(out, "    %", it.name.camelcase(false));
        if it.optional {
            it.default = (Some = (str = "zero"));
        };
        if it.length&.is(.str) {
            it.default = (Some = (str = "zero"));
        };
        if it.default.is_none() {
            if all.get(it.type) { item |
                @match(item.item&) {
                    fn enum(enum) => {
                        if enum.values.len > 0 && enum.values[0].name == "undefined" {
                            it.default = (Some = (str = "undefined"));
                        }
                    }
                    fn @"callback info"() => {
                        it.default = (Some = (str = "zero"));
                    }
                    @default => ();
                }
            };
        };
        if it.default { it |
            ::tagged(NumberOrString);
            // TODO: {"name": "dst factor", "type": "blend factor", "default": "zero"}
            //       should mean the enum value .zero, but everywhere else they say default:zero they mean a struct of all zeros
            if (it&.is(.str) && (it.str == "nullptr" || it.str == "zero"))  {
                @fmt(out, " := zeroed(%)", type);
            } else {
                @fmt(out, ": %", type);
                @fmt(out, " = %", it);
            };
        } else {
            @fmt(out, ": %", type);
        };
        @fmt(out, ";\n");
    };
    if callback {
        @fmt(out, "    userdata1: rawptr;\n    userdata2 := zeroed(rawptr);\n");
    };
    @fmt(out, "};\n");
}

finish_function_signeture :: fn(args: []Member, returns: Str, out: *List(u8), callback: bool) void = {
    each args { it |
        @fmt(out, "%: %, ", it.name.snakecase(), it.type.type_name(it.annotation));
    };
    if callback {
        @fmt(out, "userdata1: rawptr, userdata2: rawptr, ");
    }
    @fmt(out, ") %", returns.type_name(.None));
}

gen_js :: fn(out: *List(u8), all: *HashMap(Str, FullItem), WGPU: ScopeId) void = {
    @fmt(out, "export const webgpu = {\n");
    each all { name, item |
        self_name := name.camelcase(true);
        @match(item.item&) {
            fn object(it) => {
                @fmt(out, "wgpu%Release: (self) => {},\n", self_name);
                @fmt(out, "wgpu%AddRef: (self) => {},\n", self_name);
                each it.methods { it |
                    @fmt(out, "wgpu%%: (self, ", self_name, it.name.camelcase(true));
                    for it.args { it |
                        @fmt(out, "%, ", it.name.snakecase());
                    };
                    @fmt(out, ") => { console.log(\"TODO: % %\");\n},\n", self_name, it.name);
                };
            }
            fn function(it) => {
                @fmt(out, "wgpu%: (", self_name);
                for it.args { it |
                    @fmt(out, "%, ", it.name.snakecase());
                };
                @fmt(out, ") => { console.log(\"TODO: %\");\n},\n", self_name);
            }
            @default => ();
        };
    };
    @fmt(out, "};\n");
    @fmt(out, "export const reader = {\n");
    each all { name, item |
        self_name := name.camelcase(true);
        good_tags := !item.tags.contains("native") && !item.tags.contains("dawn") && !item.tags.contains("emscripten");
        @match(item.item&) {
            fn structure(it) => if name != "string view" && good_tags {
                Self := Type.get_constant(WGPU, self_name.sym()).unwrap();
                require_layout_ready(Self);
                
                @fmt(out, "%: function(i) {\n", self_name);
                @fmt(out, "    if (i == 0n) return undefined;\n");
                @fmt(out, "    let o = {};\n");
                members := it.members&;
                each members { it |
                    f := find_field(Self, it);
                    reader_name := @if_else {
                        @if(f.ty == []u8) => "Str";
                        @else => it.type.type_name(it.annotation);
                    };
                    ::tagged(@type it.length);
                    paren := false;
                    if it.length&.is(.str) {
                        length_field_name := it.length.str;
                        @assert(reader_name.starts_with("*"));
                        reader_name = reader_name.rest(1);
                        count_f := members.find(fn(jt) => jt.name == it.length.str).unwrap();
                        count_off := find_field(Self, count_f)[].byte_offset;
                        reader_name = @tfmt("array(this.%, %n, this.i64(i + %n), ", reader_name, size_of(Deref(f.ty)), count_off);
                        paren = true;
                    };
                    if reader_name.starts_with("*") {
                        reader_name = reader_name.rest(1);
                        reader_name = @tfmt("pointer(this.%, ", reader_name);
                        paren = true;
                    };
                    @fmt(out, "    o.% = this.%(i + %n)", f.name.str(), reader_name, f.byte_offset);
                    if paren {
                        @fmt(out, ")");
                    };
                    @fmt(out, ";\n");
                };
                @fmt(out, "    return o;\n");
                @fmt(out, "},\n");
            }
            fn enum(it) => {
                @fmt(out, "%: function(i) {\n", self_name);
                @fmt(out, "    i = this.u32(i);\n");
                each it.values { it |
                    if it.name == "BGRA8 unorm" {  // TODO: ffs
                        it.jsrepr = (Some = "'bgra8unorm'");
                    };
                    if it.name == "RGBA8 unorm" {  // TODO: ffs
                        it.jsrepr = (Some = "'rgba8unorm'");
                    };
                    if it.name == "R8 unorm" {  // TODO: ffs
                        it.jsrepr = (Some = "'r8unorm'");
                    };
                    repr := it.jsrepr || @tfmt("\"%\"", it.name.dashcase());
                    @fmt(out, "    if (i == %) return %;\n", it.value, repr);
                };
                @fmt(out, "    console.error(\"invalid enum value\");\n");
                @fmt(out, "},\n");
            }
            fn bitmask(it) => {
                @fmt(out, "%: function(i) {\n", self_name);
                @fmt(out, "    return this.i64(i);\n");
                @fmt(out, "},\n");
            }
            fn object(it) => {
                @fmt(out, "%: function(i) {\n", self_name);
                @fmt(out, "    return this.r64(i);\n");
                @fmt(out, "},\n");
            }
            @default => ();
        };
    };
    @fmt(out, "};\n");
    @fmt(out, "export const writer = {\n");
    each all { name, item |
        self_name := name.camelcase(true);
        @match(item.item&) {
            fn structure(it) => if name == "limits" {
                Self := Type.get_constant(WGPU, self_name.sym()).unwrap();
                require_layout_ready(Self);
                
                @fmt(out, "%: function(i, o) {\n", self_name);
                @fmt(out, "    if (i == 0n) return;\n");
                members := it.members&;
                each members { it |
                    f := find_field(Self, it);
                    reader_name := @if_else {
                        @if(f.ty == []u8) => "Str";
                        @else => it.type.type_name(it.annotation);
                    };
                    ::tagged(@type it.length);
                    @fmt(out, "    this.%(i + %n, o.%)", reader_name, f.byte_offset, f.name.str());
                    @fmt(out, ";\n");
                };
                @fmt(out, "},\n");
            }
            @default => ();
        };
    };
    @fmt(out, "};\n");
}

find_field :: fn(T: Type, it: *Member) *Field = {
    name := it.name.camelcase(false).sym();
    it := T.get_fields().find(fn(it) => it.name == name);
    it.unwrap()
}

type_name :: fn(s: Str, annotation: ?Str) Str = {
    s := @switch(s) {
        @case("uint32_t") => "u32";
        @case("int32_t") => "i32";
        @case("size_t") => "i64";
        @case("float") => "f32";
        @case("double") => "f64";
        @case("void *") => "rawptr";
        @case("void const *") => "rawptr";
        @case("uint64_t") => "i64";  // signed is less annoying for now
        @case("int") => "i32";
        @case("string view") => "[]u8";
        @case("uint16_t") => "u16";
        @case("void") => "void";
        @case("char") => "u8";
        @case("uint8_t") => "u8";
        @default => s.camelcase(true);
    };
    
    if annotation { a |
        while => a.len > 0 {
            if a.starts_with("const") {
                a = a.rest("const".len());
            };
            if a.starts_with("*") {
                s = @tfmt("*%", s);
                a = a.rest(1);
            };
        }
    };
    
    if s == "*void" {
        s = "rawptr";
    };
    
    s
}

camelcase :: fn(s: Str, first: bool) Str = {
    out := u8.list(s.len, temp());
    if s[0].is_ascii_digit() {
        out&.push_all("_");
    };
    for s { c |
        if c == " ".ascii() {
            first = true;
        } else {
            if first {
                out&.push(c.ascii_to_upper());
                first = false;
            } else {
                out&.push(c);
            }
        }
    };
    out.items()
}

snakecase :: fn(s: Str) Str = {
    s := s.shallow_copy(temp());
    each s { c |
        if c[] == " ".ascii() {
            c[] = "_".ascii();
        };
    };
    s
}

dashcase :: fn(s: Str) Str = {
    s := s.shallow_copy(temp());
    each s { c |
        c[] = c[].ascii_to_lower();
        if c[] == " ".ascii() {
            c[] = "-".ascii();
        };
    };
    s
}

fn display(self: NumberOrString, out: *List(u8)) void = {
    @match(self) {
        fn int(it) => @fmt(out, "%", it);
        fn str(it) => @if_else {
            @if(it.starts_with("0x")) => @fmt(out, "%", it);
            @if(it.ends_with("f")) => @fmt(out, "%", it.slice(0, it.len - 1));
            @if(it == "1" || it == "0") => @fmt(out, "%", it);
            @if(it.starts_with("whole ") && it.ends_with(" size")) => @fmt(out, "%", it.camelcase(true));
            @if(it.ends_with(" undefined")) => @fmt(out, "%", it.camelcase(true));
            @else => @fmt(out, ".%", it.camelcase(true));
        };
    }
}

parse_dawn_api :: fn(json: *JsonParser) Result(HashMap(Str, FullItem), Str) = {
    it := @try(json.next()) return;
    ::tagged(@type it);
    @assert(it&.is(.StartDict));
    out: HashMap(Str, FullItem) = init(temp());
    loop {
        continue :: local_return;
        it := @try(json.next()) return;
        if it&.is(.Key) {
            item_name := it.Key;
            if item_name.starts_with("_") {
                @try(json.skip_next_value()) return;
            } else {
                // TODO: derive for internally tagged things and #use for shared fields
                mark := json.mark();
                
                Common :: @struct {
                    category: Str;
                    tags: []Str = empty();
                };
                c := zeroed Common;
                ::DeriveJson(Common);
                ok := parse_json(json, c&);
                @if(!ok) return(Err = @tfmt("failed to parse '%'", item_name));
                json.reset(mark);
                
                item := zeroed Item;
                ::tagged(Item);
                ::DeriveJson(Member);
                ::DeriveJson(Object.Method);
                ::DeriveJson(Enum.Value);
                inline_for Item.get_variants() { $case |
                    name :: case._0.str();
                    if c.category == name {
                        tag :: Item.Tag().from_name(name).unwrap();
                        item&.tag_ptr()[] = tag;
                        data := get_variant_ptr(Item, item&, tag);
                        ::DeriveJson(@type data[]);
                        ok := parse_json(json, data);
                        @if(!ok) return(Err = @tfmt("failed to parse '%'", item_name));
                        out&.insert(item_name, (item = item, tags = c.tags));
                        continue();
                    };
                };
                return(Err = @tfmt("unknown category '%' for '%'", c.category, item_name));
            };
        } else {
            @assert(it&.is(.End));
            it := @try(json.next()) return;
            @assert(it&.is(.Eof));
            return(Ok = out);
        };
    };
}

#use("@/lib/encoding/json.fr");
#use("@/lib/encoding/json_reflect.fr");
#use("@/lib/encoding/base64.fr");
#use("@/lib/collections/map.fr");
::import("@/examples/testing.fr");

FullItem :: @struct {
    item: Item;
    tags: []Str;
};

Item :: @tagged(
    structure: Structure,
    native: Native,
    typedef: TypeDef,
    enum: Enum,
    bitmask: Enum,
    @"function pointer": Function,
    object: Object,
    constant: Constant,
    function: Function,
    @"callback function": Function,
    @"callback info": Structure,
);

Member :: @struct {
    name: Str;
    type: Str;
    annotation: ?Str;
    length: NumberOrString = (int = 1);
    optional := false;
    default: ?NumberOrString;
    wire_is_data_only := false;
};

Native :: @struct {
    @"wire transparent" := true;
};

TypeDef :: @struct {
    type: Str;
};

Enum :: @struct {
    values: []Value;
    emscripten_no_enum_table := false;
    
    Value :: @struct {
        name: Str;
        value: NumberOrString;
        jsrepr: ?Str;
        value := true;
    }
};

Structure :: @struct {
    members: []Member = empty();
    extensible: BoolOrString = (bool = false);  // Chained.none;
    chained: ?Str;  // = Chained.none;
    @"chain roots": []Str = empty();
    
    //Chained :: @enum(none, in, out, false);  // TODO
}

Object :: @struct {
    methods: []Method;
    @"no autolock" := false;
    
    Method :: @struct {
        name: Str;
        returns := "void";
        args: []Member = empty();
        @"no autolock" := false;
    }
}

Constant :: @struct {
    type: Str;
    value: Str;
};

Function :: @struct {
    returns := "void";
    args: []Member;
};

NumberOrString :: @tagged(int: i64, str: Str);

fn parse_json(json: *JsonParser, self: *NumberOrString) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    @match(token) {
        fn Float(n) => {
            self[] = (int = n.int());
            true
        }
        fn StringValue(s) => {
            self[] = (str = s);
            true
        }
        @default => false;
    }
}

BoolOrString :: @tagged(bool: bool, str: Str);

fn parse_json(json: *JsonParser, self: *BoolOrString) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    @match(token) {
        fn BoolValue(n) => {
            self[] = (bool = n);
            true
        }
        fn StringValue(s) => {
            self[] = (str = s);
            true
        }
        @default => false;
    }
}
