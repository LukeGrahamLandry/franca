// 
// Abstraction will continue until moral improves. 
// Using Dawn is a bit like if you make an electron app but then make a canvas 
// that covers you whole screen and just draw into that.
//
// (pre_init, get_swapchain, pre_frame, post_frame)
// This is cannibalized from various sample code for integration with glfw: 
//  wgpu: https://github.com/gfx-rs/wgpu-native/blob/afba393d99a8bc98b57b03a5ae8afa6f6eb72d17/examples/triangle/main.c
// sokol: https://github.com/floooh/sokol-samples/blob/d94da3bbb54695801eb5daf2c3ee4638305e5f0a/wgpu/wgpu_entry_swapchain.c
// This is the same idea but for app.fr (which sokol_app.h doesn't do? -- that was true in may2025)
//

WGPU :: import("@/graphics/web/webgpu.fr");
GraphicsState :: @if(@run(SOKOL_BACKEND == .WGPU), RealGraphicsState, @struct(noframe: bool));

RealGraphicsState :: @struct {
    instance: WGPU.Instance;
    surface: WGPU.Surface;
    device: WGPU.Device;
    adapter: WGPU.Adapter;
    config: WGPU.SurfaceConfiguration;
    
    depth_tex: WGPU.Texture;
    msaa_tex: WGPU.Texture;
    depth_view: WGPU.TextureView;
    msaa_view: WGPU.TextureView;
    swapchain_view: WGPU.TextureView;
    
    wip_frame: Ty(WGPU.Texture, WGPU.TextureView);
    noframe: bool;
    is_browser: bool;
};

// TODO: do i have to do anything to get logging info? 
//       wgpuDevicePushErrorScope/wgpuDevicePopErrorScope?
pre_init :: fn(sapp: *Sapp.Self) void = {
    macos: *Sapp.Macos.Impl = sapp.impl();
    layer := @objc @as(rawptr) macos.view.layer();
    web := sapp.webgpu&;
    
    web.instance = WGPU'wgpuCreateInstance(zeroed(*WGPU.InstanceDescriptor));
    
    web.surface = createSurface(web.instance, @ref @as(WGPU.SurfaceDescriptor) (
        nextInChain = (@ref @as(WGPU.SurfaceSourceMetalLayer) (
            chain = (sType = .SurfaceSourceMetalLayer),
            layer = layer,
        ))[].chain&,
    ));
    @debug_assert(!web.surface._.is_null(), "createSurface");
    
    web.instance.requestAdapter(@ref @as(WGPU.RequestAdapterOptions) (
        compatibleSurface = web.surface,
    ), (
        callback = fn(status, adapter, message, userdata1, _userdata2) void = {
            ::enum(@type status);   
            @assert(status == .Success, "requestAdapter: %", message);
            GraphicsState.ptr_from_raw(userdata1)[].adapter = adapter;
        },
        userdata1 = GraphicsState.raw_from_ptr(web),
        mode = .AllowSpontaneous,
    ));
    @debug_assert(!web.adapter._.is_null(), "we don't fuck with async here");
    
    web.adapter.requestDevice(@ref @as(WGPU.DeviceDescriptor) (
        defaultQueue = (),
        requiredFeatureCount = 1,
        requiredFeatures = @ref WGPU.FeatureName.Depth32FloatStencil8,
        uncapturedErrorCallbackInfo = (
            callback = fn(device, kind, message, env, __) void = {
                ::enum(@type kind);
                set_dynamic_context(env);
                if kind != .NoError {
                    // TODO: nicer logging api
                    @panic("dawn says your code is bad and you should feel bad:\n %", message);
                }
            }, 
            userdata1 = get_dynamic_context(),
        ),
    ), (
        callback = fn(status, device, message, userdata1, _userdata2) void = {
            ::enum(@type status);
            @assert(status == .Success, "requestDevice: %", message);
            GraphicsState.ptr_from_raw(userdata1)[].device = device;
        },
        userdata1 = GraphicsState.raw_from_ptr(web),
        mode = .AllowSpontaneous,
    ));
    @debug_assert(!web.device._.is_null(), "we don't fuck with async here");
    
    caps := zeroed WGPU.SurfaceCapabilities;
    getCapabilities(web.surface, web.adapter, caps&);
    @debug_assert(caps.formatCount > 0 && caps.alphaModeCount > 0);
    
    web.config = (
        device = web.device,
        usage = (_ = @or(WGPU.TextureUsage.CopySrc, WGPU.TextureUsage.RenderAttachment)),
        format = caps.formats[],
        presentMode = .Fifo,
        alphaMode = caps.alphaModes[],
        width = trunc sapp.framebuffer_width,
        height = trunc sapp.framebuffer_height,
    );
    web.surface.configure(web.config&);
    // TODO: what about depth texture / msaa :DEPTH
}

fn get_swapchain(wgpu: *GraphicsState) Sg.WgpuSwapchain = (
    render_view = @if(wgpu.msaa_view._.is_null(), wgpu.swapchain_view, wgpu.msaa_view),
    resolve_view = @if(wgpu.msaa_view._.is_null(), zeroed(WGPU.TextureView), wgpu.swapchain_view),
    depth_stencil_view = wgpu.depth_view,
);

pre_frame :: fn(sapp: *Sapp.Self) void = {
    web := sapp.webgpu&;
    
    if web.is_browser {
        web.swapchain_view = web.wip_frame._1;
    } else {
        release(get_current_surface(web));
    };
}

get_current_surface :: fn(web: *GraphicsState) WGPU.Texture = {
    web.instance.processEvents();  // TODO: does this do anything? does it need to go at the end?
    
    surface_tex := zeroed WGPU.SurfaceTexture;
    web.surface.getCurrentTexture(surface_tex&);
    
    ::enum(@type surface_tex.status);
    if @is(surface_tex.status, .Timeout, .Outdated, .Lost) {
        panic("todo: failed surface");
        // Skip this frame, and re-configure surface.
        // - release surface_tex.texture if it was set  
        // - update web.config.(width, height)
        return();
    };
    if !@is(surface_tex.status, .SuccessOptimal, .SuccessSuboptimal) {
        @panic("getCurrentTexture");
    };
    @debug_assert(!surface_tex.texture._.is_null(), "failed getCurrentTexture");    
    web.swapchain_view = createView(surface_tex.texture, zeroed(*WGPU.TextureViewDescriptor));
    @debug_assert(!web.swapchain_view._.is_null(), "failed to create swapchain_view");   
    surface_tex.texture 
}

post_frame :: fn(sapp: *Sapp.Self) void = {
    web := sapp.webgpu&;
    if web.is_browser {
        @if(web.noframe) return();
        surface_tex := get_current_surface(web);
        copy_scratch_to_surface(web, surface_tex);
        release(surface_tex);
        release(web.swapchain_view);
    } else {
        release(web.swapchain_view);
        web.swapchain_view = zeroed @type web.swapchain_view;
        @if(web.noframe) return();
        present(web.surface);
    };
}

copy_scratch_to_surface :: fn(web: *GraphicsState, surface_tex: WGPU.Texture) void = {
    // maybe wasteful to not do it as part of the same encoder as the rest of the frame, 
    // but its not like one copy is slow so it's fine for now.  
    q := web.device.getQueue();
    enc := createCommandEncoder(web.device, @ref(zeroed WGPU.CommandEncoderDescriptor));
    dest, src := (surface_tex, web.wip_frame._0);
    enc.copyTextureToTexture(
        @ref(@as(WGPU.TexelCopyTextureInfo) (texture = src, origin = zeroed(WGPU.Origin3D))), 
        @ref(@as(WGPU.TexelCopyTextureInfo) (texture = dest, origin = zeroed(WGPU.Origin3D))), 
        @ref(@as(WGPU.Extent3D) (width = web.config.width, height = web.config.height)),
    );
    buf := finish(enc, @ref(zeroed WGPU.CommandBufferDescriptor));
    submit(q, 1, buf&);
    release(buf);
    release(enc);
    release(q);
}

init_browser_wip_frame :: fn(web: *GraphicsState) void = {
    if web.is_browser {
        ::Sg.Webgpu;
        release(web.wip_frame._0);
        release(web.wip_frame._1);
    };
    ::Sg.Webgpu;
    tex := createTexture(web.device, @ref(@as(WGPU.TextureDescriptor) (
        label = "saved-frame",
        usage = (_ = @or(WGPU.TextureUsage.CopySrc, WGPU.TextureUsage.CopyDst, WGPU.TextureUsage.RenderAttachment)),
        dimension = ._2D,
        size = (
            width = web.config.width,
            height = web.config.height,
        ),
        format = .BGRA8Unorm, // TODO: navigator.gpu.getPreferredCanvasFormat(),
        mipLevelCount = 1,
        sampleCount = 1,
    )));
    view := createView(tex, @ref(@as(WGPU.TextureViewDescriptor)(
        usage = (_ = 0),
        label = "saved-frame",
        dimension = ._2D,
        mipLevelCount = 1,
        arrayLayerCount = 1,
        aspect = .All,
    )));
    @assert(!tex._.is_null(), "failed to create wip_frame");
    web.wip_frame = (tex, view);
    web.is_browser = true;
}

native_shutdown :: fn(sapp: *Sapp.Self) void = {
    // TODO
}

print_error :: fn(status: WGPU.PopErrorScopeStatus, kind: WGPU.ErrorType, message: Str, env: rawptr, __: rawptr) void = {
    ::enum(@type kind);
    set_dynamic_context(env);
    if kind != .NoError {
        @panic("dawn says your code is bad and you should feel bad:\n %", message);
    }
}

//
// The rest of this is HTML5 windowing/event stuff. 
// It can be used if you want to get events in the browser even without using the webgpu stuff 
// (you'd just have to setup your own wasm exports for rendering). 
// 
// THIS IS UNFINISHED
//

Impl :: @struct {
    env: rawptr;
    modifiers: Sapp.Modifiers;
}

// this asks the js side to call francaSaveState
francaRequestState :: fn(web: *Impl, frame: @FnPtr(web: *Impl) void, francaSaveState: @FnPtr(web: *Impl, adapter: WGPU.Adapter, device: WGPU.Device, surface: WGPU.Surface, w: f64, h: f64, devicePixelRatio: f64) void) void #import("webgpu");

fn run(web: *Impl, desc: *Sapp.Desc) Never = {
    web.env = get_dynamic_context();
    francaRequestState(web, fn(web: *Impl) void = {
        set_dynamic_context(web.env);
        web.common().frame();
    }, francaSaveState);
    unreachable()
}

#export
fn francaSaveState(web: *Impl, adapter: WGPU.Adapter, device: WGPU.Device, surface: WGPU.Surface, w: f64, h: f64, devicePixelRatio: f64) void = {
    set_dynamic_context(web.env);
    sapp := web.common();
    sapp.webgpu.adapter = adapter;
    sapp.webgpu.device = device;
    sapp.webgpu.surface = surface;
    sapp.valid = true;
    // confusing that these are already multiplied by devicePixelRatio but not in resize event
    sapp.framebuffer_width = w.int();  
    sapp.framebuffer_height = h.int();
    sapp.window_width = (w / devicePixelRatio).int();
    sapp.window_height = (h / devicePixelRatio).int();
    sapp.dpi_scale = devicePixelRatio.cast();
    
    sapp.webgpu.config.width =  sapp.framebuffer_width.trunc();
    sapp.webgpu.config.height = sapp.framebuffer_height.trunc();
    init_browser_wip_frame(sapp.webgpu&);
}

fn set_icon(web: *Impl, desc: []Sapp.ImageDesc) void = {
    eprintln("TODO: set_icon");
}

fn set_window_title(web: *Impl, title: CStr) void = {
    eprintln("TODO: set_window_title");
}

fn get_clipboard_string(web: *Impl) *RawList(u8) = {
    eprintln("TODO: get_clipboard_string");
    zeroed(*RawList(u8))
}

fn set_clipboard_string(web: *Impl, str: CStr) void = {
    eprintln("TODO: set_clipboard_string");
}

fn lock_mouse(web: *Impl, lock: bool) void = {
    eprintln("TODO: lock_mouse");
}

fn set_mouse_cursor(web: *Impl, cursor: Sapp.MouseCursor) void = {
    eprintln("TODO: set_mouse_cursor");
}

fn toggle_fullscreen(sapp: *Impl) void = {
    eprintln("TODO: toggle_fullscreen");
}

fn update_cursor(web: *Impl, cursor: Sapp.MouseCursor, shown: bool) void = {
    eprintln("TODO: update_cursor");
}

fn keytable(web: *Impl) []Sapp.Keycode = {
    eprintln("TODO: keytable");
    empty()
}

// TODO: remap key_code and char_code
#export
fn mouse_event(web: *Impl, type: Sapp.EventType, button: u32, x: f32, y: f32, dx: f32, dy: f32) void = {
    //@println("% % % % % %", type, button, x, y, dx, dy);
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.mouse.x = x * sapp.dpi_scale;
    sapp.mouse.y = y * sapp.dpi_scale;
    sapp.mouse.dx = dx * sapp.dpi_scale;
    sapp.mouse.dy = dy * sapp.dpi_scale;
    sapp.init_event(type);
    sapp.event.mouse_button = @as(Sapp.Mousebutton) button;
    ::enum(Sapp.Mousebutton);
    if @is(type, .MOUSE_DOWN, .MOUSE_UP) {
        @match(sapp.event.mouse_button) {
            fn LEFT() => web.modifiers&.set(.left_mouse, int(type == .MOUSE_DOWN));
            fn RIGHT() => web.modifiers&.set(.right_mouse, int(type == .MOUSE_DOWN));
            fn MIDDLE() => web.modifiers&.set(.middle_mouse, int(type == .MOUSE_DOWN));
            @default => ();
        };
    };
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
}

#export
fn key_event(web: *Impl, type: Sapp.EventType, key: u32, alt: bool, ctrl: bool, meta: bool, shift: bool, repeat: bool) void = {
    //@println("% % % % % % %", type, key, alt, ctrl, meta, shift, repeat);
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(type);
    sapp.event.key_code = @as(Sapp.Keycode) @as(u16) key.trunc();
    if key == 13 {
        sapp.event.key_code = .ENTER;
    };
    sapp.event.key_repeat = repeat;
    if type == .CHAR {
        sapp.event.char_code = key;
    };
    
    // TODO: alt, ctrl, meta, shift, repeat
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
    // TODO: modifiers
    //shift        := 1,
    //control      := 1,
    //alt          := 1,
    //super        := 1,  // command
}

// TODO: respect app.desc.high_dpi somehow
#export
fn resize_event(web: *Impl, type: Sapp.EventType, w: f64, h: f64,devicePixelRatio: f64) void = {
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(type);
    sapp.window_width = w.int();
    sapp.window_height = h.int();
    sapp.framebuffer_width = (w * devicePixelRatio).int();
    sapp.framebuffer_height = (h * devicePixelRatio).int();
    sapp.dpi_scale = devicePixelRatio.cast();
    sapp.event.modifiers = web.modifiers;
    sapp.webgpu.config.width = sapp.framebuffer_width.trunc();
    sapp.webgpu.config.height = sapp.framebuffer_height.trunc();
    sapp.webgpu&.init_browser_wip_frame();
    sapp.call_event(sapp.event&);
}

#export
fn scroll_event(web: *Impl, dx: f64, dy: f64) void = {
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(.MOUSE_SCROLL);
    sapp.event.scroll_x = dx.cast();
    sapp.event.scroll_y = dy.cast();
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
}
