// 
// Abstraction will continue until moral improves. 
// Using Dawn is a bit like if you make an electron app but then make a canvas 
// that covers you whole screen and just draw into that.
//
// (pre_init, get_swapchain, pre_frame, post_frame)
// This is cannibalized from various sample code for integration with glfw: 
//  wgpu: https://github.com/gfx-rs/wgpu-native/blob/afba393d99a8bc98b57b03a5ae8afa6f6eb72d17/examples/triangle/main.c
// sokol: https://github.com/floooh/sokol-samples/blob/d94da3bbb54695801eb5daf2c3ee4638305e5f0a/wgpu/wgpu_entry_swapchain.c
// This is the same idea but for app.fr (which sokol_app.h doesn't do? -- that was true in may2025)
//

WGPU :: import("@/graphics/web/webgpu.fr");
GraphicsState :: @if(@run(SOKOL_BACKEND == .WGPU), RealGraphicsState, @struct(noframe: bool));

RealGraphicsState :: @struct {
    instance: WGPU.Instance;
    surface: WGPU.Surface;
    device: WGPU.Device;
    adapter: WGPU.Adapter;
    config: WGPU.SurfaceConfiguration;
    
    depth_tex: WGPU.Texture;
    msaa_tex: WGPU.Texture;
    depth_view: WGPU.TextureView;
    msaa_view: WGPU.TextureView;
    swapchain_view: WGPU.TextureView;
    old_frame: WGPU.TextureView;
    
    noframe: bool;
};

// TODO: do i have to do anything to get logging info? 
//       wgpuDevicePushErrorScope/wgpuDevicePopErrorScope?
pre_init :: fn(sapp: *Sapp.Self) void = {
    macos: *Sapp.Macos.Impl = sapp.impl();
    layer := @objc @as(rawptr) macos.view.layer();
    web := sapp.webgpu&;
    
    web.instance = WGPU'wgpuCreateInstance(zeroed(*WGPU.InstanceDescriptor));
    
    web.surface = createSurface(web.instance, @ref @as(WGPU.SurfaceDescriptor) (
        nextInChain = (@ref @as(WGPU.SurfaceSourceMetalLayer) (
            chain = (sType = .SurfaceSourceMetalLayer),
            layer = layer,
        ))[].chain&,
    ));
    @debug_assert(!web.surface._.is_null(), "createSurface");
    
    web.instance.requestAdapter(@ref @as(WGPU.RequestAdapterOptions) (
        compatibleSurface = web.surface,
    ), (
        callback = fn(status, adapter, message, userdata1, _userdata2) void = {
            ::enum(@type status);   
            @assert(status == .Success, "requestAdapter: %", message);
            GraphicsState.ptr_from_raw(userdata1)[].adapter = adapter;
        },
        userdata1 = GraphicsState.raw_from_ptr(web),
        mode = .AllowSpontaneous,
    ));
    @debug_assert(!web.adapter._.is_null(), "we don't fuck with async here");
    
    web.adapter.requestDevice(@ref @as(WGPU.DeviceDescriptor) (
        defaultQueue = (),
        requiredFeatureCount = 1,
        requiredFeatures = @ref WGPU.FeatureName.Depth32FloatStencil8,
        uncapturedErrorCallbackInfo = (
            callback = fn(device, kind, message, env, __) void = {
                ::enum(@type kind);
                set_dynamic_context(env);
                if kind != .NoError {
                    // TODO: nicer logging api
                    @panic("dawn says your code is bad and you should feel bad:\n %", message);
                }
            }, 
            userdata1 = get_dynamic_context(),
        ),
    ), (
        callback = fn(status, device, message, userdata1, _userdata2) void = {
            ::enum(@type status);
            @assert(status == .Success, "requestDevice: %", message);
            GraphicsState.ptr_from_raw(userdata1)[].device = device;
        },
        userdata1 = GraphicsState.raw_from_ptr(web),
        mode = .AllowSpontaneous,
    ));
    @debug_assert(!web.device._.is_null(), "we don't fuck with async here");
    
    caps := zeroed WGPU.SurfaceCapabilities;
    getCapabilities(web.surface, web.adapter, caps&);
    @debug_assert(caps.formatCount > 0 && caps.alphaModeCount > 0);
    
    web.config = (
        device = web.device,
        usage = (_ = WGPU.TextureUsage.RenderAttachment),
        format = caps.formats[],
        presentMode = .Fifo,
        alphaMode = caps.alphaModes[],
        width = trunc sapp.framebuffer_width,
        height = trunc sapp.framebuffer_height,
    );
    web.surface.configure(web.config&);
    
    // TODO: what about depth texture / msaa :DEPTH
}

fn get_swapchain(wgpu: *GraphicsState) Sg.WgpuSwapchain = (
    render_view = @if(wgpu.msaa_view._.is_null(), wgpu.swapchain_view, wgpu.msaa_view),
    resolve_view = @if(wgpu.msaa_view._.is_null(), zeroed(WGPU.TextureView), wgpu.swapchain_view),
    depth_stencil_view = wgpu.depth_view,
);

pre_frame :: fn(sapp: *Sapp.Self) void = {
    surface_tex := zeroed WGPU.SurfaceTexture;
    web := sapp.webgpu&;
    web.instance.processEvents();  // TODO: does this do anything? does it need to go at the end?
    
    web.surface.getCurrentTexture(surface_tex&);
    
    ::enum(@type surface_tex.status);
    if @is(surface_tex.status, .Timeout, .Outdated, .Lost) {
        panic("todo: failed surface");
        // Skip this frame, and re-configure surface.
        // - release surface_tex.texture if it was set  
        // - update web.config.(width, height)
        return();
    };
    if !@is(surface_tex.status, .SuccessOptimal, .SuccessSuboptimal) {
        @panic("getCurrentTexture");
    };
    @debug_assert(!surface_tex.texture._.is_null());
    web.swapchain_view = createView(surface_tex.texture, zeroed(*WGPU.TextureViewDescriptor));
    release(surface_tex.texture);
    @debug_assert(!web.swapchain_view._.is_null());    
}

post_frame :: fn(sapp: *Sapp.Self) void = {
    web := sapp.webgpu&;
    release(web.swapchain_view);
    web.swapchain_view = zeroed @type web.swapchain_view;
    @if(web.noframe) return();
    present(web.surface);
}

native_shutdown :: fn(sapp: *Sapp.Self) void = {
    // TODO
}

print_error :: fn(status: WGPU.PopErrorScopeStatus, kind: WGPU.ErrorType, message: Str, env: rawptr, __: rawptr) void = {
    ::enum(@type kind);
    set_dynamic_context(env);
    if kind != .NoError {
        @panic("dawn says your code is bad and you should feel bad:\n %", message);
    }
}

//
// The rest of this is HTML5 windowing/event stuff. 
// It can be used if you want to get events in the browser even without using the webgpu stuff 
// (you'd just have to setup your own wasm exports for rendering). 
// 
// THIS IS UNFINISHED
//

Impl :: @struct {
    env: rawptr;
    modifiers: Sapp.Modifiers;
}

// this asks the js side to call francaSaveState
francaRequestState :: fn(web: *Impl, frame: @FnPtr(web: *Impl) bool, init: @FnPtr(web: *Impl, adapter: WGPU.Adapter, device: WGPU.Device, surface: WGPU.Surface, width: i64, height: i64, devicePixelRatio: f64) void) void #import("webgpu");

fn run(web: *Impl, desc: *Sapp.Desc) Never = {
    web.env = get_dynamic_context();
    francaRequestState(web, fn(web: *Impl) bool = {
        set_dynamic_context(web.env);
        web.common().frame();
        web.common()[].webgpu.noframe
    }, francaSaveState);
    throw := bit_cast_unchecked(i64, @FnPtr() Never, 0);
    throw()
}

#export
fn francaSaveState(web: *Impl, adapter: WGPU.Adapter, device: WGPU.Device, surface: WGPU.Surface, width: i64, height: i64, devicePixelRatio: f64) void = {
    set_dynamic_context(web.env);
    sapp := web.common();
    sapp.webgpu.adapter = adapter;
    sapp.webgpu.device = device;
    sapp.webgpu.surface = surface;
    sapp.valid = true;
    sapp.framebuffer_width = width;
    sapp.framebuffer_height = height;
    sapp.window_width = width;
    sapp.window_height = height;
    sapp.dpi_scale = devicePixelRatio.cast();
}

fn set_icon(web: *Impl, desc: []Sapp.ImageDesc) void = {
    eprintln("TODO: set_icon");
}

fn set_window_title(web: *Impl, title: CStr) void = {
    eprintln("TODO: set_window_title");
}

fn get_clipboard_string(web: *Impl) *RawList(u8) = {
    eprintln("TODO: get_clipboard_string");
    zeroed(*RawList(u8))
}

fn set_clipboard_string(web: *Impl, str: CStr) void = {
    eprintln("TODO: set_clipboard_string");
}

fn lock_mouse(web: *Impl, lock: bool) void = {
    eprintln("TODO: lock_mouse");
}

fn set_mouse_cursor(web: *Impl, cursor: Sapp.MouseCursor) void = {
    eprintln("TODO: set_mouse_cursor");
}

fn toggle_fullscreen(sapp: *Impl) void = {
    eprintln("TODO: toggle_fullscreen");
}

fn update_cursor(web: *Impl, cursor: Sapp.MouseCursor, shown: bool) void = {
    eprintln("TODO: update_cursor");
}

fn keytable(web: *Impl) []Sapp.Keycode = {
    eprintln("TODO: keytable");
    empty()
}

// TODO: remap key_code and char_code
#export
fn mouse_event(web: *Impl, type: Sapp.EventType, button: u32, x: f32, y: f32, dx: f32, dy: f32) void = {
    //@println("% % % % % %", type, button, x, y, dx, dy);
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.mouse.x = x * sapp.dpi_scale;
    sapp.mouse.y = y * sapp.dpi_scale;
    sapp.mouse.dx = dx * sapp.dpi_scale;
    sapp.mouse.dy = dy * sapp.dpi_scale;
    sapp.init_event(type);
    sapp.event.mouse_button = @as(Sapp.Mousebutton) button;
    ::enum(Sapp.Mousebutton);
    if @is(type, .MOUSE_DOWN, .MOUSE_UP) {
        @match(sapp.event.mouse_button) {
            fn LEFT() => web.modifiers&.set(.left_mouse, int(type == .MOUSE_DOWN));
            fn RIGHT() => web.modifiers&.set(.right_mouse, int(type == .MOUSE_DOWN));
            fn MIDDLE() => web.modifiers&.set(.middle_mouse, int(type == .MOUSE_DOWN));
            @default => ();
        };
    };
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
}

#export
fn key_event(web: *Impl, type: Sapp.EventType, key: u32, alt: bool, ctrl: bool, meta: bool, shift: bool, repeat: bool) void = {
    //@println("% % % % % % %", type, key, alt, ctrl, meta, shift, repeat);
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(type);
    sapp.event.key_code = @as(Sapp.Keycode) @as(u16) key.trunc();
    sapp.event.key_repeat = repeat;
    // TODO: alt, ctrl, meta, shift, repeat
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
    // TODO: modifiers
    //shift        := 1,
    //control      := 1,
    //alt          := 1,
    //super        := 1,  // command
}

#export
fn resize_event(web: *Impl, type: Sapp.EventType, fw: f64, fh: f64, ww: f64, wh: f64, devicePixelRatio: f64) void = {
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(type);
    sapp.window_width = ww.int();
    sapp.window_height = wh.int();
    sapp.framebuffer_width = fw.int();
    sapp.framebuffer_height = fh.int();
    sapp.dpi_scale = devicePixelRatio.cast();
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
}

#export
fn scroll_event(web: *Impl, dx: f64, dy: f64) void = {
    ::enum(Sapp.EventType);
    sapp := web.common();
    if(!sapp.events_enabled(), => return());
    set_dynamic_context(web.env);
    sapp.init_event(.MOUSE_SCROLL);
    sapp.event.scroll_x = dx.cast();
    sapp.event.scroll_y = dy.cast();
    sapp.event.modifiers = web.modifiers;
    sapp.call_event(sapp.event&);
}
