// Bindings to the WebGPU C API. 
// Generated from: https://github.com/webgpu-native/webgpu-headers/blob/504373dcfc7f3d49f98b392a5115aa87a8f0d163/webgpu.h
// which is BSD-3-Clause License. Copyright 2019-2023 WebGPU-Native developers. 
// and then tweaked to be more convenient to call from franca. 
//
// Implementations:
// - wgpu | firefox | rust | MIT or Apache
//      - BUT YOU CAN NOT USE THIS ONE BECAUSE THEY DO NOT PROVIDE THE SAME ABI AS DAWN IT WILL NOT WORK
//      - https://github.com/gfx-rs/wgpu 
//      - https://github.com/gfx-rs/wgpu-native
// - dawn | chrome  | c++  | BSD 3-Clause
//      - https://dawn.googlesource.com/dawn
//
// TODO: how do licenses work? does every program that links against wgpu with this file 
//       count as a redistribution in binary form and need to spit out the full license text? 
// TODO: clean this up so it's usable on its own (mostly just putting in default field values)
// TODO: constants for flags 
// TODO: do i want to commit to being good at wnebsnite stuff and parse webidl instead? 
//       but maybe that doesn't help here because i want to match the abi of the c code 
//       which is generated from webgpu.yml (which i think is not generated from WebGPU.webidl). 
//       i don't love fucking crazy turtles all the way down 17 layers of generated bindings :(
// TODO: @rec makes typename() work better :CompilerBug

Flags :: u64;
Bool :: @enum(u32) (False = 0, True = 1); // they use this in structs so it can't just be my `bool`
Adapter :: @rec @struct(_: rawptr);
BindGroup :: @rec @struct(_: rawptr);
BindGroupLayout :: @rec @struct(_: rawptr);
Buffer :: @rec @struct(_: rawptr);
CommandBuffer :: @rec @struct(_: rawptr);
CommandEncoder :: @rec @struct(_: rawptr);
ComputePassEncoder :: @struct(_: rawptr);
ComputePipeline :: @rec @struct(_: rawptr);
Device :: @rec @struct(_: rawptr);
Instance :: @rec @struct(_: rawptr);
PipelineLayout :: @rec @struct(_: rawptr);
QuerySet :: @rec @struct(_: rawptr);
Queue :: @rec @struct(_: rawptr);
RenderBundle :: @rec @struct(_: rawptr);
RenderBundleEncoder :: @struct(_: rawptr);
RenderPassEncoder :: @struct(_: rawptr);
RenderPipeline :: @rec @struct(_: rawptr);
Sampler :: @rec @struct(_: rawptr);
ShaderModule :: @rec @struct(_: rawptr);
Surface :: @rec @struct(_: rawptr);
Texture :: @rec @struct(_: rawptr);
TextureView :: @rec @struct(_: rawptr);
AdapterType :: @enum(i32) (
    DiscreteGPU = 1,
    IntegratedGPU = 2,
    CPU = 3,
    Unknown = 4,
);
AddressMode :: @enum(i32) (
    Undefined = 0,
    ClampToEdge = 1,
    Repeat = 2,
    MirrorRepeat = 3,
);
BackendType :: @enum(i32) (
    Undefined = 0,
    Null = 1,
    WebGPU = 2,
    D3D11 = 3,
    D3D12 = 4,
    Metal = 5,
    Vulkan = 6,
    OpenGL = 7,
    OpenGLES = 8,
);
BlendFactor :: @enum(i32) (
    Undefined = 0,
    Zero = 1,
    One = 2,
    Src = 3,
    OneMinusSrc = 4,
    SrcAlpha = 5,
    OneMinusSrcAlpha = 6,
    Dst = 7,
    OneMinusDst = 8,
    DstAlpha = 9,
    OneMinusDstAlpha = 10,
    SrcAlphaSaturated = 11,
    Constant = 12,
    OneMinusConstant = 13,
    Src1 = 14,
    OneMinusSrc1 = 15,
    Src1Alpha = 16,
    OneMinusSrc1Alpha = 17,
);
BlendOperation :: @enum(i32) (
    Undefined = 0,
    Add = 1,
    Subtract = 2,
    ReverseSubtract = 3,
    Min = 4,
    Max = 5,
);
BufferBindingType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Uniform = 2,
    Storage = 3,
    ReadOnlyStorage = 4,
);
BufferMapState :: @enum(i32) (
    Unmapped = 1,
    Pending = 2,
    Mapped = 3,
);
CallbackMode :: @enum(i32) (
    WaitAnyOnly = 1,
    AllowProcessEvents = 2,
    AllowSpontaneous = 3,
);
CompareFunction :: @enum(i32) (
    Undefined = 0,
    Never = 1,
    Less = 2,
    Equal = 3,
    LessEqual = 4,
    Greater = 5,
    NotEqual = 6,
    GreaterEqual = 7,
    Always = 8,
);
CompilationInfoRequestStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
);
CompilationMessageType :: @enum(i32) (
    Error = 1,
    Warning = 2,
    Info = 3,
);
CompositeAlphaMode :: @enum(i32) (
    Auto = 0,
    Opaque = 1,
    Premultiplied = 2,
    Unpremultiplied = 3,
    Inherit = 4,
);
CreatePipelineAsyncStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    ValidationError = 3,
    InternalError = 4,
);
CullMode :: @enum(i32) (
    Undefined = 0,
    None = 1,
    Front = 2,
    Back = 3,
);
DeviceLostReason :: @enum(i32) (
    Unknown = 1,
    Destroyed = 2,
    CallbackCancelled = 3,
    FailedCreation = 4,
);
ErrorFilter :: @enum(i32) (
    Validation = 1,
    OutOfMemory = 2,
    Internal = 3,
);
ErrorType :: @enum(i32) (
    NoError = 1,
    Validation = 2,
    OutOfMemory = 3,
    Internal = 4,
    Unknown = 5,
);
FeatureLevel :: @enum(i32) (
    Undefined = 0,
    Compatibility = 1,
    Core = 2,
);
FeatureName :: @enum(i32) (
   DepthClipControl = 1,
   Depth32FloatStencil8 = 2,
   TimestampQuery = 3,
   TextureCompressionBC = 4,
   TextureCompressionBCSliced3D = 5,
   TextureCompressionETC2 = 6,
   TextureCompressionASTC = 7,
   TextureCompressionASTCSliced3D = 8,
   IndirectFirstInstance = 9,
   ShaderF16 = 10,
   RG11B10UfloatRenderable = 11,
   BGRA8UnormStorage = 12,
   Float32Filterable = 13,
   Float32Blendable = 14,
   ClipDistances = 15,
   DualSourceBlending = 16,
   Subgroups = 17,
);
FilterMode :: @enum(i32) (
    Undefined = 0,
    Nearest = 1,
    Linear = 2,
);
FrontFace :: @enum(i32) (
    Undefined = 0,
    CCW = 1,
    CW = 2,
);
IndexFormat :: @enum(i32) (
    Undefined = 0,
    Uint16 = 1,
    Uint32 = 2,
);
InstanceFeatureName :: @enum(i32) (
    TimedWaitAnyEnable = 1,
    ShaderSourceSPIRV = 2,
);
LoadOp :: @enum(i32) (
    Undefined = 0,
    Load = 1,
    Clear = 2,
);
MapAsyncStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
    Aborted = 4,
);
MipmapFilterMode :: @enum(i32) (
    Undefined = 0,
    Nearest = 1,
    Linear = 2,
);
OptionalBool :: @enum(i32) (
    False = 0,
    True = 1,
    Undefined = 2,
);
PopErrorScopeStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
PowerPreference :: @enum(i32) (
    Undefined = 0,
    LowPower = 1,
    HighPerformance = 2,
);
PredefinedColorSpace :: @enum(i32) (
    SRGB = 1,
    DisplayP3 = 2,
);
PresentMode :: @enum(i32) (
    Undefined = 0,
    Fifo = 1,
    FifoRelaxed = 2,
    Immediate = 3,
    Mailbox = 4,
);
PrimitiveTopology :: @enum(i32) (
    Undefined = 0,
    PointList = 1,
    LineList = 2,
    LineStrip = 3,
    TriangleList = 4,
    TriangleStrip = 5,
);
QueryType :: @enum(i32) (
    Occlusion = 1,
    Timestamp = 2,
);
QueueWorkDoneStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
RequestAdapterStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Unavailable = 3,
    Error = 4,
);
RequestDeviceStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
SType :: @enum(i32) (
    ShaderSourceSPIRV = 1,
    ShaderSourceWGSL = 2,
    RenderPassMaxDrawCount = 3,
    SurfaceSourceMetalLayer = 4,
    SurfaceSourceWindowsHWND = 5,
    SurfaceSourceXlibWindow = 6,
    SurfaceSourceWaylandSurface = 7,
    SurfaceSourceAndroidNativeWindow = 8,
    SurfaceSourceXCBWindow = 9,
    SurfaceColorManagement = 10,
    RequestAdapterWebXROptions = 11,
);
SamplerBindingType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Filtering = 2,
    NonFiltering = 3,
    Comparison = 4,
);
Status :: @enum(i32) (
    Success = 1,
    Error = 2,
);
StencilOperation :: @enum(i32) (
    Undefined = 0,
    Keep = 1,
    Zero = 2,
    Replace = 3,
    Invert = 4,
    IncrementClamp = 5,
    DecrementClamp = 6,
    IncrementWrap = 7,
    DecrementWrap = 8,
);
StorageTextureAccess :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    WriteOnly = 2,
    ReadOnly = 3,
    ReadWrite = 4,
);
StoreOp :: @enum(i32) (
    Undefined = 0,
    Store = 1,
    Discard = 2,
);
SurfaceGetCurrentTextureStatus :: @enum(i32) (
    SuccessOptimal = 1,
    SuccessSuboptimal = 2,
    Timeout = 3,
    Outdated = 4,
    Lost = 5,
    Error = 6,
);
TextureAspect :: @enum(i32) (
    Undefined = 0,
    All = 1,
    StencilOnly = 2,
    DepthOnly = 3,
);
TextureDimension :: @enum(i32) (
    Undefined = 0,
    _1D = 1,
    _2D = 2,
    _3D = 3,
);
TextureFormat :: @enum(i32) (
    Undefined = 0,
    R8Unorm = 1,
    R8Snorm = 2,
    R8Uint = 3,
    R8Sint = 4,
    R16Uint = 5,
    R16Sint = 6,
    R16Float = 7,
    RG8Unorm = 8,
    RG8Snorm = 9,
    RG8Uint = 10,
    RG8Sint = 11,
    R32Float = 12,
    R32Uint = 13,
    R32Sint = 14,
    RG16Uint = 15,
    RG16Sint = 16,
    RG16Float = 17,
    RGBA8Unorm = 18,
    RGBA8UnormSrgb = 19,
    RGBA8Snorm = 20,
    RGBA8Uint = 21,
    RGBA8Sint = 22,
    BGRA8Unorm = 23,
    BGRA8UnormSrgb = 24,
    RGB10A2Uint = 25,
    RGB10A2Unorm = 26,
    RG11B10Ufloat = 27,
    RGB9E5Ufloat = 28,
    RG32Float = 29,
    RG32Uint = 30,
    RG32Sint = 31,
    RGBA16Uint = 32,
    RGBA16Sint = 33,
    RGBA16Float = 34,
    RGBA32Float = 35,
    RGBA32Uint = 36,
    RGBA32Sint = 37,
    Stencil8 = 38,
    Depth16Unorm = 39,
    Depth24Plus = 40,
    Depth24PlusStencil8 = 41,
    Depth32Float = 42,
    Depth32FloatStencil8 = 43,
    BC1RGBAUnorm = 44,
    BC1RGBAUnormSrgb = 45,
    BC2RGBAUnorm = 46,
    BC2RGBAUnormSrgb = 47,
    BC3RGBAUnorm = 48,
    BC3RGBAUnormSrgb = 49,
    BC4RUnorm = 50,
    BC4RSnorm = 51,
    BC5RGUnorm = 52,
    BC5RGSnorm = 53,
    BC6HRGBUfloat = 54,
    BC6HRGBFloat = 55,
    BC7RGBAUnorm = 56,
    BC7RGBAUnormSrgb = 57,
    ETC2RGB8Unorm = 58,
    ETC2RGB8UnormSrgb = 59,
    ETC2RGB8A1Unorm = 60,
    ETC2RGB8A1UnormSrgb = 61,
    ETC2RGBA8Unorm = 62,
    ETC2RGBA8UnormSrgb = 63,
    EACR11Unorm = 64,
    EACR11Snorm = 65,
    EACRG11Unorm = 66,
    EACRG11Snorm = 67,
    ASTC4x4Unorm = 68,
    ASTC4x4UnormSrgb = 69,
    ASTC5x4Unorm = 70,
    ASTC5x4UnormSrgb = 71,
    ASTC5x5Unorm = 72,
    ASTC5x5UnormSrgb = 73,
    ASTC6x5Unorm = 74,
    ASTC6x5UnormSrgb = 75,
    ASTC6x6Unorm = 76,
    ASTC6x6UnormSrgb = 77,
    ASTC8x5Unorm = 78,
    ASTC8x5UnormSrgb = 79,
    ASTC8x6Unorm = 80,
    ASTC8x6UnormSrgb = 81,
    ASTC8x8Unorm = 82,
    ASTC8x8UnormSrgb = 83,
    ASTC10x5Unorm = 84,
    ASTC10x5UnormSrgb = 85,
    ASTC10x6Unorm = 86,
    ASTC10x6UnormSrgb = 87,
    ASTC10x8Unorm = 88,
    ASTC10x8UnormSrgb = 89,
    ASTC10x10Unorm = 90,
    ASTC10x10UnormSrgb = 91,
    ASTC12x10Unorm = 92,
    ASTC12x10UnormSrgb = 93,
    ASTC12x12Unorm = 94,
    ASTC12x12UnormSrgb = 95,
);
TextureSampleType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Float = 2,
    UnfilterableFloat = 3,
    Depth = 4,
    Sint = 5,
    Uint = 6,
);
TextureViewDimension :: @enum(i32) (
    Undefined = 0,
    _1D = 1,
    _2D = 2,
    _2DArray = 3,
    Cube = 4,
    CubeArray = 5,
    _3D = 6,
);
ToneMappingMode :: @enum(i32) (
    Standard = 1,
    Extended = 2,
);
VertexFormat :: @enum(i32) (
    Uint8 = 1,
    Uint8x2 = 2,
    Uint8x4 = 3,
    Sint8 = 4,
    Sint8x2 = 5,
    Sint8x4 = 6,
    Unorm8 = 7,
    Unorm8x2 = 8,
    Unorm8x4 = 9,
    Snorm8 = 10,
    Snorm8x2 = 11,
    Snorm8x4 = 12,
    Uint16 = 13,
    Uint16x2 = 14,
    Uint16x4 = 15,
    Sint16 = 16,
    Sint16x2 = 17,
    Sint16x4 = 18,
    Unorm16 = 19,
    Unorm16x2 = 20,
    Unorm16x4 = 21,
    Snorm16 = 22,
    Snorm16x2 = 23,
    Snorm16x4 = 24,
    Float16 = 25,
    Float16x2 = 26,
    Float16x4 = 27,
    Float32 = 28,
    Float32x2 = 29,
    Float32x3 = 30,
    Float32x4 = 31,
    Uint32 = 32,
    Uint32x2 = 33,
    Uint32x3 = 34,
    Uint32x4 = 35,
    Sint32 = 36,
    Sint32x2 = 37,
    Sint32x3 = 38,
    Sint32x4 = 39,
    Unorm10_10_10_2 = 40,
    Unorm8x4BGRA = 41,
);
VertexStepMode :: @enum(i32) (
    Undefined = 0,
    Vertex = 1,
    Instance = 2,
);
WGSLLanguageFeatureName :: @enum(i32) (
    ReadonlyAndReadwriteStorageTextures = 1,
    Packed4x8IntegerDotProduct = 2,
    UnrestrictedPointerParameters = 3,
    PointerCompositeAccess = 4,
);
WaitStatus :: @enum(i32) (
    Success = 1,
    TimedOut = 2,
    Error = 3,
);

#use("@/lib/bit_fields.fr");
TextureUsage :: @bit_fields(
    CopySrc := 1,
    CopyDst := 1,
    TextureBinding := 1,
    StorageBinding := 1,
    RenderAttachment := 1,
    _ := 64-5,
);

BufferUsage :: @struct(_: Flags);
ColorWriteMask :: @struct {
    _: Flags;
    
    None  :: 0x0;
    Red   :: 0x1;
    Green :: 0x2;
    Blue  :: 0x4;
    Alpha :: 0x8;
    All   :: 0xF;
};
MapMode :: @struct(_: Flags);
ShaderStage :: @struct(_: Flags);
Proc :: @FnPtr() void;
BufferMapCallback :: @FnPtr(MapAsyncStatus, []u8, rawptr, rawptr) void;
CompilationInfoCallback :: @FnPtr(CompilationInfoRequestStatus, *CompilationInfo, rawptr, rawptr) void;
CreateComputePipelineAsyncCallback :: @FnPtr(CreatePipelineAsyncStatus, ComputePipeline, []u8, rawptr, rawptr) void;
CreateRenderPipelineAsyncCallback :: @FnPtr(CreatePipelineAsyncStatus, RenderPipeline, []u8, rawptr, rawptr) void;
DeviceLostCallback :: @FnPtr(*Device, DeviceLostReason, []u8, rawptr, rawptr) void;
PopErrorScopeCallback :: @FnPtr(PopErrorScopeStatus, ErrorType, []u8, rawptr, rawptr) void;
QueueWorkDoneCallback :: @FnPtr(QueueWorkDoneStatus, []u8, rawptr, rawptr) void;
RequestAdapterCallback :: @FnPtr(RequestAdapterStatus, Adapter, []u8, rawptr, rawptr) void;
RequestDeviceCallback :: @FnPtr(RequestDeviceStatus, Device, []u8, rawptr, rawptr) void;
UncapturedErrorCallback :: @FnPtr(*Device, ErrorType, []u8, rawptr, rawptr) void;
// TODO: this is an @tagged
ChainedStruct :: @rec @struct(
    next := zeroed(*ChainedStruct),
    sType := zeroed SType,
);
BufferMapCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: BufferMapCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CompilationInfoCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: CompilationInfoCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CreateComputePipelineAsyncCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: CreateComputePipelineAsyncCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CreateRenderPipelineAsyncCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: CreateRenderPipelineAsyncCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
DeviceLostCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: DeviceLostCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
PopErrorScopeCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode := CallbackMode.AllowSpontaneous,
    callback: PopErrorScopeCallback,
    userdata1 := zeroed rawptr,
    userdata2 := zeroed rawptr,
);
QueueWorkDoneCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode: CallbackMode,
    callback: QueueWorkDoneCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
RequestAdapterCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode := CallbackMode.AllowSpontaneous,
    callback: RequestAdapterCallback,
    userdata1: rawptr,
    userdata2 := zeroed rawptr,
);
RequestDeviceCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    mode := CallbackMode.AllowSpontaneous,
    callback: RequestDeviceCallback,
    userdata1: rawptr,
    userdata2 := zeroed rawptr,
);
UncapturedErrorCallbackInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    callback: UncapturedErrorCallback,
    userdata1 := zeroed rawptr,
    userdata2 := zeroed rawptr,
);
AdapterInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    vendor: []u8,
    architecture: []u8,
    device: []u8,
    description: []u8,
    backendType: BackendType,
    adapterType: AdapterType,
    vendorID: u32,
    deviceID: u32,
    subgroupMinSize: u32,
    subgroupMaxSize: u32,
);
BindGroupEntry :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    binding: u32,
    buffer := zeroed Buffer,
    offset: i64 = 0,
    size: i64 = 0,
    sampler := zeroed Sampler,
    textureView := zeroed TextureView,
);
BlendComponent :: @rec @struct(
    operation: BlendOperation,
    srcFactor: BlendFactor,
    dstFactor: BlendFactor,
);
BufferBindingLayout :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    type: BufferBindingType,
    hasDynamicOffset := Bool.False,
    minBindingSize: u64 = 0,
);
BufferDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label := zeroed([]u8),
    usage: BufferUsage,
    size: u64,
    mappedAtCreation := Bool.False,
);
Color :: @rec @struct(
    r: f64,
    g: f64,
    b: f64,
    a: f64,
);
CommandBufferDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
);
CommandEncoderDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
);
CompilationMessage :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    message: []u8,
    type: CompilationMessageType,
    lineNum: u64,
    linePos: u64,
    offset: u64,
    length: u64,
);
ConstantEntry :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    key: []u8,
    value: f64,
);
Extent3D :: @rec @struct(
    width: u32,
    height: u32,
    depthOrArrayLayers: u32,
);
Future :: @rec @struct(
    id: u64,
);
InstanceLimits :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    timedWaitAnyMaxCount: usize,
);
Limits :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    maxTextureDimension1D: u32,
    maxTextureDimension2D: u32,
    maxTextureDimension3D: u32,
    maxTextureArrayLayers: u32,
    maxBindGroups: u32,
    maxBindGroupsPlusVertexBuffers: u32,
    maxBindingsPerBindGroup: u32,
    maxDynamicUniformBuffersPerPipelineLayout: u32,
    maxDynamicStorageBuffersPerPipelineLayout: u32,
    maxSampledTexturesPerShaderStage: u32,
    maxSamplersPerShaderStage: u32,
    maxStorageBuffersPerShaderStage: u32,
    maxStorageTexturesPerShaderStage: u32,
    maxUniformBuffersPerShaderStage: u32,
    maxUniformBufferBindingSize: u64,
    maxStorageBufferBindingSize: u64,
    minUniformBufferOffsetAlignment: u32,
    minStorageBufferOffsetAlignment: u32,
    maxVertexBuffers: u32,
    maxBufferSize: u64,
    maxVertexAttributes: u32,
    maxVertexBufferArrayStride: u32,
    maxInterStageShaderVariables: u32,
    maxColorAttachments: u32,
    maxColorAttachmentBytesPerSample: u32,
    maxComputeWorkgroupStorageSize: u32,
    maxComputeInvocationsPerWorkgroup: u32,
    maxComputeWorkgroupSizeX: u32,
    maxComputeWorkgroupSizeY: u32,
    maxComputeWorkgroupSizeZ: u32,
    maxComputeWorkgroupsPerDimension: u32,
    //maxImmediateSize: u32,
    maxStorageBuffersInVertexStage: u32,
    maxStorageTexturesInVertexStage: u32,
    maxStorageBuffersInFragmentStage: u32,
    maxStorageTexturesInFragmentStage: u32,
);
MultisampleState :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    count: u32,
    mask: u32,
    alphaToCoverageEnabled: Bool,
);
Origin3D :: @rec @struct(
    x: u32,
    y: u32,
    z: u32,
);
PassTimestampWrites :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    querySet: QuerySet,
    beginningOfPassWriteIndex: u32,
    endOfPassWriteIndex: u32,
);
PipelineLayoutDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8 = empty(),
    bindGroupLayoutCount: usize = 0,
    bindGroupLayouts: *BindGroupLayout,
    immediateSize: u32 = 0,
);
PrimitiveState :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    topology: PrimitiveTopology,
    stripIndexFormat: IndexFormat,
    frontFace: FrontFace,
    cullMode: CullMode,
    unclippedDepth := Bool.False,
);
QuerySetDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    type: QueryType,
    count: u32,
);
QueueDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
);
RenderBundleDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
);
RenderBundleEncoderDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    colorFormatCount: usize,
    colorFormats: *TextureFormat,
    depthStencilFormat: TextureFormat,
    sampleCount: u32,
    depthReadOnly: Bool,
    stencilReadOnly: Bool,
);
RenderPassDepthStencilAttachment :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    view: TextureView,
    depthLoadOp: LoadOp,
    depthStoreOp: StoreOp,
    depthClearValue: f32,
    depthReadOnly: Bool,
    stencilLoadOp: LoadOp,
    stencilStoreOp: StoreOp,
    stencilClearValue: u32,
    stencilReadOnly: Bool,
);
RenderPassMaxDrawCount :: @rec @struct(
    chain: ChainedStruct,
    maxDrawCount: u64,
);
RequestAdapterOptions :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    featureLevel := FeatureLevel.Undefined,
    powerPreference := PowerPreference.Undefined,
    forceFallbackAdapter := Bool.False,
    backendType := BackendType.Undefined,
    compatibleSurface: Surface,
);
RequestAdapterWebXROptions :: @rec @struct(
    chain: ChainedStruct,
    xrCompatible: Bool,
);
SamplerBindingLayout :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    type: SamplerBindingType,
);
SamplerDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    addressModeU: AddressMode,
    addressModeV: AddressMode,
    addressModeW: AddressMode,
    magFilter: FilterMode,
    minFilter: FilterMode,
    mipmapFilter: MipmapFilterMode,
    lodMinClamp: f32,
    lodMaxClamp: f32,
    compare: CompareFunction,
    maxAnisotropy: u16,
);
ShaderModuleDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
);
ShaderSourceSPIRV :: @rec @struct(
    chain: ChainedStruct,
    codeSize: u32,
    code: *u32,
);
ShaderSourceWGSL :: @rec @struct(
    chain: ChainedStruct,
    code: []u8,
);
StencilFaceState :: @rec @struct(
    compare: CompareFunction,
    failOp: StencilOperation,
    depthFailOp: StencilOperation,
    passOp: StencilOperation,
);
StorageTextureBindingLayout :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    access: StorageTextureAccess,
    format: TextureFormat,
    viewDimension: TextureViewDimension,
);
SupportedFeatures :: @rec @struct(
    featureCount: usize,
    features: *FeatureName,
);
SupportedInstanceFeatures :: @rec @struct(
    featureCount: usize,
    features: *InstanceFeatureName,
);
SupportedWGSLLanguageFeatures :: @rec @struct(
    featureCount: usize,
    features: *WGSLLanguageFeatureName,
);
SurfaceCapabilities :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    usages: TextureUsage,
    formatCount: usize,
    formats: *TextureFormat,  // array
    presentModeCount: usize,
    presentModes: *PresentMode,
    alphaModeCount: usize,
    alphaModes: *CompositeAlphaMode,
);
SurfaceColorManagement :: @rec @struct(
    chain: ChainedStruct,
    colorSpace: PredefinedColorSpace,
    toneMappingMode: ToneMappingMode,
);
SurfaceConfiguration :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    device: Device,
    format: TextureFormat,
    usage: TextureUsage,
    width: u32,
    height: u32,
    viewFormatCount: usize = 0,
    viewFormats := zeroed(*TextureFormat),
    alphaMode: CompositeAlphaMode,
    presentMode: PresentMode,
);
SurfaceDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8 = empty(),
);
SurfaceSourceAndroidNativeWindow :: @rec @struct(
    chain: ChainedStruct,
    window: rawptr,
);
SurfaceSourceMetalLayer :: @rec @struct(
    chain: ChainedStruct,
    layer: rawptr,
);
SurfaceSourceWaylandSurface :: @rec @struct(
    chain: ChainedStruct,
    display: rawptr,
    surface: rawptr,
);
SurfaceSourceWindowsHWND :: @rec @struct(
    chain: ChainedStruct,
    hinstance: rawptr,
    hwnd: rawptr,
);
SurfaceSourceXCBWindow :: @rec @struct(
    chain: ChainedStruct,
    connection: rawptr,
    window: u32,
);
SurfaceSourceXlibWindow :: @rec @struct(
    chain: ChainedStruct,
    display: rawptr,
    window: u64,
);
SurfaceTexture :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    texture: Texture,
    status: SurfaceGetCurrentTextureStatus,
);
TexelCopyBufferLayout :: @rec @struct(
    offset: u64,
    bytesPerRow: u32,
    rowsPerImage: u32,
);
TextureBindingLayout :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    sampleType: TextureSampleType,
    viewDimension: TextureViewDimension,
    multisampled: Bool,
);
TextureViewDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    format := TextureFormat.Undefined,
    dimension := TextureViewDimension.Undefined,
    baseMipLevel: u32,
    mipLevelCount: u32,
    baseArrayLayer: u32,
    arrayLayerCount: u32,
    aspect := TextureAspect.Undefined,
    usage: TextureUsage,
);

VertexAttribute :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    format: VertexFormat,
    offset: u64,
    shaderLocation: u32,
);
BindGroupDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8 = empty(),
    layout := zeroed BindGroupLayout,
    entryCount: usize = 0,
    entries := zeroed(*BindGroupEntry),
);
BindGroupLayoutEntry :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    binding: u32,
    visibility: ShaderStage,
    //bindingArraySize: u32 = 0,
    buffer := zeroed BufferBindingLayout,
    sampler := zeroed SamplerBindingLayout,
    texture := zeroed TextureBindingLayout,
    storageTexture := zeroed StorageTextureBindingLayout,
);
BlendState :: @rec @struct(
    color: BlendComponent,
    alpha: BlendComponent,
);
CompilationInfo :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    messageCount: usize,
    messages: *CompilationMessage,
);
ComputePassDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    timestampWrites := zeroed(*PassTimestampWrites),
);
ProgrammableStage :: @struct {
    nextInChain := zeroed(*ChainedStruct);
    module: ShaderModule;
    entryPoint: []u8;
    constantCount: usize = 0;
    constants := zeroed(*ConstantEntry);
};
ComputeState :: @struct {
    _: ProgrammableStage #use = ();
};
DepthStencilState :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    format: TextureFormat,
    depthWriteEnabled: OptionalBool,
    depthCompare: CompareFunction,
    stencilFront: StencilFaceState,
    stencilBack: StencilFaceState,
    stencilReadMask: u32,
    stencilWriteMask: u32,
    depthBias: i32,
    depthBiasSlopeScale: f32,
    depthBiasClamp: f32,
);
DeviceDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8 = empty(),
    requiredFeatureCount := 0,
    requiredFeatures := zeroed(*FeatureName),
    requiredLimits := zeroed(*Limits),
    defaultQueue := zeroed QueueDescriptor,
    deviceLostCallbackInfo := zeroed DeviceLostCallbackInfo,
    uncapturedErrorCallbackInfo := zeroed UncapturedErrorCallbackInfo,
);
FutureWaitInfo :: @rec @struct(
    future: Future,
    completed: Bool,
);
InstanceDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    requiredFeatureCount: usize,
    requiredFeatures: *InstanceFeatureName,
    requiredLimits: *InstanceLimits,
);
RenderPassColorAttachment :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    view: TextureView,
    depthSlice: u32 = MAX_u32,
    resolveTarget: TextureView,
    loadOp: LoadOp,
    storeOp: StoreOp,
    clearValue: Color,
);
TexelCopyBufferInfo :: @rec @struct(
    layout: TexelCopyBufferLayout,
    buffer: Buffer,
);
TexelCopyTextureInfo :: @rec @struct(
    texture: Texture,
    mipLevel: u32,
    origin: Origin3D,
    aspect: TextureAspect,
);
TextureDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    usage: TextureUsage,
    dimension: TextureDimension,
    size: Extent3D,
    format: TextureFormat,
    mipLevelCount: u32,
    sampleCount: u32,
    viewFormatCount: usize,
    viewFormats: *TextureFormat,
);
VertexBufferLayout :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    stepMode: VertexStepMode,
    arrayStride: u64,
    attributeCount: usize,
    attributes: *VertexAttribute,
);
BindGroupLayoutDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8 = empty(),
    entryCount: usize,
    entries: *BindGroupLayoutEntry,
);
ColorTargetState :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    format: TextureFormat,
    blend: *BlendState,
    writeMask: ColorWriteMask,
);
ComputePipelineDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    layout: PipelineLayout,
    compute: ComputeState,
);
RenderPassDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    colorAttachmentCount: usize,
    colorAttachments: *RenderPassColorAttachment,
    depthStencilAttachment: *RenderPassDepthStencilAttachment,
    occlusionQuerySet: QuerySet,
    timestampWrites: *PassTimestampWrites,
);
VertexState :: @struct {
    _: ProgrammableStage #use = ();
    bufferCount: usize;
    buffers: *VertexBufferLayout;
};
FragmentState :: @struct {
    _: ProgrammableStage #use = ();
    targetCount: usize;
    targets: *ColorTargetState;
};
RenderPipelineDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    layout: PipelineLayout,
    vertex: VertexState,
    primitive: PrimitiveState,
    depthStencil: *DepthStencilState,
    multisample: MultisampleState,
    fragment: *FragmentState,
);
wgpuCreateInstance :: fn(descriptor: *InstanceDescriptor) Instance #import("webgpu");
wgpuGetInstanceFeatures :: fn(features: *SupportedInstanceFeatures) void #import("webgpu");
wgpuGetInstanceLimits :: fn(limits: *InstanceLimits) Status #import("webgpu");
wgpuHasInstanceFeature :: fn(feature: InstanceFeatureName) Bool #import("webgpu");
wgpuGetProcAddress :: fn(procName: []u8) Proc #import("webgpu");
wgpuAdapterGetFeatures :: fn(adapter: Adapter, features: *SupportedFeatures) void #import("webgpu");
wgpuAdapterGetInfo :: fn(adapter: Adapter, info: *AdapterInfo) Status #import("webgpu");
wgpuAdapterGetLimits :: fn(adapter: Adapter, limits: *Limits) Status #import("webgpu");
wgpuAdapterHasFeature :: fn(adapter: Adapter, feature: FeatureName) Bool #import("webgpu");
wgpuAdapterRequestDevice :: fn(adapter: Adapter, descriptor: *DeviceDescriptor, callbackInfo: RequestDeviceCallbackInfo) Future #import("webgpu");
wgpuAdapterAddRef :: fn(adapter: Adapter) void #import("webgpu");
wgpuAdapterRelease :: fn(adapter: Adapter) void #import("webgpu");
wgpuAdapterInfoFreeMembers :: fn(adapterInfo: AdapterInfo) void #import("webgpu");
wgpuBindGroupSetLabel :: fn(bindGroup: BindGroup, label: []u8) void #import("webgpu");
wgpuBindGroupAddRef :: fn(bindGroup: BindGroup) void #import("webgpu");
wgpuBindGroupRelease :: fn(bindGroup: BindGroup) void #import("webgpu");
wgpuBindGroupLayoutSetLabel :: fn(bindGroupLayout: BindGroupLayout, label: []u8) void #import("webgpu");
wgpuBindGroupLayoutAddRef :: fn(bindGroupLayout: BindGroupLayout) void #import("webgpu");
wgpuBindGroupLayoutRelease :: fn(bindGroupLayout: BindGroupLayout) void #import("webgpu");
wgpuBufferDestroy :: fn(buffer: Buffer) void #import("webgpu");
wgpuBufferGetConstMappedRange :: fn(buffer: Buffer, offset: usize, size: usize) rawptr #import("webgpu");
wgpuBufferGetMapState :: fn(buffer: Buffer) BufferMapState #import("webgpu");
wgpuBufferGetMappedRange :: fn(buffer: Buffer, offset: usize, size: usize) *u8 #import("webgpu");
wgpuBufferGetSize :: fn(buffer: Buffer) u64 #import("webgpu");
wgpuBufferGetUsage :: fn(buffer: Buffer) BufferUsage #import("webgpu");
wgpuBufferMapAsync :: fn(buffer: Buffer, mode: MapMode, offset: usize, size: usize, callbackInfo: BufferMapCallbackInfo) Future #import("webgpu");
wgpuBufferReadMappedRange :: fn(buffer: Buffer, offset: usize, data: rawptr, size: usize) Status #import("webgpu");
wgpuBufferSetLabel :: fn(buffer: Buffer, label: []u8) void #import("webgpu");
wgpuBufferUnmap :: fn(buffer: Buffer) void #import("webgpu");
wgpuBufferWriteMappedRange :: fn(buffer: Buffer, offset: usize, data: rawptr, size: usize) Status #import("webgpu");
wgpuBufferAddRef :: fn(buffer: Buffer) void #import("webgpu");
wgpuBufferRelease :: fn(buffer: Buffer) void #import("webgpu");
wgpuCommandBufferSetLabel :: fn(commandBuffer: CommandBuffer, label: []u8) void #import("webgpu");
wgpuCommandBufferAddRef :: fn(commandBuffer: CommandBuffer) void #import("webgpu");
wgpuCommandBufferRelease :: fn(commandBuffer: CommandBuffer) void #import("webgpu");
wgpuCommandEncoderBeginComputePass :: fn(commandEncoder: CommandEncoder, descriptor: *ComputePassDescriptor) ComputePassEncoder #import("webgpu");
wgpuCommandEncoderBeginRenderPass :: fn(commandEncoder: CommandEncoder, descriptor: *RenderPassDescriptor) RenderPassEncoder #import("webgpu");
wgpuCommandEncoderClearBuffer :: fn(commandEncoder: CommandEncoder, buffer: Buffer, offset: u64, size: u64) void #import("webgpu");
wgpuCommandEncoderCopyBufferToBuffer :: fn(commandEncoder: CommandEncoder, source: Buffer, sourceOffset: u64, destination: Buffer, destinationOffset: u64, size: u64) void #import("webgpu");
wgpuCommandEncoderCopyBufferToTexture :: fn(commandEncoder: CommandEncoder, source: *TexelCopyBufferInfo, destination: *TexelCopyTextureInfo, copySize: *Extent3D) void #import("webgpu");
wgpuCommandEncoderCopyTextureToBuffer :: fn(commandEncoder: CommandEncoder, source: *TexelCopyTextureInfo, destination: *TexelCopyBufferInfo, copySize: *Extent3D) void #import("webgpu");
wgpuCommandEncoderCopyTextureToTexture :: fn(commandEncoder: CommandEncoder, source: *TexelCopyTextureInfo, destination: *TexelCopyTextureInfo, copySize: *Extent3D) void #import("webgpu");
wgpuCommandEncoderFinish :: fn(commandEncoder: CommandEncoder, descriptor: *CommandBufferDescriptor) CommandBuffer #import("webgpu");
wgpuCommandEncoderInsertDebugMarker :: fn(commandEncoder: CommandEncoder, markerLabel: []u8) void #import("webgpu");
wgpuCommandEncoderPopDebugGroup :: fn(commandEncoder: CommandEncoder) void #import("webgpu");
wgpuCommandEncoderPushDebugGroup :: fn(commandEncoder: CommandEncoder, groupLabel: []u8) void #import("webgpu");
wgpuCommandEncoderResolveQuerySet :: fn(commandEncoder: CommandEncoder, querySet: QuerySet, firstQuery: u32, queryCount: u32, destination: Buffer, destinationOffset: u64) void #import("webgpu");
wgpuCommandEncoderSetLabel :: fn(commandEncoder: CommandEncoder, label: []u8) void #import("webgpu");
wgpuCommandEncoderWriteTimestamp :: fn(commandEncoder: CommandEncoder, querySet: QuerySet, queryIndex: u32) void #import("webgpu");
wgpuCommandEncoderAddRef :: fn(commandEncoder: CommandEncoder) void #import("webgpu");
wgpuCommandEncoderRelease :: fn(commandEncoder: CommandEncoder) void #import("webgpu");
wgpuComputePassEncoderDispatchWorkgroups :: fn(computePassEncoder: ComputePassEncoder, workgroupCountX: u32, workgroupCountY: u32, workgroupCountZ: u32) void #import("webgpu");
wgpuComputePassEncoderDispatchWorkgroupsIndirect :: fn(computePassEncoder: ComputePassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
wgpuComputePassEncoderEnd :: fn(computePassEncoder: ComputePassEncoder) void #import("webgpu");
wgpuComputePassEncoderInsertDebugMarker :: fn(computePassEncoder: ComputePassEncoder, markerLabel: []u8) void #import("webgpu");
wgpuComputePassEncoderPopDebugGroup :: fn(computePassEncoder: ComputePassEncoder) void #import("webgpu");
wgpuComputePassEncoderPushDebugGroup :: fn(computePassEncoder: ComputePassEncoder, groupLabel: []u8) void #import("webgpu");
wgpuComputePassEncoderSetBindGroup :: fn(computePassEncoder: ComputePassEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
wgpuComputePassEncoderSetLabel :: fn(computePassEncoder: ComputePassEncoder, label: []u8) void #import("webgpu");
wgpuComputePassEncoderSetPipeline :: fn(computePassEncoder: ComputePassEncoder, pipeline: ComputePipeline) void #import("webgpu");
wgpuComputePassEncoderAddRef :: fn(computePassEncoder: ComputePassEncoder) void #import("webgpu");
wgpuComputePassEncoderRelease :: fn(computePassEncoder: ComputePassEncoder) void #import("webgpu");
wgpuComputePipelineGetBindGroupLayout :: fn(computePipeline: ComputePipeline, groupIndex: u32) BindGroupLayout #import("webgpu");
wgpuComputePipelineSetLabel :: fn(computePipeline: ComputePipeline, label: []u8) void #import("webgpu");
wgpuComputePipelineAddRef :: fn(computePipeline: ComputePipeline) void #import("webgpu");
wgpuComputePipelineRelease :: fn(computePipeline: ComputePipeline) void #import("webgpu");
wgpuDeviceCreateBindGroup :: fn(device: Device, descriptor: *BindGroupDescriptor) BindGroup #import("webgpu");
wgpuDeviceCreateBindGroupLayout :: fn(device: Device, descriptor: *BindGroupLayoutDescriptor) BindGroupLayout #import("webgpu");
wgpuDeviceCreateBuffer :: fn(device: Device, descriptor: *BufferDescriptor) Buffer #import("webgpu");
wgpuDeviceCreateCommandEncoder :: fn(device: Device, descriptor: *CommandEncoderDescriptor) CommandEncoder #import("webgpu");
wgpuDeviceCreateComputePipeline :: fn(device: Device, descriptor: *ComputePipelineDescriptor) ComputePipeline #import("webgpu");
wgpuDeviceCreateComputePipelineAsync :: fn(device: Device, descriptor: *ComputePipelineDescriptor, callbackInfo: CreateComputePipelineAsyncCallbackInfo) Future #import("webgpu");
wgpuDeviceCreatePipelineLayout :: fn(device: Device, descriptor: *PipelineLayoutDescriptor) PipelineLayout #import("webgpu");
wgpuDeviceCreateQuerySet :: fn(device: Device, descriptor: *QuerySetDescriptor) QuerySet #import("webgpu");
wgpuDeviceCreateRenderBundleEncoder :: fn(device: Device, descriptor: *RenderBundleEncoderDescriptor) RenderBundleEncoder #import("webgpu");
wgpuDeviceCreateRenderPipeline :: fn(device: Device, descriptor: *RenderPipelineDescriptor) RenderPipeline #import("webgpu");
wgpuDeviceCreateRenderPipelineAsync :: fn(device: Device, descriptor: *RenderPipelineDescriptor, callbackInfo: CreateRenderPipelineAsyncCallbackInfo) Future #import("webgpu");
wgpuDeviceCreateSampler :: fn(device: Device, descriptor: *SamplerDescriptor) Sampler #import("webgpu");
wgpuDeviceCreateShaderModule :: fn(device: Device, descriptor: *ShaderModuleDescriptor) ShaderModule #import("webgpu");
wgpuDeviceCreateTexture :: fn(device: Device, descriptor: *TextureDescriptor) Texture #import("webgpu");
wgpuDeviceDestroy :: fn(device: Device) void #import("webgpu");
wgpuDeviceGetAdapterInfo :: fn(device: Device, adapterInfo: *AdapterInfo) Status #import("webgpu");
wgpuDeviceGetFeatures :: fn(device: Device, features: *SupportedFeatures) void #import("webgpu");
wgpuDeviceGetLimits :: fn(device: Device, limits: *Limits) Status #import("webgpu");
wgpuDeviceGetLostFuture :: fn(device: Device) Future #import("webgpu");
wgpuDeviceGetQueue :: fn(device: Device) Queue #import("webgpu");
wgpuDeviceHasFeature :: fn(device: Device, feature: FeatureName) Bool #import("webgpu");
wgpuDevicePopErrorScope :: fn(device: Device, callbackInfo: PopErrorScopeCallbackInfo) Future #import("webgpu");
wgpuDevicePushErrorScope :: fn(device: Device, filter: ErrorFilter) void #import("webgpu");
wgpuDeviceSetLabel :: fn(device: Device, label: []u8) void #import("webgpu");
wgpuDeviceAddRef :: fn(device: Device) void #import("webgpu");
wgpuDeviceRelease :: fn(device: Device) void #import("webgpu");
wgpuInstanceCreateSurface :: fn(instance: Instance, descriptor: *SurfaceDescriptor) Surface #import("webgpu");
wgpuInstanceGetWGSLLanguageFeatures :: fn(instance: Instance, features: *SupportedWGSLLanguageFeatures) Status #import("webgpu");
wgpuInstanceHasWGSLLanguageFeature :: fn(instance: Instance, feature: WGSLLanguageFeatureName) Bool #import("webgpu");
wgpuInstanceProcessEvents :: fn(instance: Instance) void #import("webgpu");
wgpuInstanceRequestAdapter :: fn(instance: Instance, options: *RequestAdapterOptions, callbackInfo: RequestAdapterCallbackInfo) Future #import("webgpu");
wgpuInstanceWaitAny :: fn(instance: Instance, futureCount: usize, futures: *FutureWaitInfo, timeoutNS: u64) WaitStatus #import("webgpu");
wgpuInstanceAddRef :: fn(instance: Instance) void #import("webgpu");
wgpuInstanceRelease :: fn(instance: Instance) void #import("webgpu");
wgpuPipelineLayoutSetLabel :: fn(pipelineLayout: PipelineLayout, label: []u8) void #import("webgpu");
wgpuPipelineLayoutAddRef :: fn(pipelineLayout: PipelineLayout) void #import("webgpu");
wgpuPipelineLayoutRelease :: fn(pipelineLayout: PipelineLayout) void #import("webgpu");
wgpuQuerySetDestroy :: fn(querySet: QuerySet) void #import("webgpu");
wgpuQuerySetGetCount :: fn(querySet: QuerySet) u32 #import("webgpu");
wgpuQuerySetGetType :: fn(querySet: QuerySet) QueryType #import("webgpu");
wgpuQuerySetSetLabel :: fn(querySet: QuerySet, label: []u8) void #import("webgpu");
wgpuQuerySetAddRef :: fn(querySet: QuerySet) void #import("webgpu");
wgpuQuerySetRelease :: fn(querySet: QuerySet) void #import("webgpu");
wgpuQueueOnSubmittedWorkDone :: fn(queue: Queue, callbackInfo: QueueWorkDoneCallbackInfo) Future #import("webgpu");
wgpuQueueSetLabel :: fn(queue: Queue, label: []u8) void #import("webgpu");
wgpuQueueSubmit :: fn(queue: Queue, commandCount: usize, commands: *CommandBuffer) void #import("webgpu");
wgpuQueueWriteBuffer :: fn(queue: Queue, buffer: Buffer, bufferOffset: u64, data: *u8, size: i64) void #import("webgpu");
wgpuQueueWriteTexture :: fn(queue: Queue, destination: *TexelCopyTextureInfo, data: rawptr, dataSize: usize, dataLayout: *TexelCopyBufferLayout, writeSize: *Extent3D) void #import("webgpu");
wgpuQueueAddRef :: fn(queue: Queue) void #import("webgpu");
wgpuQueueRelease :: fn(queue: Queue) void #import("webgpu");
wgpuRenderBundleSetLabel :: fn(renderBundle: RenderBundle, label: []u8) void #import("webgpu");
wgpuRenderBundleAddRef :: fn(renderBundle: RenderBundle) void #import("webgpu");
wgpuRenderBundleRelease :: fn(renderBundle: RenderBundle) void #import("webgpu");
wgpuRenderBundleEncoderDraw :: fn(renderBundleEncoder: RenderBundleEncoder, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void #import("webgpu");
wgpuRenderBundleEncoderDrawIndexed :: fn(renderBundleEncoder: RenderBundleEncoder, indexCount: u32, instanceCount: u32, firstIndex: u32, baseVertex: i32, firstInstance: u32) void #import("webgpu");
wgpuRenderBundleEncoderDrawIndexedIndirect :: fn(renderBundleEncoder: RenderBundleEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
wgpuRenderBundleEncoderDrawIndirect :: fn(renderBundleEncoder: RenderBundleEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
wgpuRenderBundleEncoderFinish :: fn(renderBundleEncoder: RenderBundleEncoder, descriptor: *RenderBundleDescriptor) RenderBundle #import("webgpu");
wgpuRenderBundleEncoderInsertDebugMarker :: fn(renderBundleEncoder: RenderBundleEncoder, markerLabel: []u8) void #import("webgpu");
wgpuRenderBundleEncoderPopDebugGroup :: fn(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
wgpuRenderBundleEncoderPushDebugGroup :: fn(renderBundleEncoder: RenderBundleEncoder, groupLabel: []u8) void #import("webgpu");
wgpuRenderBundleEncoderSetBindGroup :: fn(renderBundleEncoder: RenderBundleEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
wgpuRenderBundleEncoderSetIndexBuffer :: fn(renderBundleEncoder: RenderBundleEncoder, buffer: Buffer, format: IndexFormat, offset: u64, size: u64) void #import("webgpu");
wgpuRenderBundleEncoderSetLabel :: fn(renderBundleEncoder: RenderBundleEncoder, label: []u8) void #import("webgpu");
wgpuRenderBundleEncoderSetPipeline :: fn(renderBundleEncoder: RenderBundleEncoder, pipeline: RenderPipeline) void #import("webgpu");
wgpuRenderBundleEncoderSetVertexBuffer :: fn(renderBundleEncoder: RenderBundleEncoder, slot: u32, buffer: Buffer, offset: u64, size: u64) void #import("webgpu");
wgpuRenderBundleEncoderAddRef :: fn(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
wgpuRenderBundleEncoderRelease :: fn(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
wgpuRenderPassEncoderBeginOcclusionQuery :: fn(renderPassEncoder: RenderPassEncoder, queryIndex: u32) void #import("webgpu");
wgpuRenderPassEncoderDraw :: fn(renderPassEncoder: RenderPassEncoder, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void #import("webgpu");
wgpuRenderPassEncoderDrawIndexed :: fn(renderPassEncoder: RenderPassEncoder, indexCount: u32, instanceCount: u32, firstIndex: u32, baseVertex: i32, firstInstance: u32) void #import("webgpu");
wgpuRenderPassEncoderDrawIndexedIndirect :: fn(renderPassEncoder: RenderPassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
wgpuRenderPassEncoderDrawIndirect :: fn(renderPassEncoder: RenderPassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
wgpuRenderPassEncoderEnd :: fn(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
wgpuRenderPassEncoderEndOcclusionQuery :: fn(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
wgpuRenderPassEncoderExecuteBundles :: fn(renderPassEncoder: RenderPassEncoder, bundleCount: usize, bundles: *RenderBundle) void #import("webgpu");
wgpuRenderPassEncoderInsertDebugMarker :: fn(renderPassEncoder: RenderPassEncoder, markerLabel: []u8) void #import("webgpu");
wgpuRenderPassEncoderPopDebugGroup :: fn(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
wgpuRenderPassEncoderPushDebugGroup :: fn(renderPassEncoder: RenderPassEncoder, groupLabel: []u8) void #import("webgpu");
wgpuRenderPassEncoderSetBindGroup :: fn(renderPassEncoder: RenderPassEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
wgpuRenderPassEncoderSetBlendConstant :: fn(renderPassEncoder: RenderPassEncoder, color: *Color) void #import("webgpu");
wgpuRenderPassEncoderSetIndexBuffer :: fn(renderPassEncoder: RenderPassEncoder, buffer: Buffer, format: IndexFormat, offset: i64, size: i64) void #import("webgpu");
wgpuRenderPassEncoderSetLabel :: fn(renderPassEncoder: RenderPassEncoder, label: []u8) void #import("webgpu");
wgpuRenderPassEncoderSetPipeline :: fn(renderPassEncoder: RenderPassEncoder, pipeline: RenderPipeline) void #import("webgpu");
wgpuRenderPassEncoderSetScissorRect :: fn(renderPassEncoder: RenderPassEncoder, x: u32, y: u32, width: u32, height: u32) void #import("webgpu");
wgpuRenderPassEncoderSetStencilReference :: fn(renderPassEncoder: RenderPassEncoder, reference: u32) void #import("webgpu");
wgpuRenderPassEncoderSetVertexBuffer :: fn(renderPassEncoder: RenderPassEncoder, slot: u32, buffer: Buffer, offset: i64, size: i64) void #import("webgpu");
wgpuRenderPassEncoderSetViewport :: fn(renderPassEncoder: RenderPassEncoder, x: f32, y: f32, width: f32, height: f32, minDepth: f32, maxDepth: f32) void #import("webgpu");
wgpuRenderPassEncoderAddRef :: fn(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
wgpuRenderPassEncoderRelease :: fn(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
wgpuRenderPipelineGetBindGroupLayout :: fn(renderPipeline: RenderPipeline, groupIndex: u32) BindGroupLayout #import("webgpu");
wgpuRenderPipelineSetLabel :: fn(renderPipeline: RenderPipeline, label: []u8) void #import("webgpu");
wgpuRenderPipelineAddRef :: fn(renderPipeline: RenderPipeline) void #import("webgpu");
wgpuRenderPipelineRelease :: fn(renderPipeline: RenderPipeline) void #import("webgpu");
wgpuSamplerSetLabel :: fn(sampler: Sampler, label: []u8) void #import("webgpu");
wgpuSamplerAddRef :: fn(sampler: Sampler) void #import("webgpu");
wgpuSamplerRelease :: fn(sampler: Sampler) void #import("webgpu");
wgpuShaderModuleGetCompilationInfo :: fn(shaderModule: ShaderModule, callbackInfo: CompilationInfoCallbackInfo) Future #import("webgpu");
wgpuShaderModuleSetLabel :: fn(shaderModule: ShaderModule, label: []u8) void #import("webgpu");
wgpuShaderModuleAddRef :: fn(shaderModule: ShaderModule) void #import("webgpu");
wgpuShaderModuleRelease :: fn(shaderModule: ShaderModule) void #import("webgpu");
wgpuSupportedFeaturesFreeMembers :: fn(supportedFeatures: SupportedFeatures) void #import("webgpu");
wgpuSupportedInstanceFeaturesFreeMembers :: fn(supportedInstanceFeatures: SupportedInstanceFeatures) void #import("webgpu");
wgpuSupportedWGSLLanguageFeaturesFreeMembers :: fn(supportedWGSLLanguageFeatures: SupportedWGSLLanguageFeatures) void #import("webgpu");
wgpuSurfaceConfigure :: fn(surface: Surface, config: *SurfaceConfiguration) void #import("webgpu");
wgpuSurfaceGetCapabilities :: fn(surface: Surface, adapter: Adapter, capabilities: *SurfaceCapabilities) Status #import("webgpu");
wgpuSurfaceGetCurrentTexture :: fn(surface: Surface, surfaceTexture: *SurfaceTexture) void #import("webgpu");
wgpuSurfacePresent :: fn(surface: Surface) Status #import("webgpu");
wgpuSurfaceSetLabel :: fn(surface: Surface, label: []u8) void #import("webgpu");
wgpuSurfaceUnconfigure :: fn(surface: Surface) void #import("webgpu");
wgpuSurfaceAddRef :: fn(surface: Surface) void #import("webgpu");
wgpuSurfaceRelease :: fn(surface: Surface) void #import("webgpu");
wgpuSurfaceCapabilitiesFreeMembers :: fn(surfaceCapabilities: SurfaceCapabilities) void #import("webgpu");
wgpuTextureCreateView :: fn(texture: Texture, descriptor: *TextureViewDescriptor) TextureView #import("webgpu");
wgpuTextureDestroy :: fn(texture: Texture) void #import("webgpu");
wgpuTextureGetDepthOrArrayLayers :: fn(texture: Texture) u32 #import("webgpu");
wgpuTextureGetDimension :: fn(texture: Texture) TextureDimension #import("webgpu");
wgpuTextureGetFormat :: fn(texture: Texture) TextureFormat #import("webgpu");
wgpuTextureGetHeight :: fn(texture: Texture) u32 #import("webgpu");
wgpuTextureGetMipLevelCount :: fn(texture: Texture) u32 #import("webgpu");
wgpuTextureGetSampleCount :: fn(texture: Texture) u32 #import("webgpu");
wgpuTextureGetUsage :: fn(texture: Texture) TextureUsage #import("webgpu");
wgpuTextureGetWidth :: fn(texture: Texture) u32 #import("webgpu");
wgpuTextureSetLabel :: fn(texture: Texture, label: []u8) void #import("webgpu");
wgpuTextureAddRef :: fn(texture: Texture) void #import("webgpu");
wgpuTextureRelease :: fn(texture: Texture) void #import("webgpu");
wgpuTextureViewSetLabel :: fn(textureView: TextureView, label: []u8) void #import("webgpu");
wgpuTextureViewAddRef :: fn(textureView: TextureView) void #import("webgpu");
wgpuTextureViewRelease :: fn(textureView: TextureView) void #import("webgpu");
