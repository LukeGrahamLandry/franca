// Generated from: https://github.com/webgpu-native/webgpu-headers/blob/504373dcfc7f3d49f98b392a5115aa87a8f0d163/webgpu.h
// which is BSD-3-Clause License. Copyright 2019-2023 WebGPU-Native developers. 
//
// Implementations:
// - wgpu | firefox | rust | MIT or Apache
//      - https://github.com/gfx-rs/wgpu 
//      - https://github.com/gfx-rs/wgpu-native
// - dawn | chrome  | c++  | BSD 3-Clause
//      - https://dawn.googlesource.com/dawn
//
// TODO: how do licenses work? does every program that links against wgpu with this file 
//       count as a redistribution in binary form and need to spit out the full license text? 
// TODO: clean this up so it's usable on its own (mostly just putting in default field values)
// TODO: constants for flags 

Flags :: u64;
Bool :: @enum(u32) (False = 0, True = 1); // they use this in structs so it can't just be my `bool`
Adapter :: *@struct();
BindGroup :: *@struct();
BindGroupLayout :: *@struct();
Buffer :: *@struct();
CommandBuffer :: *@struct();
CommandEncoder :: *@struct();
ComputePassEncoder :: *@struct();
ComputePipeline :: *@struct();
Device :: *@struct();
Instance :: *@struct();
PipelineLayout :: *@struct();
QuerySet :: *@struct();
Queue :: *@struct();
RenderBundle :: *@struct();
RenderBundleEncoder :: *@struct();
RenderPassEncoder :: *@struct();
RenderPipeline :: *@struct();
Sampler :: *@struct();
ShaderModule :: *@struct();
Surface :: *@struct();
Texture :: *@struct();
TextureView :: *@struct();
AdapterType :: @enum(i32) (
    DiscreteGPU = 1,
    IntegratedGPU = 2,
    CPU = 3,
    Unknown = 4,
);
AddressMode :: @enum(i32) (
    Undefined = 0,
    ClampToEdge = 1,
    Repeat = 2,
    MirrorRepeat = 3,
);
BackendType :: @enum(i32) (
    Undefined = 0,
    Null = 1,
    WebGPU = 2,
    D3D11 = 3,
    D3D12 = 4,
    Metal = 5,
    Vulkan = 6,
    OpenGL = 7,
    OpenGLES = 8,
);
BlendFactor :: @enum(i32) (
    Undefined = 0,
    Zero = 1,
    One = 2,
    Src = 3,
    OneMinusSrc = 4,
    SrcAlpha = 5,
    OneMinusSrcAlpha = 6,
    Dst = 7,
    OneMinusDst = 8,
    DstAlpha = 9,
    OneMinusDstAlpha = 10,
    SrcAlphaSaturated = 11,
    Constant = 12,
    OneMinusConstant = 13,
    Src1 = 14,
    OneMinusSrc1 = 15,
    Src1Alpha = 16,
    OneMinusSrc1Alpha = 17,
);
BlendOperation :: @enum(i32) (
    Undefined = 0,
    Add = 1,
    Subtract = 2,
    ReverseSubtract = 3,
    Min = 4,
    Max = 5,
);
BufferBindingType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Uniform = 2,
    Storage = 3,
    ReadOnlyStorage = 4,
);
BufferMapState :: @enum(i32) (
    Unmapped = 1,
    Pending = 2,
    Mapped = 3,
);
CallbackMode :: @enum(i32) (
    WaitAnyOnly = 1,
    AllowProcessEvents = 2,
    AllowSpontaneous = 3,
);
CompareFunction :: @enum(i32) (
    Undefined = 0,
    Never = 1,
    Less = 2,
    Equal = 3,
    LessEqual = 4,
    Greater = 5,
    NotEqual = 6,
    GreaterEqual = 7,
    Always = 8,
);
CompilationInfoRequestStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
);
CompilationMessageType :: @enum(i32) (
    Error = 1,
    Warning = 2,
    Info = 3,
);
CompositeAlphaMode :: @enum(i32) (
    Auto = 0,
    Opaque = 1,
    Premultiplied = 2,
    Unpremultiplied = 3,
    Inherit = 4,
);
CreatePipelineAsyncStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    ValidationError = 3,
    InternalError = 4,
);
CullMode :: @enum(i32) (
    Undefined = 0,
    None = 1,
    Front = 2,
    Back = 3,
);
DeviceLostReason :: @enum(i32) (
    Unknown = 1,
    Destroyed = 2,
    CallbackCancelled = 3,
    FailedCreation = 4,
);
ErrorFilter :: @enum(i32) (
    Validation = 1,
    OutOfMemory = 2,
    Internal = 3,
);
ErrorType :: @enum(i32) (
    NoError = 1,
    Validation = 2,
    OutOfMemory = 3,
    Internal = 4,
    Unknown = 5,
);
FeatureLevel :: @enum(i32) (
    Undefined = 0,
    Compatibility = 1,
    Core = 2,
);
FeatureName :: @enum(i32) (
   DepthClipControl = 1,
   Depth32FloatStencil8 = 2,
   TimestampQuery = 3,
   TextureCompressionBC = 4,
   TextureCompressionBCSliced3D = 5,
   TextureCompressionETC2 = 6,
   TextureCompressionASTC = 7,
   TextureCompressionASTCSliced3D = 8,
   IndirectFirstInstance = 9,
   ShaderF16 = 10,
   RG11B10UfloatRenderable = 11,
   BGRA8UnormStorage = 12,
   Float32Filterable = 13,
   Float32Blendable = 14,
   ClipDistances = 15,
   DualSourceBlending = 16,
   Subgroups = 17,
   Force32 = 2147483647,
);
FilterMode :: @enum(i32) (
    Undefined = 0,
    Nearest = 1,
    Linear = 2,
);
FrontFace :: @enum(i32) (
    Undefined = 0,
    CCW = 1,
    CW = 2,
);
IndexFormat :: @enum(i32) (
    Undefined = 0,
    Uint16 = 1,
    Uint32 = 2,
);
InstanceFeatureName :: @enum(i32) (
    TimedWaitAnyEnable = 1,
    ShaderSourceSPIRV = 2,
);
LoadOp :: @enum(i32) (
    Undefined = 0,
    Load = 1,
    Clear = 2,
);
MapAsyncStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
    Aborted = 4,
);
MipmapFilterMode :: @enum(i32) (
    Undefined = 0,
    Nearest = 1,
    Linear = 2,
);
OptionalBool :: @enum(i32) (
    False = 0,
    True = 1,
    Undefined = 2,
);
PopErrorScopeStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
PowerPreference :: @enum(i32) (
    Undefined = 0,
    LowPower = 1,
    HighPerformance = 2,
);
PredefinedColorSpace :: @enum(i32) (
    SRGB = 1,
    DisplayP3 = 2,
);
PresentMode :: @enum(i32) (
    Undefined = 0,
    Fifo = 1,
    FifoRelaxed = 2,
    Immediate = 3,
    Mailbox = 4,
);
PrimitiveTopology :: @enum(i32) (
    Undefined = 0,
    PointList = 1,
    LineList = 2,
    LineStrip = 3,
    TriangleList = 4,
    TriangleStrip = 5,
);
QueryType :: @enum(i32) (
    Occlusion = 1,
    Timestamp = 2,
);
QueueWorkDoneStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
RequestAdapterStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Unavailable = 3,
    Error = 4,
);
RequestDeviceStatus :: @enum(i32) (
    Success = 1,
    CallbackCancelled = 2,
    Error = 3,
);
SType :: @enum(i32) (
    ShaderSourceSPIRV = 1,
    ShaderSourceWGSL = 2,
    RenderPassMaxDrawCount = 3,
    SurfaceSourceMetalLayer = 4,
    SurfaceSourceWindowsHWND = 5,
    SurfaceSourceXlibWindow = 6,
    SurfaceSourceWaylandSurface = 7,
    SurfaceSourceAndroidNativeWindow = 8,
    SurfaceSourceXCBWindow = 9,
    SurfaceColorManagement = 10,
    RequestAdapterWebXROptions = 11,
);
SamplerBindingType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Filtering = 2,
    NonFiltering = 3,
    Comparison = 4,
);
Status :: @enum(i32) (
    Success = 1,
    Error = 2,
);
StencilOperation :: @enum(i32) (
    Undefined = 0,
    Keep = 1,
    Zero = 2,
    Replace = 3,
    Invert = 4,
    IncrementClamp = 5,
    DecrementClamp = 6,
    IncrementWrap = 7,
    DecrementWrap = 8,
);
StorageTextureAccess :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    WriteOnly = 2,
    ReadOnly = 3,
    ReadWrite = 4,
);
StoreOp :: @enum(i32) (
    Undefined = 0,
    Store = 1,
    Discard = 2,
);
SurfaceGetCurrentTextureStatus :: @enum(i32) (
    SuccessOptimal = 1,
    SuccessSuboptimal = 2,
    Timeout = 3,
    Outdated = 4,
    Lost = 5,
    Error = 6,
);
TextureAspect :: @enum(i32) (
    Undefined = 0,
    All = 1,
    StencilOnly = 2,
    DepthOnly = 3,
);
TextureDimension :: @enum(i32) (
    Undefined = 0,
    _1D = 1,
    _2D = 2,
    _3D = 3,
);
TextureFormat :: @enum(i32) (
    Undefined = 0,
    R8Unorm = 1,
    R8Snorm = 2,
    R8Uint = 3,
    R8Sint = 4,
    R16Uint = 5,
    R16Sint = 6,
    R16Float = 7,
    RG8Unorm = 8,
    RG8Snorm = 9,
    RG8Uint = 10,
    RG8Sint = 11,
    R32Float = 12,
    R32Uint = 13,
    R32Sint = 14,
    RG16Uint = 15,
    RG16Sint = 16,
    RG16Float = 17,
    RGBA8Unorm = 18,
    RGBA8UnormSrgb = 19,
    RGBA8Snorm = 20,
    RGBA8Uint = 21,
    RGBA8Sint = 22,
    BGRA8Unorm = 23,
    BGRA8UnormSrgb = 24,
    RGB10A2Uint = 25,
    RGB10A2Unorm = 26,
    RG11B10Ufloat = 27,
    RGB9E5Ufloat = 28,
    RG32Float = 29,
    RG32Uint = 30,
    RG32Sint = 31,
    RGBA16Uint = 32,
    RGBA16Sint = 33,
    RGBA16Float = 34,
    RGBA32Float = 35,
    RGBA32Uint = 36,
    RGBA32Sint = 37,
    Stencil8 = 38,
    Depth16Unorm = 39,
    Depth24Plus = 40,
    Depth24PlusStencil8 = 41,
    Depth32Float = 42,
    Depth32FloatStencil8 = 43,
    BC1RGBAUnorm = 44,
    BC1RGBAUnormSrgb = 45,
    BC2RGBAUnorm = 46,
    BC2RGBAUnormSrgb = 47,
    BC3RGBAUnorm = 48,
    BC3RGBAUnormSrgb = 49,
    BC4RUnorm = 50,
    BC4RSnorm = 51,
    BC5RGUnorm = 52,
    BC5RGSnorm = 53,
    BC6HRGBUfloat = 54,
    BC6HRGBFloat = 55,
    BC7RGBAUnorm = 56,
    BC7RGBAUnormSrgb = 57,
    ETC2RGB8Unorm = 58,
    ETC2RGB8UnormSrgb = 59,
    ETC2RGB8A1Unorm = 60,
    ETC2RGB8A1UnormSrgb = 61,
    ETC2RGBA8Unorm = 62,
    ETC2RGBA8UnormSrgb = 63,
    EACR11Unorm = 64,
    EACR11Snorm = 65,
    EACRG11Unorm = 66,
    EACRG11Snorm = 67,
    ASTC4x4Unorm = 68,
    ASTC4x4UnormSrgb = 69,
    ASTC5x4Unorm = 70,
    ASTC5x4UnormSrgb = 71,
    ASTC5x5Unorm = 72,
    ASTC5x5UnormSrgb = 73,
    ASTC6x5Unorm = 74,
    ASTC6x5UnormSrgb = 75,
    ASTC6x6Unorm = 76,
    ASTC6x6UnormSrgb = 77,
    ASTC8x5Unorm = 78,
    ASTC8x5UnormSrgb = 79,
    ASTC8x6Unorm = 80,
    ASTC8x6UnormSrgb = 81,
    ASTC8x8Unorm = 82,
    ASTC8x8UnormSrgb = 83,
    ASTC10x5Unorm = 84,
    ASTC10x5UnormSrgb = 85,
    ASTC10x6Unorm = 86,
    ASTC10x6UnormSrgb = 87,
    ASTC10x8Unorm = 88,
    ASTC10x8UnormSrgb = 89,
    ASTC10x10Unorm = 90,
    ASTC10x10UnormSrgb = 91,
    ASTC12x10Unorm = 92,
    ASTC12x10UnormSrgb = 93,
    ASTC12x12Unorm = 94,
    ASTC12x12UnormSrgb = 95,
);
TextureSampleType :: @enum(i32) (
    BindingNotUsed = 0,
    Undefined = 1,
    Float = 2,
    UnfilterableFloat = 3,
    Depth = 4,
    Sint = 5,
    Uint = 6,
);
TextureViewDimension :: @enum(i32) (
    Undefined = 0,
    _1D = 1,
    _2D = 2,
    _2DArray = 3,
    Cube = 4,
    CubeArray = 5,
    _3D = 6,
);
ToneMappingMode :: @enum(i32) (
    Standard = 1,
    Extended = 2,
);
VertexFormat :: @enum(i32) (
    Uint8 = 1,
    Uint8x2 = 2,
    Uint8x4 = 3,
    Sint8 = 4,
    Sint8x2 = 5,
    Sint8x4 = 6,
    Unorm8 = 7,
    Unorm8x2 = 8,
    Unorm8x4 = 9,
    Snorm8 = 10,
    Snorm8x2 = 11,
    Snorm8x4 = 12,
    Uint16 = 13,
    Uint16x2 = 14,
    Uint16x4 = 15,
    Sint16 = 16,
    Sint16x2 = 17,
    Sint16x4 = 18,
    Unorm16 = 19,
    Unorm16x2 = 20,
    Unorm16x4 = 21,
    Snorm16 = 22,
    Snorm16x2 = 23,
    Snorm16x4 = 24,
    Float16 = 25,
    Float16x2 = 26,
    Float16x4 = 27,
    Float32 = 28,
    Float32x2 = 29,
    Float32x3 = 30,
    Float32x4 = 31,
    Uint32 = 32,
    Uint32x2 = 33,
    Uint32x3 = 34,
    Uint32x4 = 35,
    Sint32 = 36,
    Sint32x2 = 37,
    Sint32x3 = 38,
    Sint32x4 = 39,
    Unorm10_10_10_2 = 40,
    Unorm8x4BGRA = 41,
);
VertexStepMode :: @enum(i32) (
    Undefined = 0,
    Vertex = 1,
    Instance = 2,
);
WGSLLanguageFeatureName :: @enum(i32) (
    ReadonlyAndReadwriteStorageTextures = 1,
    Packed4x8IntegerDotProduct = 2,
    UnrestrictedPointerParameters = 3,
    PointerCompositeAccess = 4,
);
WaitStatus :: @enum(i32) (
    WaitStatus_Success = 1,
    WaitStatus_TimedOut = 2,
    WaitStatus_Error = 3,
    WaitStatus_Force32 = 2147483647,
);
BufferUsage :: Flags;
ColorWriteMask :: Flags;
MapMode :: Flags;
ShaderStage :: Flags;
TextureUsage :: Flags;
Proc :: @FnPtr(_: i64) void;  // :TodoDontZeroX0WhenVoid
BufferMapCallback :: @FnPtr(MapAsyncStatus, []u8, rawptr, rawptr) void;
CompilationInfoCallback :: @FnPtr(CompilationInfoRequestStatus, *CompilationInfo, rawptr, rawptr) void;
CreateComputePipelineAsyncCallback :: @FnPtr(CreatePipelineAsyncStatus, ComputePipeline, []u8, rawptr, rawptr) void;
CreateRenderPipelineAsyncCallback :: @FnPtr(CreatePipelineAsyncStatus, RenderPipeline, []u8, rawptr, rawptr) void;
DeviceLostCallback :: @FnPtr(*Device, DeviceLostReason, []u8, rawptr, rawptr) void;
PopErrorScopeCallback :: @FnPtr(PopErrorScopeStatus, ErrorType, []u8, rawptr, rawptr) void;
QueueWorkDoneCallback :: @FnPtr(QueueWorkDoneStatus, []u8, rawptr, rawptr) void;
RequestAdapterCallback :: @FnPtr(RequestAdapterStatus, Adapter, []u8, rawptr, rawptr) void;
RequestDeviceCallback :: @FnPtr(RequestDeviceStatus, Device, []u8, rawptr, rawptr) void;
UncapturedErrorCallback :: @FnPtr(*Device, ErrorType, []u8, rawptr, rawptr) void;
ChainedStruct :: @rec @struct(
    next: *ChainedStruct,
    sType: SType,
);
BufferMapCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: BufferMapCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CompilationInfoCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: CompilationInfoCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CreateComputePipelineAsyncCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: CreateComputePipelineAsyncCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
CreateRenderPipelineAsyncCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: CreateRenderPipelineAsyncCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
DeviceLostCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: DeviceLostCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
PopErrorScopeCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: PopErrorScopeCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
QueueWorkDoneCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: QueueWorkDoneCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
RequestAdapterCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: RequestAdapterCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
RequestDeviceCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    mode: CallbackMode,
    callback: RequestDeviceCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
UncapturedErrorCallbackInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    callback: UncapturedErrorCallback,
    userdata1: rawptr,
    userdata2: rawptr,
);
AdapterInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    vendor: []u8,
    architecture: []u8,
    device: []u8,
    description: []u8,
    backendType: BackendType,
    adapterType: AdapterType,
    vendorID: u32,
    deviceID: u32,
    subgroupMinSize: u32,
    subgroupMaxSize: u32,
);
BindGroupEntry :: @rec @struct(
    nextInChain: *ChainedStruct,
    binding: u32,
    buffer: Buffer,
    offset: u64,
    size: u64,
    sampler: Sampler,
    textureView: TextureView,
);
BlendComponent :: @rec @struct(
    operation: BlendOperation,
    srcFactor: BlendFactor,
    dstFactor: BlendFactor,
);
BufferBindingLayout :: @rec @struct(
    nextInChain: *ChainedStruct,
    type: BufferBindingType,
    hasDynamicOffset: Bool,
    minBindingSize: u64,
);
BufferDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    usage: BufferUsage,
    size: u64,
    mappedAtCreation: Bool,
);
Color :: @rec @struct(
    r: f64,
    g: f64,
    b: f64,
    a: f64,
);
CommandBufferDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
CommandEncoderDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
CompilationMessage :: @rec @struct(
    nextInChain: *ChainedStruct,
    message: []u8,
    type: CompilationMessageType,
    lineNum: u64,
    linePos: u64,
    offset: u64,
    length: u64,
);
ConstantEntry :: @rec @struct(
    nextInChain: *ChainedStruct,
    key: []u8,
    value: f64,
);
Extent3D :: @rec @struct(
    width: u32,
    height: u32,
    depthOrArrayLayers: u32,
);
Future :: @rec @struct(
    id: u64,
);
InstanceLimits :: @rec @struct(
    nextInChain: *ChainedStruct,
    timedWaitAnyMaxCount: usize,
);
Limits :: @rec @struct(
    nextInChain: *ChainedStruct,
    maxTextureDimension1D: u32,
    maxTextureDimension2D: u32,
    maxTextureDimension3D: u32,
    maxTextureArrayLayers: u32,
    maxBindGroups: u32,
    maxBindGroupsPlusVertexBuffers: u32,
    maxBindingsPerBindGroup: u32,
    maxDynamicUniformBuffersPerPipelineLayout: u32,
    maxDynamicStorageBuffersPerPipelineLayout: u32,
    maxSampledTexturesPerShaderStage: u32,
    maxSamplersPerShaderStage: u32,
    maxStorageBuffersPerShaderStage: u32,
    maxStorageTexturesPerShaderStage: u32,
    maxUniformBuffersPerShaderStage: u32,
    maxUniformBufferBindingSize: u64,
    maxStorageBufferBindingSize: u64,
    minUniformBufferOffsetAlignment: u32,
    minStorageBufferOffsetAlignment: u32,
    maxVertexBuffers: u32,
    maxBufferSize: u64,
    maxVertexAttributes: u32,
    maxVertexBufferArrayStride: u32,
    maxInterStageShaderVariables: u32,
    maxColorAttachments: u32,
    maxColorAttachmentBytesPerSample: u32,
    maxComputeWorkgroupStorageSize: u32,
    maxComputeInvocationsPerWorkgroup: u32,
    maxComputeWorkgroupSizeX: u32,
    maxComputeWorkgroupSizeY: u32,
    maxComputeWorkgroupSizeZ: u32,
    maxComputeWorkgroupsPerDimension: u32,
    maxImmediateSize: u32,
);
MultisampleState :: @rec @struct(
    nextInChain: *ChainedStruct,
    count: u32,
    mask: u32,
    alphaToCoverageEnabled: Bool,
);
Origin3D :: @rec @struct(
    x: u32,
    y: u32,
    z: u32,
);
PassTimestampWrites :: @rec @struct(
    nextInChain: *ChainedStruct,
    querySet: QuerySet,
    beginningOfPassWriteIndex: u32,
    endOfPassWriteIndex: u32,
);
PipelineLayoutDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    bindGroupLayoutCount: usize,
    bindGroupLayouts: *BindGroupLayout,
    immediateSize: u32,
);
PrimitiveState :: @rec @struct(
    nextInChain: *ChainedStruct,
    topology: PrimitiveTopology,
    stripIndexFormat: IndexFormat,
    frontFace: FrontFace,
    cullMode: CullMode,
    unclippedDepth: Bool,
);
QuerySetDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    type: QueryType,
    count: u32,
);
QueueDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
RenderBundleDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
RenderBundleEncoderDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    colorFormatCount: usize,
    colorFormats: *TextureFormat,
    depthStencilFormat: TextureFormat,
    sampleCount: u32,
    depthReadOnly: Bool,
    stencilReadOnly: Bool,
);
RenderPassDepthStencilAttachment :: @rec @struct(
    nextInChain: *ChainedStruct,
    view: TextureView,
    depthLoadOp: LoadOp,
    depthStoreOp: StoreOp,
    depthClearValue: f32,
    depthReadOnly: Bool,
    stencilLoadOp: LoadOp,
    stencilStoreOp: StoreOp,
    stencilClearValue: u32,
    stencilReadOnly: Bool,
);
RenderPassMaxDrawCount :: @rec @struct(
    chain: ChainedStruct,
    maxDrawCount: u64,
);
RequestAdapterOptions :: @rec @struct(
    nextInChain: *ChainedStruct,
    featureLevel: FeatureLevel,
    powerPreference: PowerPreference,
    forceFallbackAdapter: Bool,
    backendType: BackendType,
    compatibleSurface: Surface,
);
RequestAdapterWebXROptions :: @rec @struct(
    chain: ChainedStruct,
    xrCompatible: Bool,
);
SamplerBindingLayout :: @rec @struct(
    nextInChain: *ChainedStruct,
    type: SamplerBindingType,
);
SamplerDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    addressModeU: AddressMode,
    addressModeV: AddressMode,
    addressModeW: AddressMode,
    magFilter: FilterMode,
    minFilter: FilterMode,
    mipmapFilter: MipmapFilterMode,
    lodMinClamp: f32,
    lodMaxClamp: f32,
    compare: CompareFunction,
    maxAnisotropy: u16,
);
ShaderModuleDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
ShaderSourceSPIRV :: @rec @struct(
    chain: ChainedStruct,
    codeSize: u32,
    code: *u32,
);
ShaderSourceWGSL :: @rec @struct(
    chain: ChainedStruct,
    code: []u8,
);
StencilFaceState :: @rec @struct(
    compare: CompareFunction,
    failOp: StencilOperation,
    depthFailOp: StencilOperation,
    passOp: StencilOperation,
);
StorageTextureBindingLayout :: @rec @struct(
    nextInChain: *ChainedStruct,
    access: StorageTextureAccess,
    format: TextureFormat,
    viewDimension: TextureViewDimension,
);
SupportedFeatures :: @rec @struct(
    featureCount: usize,
    features: *FeatureName,
);
SupportedInstanceFeatures :: @rec @struct(
    featureCount: usize,
    features: *InstanceFeatureName,
);
SupportedWGSLLanguageFeatures :: @rec @struct(
    featureCount: usize,
    features: *WGSLLanguageFeatureName,
);
SurfaceCapabilities :: @rec @struct(
    nextInChain: *ChainedStruct,
    usages: TextureUsage,
    formatCount: usize,
    formats: *TextureFormat,
    presentModeCount: usize,
    presentModes: *PresentMode,
    alphaModeCount: usize,
    alphaModes: *CompositeAlphaMode,
);
SurfaceColorManagement :: @rec @struct(
    chain: ChainedStruct,
    colorSpace: PredefinedColorSpace,
    toneMappingMode: ToneMappingMode,
);
SurfaceConfiguration :: @rec @struct(
    nextInChain: *ChainedStruct,
    device: Device,
    format: TextureFormat,
    usage: TextureUsage,
    width: u32,
    height: u32,
    viewFormatCount: usize,
    viewFormats: *TextureFormat,
    alphaMode: CompositeAlphaMode,
    presentMode: PresentMode,
);
SurfaceDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
);
SurfaceSourceAndroidNativeWindow :: @rec @struct(
    chain: ChainedStruct,
    window: rawptr,
);
SurfaceSourceMetalLayer :: @rec @struct(
    chain: ChainedStruct,
    layer: rawptr,
);
SurfaceSourceWaylandSurface :: @rec @struct(
    chain: ChainedStruct,
    display: rawptr,
    surface: rawptr,
);
SurfaceSourceWindowsHWND :: @rec @struct(
    chain: ChainedStruct,
    hinstance: rawptr,
    hwnd: rawptr,
);
SurfaceSourceXCBWindow :: @rec @struct(
    chain: ChainedStruct,
    connection: rawptr,
    window: u32,
);
SurfaceSourceXlibWindow :: @rec @struct(
    chain: ChainedStruct,
    display: rawptr,
    window: u64,
);
SurfaceTexture :: @rec @struct(
    nextInChain: *ChainedStruct,
    texture: Texture,
    status: SurfaceGetCurrentTextureStatus,
);
TexelCopyBufferLayout :: @rec @struct(
    offset: u64,
    bytesPerRow: u32,
    rowsPerImage: u32,
);
TextureBindingLayout :: @rec @struct(
    nextInChain: *ChainedStruct,
    sampleType: TextureSampleType,
    viewDimension: TextureViewDimension,
    multisampled: Bool,
);
TextureViewDescriptor :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    label: []u8,
    format := TextureFormat.Undefined,
    dimension := TextureViewDimension.Undefined,
    baseMipLevel: u32,
    mipLevelCount: u32,
    baseArrayLayer: u32,
    arrayLayerCount: u32,
    aspect := TextureAspect.Undefined,
    usage := TextureUsage.Undefined,
);

VertexAttribute :: @rec @struct(
    nextInChain: *ChainedStruct,
    format: VertexFormat,
    offset: u64,
    shaderLocation: u32,
);
BindGroupDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    layout: BindGroupLayout,
    entryCount: usize,
    entries: *BindGroupEntry,
);
BindGroupLayoutEntry :: @rec @struct(
    nextInChain: *ChainedStruct,
    binding: u32,
    visibility: ShaderStage,
    bindingArraySize: u32,
    buffer: BufferBindingLayout,
    sampler: SamplerBindingLayout,
    texture: TextureBindingLayout,
    storageTexture: StorageTextureBindingLayout,
);
BlendState :: @rec @struct(
    color: BlendComponent,
    alpha: BlendComponent,
);
CompilationInfo :: @rec @struct(
    nextInChain: *ChainedStruct,
    messageCount: usize,
    messages: *CompilationMessage,
);
ComputePassDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    timestampWrites: *PassTimestampWrites,
);
ComputeState :: @rec @struct(
    nextInChain: *ChainedStruct,
    module: ShaderModule,
    entryPoint: []u8,
    constantCount: usize,
    constants: *ConstantEntry,
);
DepthStencilState :: @rec @struct(
    nextInChain := zeroed(*ChainedStruct),
    format: TextureFormat,
    depthWriteEnabled: OptionalBool,
    depthCompare: CompareFunction,
    stencilFront: StencilFaceState,
    stencilBack: StencilFaceState,
    stencilReadMask: u32,
    stencilWriteMask: u32,
    depthBias: Int32,
    depthBiasSlopeScale: f32,
    depthBiasClamp: f32,
);
DeviceDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    requiredFeatureCount: usize,
    requiredFeatures: *FeatureName,
    requiredLimits: *Limits,
    defaultQueue: QueueDescriptor,
    deviceLostCallbackInfo: DeviceLostCallbackInfo,
    uncapturedErrorCallbackInfo: UncapturedErrorCallbackInfo,
);
FutureWaitInfo :: @rec @struct(
    future: Future,
    completed: Bool,
);
InstanceDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    requiredFeatureCount: usize,
    requiredFeatures: *InstanceFeatureName,
    requiredLimits: *InstanceLimits,
);
RenderPassColorAttachment :: @rec @struct(
    nextInChain: *ChainedStruct,
    view: TextureView,
    depthSlice: u32,
    resolveTarget: TextureView,
    loadOp: LoadOp,
    storeOp: StoreOp,
    clearValue: Color,
);
TexelCopyBufferInfo :: @rec @struct(
    layout: TexelCopyBufferLayout,
    buffer: Buffer,
);
TexelCopyTextureInfo :: @rec @struct(
    texture: Texture,
    mipLevel: u32,
    origin: Origin3D,
    aspect: TextureAspect,
);
TextureDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    usage: TextureUsage,
    dimension: TextureDimension,
    size: Extent3D,
    format: TextureFormat,
    mipLevelCount: u32,
    sampleCount: u32,
    viewFormatCount: usize,
    viewFormats: *TextureFormat,
);
VertexBufferLayout :: @rec @struct(
    nextInChain: *ChainedStruct,
    stepMode: VertexStepMode,
    arrayStride: u64,
    attributeCount: usize,
    attributes: *VertexAttribute,
);
BindGroupLayoutDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    entryCount: usize,
    entries: *BindGroupLayoutEntry,
);
ColorTargetState :: @rec @struct(
    nextInChain: *ChainedStruct,
    format: TextureFormat,
    blend: *BlendState,
    writeMask: ColorWriteMask,
);
ComputePipelineDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    layout: PipelineLayout,
    compute: ComputeState,
);
RenderPassDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    colorAttachmentCount: usize,
    colorAttachments: *RenderPassColorAttachment,
    depthStencilAttachment: *RenderPassDepthStencilAttachment,
    occlusionQuerySet: QuerySet,
    timestampWrites: *PassTimestampWrites,
);
VertexState :: @rec @struct(
    nextInChain: *ChainedStruct,
    module: ShaderModule,
    entryPoint: []u8,
    constantCount: usize,
    constants: *ConstantEntry,
    bufferCount: usize,
    buffers: *VertexBufferLayout,
);
FragmentState :: @rec @struct(
    nextInChain: *ChainedStruct,
    module: ShaderModule,
    entryPoint: []u8,
    constantCount: usize,
    constants: *ConstantEntry,
    targetCount: usize,
    targets: *ColorTargetState,
);
RenderPipelineDescriptor :: @rec @struct(
    nextInChain: *ChainedStruct,
    label: []u8,
    layout: PipelineLayout,
    vertex: VertexState,
    primitive: PrimitiveState,
    depthStencil: *DepthStencilState,
    multisample: MultisampleState,
    fragment: *FragmentState,
);
fn wgpuCreateInstance(descriptor: *InstanceDescriptor) Instance #import("webgpu");
fn wgpuGetInstanceFeatures(features: *SupportedInstanceFeatures) void #import("webgpu");
fn wgpuGetInstanceLimits(limits: *InstanceLimits) Status #import("webgpu");
fn wgpuHasInstanceFeature(feature: InstanceFeatureName) Bool #import("webgpu");
fn wgpuGetProcAddress(procName: []u8) Proc #import("webgpu");
fn wgpuAdapterGetFeatures(adapter: Adapter, features: *SupportedFeatures) void #import("webgpu");
fn wgpuAdapterGetInfo(adapter: Adapter, info: *AdapterInfo) Status #import("webgpu");
fn wgpuAdapterGetLimits(adapter: Adapter, limits: *Limits) Status #import("webgpu");
fn wgpuAdapterHasFeature(adapter: Adapter, feature: FeatureName) Bool #import("webgpu");
fn wgpuAdapterRequestDevice(adapter: Adapter, descriptor: *DeviceDescriptor, callbackInfo: RequestDeviceCallbackInfo) Future #import("webgpu");
fn wgpuAdapterAddRef(adapter: Adapter) void #import("webgpu");
fn wgpuAdapterRelease(adapter: Adapter) void #import("webgpu");
fn wgpuAdapterInfoFreeMembers(adapterInfo: AdapterInfo) void #import("webgpu");
fn wgpuBindGroupSetLabel(bindGroup: BindGroup, label: []u8) void #import("webgpu");
fn wgpuBindGroupAddRef(bindGroup: BindGroup) void #import("webgpu");
fn wgpuBindGroupRelease(bindGroup: BindGroup) void #import("webgpu");
fn wgpuBindGroupLayoutSetLabel(bindGroupLayout: BindGroupLayout, label: []u8) void #import("webgpu");
fn wgpuBindGroupLayoutAddRef(bindGroupLayout: BindGroupLayout) void #import("webgpu");
fn wgpuBindGroupLayoutRelease(bindGroupLayout: BindGroupLayout) void #import("webgpu");
fn wgpuBufferDestroy(buffer: Buffer) void #import("webgpu");
fn wgpuBufferGetConstMappedRange(buffer: Buffer, offset: usize, size: usize) rawptr #import("webgpu");
fn wgpuBufferGetMapState(buffer: Buffer) BufferMapState #import("webgpu");
fn wgpuBufferGetMappedRange(buffer: Buffer, offset: usize, size: usize) rawptr #import("webgpu");
fn wgpuBufferGetSize(buffer: Buffer) u64 #import("webgpu");
fn wgpuBufferGetUsage(buffer: Buffer) BufferUsage #import("webgpu");
fn wgpuBufferMapAsync(buffer: Buffer, mode: MapMode, offset: usize, size: usize, callbackInfo: BufferMapCallbackInfo) Future #import("webgpu");
fn wgpuBufferReadMappedRange(buffer: Buffer, offset: usize, data: rawptr, size: usize) Status #import("webgpu");
fn wgpuBufferSetLabel(buffer: Buffer, label: []u8) void #import("webgpu");
fn wgpuBufferUnmap(buffer: Buffer) void #import("webgpu");
fn wgpuBufferWriteMappedRange(buffer: Buffer, offset: usize, data: rawptr, size: usize) Status #import("webgpu");
fn wgpuBufferAddRef(buffer: Buffer) void #import("webgpu");
fn wgpuBufferRelease(buffer: Buffer) void #import("webgpu");
fn wgpuCommandBufferSetLabel(commandBuffer: CommandBuffer, label: []u8) void #import("webgpu");
fn wgpuCommandBufferAddRef(commandBuffer: CommandBuffer) void #import("webgpu");
fn wgpuCommandBufferRelease(commandBuffer: CommandBuffer) void #import("webgpu");
fn wgpuCommandEncoderBeginComputePass(commandEncoder: CommandEncoder, descriptor: *ComputePassDescriptor) ComputePassEncoder #import("webgpu");
fn wgpuCommandEncoderBeginRenderPass(commandEncoder: CommandEncoder, descriptor: *RenderPassDescriptor) RenderPassEncoder #import("webgpu");
fn wgpuCommandEncoderClearBuffer(commandEncoder: CommandEncoder, buffer: Buffer, offset: u64, size: u64) void #import("webgpu");
fn wgpuCommandEncoderCopyBufferToBuffer(commandEncoder: CommandEncoder, source: Buffer, sourceOffset: u64, destination: Buffer, destinationOffset: u64, size: u64) void #import("webgpu");
fn wgpuCommandEncoderCopyBufferToTexture(commandEncoder: CommandEncoder, source: *TexelCopyBufferInfo, destination: *TexelCopyTextureInfo, copySize: *Extent3D) void #import("webgpu");
fn wgpuCommandEncoderCopyTextureToBuffer(commandEncoder: CommandEncoder, source: *TexelCopyTextureInfo, destination: *TexelCopyBufferInfo, copySize: *Extent3D) void #import("webgpu");
fn wgpuCommandEncoderCopyTextureToTexture(commandEncoder: CommandEncoder, source: *TexelCopyTextureInfo, destination: *TexelCopyTextureInfo, copySize: *Extent3D) void #import("webgpu");
fn wgpuCommandEncoderFinish(commandEncoder: CommandEncoder, descriptor: *CommandBufferDescriptor) CommandBuffer #import("webgpu");
fn wgpuCommandEncoderInsertDebugMarker(commandEncoder: CommandEncoder, markerLabel: []u8) void #import("webgpu");
fn wgpuCommandEncoderPopDebugGroup(commandEncoder: CommandEncoder) void #import("webgpu");
fn wgpuCommandEncoderPushDebugGroup(commandEncoder: CommandEncoder, groupLabel: []u8) void #import("webgpu");
fn wgpuCommandEncoderResolveQuerySet(commandEncoder: CommandEncoder, querySet: QuerySet, firstQuery: u32, queryCount: u32, destination: Buffer, destinationOffset: u64) void #import("webgpu");
fn wgpuCommandEncoderSetLabel(commandEncoder: CommandEncoder, label: []u8) void #import("webgpu");
fn wgpuCommandEncoderWriteTimestamp(commandEncoder: CommandEncoder, querySet: QuerySet, queryIndex: u32) void #import("webgpu");
fn wgpuCommandEncoderAddRef(commandEncoder: CommandEncoder) void #import("webgpu");
fn wgpuCommandEncoderRelease(commandEncoder: CommandEncoder) void #import("webgpu");
fn wgpuComputePassEncoderDispatchWorkgroups(computePassEncoder: ComputePassEncoder, workgroupCountX: u32, workgroupCountY: u32, workgroupCountZ: u32) void #import("webgpu");
fn wgpuComputePassEncoderDispatchWorkgroupsIndirect(computePassEncoder: ComputePassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
fn wgpuComputePassEncoderEnd(computePassEncoder: ComputePassEncoder) void #import("webgpu");
fn wgpuComputePassEncoderInsertDebugMarker(computePassEncoder: ComputePassEncoder, markerLabel: []u8) void #import("webgpu");
fn wgpuComputePassEncoderPopDebugGroup(computePassEncoder: ComputePassEncoder) void #import("webgpu");
fn wgpuComputePassEncoderPushDebugGroup(computePassEncoder: ComputePassEncoder, groupLabel: []u8) void #import("webgpu");
fn wgpuComputePassEncoderSetBindGroup(computePassEncoder: ComputePassEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
fn wgpuComputePassEncoderSetLabel(computePassEncoder: ComputePassEncoder, label: []u8) void #import("webgpu");
fn wgpuComputePassEncoderSetPipeline(computePassEncoder: ComputePassEncoder, pipeline: ComputePipeline) void #import("webgpu");
fn wgpuComputePassEncoderAddRef(computePassEncoder: ComputePassEncoder) void #import("webgpu");
fn wgpuComputePassEncoderRelease(computePassEncoder: ComputePassEncoder) void #import("webgpu");
fn wgpuComputePipelineGetBindGroupLayout(computePipeline: ComputePipeline, groupIndex: u32) BindGroupLayout #import("webgpu");
fn wgpuComputePipelineSetLabel(computePipeline: ComputePipeline, label: []u8) void #import("webgpu");
fn wgpuComputePipelineAddRef(computePipeline: ComputePipeline) void #import("webgpu");
fn wgpuComputePipelineRelease(computePipeline: ComputePipeline) void #import("webgpu");
fn wgpuDeviceCreateBindGroup(device: Device, descriptor: *BindGroupDescriptor) BindGroup #import("webgpu");
fn wgpuDeviceCreateBindGroupLayout(device: Device, descriptor: *BindGroupLayoutDescriptor) BindGroupLayout #import("webgpu");
fn wgpuDeviceCreateBuffer(device: Device, descriptor: *BufferDescriptor) Buffer #import("webgpu");
fn wgpuDeviceCreateCommandEncoder(device: Device, descriptor: *CommandEncoderDescriptor) CommandEncoder #import("webgpu");
fn wgpuDeviceCreateComputePipeline(device: Device, descriptor: *ComputePipelineDescriptor) ComputePipeline #import("webgpu");
fn wgpuDeviceCreateComputePipelineAsync(device: Device, descriptor: *ComputePipelineDescriptor, callbackInfo: CreateComputePipelineAsyncCallbackInfo) Future #import("webgpu");
fn wgpuDeviceCreatePipelineLayout(device: Device, descriptor: *PipelineLayoutDescriptor) PipelineLayout #import("webgpu");
fn wgpuDeviceCreateQuerySet(device: Device, descriptor: *QuerySetDescriptor) QuerySet #import("webgpu");
fn wgpuDeviceCreateRenderBundleEncoder(device: Device, descriptor: *RenderBundleEncoderDescriptor) RenderBundleEncoder #import("webgpu");
fn wgpuDeviceCreateRenderPipeline(device: Device, descriptor: *RenderPipelineDescriptor) RenderPipeline #import("webgpu");
fn wgpuDeviceCreateRenderPipelineAsync(device: Device, descriptor: *RenderPipelineDescriptor, callbackInfo: CreateRenderPipelineAsyncCallbackInfo) Future #import("webgpu");
fn wgpuDeviceCreateSampler(device: Device, descriptor: *SamplerDescriptor) Sampler #import("webgpu");
fn wgpuDeviceCreateShaderModule(device: Device, descriptor: *ShaderModuleDescriptor) ShaderModule #import("webgpu");
fn wgpuDeviceCreateTexture(device: Device, descriptor: *TextureDescriptor) Texture #import("webgpu");
fn wgpuDeviceDestroy(device: Device) void #import("webgpu");
fn wgpuDeviceGetAdapterInfo(device: Device, adapterInfo: *AdapterInfo) Status #import("webgpu");
fn wgpuDeviceGetFeatures(device: Device, features: *SupportedFeatures) void #import("webgpu");
fn wgpuDeviceGetLimits(device: Device, limits: *Limits) Status #import("webgpu");
fn wgpuDeviceGetLostFuture(device: Device) Future #import("webgpu");
fn wgpuDeviceGetQueue(device: Device) Queue #import("webgpu");
fn wgpuDeviceHasFeature(device: Device, feature: FeatureName) Bool #import("webgpu");
fn wgpuDevicePopErrorScope(device: Device, callbackInfo: PopErrorScopeCallbackInfo) Future #import("webgpu");
fn wgpuDevicePushErrorScope(device: Device, filter: ErrorFilter) void #import("webgpu");
fn wgpuDeviceSetLabel(device: Device, label: []u8) void #import("webgpu");
fn wgpuDeviceAddRef(device: Device) void #import("webgpu");
fn wgpuDeviceRelease(device: Device) void #import("webgpu");
fn wgpuInstanceCreateSurface(instance: Instance, descriptor: *SurfaceDescriptor) Surface #import("webgpu");
fn wgpuInstanceGetWGSLLanguageFeatures(instance: Instance, features: *SupportedWGSLLanguageFeatures) Status #import("webgpu");
fn wgpuInstanceHasWGSLLanguageFeature(instance: Instance, feature: WGSLLanguageFeatureName) Bool #import("webgpu");
fn wgpuInstanceProcessEvents(instance: Instance) void #import("webgpu");
fn wgpuInstanceRequestAdapter(instance: Instance, options: *RequestAdapterOptions, callbackInfo: RequestAdapterCallbackInfo) Future #import("webgpu");
fn wgpuInstanceWaitAny(instance: Instance, futureCount: usize, futures: *FutureWaitInfo, timeoutNS: u64) WaitStatus #import("webgpu");
fn wgpuInstanceAddRef(instance: Instance) void #import("webgpu");
fn wgpuInstanceRelease(instance: Instance) void #import("webgpu");
fn wgpuPipelineLayoutSetLabel(pipelineLayout: PipelineLayout, label: []u8) void #import("webgpu");
fn wgpuPipelineLayoutAddRef(pipelineLayout: PipelineLayout) void #import("webgpu");
fn wgpuPipelineLayoutRelease(pipelineLayout: PipelineLayout) void #import("webgpu");
fn wgpuQuerySetDestroy(querySet: QuerySet) void #import("webgpu");
fn wgpuQuerySetGetCount(querySet: QuerySet) u32 #import("webgpu");
fn wgpuQuerySetGetType(querySet: QuerySet) QueryType #import("webgpu");
fn wgpuQuerySetSetLabel(querySet: QuerySet, label: []u8) void #import("webgpu");
fn wgpuQuerySetAddRef(querySet: QuerySet) void #import("webgpu");
fn wgpuQuerySetRelease(querySet: QuerySet) void #import("webgpu");
fn wgpuQueueOnSubmittedWorkDone(queue: Queue, callbackInfo: QueueWorkDoneCallbackInfo) Future #import("webgpu");
fn wgpuQueueSetLabel(queue: Queue, label: []u8) void #import("webgpu");
fn wgpuQueueSubmit(queue: Queue, commandCount: usize, commands: *CommandBuffer) void #import("webgpu");
fn wgpuQueueWriteBuffer(queue: Queue, buffer: Buffer, bufferOffset: u64, data: rawptr, size: usize) void #import("webgpu");
fn wgpuQueueWriteTexture(queue: Queue, destination: *TexelCopyTextureInfo, data: rawptr, dataSize: usize, dataLayout: *TexelCopyBufferLayout, writeSize: *Extent3D) void #import("webgpu");
fn wgpuQueueAddRef(queue: Queue) void #import("webgpu");
fn wgpuQueueRelease(queue: Queue) void #import("webgpu");
fn wgpuRenderBundleSetLabel(renderBundle: RenderBundle, label: []u8) void #import("webgpu");
fn wgpuRenderBundleAddRef(renderBundle: RenderBundle) void #import("webgpu");
fn wgpuRenderBundleRelease(renderBundle: RenderBundle) void #import("webgpu");
fn wgpuRenderBundleEncoderDraw(renderBundleEncoder: RenderBundleEncoder, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void #import("webgpu");
fn wgpuRenderBundleEncoderDrawIndexed(renderBundleEncoder: RenderBundleEncoder, indexCount: u32, instanceCount: u32, firstIndex: u32, baseVertex: Int32, firstInstance: u32) void #import("webgpu");
fn wgpuRenderBundleEncoderDrawIndexedIndirect(renderBundleEncoder: RenderBundleEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
fn wgpuRenderBundleEncoderDrawIndirect(renderBundleEncoder: RenderBundleEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
fn wgpuRenderBundleEncoderFinish(renderBundleEncoder: RenderBundleEncoder, descriptor: *RenderBundleDescriptor) RenderBundle #import("webgpu");
fn wgpuRenderBundleEncoderInsertDebugMarker(renderBundleEncoder: RenderBundleEncoder, markerLabel: []u8) void #import("webgpu");
fn wgpuRenderBundleEncoderPopDebugGroup(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
fn wgpuRenderBundleEncoderPushDebugGroup(renderBundleEncoder: RenderBundleEncoder, groupLabel: []u8) void #import("webgpu");
fn wgpuRenderBundleEncoderSetBindGroup(renderBundleEncoder: RenderBundleEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
fn wgpuRenderBundleEncoderSetIndexBuffer(renderBundleEncoder: RenderBundleEncoder, buffer: Buffer, format: IndexFormat, offset: u64, size: u64) void #import("webgpu");
fn wgpuRenderBundleEncoderSetLabel(renderBundleEncoder: RenderBundleEncoder, label: []u8) void #import("webgpu");
fn wgpuRenderBundleEncoderSetPipeline(renderBundleEncoder: RenderBundleEncoder, pipeline: RenderPipeline) void #import("webgpu");
fn wgpuRenderBundleEncoderSetVertexBuffer(renderBundleEncoder: RenderBundleEncoder, slot: u32, buffer: Buffer, offset: u64, size: u64) void #import("webgpu");
fn wgpuRenderBundleEncoderAddRef(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
fn wgpuRenderBundleEncoderRelease(renderBundleEncoder: RenderBundleEncoder) void #import("webgpu");
fn wgpuRenderPassEncoderBeginOcclusionQuery(renderPassEncoder: RenderPassEncoder, queryIndex: u32) void #import("webgpu");
fn wgpuRenderPassEncoderDraw(renderPassEncoder: RenderPassEncoder, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void #import("webgpu");
fn wgpuRenderPassEncoderDrawIndexed(renderPassEncoder: RenderPassEncoder, indexCount: u32, instanceCount: u32, firstIndex: u32, baseVertex: Int32, firstInstance: u32) void #import("webgpu");
fn wgpuRenderPassEncoderDrawIndexedIndirect(renderPassEncoder: RenderPassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
fn wgpuRenderPassEncoderDrawIndirect(renderPassEncoder: RenderPassEncoder, indirectBuffer: Buffer, indirectOffset: u64) void #import("webgpu");
fn wgpuRenderPassEncoderEnd(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
fn wgpuRenderPassEncoderEndOcclusionQuery(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
fn wgpuRenderPassEncoderExecuteBundles(renderPassEncoder: RenderPassEncoder, bundleCount: usize, bundles: *RenderBundle) void #import("webgpu");
fn wgpuRenderPassEncoderInsertDebugMarker(renderPassEncoder: RenderPassEncoder, markerLabel: []u8) void #import("webgpu");
fn wgpuRenderPassEncoderPopDebugGroup(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
fn wgpuRenderPassEncoderPushDebugGroup(renderPassEncoder: RenderPassEncoder, groupLabel: []u8) void #import("webgpu");
fn wgpuRenderPassEncoderSetBindGroup(renderPassEncoder: RenderPassEncoder, groupIndex: u32, group: BindGroup, dynamicOffsetCount: usize, dynamicOffsets: *u32) void #import("webgpu");
fn wgpuRenderPassEncoderSetBlendConstant(renderPassEncoder: RenderPassEncoder, color: *Color) void #import("webgpu");
fn wgpuRenderPassEncoderSetIndexBuffer(renderPassEncoder: RenderPassEncoder, buffer: Buffer, format: IndexFormat, offset: u64, size: u64) void #import("webgpu");
fn wgpuRenderPassEncoderSetLabel(renderPassEncoder: RenderPassEncoder, label: []u8) void #import("webgpu");
fn wgpuRenderPassEncoderSetPipeline(renderPassEncoder: RenderPassEncoder, pipeline: RenderPipeline) void #import("webgpu");
fn wgpuRenderPassEncoderSetScissorRect(renderPassEncoder: RenderPassEncoder, x: u32, y: u32, width: u32, height: u32) void #import("webgpu");
fn wgpuRenderPassEncoderSetStencilReference(renderPassEncoder: RenderPassEncoder, reference: u32) void #import("webgpu");
fn wgpuRenderPassEncoderSetVertexBuffer(renderPassEncoder: RenderPassEncoder, slot: u32, buffer: Buffer, offset: u64, size: u64) void #import("webgpu");
fn wgpuRenderPassEncoderSetViewport(renderPassEncoder: RenderPassEncoder, x: f32, y: f32, width: f32, height: f32, minDepth: f32, maxDepth: f32) void #import("webgpu");
fn wgpuRenderPassEncoderAddRef(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
fn wgpuRenderPassEncoderRelease(renderPassEncoder: RenderPassEncoder) void #import("webgpu");
fn wgpuRenderPipelineGetBindGroupLayout(renderPipeline: RenderPipeline, groupIndex: u32) BindGroupLayout #import("webgpu");
fn wgpuRenderPipelineSetLabel(renderPipeline: RenderPipeline, label: []u8) void #import("webgpu");
fn wgpuRenderPipelineAddRef(renderPipeline: RenderPipeline) void #import("webgpu");
fn wgpuRenderPipelineRelease(renderPipeline: RenderPipeline) void #import("webgpu");
fn wgpuSamplerSetLabel(sampler: Sampler, label: []u8) void #import("webgpu");
fn wgpuSamplerAddRef(sampler: Sampler) void #import("webgpu");
fn wgpuSamplerRelease(sampler: Sampler) void #import("webgpu");
fn wgpuShaderModuleGetCompilationInfo(shaderModule: ShaderModule, callbackInfo: CompilationInfoCallbackInfo) Future #import("webgpu");
fn wgpuShaderModuleSetLabel(shaderModule: ShaderModule, label: []u8) void #import("webgpu");
fn wgpuShaderModuleAddRef(shaderModule: ShaderModule) void #import("webgpu");
fn wgpuShaderModuleRelease(shaderModule: ShaderModule) void #import("webgpu");
fn wgpuSupportedFeaturesFreeMembers(supportedFeatures: SupportedFeatures) void #import("webgpu");
fn wgpuSupportedInstanceFeaturesFreeMembers(supportedInstanceFeatures: SupportedInstanceFeatures) void #import("webgpu");
fn wgpuSupportedWGSLLanguageFeaturesFreeMembers(supportedWGSLLanguageFeatures: SupportedWGSLLanguageFeatures) void #import("webgpu");
fn wgpuSurfaceConfigure(surface: Surface, config: *SurfaceConfiguration) void #import("webgpu");
fn wgpuSurfaceGetCapabilities(surface: Surface, adapter: Adapter, capabilities: *SurfaceCapabilities) Status #import("webgpu");
fn wgpuSurfaceGetCurrentTexture(surface: Surface, surfaceTexture: *SurfaceTexture) void #import("webgpu");
fn wgpuSurfacePresent(surface: Surface) Status #import("webgpu");
fn wgpuSurfaceSetLabel(surface: Surface, label: []u8) void #import("webgpu");
fn wgpuSurfaceUnconfigure(surface: Surface) void #import("webgpu");
fn wgpuSurfaceAddRef(surface: Surface) void #import("webgpu");
fn wgpuSurfaceRelease(surface: Surface) void #import("webgpu");
fn wgpuSurfaceCapabilitiesFreeMembers(surfaceCapabilities: SurfaceCapabilities) void #import("webgpu");
fn wgpuTextureCreateView(texture: Texture, descriptor: *TextureViewDescriptor) TextureView #import("webgpu");
fn wgpuTextureDestroy(texture: Texture) void #import("webgpu");
fn wgpuTextureGetDepthOrArrayLayers(texture: Texture) u32 #import("webgpu");
fn wgpuTextureGetDimension(texture: Texture) TextureDimension #import("webgpu");
fn wgpuTextureGetFormat(texture: Texture) TextureFormat #import("webgpu");
fn wgpuTextureGetHeight(texture: Texture) u32 #import("webgpu");
fn wgpuTextureGetMipLevelCount(texture: Texture) u32 #import("webgpu");
fn wgpuTextureGetSampleCount(texture: Texture) u32 #import("webgpu");
fn wgpuTextureGetUsage(texture: Texture) TextureUsage #import("webgpu");
fn wgpuTextureGetWidth(texture: Texture) u32 #import("webgpu");
fn wgpuTextureSetLabel(texture: Texture, label: []u8) void #import("webgpu");
fn wgpuTextureAddRef(texture: Texture) void #import("webgpu");
fn wgpuTextureRelease(texture: Texture) void #import("webgpu");
fn wgpuTextureViewSetLabel(textureView: TextureView, label: []u8) void #import("webgpu");
fn wgpuTextureViewAddRef(textureView: TextureView) void #import("webgpu");
fn wgpuTextureViewRelease(textureView: TextureView) void #import("webgpu");
