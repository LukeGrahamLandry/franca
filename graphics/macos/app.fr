// macOS application wrapper
// Adapted from sokol_app.h - https://github.com/floooh/sokol
// zlib/libpng license. Copyright (c) 2018 Andre Weissflog.
//
// Changes from Sokol
// - no dependency on an objective-c compiler
// - wait until after setActivationPolicy to set the startup icon/fullscreen (otherwise it doesn't work)
//
// TODO: figure out where the objective c compiler inserts reference counting instructions. 
//       i'm probably leaking everything or letting it free everything out from under me. 
// TODO: timing
// TODO: keep the changed cursor if the mouse leaves and then comes back 
//      (maybe the resize <-> is eating it when you mouse over the border)
// TODO: setting the title also resets the mouse cursor to default. 
// TODO: i kinda want to let you paste images NSPasteboardTypePNG
// TODO: 86760b60423d18f07f2fdb0a4f00553d4229034a

#use("@/lib/sys/objective_c.fr");
Sapp :: import("@/graphics/app.fr");

Impl :: @struct(
    flags_changed_store: u32,
    mouse_buttons: u8,
    window: ObjCId, // *NSWindow,
    tracking_area: ObjCId, // *NSTrackingArea,
    keyup_monitor: ObjCId,
    app_dlg: ObjCId, // *AppDelegate, 
    win_dlg: ObjCId, // *WindowDelegate,
    view: ObjCId, // *View,
    cursors: EnumMap(Sapp.MouseCursor, ObjCId), // *NSCursor),
    mtl_device: ObjCId, // MTLDevice,
    classes: Classes,
    env: rawptr,
);

// TODO: these #tags don't do anything but maybe they should generate register_objective_c_classes()
Classes :: @struct(
    MyAppDelegate: ObjCClass #declare #extends(NSObject) #implements(NSApplicationDelegate),
    MyWindow: ObjCClass #declare #extends(NSWindow),
    MyWindowDelegate: ObjCClass #declare #extends(NSObject) #implements(NSWindowDelegate),
    MyView: ObjCClass #declare #extends(MTKView),  // TODO: if not metal, NSOpenGLView
    NSCursor: ObjCClass,
    NSApplication: ObjCClass,
    NSEvent: ObjCClass,
    NSPasteboard: ObjCClass,
    NSWindow: ObjCClass,
    NSObject: ObjCClass,
    MTKView: ObjCClass,
    NSScreen: ObjCClass,
    NSString: ObjCClass,
    NSArray: ObjCClass,
    NSTrackingArea: ObjCClass,
    NSURL: ObjCClass,
    NSImage: ObjCClass,
    NSImageView: ObjCClass,
    NSConcreteGlobalBlock: ObjCId,
    NSPasteboardTypeFileURL: ObjCId, 
    NSPasteboardTypeString: ObjCId,
    kCAFilterNearest: ObjCId,
    kCFAllocatorDefault: ObjCId,
    NSApp: ObjCId,  // instance that represents the current app
);

fn run(m: *Impl, desc: *Sapp.Desc) Never = {
    sapp := m.common();
    c := m.classes&;
    m.env = get_dynamic_context();
    
    register_objective_c_classes(m);
    c.NSApp = @objc c.NSApplication.sharedApplication();
    
    // sanity
    inline_for_enum Classes.Fields() { $it |
        v := Classes.get_field(c, it[])[];
        xxx := :: it[].name_str();
        if xxx != "kCFAllocatorDefault" {  // UGH
            @debug_assert_ne(0, bit_cast_unchecked(@type v, i64, v), "missing %", it[]);
        };
    };

    m.app_dlg = @objc init(@objc alloc(c.MyAppDelegate));
    object_setInstanceVariable(m.app_dlg, "franca_sapp", Impl.raw_from_ptr(m));
    @objc c.NSApp.setDelegate(m.app_dlg);

    // workaround for "no key-up sent while Cmd is pressed" taken from GLFW:
    NSEventMaskKeyUp :: 1.shift_left(11);
    B :: please_just_make_a_fucking_block__LEAK;
    aBlock := B(sapp.desc.allocator, Impl.raw_from_ptr(m), @as(rawptr) keyup_monitor, c.NSConcreteGlobalBlock);
    m.keyup_monitor = @objc c.NSEvent.addLocalMonitorForEventsMatchingMask(NSEventMaskKeyUp, handler = aBlock);

    @objc c.NSApp.run();
    // NOTE: [NSApp run] never returns, instead cleanup code
    // must be put into applicationWillTerminate
    unreachable()
}

keyup_monitor :: fn(self: *Block_literal_1, event: ObjCId) ObjCId = {
    macos := Impl.ptr_from_raw(self.userdata);
    set_dynamic_context(macos.env);
    flags := @objc @as(i64) event.modifierFlags();
    NSEventModifierFlagCommand :: 1.shift_left(20);
    if flags.bit_and(NSEventModifierFlagCommand) != 0 {
        @objc sendEvent(@objc macos.classes.NSApp.keyWindow(), event);
    };
    event
};

// TODO: if i decide talking to objective c is something i want to be good at, 
//       i can definitely do a fancy comptime thing to make this not suck. 
fn register_objective_c_classes(self: *Impl) void = {
    c := self.classes&;
    
    inline_for_enum Classes.Fields() { $it |
        v := Classes.get_field(c, it[]);
        @if(@run(ObjCClass == @type v[])) {
            // Doing this for my own classes that aren't declared yet is fine, will just return nil. 
            v[] = objc_getClass(::it[].name_str().sym().c_str());
        };
    };
    
    c.MyAppDelegate = objc_allocateClassPair(c.NSObject, "FrancaAppDelegate", 0);
    c.MyWindow = objc_allocateClassPair(c.NSWindow, "FrancaWindow", 0);
    c.MyWindowDelegate = objc_allocateClassPair(c.NSObject, "FrancaWindowDelegate", 0);
    c.MyView = objc_allocateClassPair(c.MTKView, "FrancaView", 0);
    
    var :: fn(cls) => class_addIvar(cls, "franca_sapp", 8, 3, "q");
    var(c.MyAppDelegate);
    var(c.MyWindow);
    var(c.MyWindowDelegate);
    var(c.MyView);
    
    NSApplicationDelegate := objc_getProtocol(@as(CStr) "NSApplicationDelegate");
    NSWindowDelegate := objc_getProtocol(@as(CStr) "NSWindowDelegate");
    class_addProtocol(c.MyAppDelegate, NSApplicationDelegate);
    class_addProtocol(c.MyWindowDelegate, NSWindowDelegate);
    
    class_addMethod(c.MyAppDelegate, "applicationDidFinishLaunching:".sel_getUid(), applicationDidFinishLaunching, "@:@");
    class_addMethod(c.MyAppDelegate, "applicationShouldTerminateAfterLastWindowClosed:".sel_getUid(), applicationShouldTerminateAfterLastWindowClosed, "@:@");
    class_addMethod(c.MyAppDelegate, "applicationWillTerminate:".sel_getUid(), applicationWillTerminate, "@:@");
   
    class_addMethod(c.MyWindowDelegate, "windowShouldClose:".sel_getUid(), windowShouldClose, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowWillStartLiveResize:".sel_getUid(), windowWillStartLiveResize, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidResize:".sel_getUid(), windowDidResize, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidChangeScreen:".sel_getUid(), windowDidChangeScreen, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidMiniaturize:".sel_getUid(), windowDidMiniaturize, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidDeminiaturize:".sel_getUid(), windowDidDeminiaturize, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidBecomeKey:".sel_getUid(), windowDidBecomeKey, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidResignKey:".sel_getUid(), windowDidResignKey, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidEnterFullScreen:".sel_getUid(), windowDidEnterFullScreen, "@:@");
    class_addMethod(c.MyWindowDelegate, "windowDidExitFullScreen:".sel_getUid(), windowDidExitFullScreen, "@:@");
    
    class_addMethod(c.MyWindow, "initWithContentRect:styleMask:backing:defer:".sel_getUid(), initWithContentRect, "");
    class_addMethod(c.MyWindow, "draggingEntered:".sel_getUid(), draggingEntered, "");
    class_addMethod(c.MyWindow, "draggingUpdated:".sel_getUid(), draggingUpdated, "");
    class_addMethod(c.MyWindow, "performDragOperation:".sel_getUid(), performDragOperation, "");
    
    class_addMethod(c.MyView, "drawRect:".sel_getUid(), drawRect, "");
    class_addMethod(c.MyView, "isOpaque".sel_getUid(), isOpaque, "");
    class_addMethod(c.MyView, "canBecomeKeyView".sel_getUid(), canBecomeKeyView, "");
    class_addMethod(c.MyView, "acceptsFirstResponder".sel_getUid(), acceptsFirstResponder, "");
    class_addMethod(c.MyView, "updateTrackingAreas".sel_getUid(), updateTrackingAreas, "");
    class_addMethod(c.MyView, "mouseEntered:".sel_getUid(), mouseEntered, "");
    class_addMethod(c.MyView, "mouseExited:".sel_getUid(), mouseExited, "");
    class_addMethod(c.MyView, "mouseDown:".sel_getUid(), mouseDown, "");
    class_addMethod(c.MyView, "mouseUp:".sel_getUid(), mouseUp, "");
    class_addMethod(c.MyView, "rightMouseDown:".sel_getUid(), rightMouseDown, "");
    class_addMethod(c.MyView, "rightMouseUp:".sel_getUid(), rightMouseUp, "");
    class_addMethod(c.MyView, "otherMouseDown:".sel_getUid(), otherMouseDown, "");
    class_addMethod(c.MyView, "otherMouseUp:".sel_getUid(), otherMouseUp, "");
    class_addMethod(c.MyView, "otherMouseDragged:".sel_getUid(), otherMouseDragged, "");
    class_addMethod(c.MyView, "mouseMoved:".sel_getUid(), mouseMoved, "");
    class_addMethod(c.MyView, "mouseDragged:".sel_getUid(), mouseDragged, "");
    class_addMethod(c.MyView, "rightMouseDragged:".sel_getUid(), rightMouseDragged, "");
    class_addMethod(c.MyView, "scrollWheel:".sel_getUid(), scrollWheel, "");
    class_addMethod(c.MyView, "keyDown:".sel_getUid(), keyDown, "");
    class_addMethod(c.MyView, "performKeyEquivalent:".sel_getUid(), performKeyEquivalent, "");
    class_addMethod(c.MyView, "keyUp:".sel_getUid(), keyUp, "");
    class_addMethod(c.MyView, "flagsChanged:".sel_getUid(), flagsChanged, "");
    
    objc_registerClassPair(c.MyAppDelegate);
    objc_registerClassPair(c.MyWindow);
    objc_registerClassPair(c.MyWindowDelegate);
    objc_registerClassPair(c.MyView);
    
    // TODO: Expr::DataSymbol needs to let you say which library to import from 

    Dyn :: import("@/lib/dynamic_lib.fr");
    a := Dyn'open("/System/Library/Frameworks/AppKit.framework/AppKit").expect("open AppKit");
    q := Dyn'open("/System/Library/Frameworks/QuartzCore.framework/QuartzCore").expect("open QuartzCore");
    g := Dyn'open("/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics").expect("open CoreGraphics");
    
    c.kCAFilterNearest = {  // HACK
        ObjCId.ptr_from_raw(@as(rawptr) q.dlsym("kCAFilterNearest"))[]
    };
    c.NSPasteboardTypeFileURL = {  // HACK
        ObjCId.ptr_from_raw(@as(rawptr) a.dlsym("NSPasteboardTypeFileURL"))[]
    };
    c.NSPasteboardTypeString = {  // HACK
        ObjCId.ptr_from_raw(@as(rawptr) a.dlsym("NSPasteboardTypeString"))[]
    };
    objc := Dyn'open("/usr/lib/libobjc.dylib").expect("open objc");
    c.NSConcreteGlobalBlock = {  // HACK
        bit_cast_unchecked(rawptr, ObjCId, @as(rawptr) objc.dlsym("_NSConcreteGlobalBlock"))
    };
    c.kCFAllocatorDefault = {  // HACK
        ObjCId.ptr_from_raw(@as(rawptr) g.dlsym("kCFAllocatorDefault"))[]
    };
    
    
    /*
    // IMPORTANT: this #import fn() trick doesn't work aot because you always get a shim 
    c.kCAFilterNearest = {  // HACK
        kCAFilterNearest :: fn() void #import("QuartzCore");
        ObjCId.ptr_from_raw(@as(rawptr) kCAFilterNearest)[]
    };
    c.NSPasteboardTypeFileURL = {  // HACK
        NSPasteboardTypeFileURL :: fn() void #import("AppKit");
        ObjCId.ptr_from_raw(@as(rawptr) NSPasteboardTypeFileURL)[]
    };
    c.NSPasteboardTypeString = {  // HACK
        NSPasteboardTypeString :: fn() void #import("AppKit");
        ObjCId.ptr_from_raw(@as(rawptr) NSPasteboardTypeString)[]
    };
    */
}

fn macos_discard_state(m: *Impl) void = {
    // NOTE: it's safe to call [release] on a nil object
    if !m.keyup_monitor.is_null() {
        @objc m.classes.NSEvent.removeMonitor(m.keyup_monitor);
        // NOTE: removeMonitor also releases the object
        m.keyup_monitor = ObjCId.zeroed();
        // TODO: this still leaks the block because i said it was global
    };
    @objc m.tracking_area.release();
    @objc m.app_dlg.release();
    @objc m.win_dlg.release();
    @objc m.view.release();
    @debug_assert(SOKOL_BACKEND.is_metal());
    @objc m.mtl_device.release();
    @objc m.window.release();
}

fn init_cursors(self: *Impl) void = {
    C := self.classes.NSCursor;
    c := self.cursors&;
    
    c[.DEFAULT] = ObjCId.zeroed(); // not a bug
    c[.ARROW] = @objc C.arrowCursor();
    c[.IBEAM] = @objc C.IBeamCursor();
    c[.CROSSHAIR] = @objc C.crosshairCursor();
    c[.POINTING_HAND] = @objc C.pointingHandCursor();
    // TODO: use [NSCursor frameResizeCursorFromPosition:inDirections:] ?
    c[.RESIZE_EW] = @objc C._windowResizeEastWestCursor();
    c[.RESIZE_NS] = @objc C._windowResizeNorthSouthCursor();
    c[.RESIZE_NWSE] = @objc C._windowResizeNorthWestSouthEastCursor();
    c[.RESIZE_NESW] = @objc C._windowResizeNorthEastSouthWestCursor();
    c[.RESIZE_ALL] = @objc C.closedHandCursor();
    c[.NOT_ALLOWED] = @objc C.operationNotAllowedCursor();
}

fn macos_mods(sapp: *Sapp.Common, ev: ObjCId) Sapp.Modifiers = { // ev: NSEvent
    NSEvent := sapp.impl()[].classes.NSEvent;
    ::ptr_utils(@type ev[]);
    f := @if(ev.is_null(), @objc @as(u32) NSEvent.modifierFlags(), @objc @as(u32) ev.modifierFlags()); // NSEventModifierFlags
    b := @objc @as(u32) NSEvent.pressedMouseButtons();
    m := zeroed Sapp.Modifiers;
    X :: fn(mask, bit, $key: Sapp.Modifiers.Wide.Fields()) => {
        if mask.bit_and(1.shift_left(bit)) != 0 {
            m&.set(key, 1);
        };
    };
    
    // NSEventModifierFlag
    X(f, 17, .shift);
    X(f, 18, .control);
    X(f, 19, .alt);   // option
    X(f, 20, .super); // command
    X(b, 0, .left_mouse);
    X(b, 1, .right_mouse);
    X(b, 2, .middle_mouse);
    m
}

fn macos_mouse_event(sapp: *Sapp.Common, type: Sapp.EventType, btn: Sapp.Mousebutton, event: ObjCId) void = {
    if(!sapp.events_enabled(), => return());
    mod := sapp.macos_mods(event);
    sapp.init_event(type);
    sapp.event.mouse_button = btn;
    sapp.event.modifiers = mod;
    sapp.call_event(sapp.event&);
}

fn macos_key_event(sapp: *Sapp.Common, type: Sapp.EventType, key: Sapp.Keycode, repeat: bool, mod: Sapp.Modifiers) void = {
    if(!sapp.events_enabled(), => return()); 
    sapp.init_event(type);
    e := sapp.event&;
    e.key_code = key;
    e.key_repeat = repeat;
    e.modifiers = mod;
    sapp.call_event(e);
}

fn app_event(sapp: *Sapp.Common, type: Sapp.EventType) void = {
    if(!sapp.events_enabled(), => return()); 
    sapp.init_event(type);
    sapp.call_event(sapp.event&);
}

fn app_event(stash: ObjCId, type: Sapp.EventType) void = {
    sapp, _ := GET(stash);
    sapp.app_event(type);
}

/* NOTE: unlike the iOS version of this function, the macOS version
    can dynamically update the DPI scaling factor when a window is moved
    between HighDPI / LowDPI screens.
*/
fn update_dimensions(macos: *Impl) void = {
    sapp := macos.common();
    if sapp.desc.high_dpi {
        s := @objc macos.window.screen();
        sapp.dpi_scale = cast(@objc @as(f64) s.backingScaleFactor());
    } else {
        sapp.dpi_scale = 1.0;
    };
    @debug_assert(!macos.view.is_null());
    layer := @objc macos.view.layer();
    @objc layer.setContentsScale(@as(f64) sapp.dpi_scale.cast()); // NOTE: needed because we set layerContentsPlacement to a non-scaling value in windowWillStartLiveResize.
    bounds := @objc @as(CGRect) macos.view.bounds();
    sapp.window_width = int(bounds.size.width);
    sapp.window_height = int(bounds.size.height);
    @debug_assert(SOKOL_BACKEND.is_metal());
    sapp.framebuffer_width = int(bounds.size.width * sapp.dpi_scale.cast());
    sapp.framebuffer_height = int(bounds.size.height * sapp.dpi_scale.cast());
    fb_size := @objc @as(CGSize) macos.view.drawableSize();  // this is (0, 0) the first time
    cur_fb_width  := int(fb_size.width);
    cur_fb_height := int(fb_size.height);
    dim_changed  := (sapp.framebuffer_width != cur_fb_width) ||
                                (sapp.framebuffer_height != cur_fb_height);
    if sapp.framebuffer_width == 0 {
        sapp.framebuffer_width = 1;
    };
    if sapp.framebuffer_height == 0 {
        sapp.framebuffer_height = 1;
    };
    if sapp.window_width == 0 {
        sapp.window_width = 1;
    };
    if sapp.window_height == 0 {
        sapp.window_height = 1;
    };
    if dim_changed {
        @debug_assert(SOKOL_BACKEND.is_metal());
        drawable_size: CGSize = (width = sapp.framebuffer_width.float(), height = sapp.framebuffer_height.float());
        @objc macos.view.setDrawableSize(drawable_size);
        if !sapp.first_frame {
            sapp.app_event(.RESIZED);
        };
    };
}

fn toggle_fullscreen(macos: *Impl) void = {
    /* NOTE: the sapp.fullscreen flag is also notified by the
       windowDidEnterFullscreen / windowDidExitFullscreen
       event handlers */
    sapp := macos.common();
    sapp.fullscreen = !sapp.fullscreen;
    @objc macos.window.toggleFullScreen(ObjCId.zeroed());
}

fn set_clipboard_string(macos: *Impl, s: CStr) void = {
    pool := objc_autoreleasePoolPush();
    c := macos.classes&;
    p := @objc c.NSPasteboard.generalPasteboard();
    types := @objc c.NSArray.arrayWithObject(c.NSPasteboardTypeString);
    @objc p.declareTypes(types, owner = zeroed(ObjCId));
    s := @objc c.NSString.stringWithUTF8String(s);
    @objc p.setString(s, forType = c.NSPasteboardTypeString);
    objc_autoreleasePoolPop(pool);
}

fn get_clipboard_string(self: *Impl) *RawList(u8) = {
    sapp, c := (self.common(), self.classes&);
    pool := objc_autoreleasePoolPush();
    buf := sapp.clipboard.buffer&;
    buf.len = 0;
    pasteboard := @objc c.NSPasteboard.generalPasteboard();
    types := @objc pasteboard.types();
    if @objc @as(bool) types.containsObject(c.NSPasteboardTypeString) {
        s := @objc pasteboard.stringForType(c.NSPasteboardTypeString);
        // TODO: warn if paste fails somehow
        if !s.is_null() {
            s := @objc @as(CStr) s.UTF8String();
            s := s.str();
            buf.reserve(s.len, sapp.desc.allocator);
            buf.len = s.len;
            buf.items().copy_from(s);
        };
    }
    objc_autoreleasePoolPop(pool);
    buf
}

fn set_window_title(macos: *Impl, title: CStr) void = {
    NSString := macos.classes.NSString;
    title := @objc NSString.stringWithUTF8String(title);
    @objc macos.window.setTitle(title);
}

fn macos_mouse_update_from_nspoint(sapp: *Sapp.Common, mouse_pos: CGPoint, clear_dxdy: bool) void = {
    if(sapp.mouse.locked, => return()); 
    new_x := mouse_pos.x * sapp.dpi_scale.cast();
    new_y := sapp.framebuffer_height.float() - (mouse_pos.y * sapp.dpi_scale.cast()) - 1;
    if clear_dxdy {
        sapp.mouse.dx = 0.0;
        sapp.mouse.dy = 0.0;
    } else {
        if sapp.mouse.pos_valid {
            // don't update dx/dy in the very first update
            sapp.mouse.dx = new_x.cast() - sapp.mouse.x;
            sapp.mouse.dy = new_y.cast() - sapp.mouse.y;
        };
    };
    sapp.mouse.x = new_x.cast();
    sapp.mouse.y = new_y.cast();
    sapp.mouse.pos_valid = true;
}

fn macos_mouse_update_from_nsevent(sapp: *Sapp.Common, event: ObjCId, clear_dxdy: bool) void = { // NSEvent
    sapp.macos_mouse_update_from_nspoint(@objc @as(CGPoint) event.locationInWindow(), clear_dxdy);
}

fn macos_show_mouse(visible: bool) void = {
    CGDirectDisplayID :: @struct(repr: u32);
    fn CGMainDisplayID() CGDirectDisplayID #import("CoreGraphics");
    fn CGDisplayShowCursor(d: CGDirectDisplayID) void #import("CoreGraphics");
    fn CGDisplayHideCursor(d: CGDirectDisplayID) void #import("CoreGraphics");

    /* NOTE: this function is only called when the mouse visibility actually changes */
    main := CGMainDisplayID();
    if(visible, => CGDisplayShowCursor(main), => CGDisplayHideCursor(main));
}

fn lock_mouse(macos: *Impl, lock: bool) void = {
    sapp := macos.common();
    if(lock == sapp.mouse.locked, => return());
    sapp.mouse.dx = 0.0;
    sapp.mouse.dy = 0.0;
    sapp.mouse.locked = lock;
    /*
        NOTE that this code doesn't warp the mouse cursor to the window
        center as everybody else does it. This lead to a spike in the
        *second* mouse-moved event after the warp happened. The
        mouse centering doesn't seem to be required (mouse-moved events
        are reported correctly even when the cursor is at an edge of the screen).

        NOTE also that the hide/show of the mouse cursor should properly
        stack with calls to sapp_show_mouse()
    */
    NSCursor := macos.classes.NSCursor;
    fn CGAssociateMouseAndMouseCursorPosition(connected: bool) void #import("CoreGraphics");
    CGAssociateMouseAndMouseCursorPosition(!sapp.mouse.locked);
    // TODO: why not allow locking the mouse without hiding it? maybe that's never what you want? 
    if sapp.mouse.locked {
        @objc NSCursor.hide();
    } else {
        @objc NSCursor.unhide();
    };
}

::if(ObjCId);

fn update_cursor(macos: *Impl, cursor: Sapp.MouseCursor, shown: bool) void = {
    sapp := macos.common();
    NSCursor := macos.classes.NSCursor;
    // show/hide cursor only if visibility status has changed (required because show/hide stacks)
    if shown != sapp.mouse.shown {
        if(shown, => @objc NSCursor.unhide(), => @objc NSCursor.hide());
    };
    // update cursor type
    cursor_obj := macos.cursors&[cursor];
    if cursor_obj.is_null() {
        cursor_obj = @objc NSCursor.arrowCursor();
    };
    @objc cursor_obj.set();
}

fn set_icon(macos: *Impl, icon_desc: []Sapp.ImageDesc) void = {
    c := macos.classes&;
    dock_tile := @objc c.NSApp.dockTile();
    wanted := @objc @as(CGSize) dock_tile.size();
    img_desc := image_bestmatch(icon_desc, wanted.width.int(), wanted.height.int());

    // :PastedMacosBindings
    // TODO: why not just CGDataProviderCreateWithData?
    fn CGColorSpaceCreateDeviceRGB() ObjCId #import("CoreGraphics"); // CGColorSpaceRef
    fn CFDataCreate(allocator: ObjCId, data: *u8, size: i64) ObjCId #import("CoreGraphics"); // CFDataRef
    fn CGDataProviderCreateWithCFData(cf_data: ObjCId) ObjCId #import("CoreGraphics"); // CGDataProviderRef
    fn CGImageCreate(width: i64, height: i64, bitsPerComponent: i64, bitsPerPixel: i64, 
        bytesPerRow: i64, space: ObjCId, bitmapInfo: i64, provider: ObjCId, decode: i64, 
        shouldInterpolate: bool, intent: u32) ObjCId #import("CoreGraphics"); // CGImageRef
    // TODO: are these different than an objc release() message? 
    fn CFRelease(it: ObjCId) void #import("CoreGraphics");
    fn CGDataProviderRelease(it: ObjCId) void #import("CoreGraphics");
    fn CGColorSpaceRelease(it: ObjCId) void #import("CoreGraphics");
    fn CGImageRelease(it: ObjCId) void #import("CoreGraphics");
    
    cg_color_space := CGColorSpaceCreateDeviceRGB();
    cf_data := CFDataCreate(c.kCFAllocatorDefault, img_desc.pixels.ptr, img_desc.pixels.len);
    cg_data_provider := CGDataProviderCreateWithCFData(cf_data);
    bitmapInfo := bit_or(3, 1.shift_left(12));
    kCGRenderingIntentDefault :: 0;
    flags  := bit_or(3, 8192); // kCGImageAlphaLast|kCGBitmapByteOrder32Little
    cg_img := CGImageCreate(img_desc.width, img_desc.height, 8, 32, img_desc.width * 4, cg_color_space, flags, cg_data_provider, 0, false, kCGRenderingIntentDefault);
    CFRelease(cf_data);
    CGDataProviderRelease(cg_data_provider);
    CGColorSpaceRelease(cg_color_space);

    ns_image := @objc c.NSImage.alloc();
    ns_image := @objc ns_image.initWithCGImage(cg_img, size = @objc @as(i64) dock_tile.size());
    @objc dock_tile.setContentView(@objc c.NSImageView.imageViewWithImage(ns_image));
    @objc dock_tile.display();
    @objc ns_image.release();
    CGImageRelease(cg_img);
}

fn macos_frame(sapp: *Sapp.Common) void = {
    sapp.frame();
    if sapp.quit_requested || sapp.quit_ordered {
        @objc sapp.impl()[].window.performClose(0);
    }
}

// 
// This is probably pointless. 
// Instead of just putting the app state in a static variable, i put it as 
// a instance variable on all my objc classes and get it back for every message received. 
// You'd have to do something to get the dynamic environment pointer back anyway. 
// Is there any situation where you'd want two whole application contexts in the same process? 
// Does it even let you do that? NSApplication.sharedApplication() makes it seem like no? 
// 
// The #inline is important for set_dynamic_context() to do what we want :ThisWillBreakIfYouMoveAstInliningToTheBackend
fn GET(obj: ObjCId) Ty(*Sapp.Common, *Impl) #inline = {
    out := zeroed(rawptr);
    object_getInstanceVariable(obj, "franca_sapp", out&);
    @debug_assert(!out.is_null());
    i := Impl.ptr_from_raw(out);
    set_dynamic_context(i.env);
    (i.common(), i)
}

applicationDidFinishLaunching :: fn(app_delegate: ObjCId, sel: ObjCSelector, _aNotification: ObjCId) void = {
    sapp, macos := GET(app_delegate);
    c := macos.classes&;
    macos.init_cursors();
    
    screen := @objc c.NSScreen.mainScreen();
    if ((sapp.window_width == 0) || (sapp.window_height == 0)) {
        // use 4/5 of screen size (if they explicitly pass zeroes)
        screen_rect := @objc @as(CGRect) screen.frame();
        if sapp.window_width == 0 {
            sapp.window_width = int((screen_rect.size.width * 4.0) / 5.0);
        }
        if sapp.window_height == 0 {
            sapp.window_height = int((screen_rect.size.height * 4.0) / 5.0);
        }
    }
    style: i64 = 0b1111;  // NSWindowStyleMask Tiled|Closable|Miniaturizable|Resizable
    window_rect: CGRect = (origin = (x = 0, y = 0), size = (width = sapp.window_width.float(), height = sapp.window_height.float()));
    w := @objc c.MyWindow.alloc();
    
    object_setInstanceVariable(w, "franca_sapp", Impl.raw_from_ptr(macos));
    w := @objc w.initWithContentRect(window_rect, styleMask = style, backing = 2 /*NSBackingStoreBuffered*/, defer = false);
    macos.window = w;
    @debug_assert(!w.is_null());
    @objc w.setReleasedWhenClosed(false); // this is necessary for proper cleanup in applicationWillTerminate
    macos.set_window_title(sapp.desc.window_title);
    @objc w.setAcceptsMouseMovedEvents(true);
    @objc w.setRestorable(true);

    wd := @objc c.MyWindowDelegate.alloc();
    wd := @objc wd.init();
    macos.win_dlg = wd;
    @objc w.setDelegate(wd);
    object_setInstanceVariable(wd, "franca_sapp", Impl.raw_from_ptr(macos));
    @debug_assert(SOKOL_BACKEND.is_metal());
    max_fps := @objc @as(i64) screen.maximumFramesPerSecond();  // if (@available(macOS 12.0, *))
    
    fn MTLCreateSystemDefaultDevice() ObjCId #import("Metal");
    macos.mtl_device = MTLCreateSystemDefaultDevice();
    v := @objc init(@objc c.MyView.alloc());
    macos.view = v;
    object_setInstanceVariable(v, "franca_sapp", Impl.raw_from_ptr(macos));
    @objc v.updateTrackingAreas();
    @objc v.setPreferredFramesPerSecond(max_fps / sapp.swap_interval);
    @objc v.setDevice(macos.mtl_device);
    @objc v.setColorPixelFormat(80);  // MTLPixelFormatBGRA8Unorm
    @objc v.setDepthStencilPixelFormat(260);  // MTLPixelFormatDepth32Float_Stencil8
    @objc v.setSampleCount(sapp.sample_count);
    @objc v.setAutoResizeDrawable(false);
    @objc w.setContentView(v);
    @objc w.makeFirstResponder(v);
    
    layer := @objc v.layer();
    @objc layer.setMagnificationFilter(c.kCAFilterNearest);
    @objc w.center();
    sapp.valid = true;
    @objc c.NSApp.setActivationPolicy(0); // NSApplicationActivationPolicyRegular
    
    if sapp.fullscreen {
        @println("full screen");
        /* ^^^ on GL, this already toggles a rendered frame, so set the valid flag before */
        @objc w.toggleFullScreen(app_delegate);  // this doesn't work before setActivationPolicy
    };
    
    // "set the application dock icon as early as possible, otherwise the dummy icon will be visible for a short time" 
    // but this doesn't work if you do it before setActivationPolicy so it's moved here. 
    sapp.set_icon(sapp.desc.icon);
    
    @objc c.NSApp.activateIgnoringOtherApps(true);
    nil := ObjCId.zeroed();
    @objc w.makeKeyAndOrderFront(nil);
    sapp.impl().update_dimensions();
    @objc c.NSEvent.setMouseCoalescingEnabled(false);

    // workaround for window not being focused during a long init callback
    // for details see: https://github.com/floooh/sokol/pull/982
    // also see: https://gitlab.gnome.org/GNOME/gtk/-/issues/2342
    focusevent := @objc c.NSEvent.otherEventWithType(13, // NSEventTypeAppKitDefined
        location = @as(CGPoint) (x = 0, y = 0),
        modifierFlags = 0x40,
        timestamp = 0,
        windowNumber = 0,
        context = nil,
        subtype = 1, // NSEventSubtypeApplicationActivated
        data1 = 0,
        data2 = 0,
    );
    @objc c.NSApp.postEvent(focusevent, atStart = true);
}

applicationShouldTerminateAfterLastWindowClosed :: fn(app_delegate: ObjCId, sel: ObjCSelector, _sender: ObjCId) bool = 
    true;

applicationWillTerminate :: fn(app_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = {
    sapp, macos := GET(app_delegate);
    sapp.call_cleanup();
    macos.macos_discard_state();
    sapp.discard_state();
}

windowShouldClose :: fn(window_delegate: ObjCId, sel: ObjCSelector, _sender: ObjCId) bool = {
    sapp, _ := GET(window_delegate);
    /* only give user-code a chance to intervene when sapp.quit() wasn't already called */
    if !sapp.quit_ordered {
        /* if window should be closed and event handling is enabled, give user code
           a chance to intervene via sapp.cancel_quit(). */
        sapp.quit_requested = true;
        sapp.app_event(.QUIT_REQUESTED);
        /* user code hasn't intervened, quit the app */
        sapp.quit_ordered = sapp.quit_ordered || sapp.quit_requested;
    };
    sapp.quit_ordered
}

windowWillStartLiveResize :: fn(window_delegate: ObjCId, sel: ObjCSelector, notification: ObjCId) void = {
    sapp, macos := GET(window_delegate);
    // Work around the MTKView resizing glitch by "anchoring" the layer to the window corner opposite
    // to the currently manipulated corner (or edge). This prevents the content stretching back and
    // forth during resizing. This is a workaround for this issue: https://github.com/floooh/sokol/issues/700
    // Can be removed if/when migrating to CAMetalLayer: https://github.com/floooh/sokol/issues/727
    resizing_from_left := sapp.mouse.x.cast() < sapp.window_width.float()/2;
    resizing_from_top  := sapp.mouse.y.cast() < sapp.window_height.float()/2;
    br, tr, bl, tl := (7, 5, 9, 11); // NSViewLayerContentsPlacement
    p := @if(resizing_from_left,
        @if(resizing_from_top, br, tr),
        @if(resizing_from_top, bl, tl),
    );
    @objc macos.view.setLayerContentsPlacement(p);
}

windowDidResize :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = {
    _, macos := GET(window_delegate);
    macos.update_dimensions();
}

windowDidChangeScreen :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = {
    _, macos := GET(window_delegate);
    // TODO: i could send an event for this? 
    //sapp.timing_reset(sapp.timing&);  // TODO: timing
    macos.update_dimensions();
}

windowDidMiniaturize :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = 
    app_event(window_delegate, .ICONIFIED);

windowDidDeminiaturize :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = 
    app_event(window_delegate, .RESTORED);

windowDidBecomeKey :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = 
    app_event(window_delegate, .FOCUSED);

windowDidResignKey :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = 
    app_event(window_delegate, .UNFOCUSED);

windowDidEnterFullScreen :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = {
    sapp, _ := GET(window_delegate);
    sapp.fullscreen = true;
}

windowDidExitFullScreen :: fn(window_delegate: ObjCId, sel: ObjCSelector, _notification: ObjCId) void = {
    sapp, _ := GET(window_delegate);
    sapp.fullscreen = false;
}

// TODO: does anyone in crazy town call this directly? 
//       if the only place that calls it is myself in applicationDidFinishLaunching, 
//       this can just be a normal franca function without the super stuff. 
initWithContentRect :: fn(window: ObjCId, sel: ObjCSelector, contentRect: CGRect, style: u64, backingStoreType: u64, defer: bool) ObjCId = {
    _, macos := GET(window);
    c := macos.classes;
    ::ptr_utils(Deref(ObjCId));
    
    ctx: ObjCSuper = (receiver = window, super_class = c.NSWindow);
    window := @objc_super ctx&.initWithContentRect(contentRect, styleMask = style, backing = backingStoreType, defer = defer);
    @debug_assert(!window.is_null(), "initWithContentRect failed??? this won't go well for you");
    //#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300
    types := @objc c.NSArray.arrayWithObject(c.NSPasteboardTypeFileURL);
    @objc window.registerForDraggedTypes(types);
    window
}

draggingEntered :: fn(window: ObjCId, sel: ObjCSelector, sender: ObjCId) i64 = 
    1; // NSDragOperationCopy

draggingUpdated :: fn(window: ObjCId, sel: ObjCSelector, sender: ObjCId) i64 = 
    1; // NSDragOperationCopy

performDragOperation :: fn(window: ObjCId, sel: ObjCSelector, sender: ObjCId) bool = {
    //#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300
    sapp, macos := GET(window);
    d, a, c  := (sapp.drop&, sapp.desc.allocator, macos.classes&);
    pboard   := @objc sender.draggingPasteboard();  // NSPasteboard *
    can_drop := @objc @as(bool) (@objc pboard.types()).containsObject(c.NSPasteboardTypeFileURL);
    if(!can_drop, => return(false));
    files := @objc pboard.pasteboardItems();
    d.num_files = @objc @as(i64) files.count();
    
    d.buffer.len = 0;
    d.starts.len = 0;
    d.starts&.reserve(d.num_files, a);
    range(0, d.num_files) { i |
        d.starts&.push(d.buffer.len, a);
        it := @objc files.objectAtIndex(i);
        it := @objc it.stringForType(c.NSPasteboardTypeFileURL);
        it := @objc c.NSURL.fileURLWithPath(it);
        it := @objc it.standardizedURL();
        it := @objc it.path();
        it := @objc @as(CStr) it.UTF8String();
        d.buffer&.push_all(it.str(), a);
        d.buffer&.push(0, a); // for good luck
    }
    d.starts&.push(d.buffer.len, a);  // for the end of last one
    if sapp.events_enabled() {
        sapp.macos_mouse_update_from_nspoint(@objc @as(CGPoint) sender.draggingLocation(), true);
        sapp.init_event(.FILES_DROPPED);
        sapp.event.modifiers = sapp.macos_mods(ObjCId.zeroed());
        sapp.call_event(sapp.event&);
    };
    true
}

// TODO: for gl: override timerFired and prepareOpenGL on view

drawRect :: fn(view: ObjCId, sel: ObjCSelector, _rect: CGRect) void = {
    sapp, _ := GET(view);
    @debug_assert(SOKOL_BACKEND.is_metal());
    //sapp.timing_measure(sapp.timing&);  // TODO: timing
    /* Catch any last-moment input events */
    // sokol had this commented out
    // https://github.com/floooh/sokol/pull/483#issuecomment-805148815
    // sapp.macos_poll_input_events();
    pool := objc_autoreleasePoolPush();
    sapp.macos_frame();
    objc_autoreleasePoolPop(pool);
    @debug_assert(SOKOL_BACKEND.is_metal());
}

isOpaque :: fn(view: ObjCId, sel: ObjCSelector) bool = true;
canBecomeKeyView :: fn(view: ObjCId, sel: ObjCSelector) bool = true;
acceptsFirstResponder :: fn(view: ObjCId, sel: ObjCSelector) bool = true;

updateTrackingAreas :: fn(view: ObjCId, sel: ObjCSelector) void = {
    sapp, macos := GET(view);
    
    if !macos.tracking_area.is_null() {
        @objc view.removeTrackingArea(macos.tracking_area);
        @objc macos.tracking_area.release();
    }
    
    // TODO: i feel like EnabledDuringMouseDrag isn't happening. did i mistype the bits?
    // NSTracking MouseEnteredAndExited|CursorUpdate|ActiveInKeyWindow|AssumeInside|InVisibleRect|EnabledDuringMouseDrag
    options := 0b11100100101;
    
    c := macos.classes&;
    ta := @objc c.NSTrackingArea.alloc();
    ta := @objc ta.initWithRect(@objc @as(CGRect) view.bounds(), options = options, owner = view, userInfo = zeroed(ObjCId));
    macos.tracking_area = ta;
    @objc view.addTrackingArea(ta);
    
    s: ObjCSuper = (receiver = view, super_class = c.MTKView);
    @objc_super s&.updateTrackingAreas();
}

// helper function to make GL context active
fn gl_make_current(sapp: *Sapp.Common) void = {
    @debug_assert(SOKOL_BACKEND.is_metal());
}

mouseEntered :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, true);
    /* don't send mouse enter/leave while dragging (so that it behaves the same as
       on Windows while SetCapture is active
    */
    if macos.mouse_buttons == 0 {
        sapp.macos_mouse_event(.MOUSE_ENTER, .INVALID, event);
    }
}

mouseExited :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, true);
    if (0 == macos.mouse_buttons) {
        sapp.macos_mouse_event(.MOUSE_LEAVE, .INVALID, event);
    }
}

fn handle_mouse_press(view: ObjCId, event: ObjCId, action: Sapp.EventType, which: Sapp.Mousebutton) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, false);
    ::enum(@type which);
    // TODO: i guess other buttonNumbers are the side buttons? 
    //       i want those actually? but also they don't seem to get here anyway. 
    //       do i have to somehow set that button to be a real button in the garbage mouse app? 
    // TODO: it seems i get otherButton events with 0/1 for left/right, 
    //       why bother to listen to those individually then? 
    if which == .MIDDLE && (@objc @as(i64) event.buttonNumber()) != 2 {
        return()
    }
    sapp.macos_mouse_event(action, which, event);
    // TODO: use @bit_fields
    ::enum(@type action);
    old: i64 = macos.mouse_buttons.zext();
    if action == .MOUSE_DOWN {
        macos.mouse_buttons = old.bit_or(1.shift_left(which.raw().intcast())).trunc();
    } else {
        macos.mouse_buttons = old.bit_and(1.shift_left(which.raw().intcast()).bit_not()).trunc();
    }
}

mouseDown :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_press(view, event, .MOUSE_DOWN, .LEFT);

mouseUp :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_press(view, event, .MOUSE_UP, .LEFT);

rightMouseDown :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_press(view, event, .MOUSE_DOWN, .RIGHT);

rightMouseUp :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void =  
    handle_mouse_press(view, event, .MOUSE_UP, .RIGHT);

otherMouseDown :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_press(view, event, .MOUSE_DOWN, .MIDDLE);

otherMouseUp :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_press(view, event, .MOUSE_UP, .MIDDLE);

otherMouseDragged :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_move(view, event, true);

mouseMoved :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_move(view, event, false);

mouseDragged :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_move(view, event, false);

rightMouseDragged :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = 
    handle_mouse_move(view, event, false);

fn handle_mouse_move(view: ObjCId, event: ObjCId, other: bool) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, false);
    if(other && (@objc @as(i64) event.buttonNumber()) != 2, => return());
    if sapp.mouse.locked {
        sapp.mouse.dx = cast(@objc @as(f64) event.deltaX());
        sapp.mouse.dy = cast(@objc @as(f64) event.deltaY());
    }
    sapp.macos_mouse_event(.MOUSE_MOVE, .INVALID, event);
}

scrollWheel :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, true);
    if sapp.events_enabled() {
        dx := @objc @as(f64) event.scrollingDeltaX();
        dy := @objc @as(f64) event.scrollingDeltaY();
        if (@objc @as(bool) event.hasPreciseScrollingDeltas()) {
            dx *= 0.1;
            dy *= 0.1;
        }
        if dx != 0 || dy != 0 {  // TODO: why did sokol have a complicated expression here? does it ever give us nans?
            sapp.init_event(.MOUSE_SCROLL);
            sapp.event.modifiers = sapp.macos_mods(event);
            sapp.event.scroll_x = dx.cast();
            sapp.event.scroll_y = dy.cast();
            sapp.call_event(sapp.event&);
        }
    }
}

keyDown :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    if(!sapp.events_enabled(), => return());
    sapp.gl_make_current();
    mods     := sapp.macos_mods(event);
    key_code := sapp.translate_key(@objc @as(i64) event.keyCode());
    repeat := @objc @as(bool) event.isARepeat();
    sapp.macos_key_event(.KEY_DOWN, key_code, repeat, mods);
    chars := @objc event.characters(); // NSString
    len   := @objc @as(i64) chars.length();
    if len > 0 {
        sapp.init_event(.CHAR);
        sapp.event.modifiers = mods;
        range(0, len) { i |
            codepoint := @objc @as(i64) chars.characterAtIndex(i); // unichar
            if codepoint.bit_and(0xFF00) != 0xF700 {
                sapp.event.char_code = codepoint.trunc();
                sapp.event.key_repeat = repeat;
                sapp.call_event(sapp.event&);
            };
        }
    }
    /* if this is a Cmd+V (paste), also send a CLIPBOARD_PASTE event */
    if sapp.clipboard.enabled && mods.get(.super) != 0 && key_code == .V {
        sapp.init_event(.CLIPBOARD_PASTED);
        sapp.call_event(sapp.event&);
    };
}

performKeyEquivalent :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) bool = {
    // fixes Ctrl-Tab keydown not triggering a keyDown event
    // NOTE: it seems that Ctrl-F1 cannot be intercepted the same way, but since
    // this enabled critical accessibility features that's probably a good thing.
    sapp, macos := GET(view);
    k := @objc @as(i64) event.keyCode();
    ::enum(Sapp.Keycode);
    if sapp.translate_key(k) == .TAB {
        @objc macos.view.keyDown(event);
        return true;
    };
    false
}

keyUp :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    key    := sapp.translate_key(@objc @as(i64) event.keyCode());
    repeat := @objc @as(bool) event.isARepeat();
    sapp.macos_key_event(.KEY_UP, key, repeat, sapp.macos_mods(event));
}

flagsChanged :: fn(view: ObjCId, sel: ObjCSelector, event: ObjCId) void = {
    sapp, macos := GET(view);
    old_f := macos.flags_changed_store;
    new_f := @objc @as(u32) event.modifierFlags();
    macos.flags_changed_store = new_f;
    key_code := Sapp.Keycode.INVALID;
    down     := false;
    changed  := new_f.bit_xor(old_f);
    check :: fn(bit, key: Sapp.Keycode) => {
        flag := 1.shift_left(bit);
        if changed.bit_and(flag.trunc()) != 0 {
            key_code = key;
            down = 0 != new_f.zext().bit_and(flag);
        };
    };
    
    // NSEventModifierFlag
    check(17, .LEFT_SHIFT);
    check(18, .LEFT_CONTROL);
    check(19, .LEFT_ALT); // option
    check(20, .LEFT_SUPER); // command

    ::enum(@type key_code);
    if key_code != .INVALID {
        sapp.macos_key_event(@if(down, .KEY_DOWN, .KEY_UP), key_code, false, sapp.macos_mods(event));
    }
}

// my impression is that ObjCId is a rawptr and (__bridge const void*) does nothing

fn metal_get_device(macos: *Impl) rawptr = {
    @debug_assert(macos.common()[].valid, "not valid");
    @debug_assert(SOKOL_BACKEND.is_metal());
    bit_cast_unchecked(ObjCId, rawptr, macos.mtl_device)
}

fn metal_get_current_drawable(macos: *Impl) rawptr = {
    @debug_assert(macos.common()[].valid);
    @debug_assert(SOKOL_BACKEND.is_metal());
    @objc @as(rawptr) macos.view.currentDrawable()
}

fn metal_get_depth_stencil_texture(macos: *Impl) rawptr = {
    @debug_assert(macos.common()[].valid);
    @debug_assert(SOKOL_BACKEND.is_metal());
    @objc @as(rawptr) macos.view.depthStencilTexture()
}

fn metal_get_msaa_color_texture(macos: *Impl) rawptr = {
    @debug_assert(macos.common()[].valid);
    @debug_assert(SOKOL_BACKEND.is_metal());
    @objc @as(rawptr) macos.view.multisampleColorTexture()
}

fn macos_get_window(macos: *Impl) rawptr = {
    @debug_assert(SOKOL_BACKEND.is_metal()); // TODO: we just care that it's macos
    bit_cast_unchecked(ObjCId, rawptr, macos.window)
}

fn keytable(self: *Impl) []Sapp.Keycode = {
    keys :: fn(arg: FatExpr) FatExpr #macro = {
        T :: Sapp.Keycode;
        N :: 256;
        a := ast_alloc().alloc(T, N);
        each arg&.items() { e |
            a[const_eval(i64)(e.items()[0])] = const_eval(T)(e.items()[1]);
        };
        @literal a
    };
    @keys(
        (0x1D, ._0),
        (0x12, ._1),
        (0x13, ._2),
        (0x14, ._3),
        (0x15, ._4),
        (0x17, ._5),
        (0x16, ._6),
        (0x1A, ._7),
        (0x1C, ._8),
        (0x19, ._9),
        (0x00, .A),
        (0x0B, .B),
        (0x08, .C),
        (0x02, .D),
        (0x0E, .E),
        (0x03, .F),
        (0x05, .G),
        (0x04, .H),
        (0x22, .I),
        (0x26, .J),
        (0x28, .K),
        (0x25, .L),
        (0x2E, .M),
        (0x2D, .N),
        (0x1F, .O),
        (0x23, .P),
        (0x0C, .Q),
        (0x0F, .R),
        (0x01, .S),
        (0x11, .T),
        (0x20, .U),
        (0x09, .V),
        (0x0D, .W),
        (0x07, .X),
        (0x10, .Y),
        (0x06, .Z),
        (0x27, .APOSTROPHE),
        (0x2A, .BACKSLASH),
        (0x2B, .COMMA),
        (0x18, .EQUAL),
        (0x32, .GRAVE_ACCENT),
        (0x21, .LEFT_BRACKET),
        (0x1B, .MINUS),
        (0x2F, .PERIOD),
        (0x1E, .RIGHT_BRACKET),
        (0x29, .SEMICOLON),
        (0x2C, .SLASH),
        (0x0A, .WORLD_1),
        (0x33, .BACKSPACE),
        (0x39, .CAPS_LOCK),
        (0x75, .DELETE),
        (0x7D, .DOWN),
        (0x77, .END),
        (0x24, .ENTER),
        (0x35, .ESCAPE),
        (0x7A, .F1),
        (0x78, .F2),
        (0x63, .F3),
        (0x76, .F4),
        (0x60, .F5),
        (0x61, .F6),
        (0x62, .F7),
        (0x64, .F8),
        (0x65, .F9),
        (0x6D, .F10),
        (0x67, .F11),
        (0x6F, .F12),
        (0x69, .F13),
        (0x6B, .F14),
        (0x71, .F15),
        (0x6A, .F16),
        (0x40, .F17),
        (0x4F, .F18),
        (0x50, .F19),
        (0x5A, .F20),
        (0x73, .HOME),
        (0x72, .INSERT),
        (0x7B, .LEFT),
        (0x3A, .LEFT_ALT),
        (0x3B, .LEFT_CONTROL),
        (0x38, .LEFT_SHIFT),
        (0x37, .LEFT_SUPER),
        (0x6E, .MENU),
        (0x47, .NUM_LOCK),
        (0x79, .PAGE_DOWN),
        (0x74, .PAGE_UP),
        (0x7C, .RIGHT),
        (0x3D, .RIGHT_ALT),
        (0x3E, .RIGHT_CONTROL),
        (0x3C, .RIGHT_SHIFT),
        (0x36, .RIGHT_SUPER),
        (0x31, .SPACE),
        (0x30, .TAB),
        (0x7E, .UP),
        (0x52, .KP_0),
        (0x53, .KP_1),
        (0x54, .KP_2),
        (0x55, .KP_3),
        (0x56, .KP_4),
        (0x57, .KP_5),
        (0x58, .KP_6),
        (0x59, .KP_7),
        (0x5B, .KP_8),
        (0x5C, .KP_9),
        (0x45, .KP_ADD),
        (0x41, .KP_DECIMAL),
        (0x4B, .KP_DIVIDE),
        (0x4C, .KP_ENTER),
        (0x51, .KP_EQUAL),
        (0x43, .KP_MULTIPLY),
        (0x4E, .KP_SUBTRACT),
    )
}

// TODO: this is a paste from examples/soft_draw.fr do i want to write more official bindings to the apple stuff? :PastedMacosBindings
CGSize  :: @struct(width: f64, height: f64);
CGPoint :: @struct(x: f64, y: f64);
CGRect  :: @struct(origin: CGPoint, size: CGSize);  // same as NSRect
