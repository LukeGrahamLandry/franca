// macOS application wrapper
// Adapted from sokol_app.h - https://github.com/floooh/sokol
// zlib/libpng license. Copyright (c) 2018 Andre Weissflog.
//
// TODO: figure out where the objective c compiler inserts reference counting instructions. 
//       i'm probably leaking everything or letting it free everything out from under me. 
// TODO: timing
// TODO: keep the changed cursor if the mouse leaves and then comes back 
//      (maybe the resize <-> is eating it when you mouse over the border)
// TODO: setting the title also resets the mouse cursor to default. 
// TODO: i kinda want to let you paste images NSPasteboardTypePNG
// TODO: 86760b60423d18f07f2fdb0a4f00553d4229034a
// TODO: if you put it in full screen, moving the cursor to the top should 
//       show the menu bar so you can get out
// TODO: fix the thing where you stop rendering while animating into full screen 
//       (happened when using MTKView too and happens in sokol-samples/sapp/sgl-sapp.c)

#use("@/graphics/macos/objective_c.fr");
#use("@/graphics/macos/frameworks.fr");
Sapp :: import("@/graphics/app.fr");

Impl :: @struct(
    flags_changed_store: u32,
    mouse_buttons: u8,
    window: id"NSWindow",
    tracking_area: id"NSTrackingArea",
    keyup_monitor: ObjCId,
    app_dlg: id"FrancaAppDelegate",
    win_dlg: id"FrancaWindowDelegate",
    view: id"FrancaView",
    cursors: EnumMap(Sapp.MouseCursor, NSCursor),
    mtl_device: MTLDevice,
    classes: Classes,
    display_link: CVDisplayLinkRef,
    display_source: dispatch_source_t,
    depth_texture: id"MTLTexture",
);

Classes :: @struct(
    NSPasteboardTypeFileURL: NSPasteboardType, 
    NSPasteboardTypeString: NSPasteboardType,
    kCAFilterNearest: ObjCId,
    kCFAllocatorDefault: ObjCId,
    NSApp: NSApplication,  // instance that represents the current app
);

fn run(m: *Impl, desc: *Sapp.Desc) Never = {
    sapp := m.common();
    c := m.classes&;

    register_objective_c_classes(m);
    c.NSApp = NSApplication'sharedApplication();
    @debug_assert(!c.NSApp._.is_nil());

    m.app_dlg = new "FrancaAppDelegate";
    object_setInstanceVariable(m.app_dlg, "franca_sapp", Impl.raw_from_ptr(m));
    c.NSApp.setDelegate(m.app_dlg);

    // workaround for "no key-up sent while Cmd is pressed" taken from GLFW:
    NSEventMaskKeyUp :: 1.shift_left(11);
    aBlock := new_global_block(sapp.desc.allocator, Impl.raw_from_ptr(m), @as(rawptr) keyup_monitor);
    m.keyup_monitor = @objc cls("NSEvent").addLocalMonitorForEventsMatchingMask(NSEventMaskKeyUp, handler = aBlock);
    
    c.NSApp.run();
    // NOTE: [NSApp run] never returns, instead cleanup code
    // must be put into applicationWillTerminate
    unreachable()
}

keyup_monitor :: fn(self: *Block_literal_1, event: NSEvent) NSEvent = {
    macos := Impl.ptr_from_raw(self.userdata);
    flags := event.modifierFlags();
    NSEventModifierFlagCommand :: 1.shift_left(20);
    if flags.bit_and(NSEventModifierFlagCommand) != 0 {
        ::NSWindow;
        macos.classes.NSApp.keyWindow().sendEvent(event);
    };
    event
};

fn register_objective_c_classes(self: *Impl) void = {    
    // TODO: since i don't link all the frameworks properly (when i don't actually 
    //       import a real symbol from them) so you need to dlopen some stuff before 
    //       trying to get the classes or they wont exist. 
    Dyn :: import("@/lib/dynamic_lib.fr");
    _ := Dyn'open("/System/Library/Frameworks/MetalKit.framework/MetalKit").expect("open MetalKit");
    
    register_objc_class(FrancaAppDelegate);
    register_objc_class(FrancaWindow);
    register_objc_class(FrancaWindowDelegate);
    register_objc_class(FrancaView);
    
    c := self.classes&;
    c.kCAFilterNearest = ObjCId.ptr_from_raw(@import_symbol("kCAFilterNearest", "QuartzCore"))[];
    c.NSPasteboardTypeFileURL = NSPasteboardType.ptr_from_raw(@import_symbol("NSPasteboardTypeFileURL", "AppKit"))[];
    c.NSPasteboardTypeString = NSPasteboardType.ptr_from_raw(@import_symbol("NSPasteboardTypeString", "AppKit"))[];
    c.kCFAllocatorDefault = ObjCId.ptr_from_raw(@import_symbol("kCFAllocatorDefault", "CoreFoundation"))[];
}

fn macos_discard_state(m: *Impl) void = {       
    // NOTE: it's safe to call [release] on a nil object
    if !m.keyup_monitor.is_nil() {
        NSEvent'removeMonitor(m.keyup_monitor);
        // NOTE: removeMonitor also releases the object
        m.keyup_monitor = ObjCId.zeroed();
        // TODO: this still leaks the block because i said it was global
    };
    // TODO: CVDisplayLinkStop CVDisplayLinkRelease :LEAK
    
    @objc m.tracking_area.release();
    @objc m.app_dlg.release();
    @objc m.win_dlg.release();
    @objc m.view.release();
    ASSERT_NOT_GL();
    @objc m.mtl_device.release();
    @objc m.window.release();
}

fn init_cursors(self: *Impl) void = {
    c := self.cursors&;
    
    c[.DEFAULT] = NSCursor'arrowCursor();  // default to arrow
    c[.ARROW] = NSCursor'arrowCursor();
    c[.IBEAM] = NSCursor'IBeamCursor();
    c[.CROSSHAIR] = NSCursor'crosshairCursor();
    c[.POINTING_HAND] = NSCursor'pointingHandCursor();
    // TODO: use [NSCursor frameResizeCursorFromPosition:inDirections:] ?
    c[.RESIZE_EW] = NSCursor'_windowResizeEastWestCursor();
    c[.RESIZE_NS] = NSCursor'_windowResizeNorthSouthCursor();
    c[.RESIZE_NWSE] = NSCursor'_windowResizeNorthWestSouthEastCursor();
    c[.RESIZE_NESW] = NSCursor'_windowResizeNorthEastSouthWestCursor();
    c[.RESIZE_ALL] = NSCursor'closedHandCursor();
    c[.NOT_ALLOWED] = NSCursor'operationNotAllowedCursor();
}

fn macos_mods(sapp: *Sapp.Self, ev: NSEvent) Sapp.Modifiers = {
    f := @if(ev._.is_nil(), NSEvent'modifierFlags(), ev.modifierFlags()); // NSEventModifierFlags
    b := NSEvent'pressedMouseButtons();
    m := zeroed Sapp.Modifiers;
    X :: fn(mask, bit, $key: Sapp.Modifiers.Wide.Fields()) => {
        if mask.bit_and(1.shift_left(bit)) != 0 {
            m&.set(key, 1);
        };
    };
    
    // NSEventModifierFlag
    X(f, 17, .shift);
    X(f, 18, .control);
    X(f, 19, .alt);   // option
    X(f, 20, .super); // command
    X(b, 0, .left_mouse);
    X(b, 1, .right_mouse);
    X(b, 2, .middle_mouse);
    m
}

fn macos_mouse_event(sapp: *Sapp.Self, type: Sapp.EventType, btn: Sapp.Mousebutton, event: NSEvent) void = {
    if(!sapp.events_enabled(), => return());
    mod := sapp.macos_mods(event);
    sapp.init_event(type);
    sapp.event.mouse_button = btn;
    sapp.event.modifiers = mod;
    sapp.call_event(sapp.event&);
}

fn macos_key_event(sapp: *Sapp.Self, type: Sapp.EventType, key: Sapp.Keycode, repeat: bool, mod: Sapp.Modifiers) void = {
    if(!sapp.events_enabled(), => return()); 
    sapp.init_event(type);
    e := sapp.event&;
    e.key_code = key;
    e.key_repeat = repeat;
    e.modifiers = mod;
    sapp.call_event(e);
}

fn app_event(sapp: *Sapp.Self, type: Sapp.EventType) void = {
    if(!sapp.events_enabled(), => return()); 
    sapp.init_event(type);
    sapp.call_event(sapp.event&);
}

fn app_event(stash: id"T", type: Sapp.EventType) void = {
    sapp, _ := GET(stash);
    sapp.app_event(type);
}

/* NOTE: unlike the iOS version of this function, the macOS version
    can dynamically update the DPI scaling factor when a window is moved
    between HighDPI / LowDPI screens.
*/
fn update_dimensions(macos: *Impl) void = {
    sapp := macos.common();
    if sapp.desc.high_dpi {
        s := @objc macos.window.screen();
        sapp.dpi_scale = cast(@objc @as(f64) s.backingScaleFactor());
    } else {
        sapp.dpi_scale = 1.0;
    };
    @debug_assert(!macos.view.is_nil());
    layer := @objc macos.view.layer();
    @debug_assert(!layer.is_nil());
    @objc layer.setContentsScale(@as(f64) sapp.dpi_scale.cast()); // NOTE: needed because we set layerContentsPlacement to a non-scaling value in windowWillStartLiveResize.
    bounds := @objc @as(CGRect) macos.view.bounds();
    sapp.window_width = int(bounds.size.width);
    sapp.window_height = int(bounds.size.height);
    ASSERT_NOT_GL();
    sapp.framebuffer_width = int(bounds.size.width * sapp.dpi_scale.cast());
    sapp.framebuffer_height = int(bounds.size.height * sapp.dpi_scale.cast());
    fb_size := @objc @as(CGSize) layer.drawableSize();  // this is (0, 0) the first time 
    
    cur_fb_width  := int(fb_size.width);
    cur_fb_height := int(fb_size.height);
    dim_changed  := (sapp.framebuffer_width != cur_fb_width) ||
                                (sapp.framebuffer_height != cur_fb_height);
    if sapp.framebuffer_width == 0 {
        sapp.framebuffer_width = 1;
    };
    if sapp.framebuffer_height == 0 {
        sapp.framebuffer_height = 1;
    };
    if sapp.window_width == 0 {
        sapp.window_width = 1;
    };
    if sapp.window_height == 0 {
        sapp.window_height = 1;
    };
    if dim_changed {
        ASSERT_NOT_GL();
        drawable_size: CGSize = (width = sapp.framebuffer_width.float(), height = sapp.framebuffer_height.float());
        @objc layer.setDrawableSize(drawable_size);
        @if(SOKOL_BACKEND == .METAL_MACOS) macos.replace_depth_texture();
        // TODO: wgpu?
        
        if !sapp.first_frame {
            sapp.app_event(.RESIZED);
        };
    };
}

// TODO: this is kinda weird. why don't you do this in gfx? why one free texture? 
//       you could just make this yourself through the normal gfx cross platform api? 
//       (like you would when rendering onto an offscreen surface). 
fn replace_depth_texture(macos: *Impl) void = {
    sapp := macos.common();
    depth_desc := new "MTLTextureDescriptor";
    @objc_set(depth_desc) (
        width       = @as(i64) sapp.framebuffer_width,
        height      = @as(i64) sapp.framebuffer_height,
        pixelFormat = sapp.depth_format().to_mtl(),
        storageMode = 2, // MTLStorageModePrivate,
        usage       = 4, // MTLTextureUsageRenderTarget,
    );
    @objc macos.depth_texture.release();
    macos.depth_texture = @objc macos.mtl_device.newTextureWithDescriptor(depth_desc);
    @objc depth_desc.release();
}

fn toggle_fullscreen(macos: *Impl) void = {
    /* NOTE: the sapp.fullscreen flag is also notified by the
       windowDidEnterFullscreen / windowDidExitFullscreen
       event handlers */
    sapp := macos.common();
    sapp.fullscreen = !sapp.fullscreen;
    @objc macos.window.toggleFullScreen(ObjCId.zeroed());
}

fn set_clipboard_string(macos: *Impl, s: CStr) void = {
    pool := objc_autoreleasePoolPush();
    c := macos.classes&;
    p := @objc cls("NSPasteboard").generalPasteboard();
    types := @objc cls("NSArray").arrayWithObject(c.NSPasteboardTypeString);
    @objc p.declareTypes(types, owner = zeroed(ObjCId));
    s := @objc cls("NSString").stringWithUTF8String(s);
    @objc p.setString(s, forType = c.NSPasteboardTypeString);
    objc_autoreleasePoolPop(pool);
}

fn get_clipboard_string(self: *Impl) *RawList(u8) = {
    sapp, c := (self.common(), self.classes&);
    pool := objc_autoreleasePoolPush();
    buf := sapp.clipboard.buffer&;
    buf.len = 0;
    pasteboard := NSPasteboard'generalPasteboard();
    types := @objc pasteboard.types();
    if @objc @as(bool) types.containsObject(c.NSPasteboardTypeString) {
        s := pasteboard.stringForType(c.NSPasteboardTypeString);
        // TODO: warn if paste fails somehow
        if !s._.is_nil() {
            s := @objc @as(CStr) s.UTF8String();
            s := s.str();
            buf.reserve(s.len, sapp.desc.allocator);
            buf.len = s.len;
            buf.items().copy_from(s);
        } else {
            @debug_log("???? failed to get_clipboard_string");
        }
    }
    objc_autoreleasePoolPop(pool);
    buf
}

fn set_window_title(macos: *Impl, title: CStr) void = {
    title := @objc cls("NSString").stringWithUTF8String(title);
    @objc macos.window.setTitle(title);
}

fn macos_mouse_update_from_nspoint(sapp: *Sapp.Self, mouse_pos: CGPoint, clear_dxdy: bool) void = {
    if(sapp.mouse.locked, => return()); 
    new_x := mouse_pos.x * sapp.dpi_scale.cast();
    new_y := sapp.framebuffer_height.float() - (mouse_pos.y * sapp.dpi_scale.cast()) - 1;
    if clear_dxdy {
        sapp.mouse.dx = 0.0;
        sapp.mouse.dy = 0.0;
    } else {
        if sapp.mouse.pos_valid {
            // don't update dx/dy in the very first update
            sapp.mouse.dx = new_x.cast() - sapp.mouse.x;
            sapp.mouse.dy = new_y.cast() - sapp.mouse.y;
        };
    };
    sapp.mouse.x = new_x.cast();
    sapp.mouse.y = new_y.cast();
    sapp.mouse.pos_valid = true;
}

fn macos_mouse_update_from_nsevent(sapp: *Sapp.Self, event: NSEvent, clear_dxdy: bool) void = { // NSEvent
    sapp.macos_mouse_update_from_nspoint(@objc @as(CGPoint) event.locationInWindow(), clear_dxdy);
}

fn lock_mouse(macos: *Impl, lock: bool) void = {
    sapp := macos.common();
    if(lock == sapp.mouse.locked, => return());
    sapp.mouse.dx = 0.0;
    sapp.mouse.dy = 0.0;
    sapp.mouse.locked = lock;
    /*
        NOTE that this code doesn't warp the mouse cursor to the window
        center as everybody else does it. This lead to a spike in the
        *second* mouse-moved event after the warp happened. The
        mouse centering doesn't seem to be required (mouse-moved events
        are reported correctly even when the cursor is at an edge of the screen).

        NOTE also that the hide/show of the mouse cursor should properly
        stack with calls to sapp_show_mouse()
    */
    CGAssociateMouseAndMouseCursorPosition(!sapp.mouse.locked);
    // TODO: why not allow locking the mouse without hiding it? maybe that's never what you want? 
    if(sapp.mouse.locked, => NSCursor'hide(), => NSCursor'unhide());
}

::if(ObjCId);

fn update_cursor(macos: *Impl, cursor: Sapp.MouseCursor, shown: bool) void = {
    sapp := macos.common();
    // show/hide cursor only if visibility status has changed (required because show/hide stacks)
    if shown != sapp.mouse.shown {
        if(shown, => NSCursor'unhide(), => NSCursor'hide());
    };
    // update cursor type
    macos.cursors&[cursor].set();
}

fn set_icon(macos: *Impl, icon_desc: []Sapp.ImageDesc) void = {
    c := macos.classes&;
    dock_tile := @objc c.NSApp.dockTile();
    wanted := @objc @as(CGSize) dock_tile.size();
    img_desc := image_bestmatch(icon_desc, wanted.width.int(), wanted.height.int());
    
    cg_color_space := CGColorSpaceCreateDeviceRGB();
    // TODO: why not just CGDataProviderCreateWithData?
    cf_data := CFDataCreate(c.kCFAllocatorDefault, img_desc.pixels.ptr, img_desc.pixels.len);
    cg_data_provider := CGDataProviderCreateWithCFData(cf_data);
    bitmapInfo := bit_or(3, 1.shift_left(12));
    kCGRenderingIntentDefault :: 0;
    flags  := bit_or(3, 8192); // kCGImageAlphaLast|kCGBitmapByteOrder32Little
    cg_img := CGImageCreate(img_desc.width, img_desc.height, 8, 32, img_desc.width * 4, cg_color_space, flags, cg_data_provider, 0, false, kCGRenderingIntentDefault);
    CFRelease(bit_cast_unchecked(@type cf_data, ObjCId, cf_data));
    CGDataProviderRelease(cg_data_provider);
    CGColorSpaceRelease(cg_color_space);

    ns_image := @objc cls("NSImage").alloc();
    ns_image := @objc ns_image.initWithCGImage(cg_img, size = @objc @as(i64) dock_tile.size());
    @objc dock_tile.setContentView(@objc cls("NSImageView").imageViewWithImage(ns_image));
    @objc dock_tile.display();
    @objc ns_image.release();
    CGImageRelease(cg_img);
}

fn frame(macos: *Impl) void = {
    sapp := macos.common();
    pool := objc_autoreleasePoolPush();
    sapp.frame();
    if sapp.quit_requested || sapp.quit_ordered {
        @objc sapp.impl()[].window.performClose(0);
    };
    objc_autoreleasePoolPop(pool);
}

// 
// This is probably pointless. 
// Instead of just putting the app state in a static variable, i put it as 
// a instance variable on all my objc classes and get it back for every message received. 
// Is there any situation where you'd want two whole application contexts in the same process? 
// Does it even let you do that? NSApplication.sharedApplication() makes it seem like no? 
// 
fn GET(obj: id"T") Ty(*Sapp.Self, *Impl) #inline = {
    out := zeroed(rawptr);
    object_getInstanceVariable(obj, "franca_sapp", out&);
    i := Impl.ptr_from_raw(out);
    (i.common(), i)
}

FrancaAppDelegate :: @struct {
    EXTENDS :: "NSObject";
    //IMPLEMENTS :: @const_slice("NSApplicationDelegate");  // TODO: seems to be null?????
    Self :: id"FrancaAppDelegate";

    applicationDidFinishLaunching :: fn(app_delegate: Self, _: id"NSNotification") void = {
        sapp, macos := GET(app_delegate);
        c := macos.classes&;
        macos.init_cursors();
        
        screen := NSScreen'mainScreen();
        if sapp.window_width == 0 || sapp.window_height == 0 {
            // use 4/5 of screen size (if they explicitly pass zeroes)
            screen_rect := screen.frame();
            if sapp.window_width == 0 {
                sapp.window_width = int((screen_rect.size.width * 4.0) / 5.0);
            }
            if sapp.window_height == 0 {
                sapp.window_height = int((screen_rect.size.height * 4.0) / 5.0);
            }
        }
        style: i64 = 0b1111;  // NSWindowStyleMask Tiled|Closable|Miniaturizable|Resizable
        window_rect: CGRect = (origin = (x = 0, y = 0), size = (width = sapp.window_width.float(), height = sapp.window_height.float()));
        w := @objc cls("FrancaWindow").alloc();
        
        object_setInstanceVariable(w, "franca_sapp", Impl.raw_from_ptr(macos));
        w := @objc w.initWithContentRect(window_rect, styleMask = style, backing = 2 /*NSBackingStoreBuffered*/, defer = false);
        macos.window = w;
        @debug_assert(!w.is_nil());
        macos.set_window_title(sapp.desc.window_title);
        
        macos.win_dlg = new "FrancaWindowDelegate";
        object_setInstanceVariable(macos.win_dlg, "franca_sapp", Impl.raw_from_ptr(macos));
        @objc_set(w) (
            releasedWhenClosed = false, // this is necessary for proper cleanup in applicationWillTerminate
            acceptsMouseMovedEvents = true,
            restorable = true,
            delegate = macos.win_dlg,
        );
        ASSERT_NOT_GL();
        max_fps := screen.maximumFramesPerSecond();  // if (@available(macOS 12.0, *))
        TODO_USE_THIS := max_fps;
        
        macos.mtl_device = MTLCreateSystemDefaultDevice();
        @debug_assert(!macos.mtl_device._.is_nil(), "MTLCreateSystemDefaultDevice");
        v := @objc cls("FrancaView").alloc();
        object_setInstanceVariable(v, "franca_sapp", Impl.raw_from_ptr(macos)); 
        macos.view = v;
        @objc v.initWithFrame(window_rect);
        
        // TODO: make sure i'm doing whatever MTKView was doing with this information:
        //       swap_interval, sample_count, preferredFramesPerSecond = max_fps
        @objc_set(v) (
            wantsLayer = true,
            // TODO: im not convinced this behaves how i want. maybe i need to override drawRect to do something? 
            //       i want to always be drawing, without getting stuck in the full screen animation. 
            layerContentsRedrawPolicy = 2, // NSViewLayerContentsRedrawDuringViewResize
        );
        macos.setup_display_link();
        
        layer := @objc @as(id"CAMetalLayer") v.layer();
        @objc_set(layer) (
            delegate = v,
            device = macos.mtl_device,
            pixelFormat = 80, // MTLPixelFormatBGRA8Unorm
            magnificationFilter = c.kCAFilterNearest,
        );
        
        @objc v.updateTrackingAreas();
        @objc w.setContentView(v);  // this calls viewDidMoveToWindow
        @objc w.makeFirstResponder(v);
        
        @objc w.center();
        sapp.valid = true;
        
        // this lets you select the window and get key events
        c.NSApp.setActivationPolicy(0); // NSApplicationActivationPolicyRegular
        // this lets you get out of full screen by putting your mouse at the top and revealing the menu bar with the little traffic light
        @objc c.NSApp.setMainMenu(new "NSMenu");
        
        if sapp.fullscreen {
            /* ^^^ on GL, this already toggles a rendered frame, so set the valid flag before */
            @objc w.toggleFullScreen(app_delegate);  // this doesn't work before setActivationPolicy
        };
        
        // "set the application dock icon as early as possible, otherwise the dummy icon will be visible for a short time" 
        // but this doesn't work if you do it before setActivationPolicy so it's moved here. 
        sapp.set_icon(sapp.desc.icon);
        
        // this makes it pop to the front when opened
        c.NSApp.activateIgnoringOtherApps(true);
        
        nil := ObjCId.zeroed();
        @objc w.makeKeyAndOrderFront(nil);
        sapp.impl().update_dimensions();
        NSEvent'setMouseCoalescingEnabled(false);
    
        // workaround for window not being focused during a long init callback
        // for details see: https://github.com/floooh/sokol/pull/982
        // also see: https://gitlab.gnome.org/GNOME/gtk/-/issues/2342
        focusevent := NSEvent'otherEventWithType(13, // NSEventTypeAppKitDefined
             (x = 0, y = 0),
             0x40,
             0,
             0,
             nil,
             1, // NSEventSubtypeApplicationActivated
             0,
             0,
        );
        c.NSApp.postEvent(focusevent, true);
    }
    
    // TODO: allow using `_` as discard twice
    applicationShouldTerminateAfterLastWindowClosed :: fn(_: Self, __: id"NSApplication") bool = 
        true;
    
    applicationWillTerminate :: fn(self: Self, _: id"NSNotification") void = {
        sapp, macos := GET(self);
        sapp.call_cleanup();
        macos.macos_discard_state();
        sapp.discard_state();
    }
};

FrancaWindowDelegate :: @struct {
    EXTENDS :: "NSObject";
    IMPLEMENTS :: @const_slice("NSWindowDelegate");
    Self :: id"FrancaWindowDelegate";
    
    windowShouldClose :: fn(self: Self, _: id"NSWindow") bool = {
        sapp, _ := GET(self);
        /* only give user-code a chance to intervene when sapp.quit() wasn't already called */
        if !sapp.quit_ordered {
            /* if window should be closed and event handling is enabled, give user code
            a chance to intervene via sapp.cancel_quit(). */
            sapp.quit_requested = true;
            sapp.app_event(.QUIT_REQUESTED);
            /* user code hasn't intervened, quit the app */
            sapp.quit_ordered = sapp.quit_ordered || sapp.quit_requested;
        };
        sapp.quit_ordered
    }
    
    // TODO: remove this
    windowWillStartLiveResize :: fn(self: Self, _: id"NSNotification") void = {
        sapp, macos := GET(self);
        // Work around the MTKView resizing glitch by "anchoring" the layer to the window corner opposite
        // to the currently manipulated corner (or edge). This prevents the content stretching back and
        // forth during resizing. This is a workaround for this issue: https://github.com/floooh/sokol/issues/700
        // Can be removed if/when migrating to CAMetalLayer: https://github.com/floooh/sokol/issues/727
        //
        // TODO: im doing something wrong ig cause im using cametallayer now and it still looks like ass without this
        //       but only sometimes....? it's like it gets confused....? -- May 6, 2025
        //
        resizing_from_left := sapp.mouse.x.cast() < sapp.window_width.float()/2;
        resizing_from_top  := sapp.mouse.y.cast() < sapp.window_height.float()/2;
        br, tr, bl, tl := (7, 5, 9, 11); // NSViewLayerContentsPlacement
        p := @if(resizing_from_left,
            @if(resizing_from_top, br, tr),
            @if(resizing_from_top, bl, tl),
        );
        @objc macos.view.setLayerContentsPlacement(p);
    }
    
    windowDidResize :: fn(self: Self, _: id"NSNotification") void = {
        _, macos := GET(self);
        macos.update_dimensions();
    }
    
    windowDidChangeScreen :: fn(self: Self, _: id"NSNotification") void = {
        _, macos := GET(self);
        // TODO: i could send an event for this? 
        //sapp.timing_reset(sapp.timing&);  // TODO: timing
        macos.update_dimensions();
    }
    
    windowDidMiniaturize :: fn(self: Self, _: id"NSNotification") void = 
        app_event(self, .ICONIFIED);
    
    windowDidDeminiaturize :: fn(self: Self, _: id"NSNotification") void = 
        app_event(self, .RESTORED);
    
    windowDidBecomeKey :: fn(self: Self, _: id"NSNotification") void = 
        app_event(self, .FOCUSED);
    
    windowDidResignKey :: fn(self: Self, _: id"NSNotification") void = 
        app_event(self, .UNFOCUSED);
    
    windowDidEnterFullScreen :: fn(self: Self, _: id"NSNotification") void = {
        sapp, _ := GET(self);
        sapp.fullscreen = true;
    }
    
    windowDidExitFullScreen :: fn(self: Self, _: id"NSNotification") void = {
        sapp, _ := GET(self);
        sapp.fullscreen = false;
    }
    
    // TODO: could use windowDidChangeOcclusionState to turn off displaylink when it's fully covered by another window
};

FrancaWindow :: @struct {
    EXTENDS :: "NSWindow";
    Self :: id"FrancaWindow";

    // TODO: does anyone in crazy town call this directly? 
    //       if the only place that calls it is myself in applicationDidFinishLaunching, 
    //       this can just be a normal franca function without the super stuff. 
    // Parameter names matter!
    initWithContentRect :: fn(self: Self, contentRect: CGRect, styleMask: u64, backing: u64, defer: bool) ObjCId = {
        _, macos := GET(self);
        c := macos.classes;
        
        ctx: ObjCSuper = (receiver = self, super_class = cls("NSWindow"));
        window := @objc_super ctx&.initWithContentRect(contentRect, styleMask = styleMask, backing = backing, defer = defer);
        @debug_assert(!window.is_nil(), "initWithContentRect failed??? this won't go well for you");
        //#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300
        types := @objc cls("NSArray").arrayWithObject(c.NSPasteboardTypeFileURL);
        @objc window.registerForDraggedTypes(types);
        window
    }

    draggingEntered :: fn(_: Self, __: id"NSDraggingInfo") i64 =  {
        1 // NSDragOperationCopy
    }
    
    draggingUpdated :: fn(_: Self, __: id"NSDraggingInfo") i64 = {
        1 // NSDragOperationCopy
    }
    
    performDragOperation :: fn(self: Self, sender: NSDraggingInfo) bool = {
        //#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300
        sapp, macos := GET(self);
        d, a, c  := (sapp.drop&, sapp.desc.allocator, macos.classes&);
        pboard   := sender.draggingPasteboard();
        xxx := pboard.types();
        can_drop := xxx.containsObject(c.NSPasteboardTypeFileURL);
        if(!can_drop, => return(false));
        files := pboard.pasteboardItems();
        d.num_files = files.count();
        
        d.buffer.len = 0;
        d.starts.len = 0;
        d.starts&.reserve(d.num_files, a);
        range(0, d.num_files) { i |
            d.starts&.push(d.buffer.len, a);
            it := files.objectAtIndex(i).stringForType(c.NSPasteboardTypeFileURL);
            it := NSURL'fileURLWithPath(it);
            it := it.standardizedURL().path().UTF8String().str();
            d.buffer&.push_all(it, a);
            d.buffer&.push(0, a); // for good luck
        }
        d.starts&.push(d.buffer.len, a);  // for the end of last one
        if sapp.events_enabled() {
            sapp.macos_mouse_update_from_nspoint(sender.draggingLocation(), true);
            sapp.init_event(.FILES_DROPPED);
            sapp.event.modifiers = sapp.macos_mods(NSEvent.zeroed());
            sapp.call_event(sapp.event&);
        };
        true
    };
};

// TODO: for gl: override timerFired and prepareOpenGL on view
FrancaView :: @struct {
    EXTENDS :: "NSView";
    IMPLEMENTS :: @const_slice("CALayerDelegate");
    Self :: id"FrancaView";
    
    layerClass :: fn(self: Self) ObjCClass = 
        cls("CAMetalLayer");
    
    makeBackingLayer :: fn(self: Self) ObjCId = 
        @objc cls("CAMetalLayer").layer();

    setFrame :: fn(self: Self, frame: CGRect) void = {
        _, macos := GET(self);
        ctx: ObjCSuper = (receiver = self, super_class = cls("NSView"));
        @objc_super ctx&.setFrame(frame);
        macos.update_dimensions();
    }
    
    setBounds :: fn(self: Self, bounds: CGRect) void = {
        _, macos := GET(self);
        ctx: ObjCSuper = (receiver = self, super_class = cls("NSView"));
        @objc_super ctx&.setBounds(bounds);
        macos.update_dimensions();
    }
    
    isOpaque :: fn(_: Self) bool = true;
    canBecomeKeyView :: fn(_: Self) bool = true;
    acceptsFirstResponder :: fn(_: Self) bool = true;
    updateTrackingAreas :: fn(self: Self) void = {
        sapp, macos := GET(self);
        
        if !macos.tracking_area.is_nil() {
            @objc self.removeTrackingArea(macos.tracking_area);
            @objc macos.tracking_area.release();
        }
        
        // TODO: i feel like EnabledDuringMouseDrag isn't happening. did i mistype the bits?
        // NSTracking MouseEnteredAndExited|CursorUpdate|ActiveInKeyWindow|AssumeInside|InVisibleRect|EnabledDuringMouseDrag
        options: u32 = 0b11100100101;
        
        c := macos.classes&;
        ta := @objc cls("NSTrackingArea").alloc();
        ta := @objc ta.initWithRect(@objc @as(CGRect) self.bounds(), options = options, owner = self, userInfo = zeroed(ObjCId));
        macos.tracking_area = ta;
        @objc self.addTrackingArea(ta);
        
        s: ObjCSuper = (receiver = self, super_class = cls"NSView");
        @objc_super s&.updateTrackingAreas();
    }
    
    mouseEntered :: fn(self: Self, event: NSEvent) void = {
        sapp, macos := GET(self);
        sapp.gl_make_current();
        sapp.macos_mouse_update_from_nsevent(event, true);
        /* don't send mouse enter/leave while dragging (so that it behaves the same as
           on Windows while SetCapture is active
        */
        if macos.mouse_buttons == 0 {
            sapp.macos_mouse_event(.MOUSE_ENTER, .INVALID, event);
        }
    }
    
    mouseExited :: fn(self: Self, event: NSEvent) void = {
        sapp, macos := GET(self);
        sapp.gl_make_current();
        sapp.macos_mouse_update_from_nsevent(event, true);
        if (0 == macos.mouse_buttons) {
            sapp.macos_mouse_event(.MOUSE_LEAVE, .INVALID, event);
        }
    }
    
    mouseDown :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_press(view, event, .MOUSE_DOWN, .LEFT);
    
    mouseUp :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_press(view, event, .MOUSE_UP, .LEFT);
    
    rightMouseDown :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_press(view, event, .MOUSE_DOWN, .RIGHT);
    
    rightMouseUp :: fn(view: Self, event: NSEvent) void =  
        handle_mouse_press(view, event, .MOUSE_UP, .RIGHT);
    
    otherMouseDown :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_press(view, event, .MOUSE_DOWN, .MIDDLE);
    
    otherMouseUp :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_press(view, event, .MOUSE_UP, .MIDDLE);
    
    otherMouseDragged :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_move(view, event, true);
    
    mouseMoved :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_move(view, event, false);
    
    mouseDragged :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_move(view, event, false);
    
    rightMouseDragged :: fn(view: Self, event: NSEvent) void = 
        handle_mouse_move(view, event, false);
    
    scrollWheel :: fn(view: Self, event: NSEvent) void = {
        sapp, macos := GET(view);
        sapp.gl_make_current();
        sapp.macos_mouse_update_from_nsevent(event, true);
        if sapp.events_enabled() {
            dx := event.scrollingDeltaX();
            dy := event.scrollingDeltaY();
            if event.hasPreciseScrollingDeltas() {
                dx *= 0.1;
                dy *= 0.1;
            }
            if dx != 0 || dy != 0 {  // TODO: why did sokol have a complicated expression here? does it ever give us nans?
                sapp.init_event(.MOUSE_SCROLL);
                sapp.event.modifiers = sapp.macos_mods(event);
                sapp.event.scroll_x = dx.cast();
                sapp.event.scroll_y = dy.cast();
                sapp.call_event(sapp.event&);
            }
        }
    }
    
    keyDown :: fn(view: Self, event: NSEvent) void = {
        sapp, macos := GET(view);
        if(!sapp.events_enabled(), => return());
        sapp.gl_make_current();
        mods     := sapp.macos_mods(event);
        key_code := sapp.translate_key(zext event.keyCode());
        repeat   := event.isARepeat();
        sapp.macos_key_event(.KEY_DOWN, key_code, repeat, mods);
        if sapp.desc.enable_chars {
            chars := event.characters();
            len   := chars.length();
            if len > 0 {
                sapp.init_event(.CHAR);
                sapp.event.modifiers = mods;
                range(0, len) { i |
                    // TODO: sokol docs say "the UTF-32 character code" but that's not what this is. 
                    //       is it impossible to type a character that needs a surrogate? that can't be true. 
                    //       if you try the little emoji popup thingy you get 
                    //       "error messaging the mach port for IMKCFRunLoopWakeUpReliable"
                    utf16_codeunit := chars.characterAtIndex(i);
                    // don't send it if it's in the "UNICODE Private Area" 
                    if utf16_codeunit.bit_and(0xFF00) != 0xF700 {
                        sapp.event.char_code = utf16_codeunit.zext();
                        sapp.event.key_repeat = repeat;
                        sapp.call_event(sapp.event&);
                    }
                }
            };
        }
        /* if this is a Cmd+V (paste), also send a CLIPBOARD_PASTE event */
        if sapp.clipboard.enabled && mods.get(.super) != 0 && key_code == .V {
            sapp.init_event(.CLIPBOARD_PASTED);
            sapp.call_event(sapp.event&);
        };
    }
    
    performKeyEquivalent :: fn(view: Self, event: NSEvent) bool = {
        // fixes Ctrl-Tab keydown not triggering a keyDown event
        // NOTE: it seems that Ctrl-F1 cannot be intercepted the same way, but since
        // this enabled critical accessibility features that's probably a good thing.
        sapp, macos := GET(view);
        k := event.keyCode();
        if sapp.translate_key(zext k) == .TAB {
            @objc macos.view.keyDown(event);
            return true;
        };
        false
    }
    
    keyUp :: fn(view: Self, event: NSEvent) void = {
        sapp, macos := GET(view);
        sapp.gl_make_current();
        key := sapp.translate_key(zext event.keyCode());
        sapp.macos_key_event(.KEY_UP, key, event.isARepeat(), sapp.macos_mods(event));
    }
    
    flagsChanged :: fn(view: Self, event: NSEvent) void = {
        sapp, macos := GET(view);
        old_f := macos.flags_changed_store;
        new_f := event.modifierFlags();
        macos.flags_changed_store = new_f;
        key_code := Sapp.Keycode.INVALID;
        down     := false;
        changed  := new_f.bit_xor(old_f);
        check :: fn(bit, key: Sapp.Keycode) => {
            flag := 1.shift_left(bit);
            if changed.bit_and(flag.trunc()) != 0 {
                key_code = key;
                down = 0 != new_f.zext().bit_and(flag);
            };
        };
        
        // NSEventModifierFlag
        check(17, .LEFT_SHIFT);
        check(18, .LEFT_CONTROL);
        check(19, .LEFT_ALT); // option
        check(20, .LEFT_SUPER); // command
    
        if key_code != .INVALID {
            sapp.macos_key_event(@if(down, .KEY_DOWN, .KEY_UP), key_code, false, sapp.macos_mods(event));
        }
    }
};

setup_display_link :: fn(macos: *Impl) void = {
    macos.display_source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD(), 0, 0, dispatch_get_main_queue());
    @debug_assert(!macos.display_source._.is_null(), "dispatch_source_create");
    dispatch_set_context(macos.display_source, Impl.raw_from_ptr(macos));
    dispatch_source_set_event_handler_f(macos.display_source, display_link_callback2);
    dispatch_resume(macos.display_source);

    res := CVDisplayLinkCreateWithActiveCGDisplays(macos.display_link&);
    @assert(res.is_ok(), "CVDisplayLinkCreateWithActiveCGDisplays");
    @debug_assert(!macos.display_link._.is_null(), "CVDisplayLinkCreateWithActiveCGDisplays");
    
    res := CVDisplayLinkSetOutputCallback(macos.display_link, display_link_callback1, bit_cast_unchecked(*Impl, rawptr, macos));
    @assert(res.is_ok(), "CVDisplayLinkSetOutputCallback");

    disp_id := {
        screen := NSScreen'mainScreen();
        devices := screen.deviceDescription();
        name := NSString'stringWithUTF8String("NSScreenNumber");
        desc := @objc devices.objectForKey(name);
        @debug_assert(!desc.is_nil(), "CGDirectDisplayID");
        @objc @as(CGDirectDisplayID) desc.unsignedIntegerValue()
    };
    // this needs to be after SetOutputCallback
    res := CVDisplayLinkSetCurrentCGDisplay(macos.display_link, disp_id);
    @assert(res.is_ok(), "CVDisplayLinkSetCurrentCGDisplay");
    
    res := CVDisplayLinkStart(macos.display_link);
    @assert(res.is_ok(), "CVDisplayLinkStart");
}

// 3 trillion dollars buys you way more callbacks per callback than you could ever imagine. 
// this dance is to call the event/render code on the main thread. 

#avoid_shim  // (this gets called off the main thread. only matters for `main :: fn() = @run`)
display_link_callback1 :: fn(displayLink: CVDisplayLinkRef, now: rawptr, outputTime: rawptr, flagsIn: i64, flagsOut: *i64, displayLinkContext: rawptr) voidResult = {
    macos := bit_cast_unchecked(rawptr, *Impl, displayLinkContext);
    dispatch_source_merge_data(macos.display_source, 1);
    (value = 0)
}

display_link_callback2 :: fn(userdata: rawptr) void = {
    macos := Impl.ptr_from_raw(userdata);
    // TODO: produce a test where you can tell this does somethings
    /* Catch any last-moment input events */
    macos.poll_input_events();
    macos.frame();
}

// helper function to make GL context active
fn gl_make_current(sapp: *Sapp.Self) void = {
    ASSERT_NOT_GL();
}

fn handle_mouse_press(view: id"FrancaView", event: NSEvent, action: Sapp.EventType, which: Sapp.Mousebutton) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, false);
    // TODO: i guess other buttonNumbers are the side buttons? 
    //       i want those actually? but also they don't seem to get here anyway. 
    //       do i have to somehow set that button to be a real button in the garbage mouse app? 
    // TODO: it seems i get otherButton events with 0/1 for left/right, 
    //       why bother to listen to those individually then? 
    if which == .MIDDLE && event.buttonNumber() != 2 {
        return()
    }
    sapp.macos_mouse_event(action, which, event);
    // TODO: use @bit_fields
    old: i64 = macos.mouse_buttons.zext();
    if action == .MOUSE_DOWN {
        macos.mouse_buttons = old.bit_or(1.shift_left(which.raw().intcast())).trunc();
    } else {
        macos.mouse_buttons = old.bit_and(1.shift_left(which.raw().intcast()).bit_not()).trunc();
    }
}

fn handle_mouse_move(view: id"FrancaView", event: NSEvent, other: bool) void = {
    sapp, macos := GET(view);
    sapp.gl_make_current();
    sapp.macos_mouse_update_from_nsevent(event, false);
    if(other && event.buttonNumber() != 2, => return());
    if sapp.mouse.locked {
        sapp.mouse.dx = cast event.deltaX();
        sapp.mouse.dy = cast event.deltaY();
    }
    sapp.macos_mouse_event(.MOUSE_MOVE, .INVALID, event);
}

fn poll_input_events(macos: *Impl) void = {
    mask := -1;  // gimme everything! 

    pool := objc_autoreleasePoolPush();
    NSApp := macos.classes.NSApp;
    NSEventTrackingRunLoopMode := ObjCId.ptr_from_raw(@import_symbol("NSEventTrackingRunLoopMode", "AppKit"))[];
    loop {
        // NOTE: using NSDefaultRunLoopMode here causes stuttering in the GL backend,
        // see: https://github.com/floooh/sokol/issues/486
        event := @objc NSApp.nextEventMatchingMask(mask, untilDate = zeroed ObjCId, inMode = NSEventTrackingRunLoopMode, dequeue = true);
        if event.is_nil() {
            objc_autoreleasePoolPop(pool);
            return();
        }
        @objc NSApp.sendEvent(event);
    }
}

fn metal_get_device(macos: *Impl) MTLDevice = {
    @debug_assert(macos.common()[].valid, "not valid");
    ASSERT_NOT_GL();
    macos.mtl_device
}

fn get_swapchain(macos: *Impl) Sg.MetalSwapchain = {   
    @debug_assert(macos.common()[].valid);
    ASSERT_NOT_GL();
    layer := @objc macos.view.layer();
    @debug_assert(!layer.is_nil(), "missing layer!");
    (
        // TODO: maybe we want to make sure they only call this once per frame
        current_drawable = @objc layer.nextDrawable(),
        depth_stencil_texture = macos.depth_texture,
        //@objc @as(rawptr) macos.view.multisampleColorTexture()  // TODO
        msaa_color_texture = zeroed ObjCId,
    )
}

fn macos_get_window(macos: *Impl) rawptr = {
    ASSERT_NOT_GL(); // TODO: we just care that it's macos
    bit_cast_unchecked(ObjCId, rawptr, macos.window)
}

fn keytable(self: *Impl) []Sapp.Keycode = {
    keys :: fn(arg: FatExpr) FatExpr #macro = {
        T :: Sapp.Keycode;
        N :: 256;
        a := ast_alloc().alloc_zeroed(T, N);
        each arg&.items() { e |
            a[const_eval(i64)(e.items()[0])] = const_eval(T)(e.items()[1]);
        };
        @literal a
    };
    @keys(
        (0x1D, ._0),
        (0x12, ._1),
        (0x13, ._2),
        (0x14, ._3),
        (0x15, ._4),
        (0x17, ._5),
        (0x16, ._6),
        (0x1A, ._7),
        (0x1C, ._8),
        (0x19, ._9),
        (0x00, .A),
        (0x0B, .B),
        (0x08, .C),
        (0x02, .D),
        (0x0E, .E),
        (0x03, .F),
        (0x05, .G),
        (0x04, .H),
        (0x22, .I),
        (0x26, .J),
        (0x28, .K),
        (0x25, .L),
        (0x2E, .M),
        (0x2D, .N),
        (0x1F, .O),
        (0x23, .P),
        (0x0C, .Q),
        (0x0F, .R),
        (0x01, .S),
        (0x11, .T),
        (0x20, .U),
        (0x09, .V),
        (0x0D, .W),
        (0x07, .X),
        (0x10, .Y),
        (0x06, .Z),
        (0x27, .APOSTROPHE),
        (0x2A, .BACKSLASH),
        (0x2B, .COMMA),
        (0x18, .EQUAL),
        (0x32, .GRAVE_ACCENT),
        (0x21, .LEFT_BRACKET),
        (0x1B, .MINUS),
        (0x2F, .PERIOD),
        (0x1E, .RIGHT_BRACKET),
        (0x29, .SEMICOLON),
        (0x2C, .SLASH),
        (0x0A, .WORLD_1),
        (0x33, .BACKSPACE),
        (0x39, .CAPS_LOCK),
        (0x75, .DELETE),
        (0x7D, .DOWN),
        (0x77, .END),
        (0x24, .ENTER),
        (0x35, .ESCAPE),
        (0x7A, .F1),
        (0x78, .F2),
        (0x63, .F3),
        (0x76, .F4),
        (0x60, .F5),
        (0x61, .F6),
        (0x62, .F7),
        (0x64, .F8),
        (0x65, .F9),
        (0x6D, .F10),
        (0x67, .F11),
        (0x6F, .F12),
        (0x69, .F13),
        (0x6B, .F14),
        (0x71, .F15),
        (0x6A, .F16),
        (0x40, .F17),
        (0x4F, .F18),
        (0x50, .F19),
        (0x5A, .F20),
        (0x73, .HOME),
        (0x72, .INSERT),
        (0x7B, .LEFT),
        (0x3A, .LEFT_ALT),
        (0x3B, .LEFT_CONTROL),
        (0x38, .LEFT_SHIFT),
        (0x37, .LEFT_SUPER),
        (0x6E, .MENU),
        (0x47, .NUM_LOCK),
        (0x79, .PAGE_DOWN),
        (0x74, .PAGE_UP),
        (0x7C, .RIGHT),
        (0x3D, .RIGHT_ALT),
        (0x3E, .RIGHT_CONTROL),
        (0x3C, .RIGHT_SHIFT),
        (0x36, .RIGHT_SUPER),
        (0x31, .SPACE),
        (0x30, .TAB),
        (0x7E, .UP),
        (0x52, .KP_0),
        (0x53, .KP_1),
        (0x54, .KP_2),
        (0x55, .KP_3),
        (0x56, .KP_4),
        (0x57, .KP_5),
        (0x58, .KP_6),
        (0x59, .KP_7),
        (0x5B, .KP_8),
        (0x5C, .KP_9),
        (0x45, .KP_ADD),
        (0x41, .KP_DECIMAL),
        (0x4B, .KP_DIVIDE),
        (0x4C, .KP_ENTER),
        (0x51, .KP_EQUAL),
        (0x43, .KP_MULTIPLY),
        (0x4E, .KP_SUBTRACT),
    )
}
