// Shader IR -> Metal Shader Language / MSL source code.
// body[i] produces a value in variable `v{i}` of type `T{body[i].type}`.
// instructions of type Void are executed for side effects.

Counters :: @struct(user: u16, sampler: u16, texture: u16);

emit_all :: fn(self: *Function, out: *List(u8)) void = {
    @fmt(out, MSL_PRELUDE);
    n := zeroed Counters;
    enumerate self.types& { i, info |
        if !info.is(.Void) {
            @fmt(out, "typedef ");
        }
        @match(info) {
            fn Void() => ();
            fn Scalar(it) => out.push_all(@match(it[]) {
                fn F32() => "float";
                fn I32() => "int";
                fn U32() => "unsigned int";
                fn Bool() => "bool";
            });
            // TODO: int vec
            fn Vector(it) => @fmt(out, "float%", it.len);
            fn Matrix(it) => @fmt(out, "float%x%", it.col, it.row); // TODO: flipped?
            fn Texture() => @fmt(out, "texture2d<float>");
            fn Sampler() => @fmt(out, "sampler");
            fn Struct(it) => {
                @fmt(out, "struct {\n");
                enumerate it.fields { j, it |
                    @fmt(out, "    ");
                    self.ann_field(it, out, self.string(it.name), n&);
                    @fmt(out, ";\n");
                };
                @fmt(out, "}");
            };
            fn Ptr(it) => @fmt(out, "device T%*", it[]);
        };
        if !info.is(.Void) {
            @fmt(out, " T%;\n", i);
        }
    };
    
    each self.imports { it |
        emit_signature(self, out, n&, .NONE, it[]);
        @fmt(out, ";\n");
    };
    // TODO: the stuff above should be done once per module
    emit_function(self, out, n&);
}

emit_signature :: fn(self: *Function, out: *List(u8), n: *Counters, stage: Sg.ShaderStage, sig: Signature) void = {
    stage_name := @match(stage) {
        fn VERTEX() => "vertex";
        fn FRAGMENT() => "fragment";
        fn COMPUTE() => "kernel";
        fn NONE() => "";  // not an entry point
    };
    name := @if(stage == .NONE, self.string(sig.name), "main0");
    if stage == .COMPUTE {
        @fmt(out, "\n% void %(", stage_name, name);
    } else {
        @fmt(out, "\n% T% %(", stage_name, sig.ret, name);
    };
    // @debug_assert_eq(self.body[0].op, .Nop);
    enumerate sig.input { i, it |
        self.ann_field(it, out, @tfmt("v%", i+1), n);
        @fmt(out, ", ");
        // @debug_assert_eq(self.body[i+1].op, .Nop);
    };
    out.len -= out.items().ends_with(", ").int() * 2;
    @fmt(out, ")");
}

emit_function :: fn(self: *Function, out: *List(u8), n: *Counters) void = {
    emit_signature(self, out, n, self.stage, (
        // TODO: Function should just have a signature fields
        name = self.name, 
        ret = self.ret,
        input = self.input,
    ));
    @fmt(out, " {\n");
    emit_body(self, out);
}

ann_field :: fn(self: *Function, it: *IoField, out: *List(u8), name: Str, n: *Counters) void = {
    if it.uniform {
        @fmt(out, "constant ");
    }
    @fmt(out, "T% ", it.type);
    if it.uniform {
        @fmt(out, "& ");
    }
    @fmt(out, "%", name);
    info := self.types[it.type.zext()]&;
    @match(info) {  // TODO: do these do anything?
        fn Texture() => {
            @fmt(out, " [[texture(%)]]", n.texture);
            n.texture += 1;
        }
        fn Sampler() => {
            @fmt(out, " [[sampler(%)]]", n.sampler);
            n.sampler += 1;
        }
        @default => ();
    };
    
    @match(it.builtin) {
        fn vertex_index() => @fmt(out, " [[vertex_id]]");
        fn thread_position_in_grid() => @fmt(out, " [[thread_position_in_grid]]");
        fn position()     => @fmt(out, " [[position]]");
        fn colour()       => @fmt(out, " [[color(0)]]");  // todo: don't think this does anything
        fn input()        => @fmt(out, " [[stage_in]]");
        fn point_size()   => @fmt(out, " [[point_size]]");
        fn user()         => {
            @fmt(out, " [[user(locn%)]]", n.user);
            n.user += 1;
        }
        @default => ();  // TODO
    };
    if it.buffer != 255 {
        @fmt(out, " [[buffer(%)]]", it.buffer);
    }
}

emit_body :: fn(self: *Function, out: *List(u8)) void = {
    by_type := temp().alloc_zeroed(RawList(u32), self.types.len);
    enumerate self.body { i, inst |
        if inst.type != 0 {
            by_type[inst.type.zext()]&.push(i.trunc(), self.gpa);
        }
    };
    
    enumerate by_type { type, vars |
        if vars.len > 0 {
            @fmt(out, "    T% ", type);
            for vars { i |
                @fmt(out, "v%,", i);
            };
            if vars.len != 0 {
                out.len -= 1;
            };
            @fmt(out, ";\n");
        }
    };
    
    i := -1;
    first_arg := -1;
    indentation := 1;
    while => i < self.body.len - 1 {
        continue :: local_return;
        i += 1;
        inst := self.body[i];
        if(@is(inst.op, .Join, .Par, .Nop), => continue());
        
        if inst.op != .Arg {
            @fmt(out, ";\n");
            indentation -= int(@is(inst.op, .End, .Else));
            range(0, indentation, fn(_) => @fmt(out, "    "));
            indentation += int(@is(inst.op, .Loop, .If, .Else));
            if(inst.type != 0, => @fmt(out, "v% = ", i));
        }
        
        name := msl_operator(inst.op);
        if name != "" {
            if inst.b != 0 {
                @fmt(out, "v% % v%", inst.a, name, inst.b);
            } else {
                @fmt(out, "%v%", name, inst.a);
            };
            continue();
        };
        
        name := msl_function(inst.op);
        if name != "" {
            if inst.b != 0 {
                if inst.c != 0 {
                    @fmt(out, "%(v%, v%, v%)", name, inst.a, inst.b, inst.c);
                } else {
                    @fmt(out, "%(v%, v%)", name, inst.a, inst.b);
                };
            } else {
                @fmt(out, "%(v%)", name, inst.a);
            };
            continue();
        };
        
        name := msl_function_multi(inst.op);
        if name != "" { // TODO: share with Call below
            @fmt(out, "%(", name);
            @debug_assert(first_arg != -1, "malformed shader call '%'", name);
            args := self.body.items().slice(first_arg, i);
            for args { a |
                @fmt(out, "v%, ", a.a);
            };
            out.len -= 2 * int(args.len != 0);  // no trailing comma :(
            @fmt(out, ")");
            first_arg = -1;
            continue();
        };
        
        @match(inst.op) {
            fn Loop() => out.push_all("while (true) {");
            fn If()   => @fmt(out, "if (v%) {", inst.a);
            fn Else() => out.push_all("} else {");
            fn End()  => out.push_all("}");
            fn Break()    => out.push_all("break");
            fn Continue() => out.push_all("continue");
            fn Return()   => @fmt(out, "return v%", inst.a);
            fn Arg() => {
                if first_arg == -1 {
                    first_arg = i;
                };
                continue();
            }
            fn Call() => {
                if first_arg == -1 {
                    first_arg = i;
                };
                args := self.body.items().slice(first_arg, i);
                
                fid: FuncId = from_index(inst.a.zext());
                name := self.functions&.get(fid).unwrap();
                @fmt(out, "%(", name);
                for args { a |
                    @fmt(out, "v%, ", a.a);
                };
                out.len -= int(out.items().ends_with(", ")) * 2;
                @fmt(out, ")");
                
                first_arg = -1;
            }
            fn Constant() => {
                info := self.types[inst.type.zext()]&;
                @debug_assert(info.is(.Scalar));
                emit_bits(out, inst.a, info.Scalar);
            }
            fn sample() => @fmt(out, "v%.sample(v%, v%)", inst.a, inst.b, inst.c);
            fn SetVar() => @fmt(out, "v% = v%", inst.a, inst.b);
            fn SetVarField() => {
                name: Symbol = inst.c.symbol_from_id();
                @fmt(out, "v%.% = v%", inst.a, self.string(name), inst.b);
            }
            fn SetDeref() => @fmt(out, "*v% = v%", inst.a, inst.b);
            fn AddrField() => {
                name: Symbol = inst.b.symbol_from_id();
                @fmt(out, "&v%->%", inst.a, self.string(name));
            }
            fn GetField() => {
                name: Symbol = inst.b.symbol_from_id();
                @fmt(out, "v%->%", inst.a, self.string(name));
            }
            fn GetVarField() => {
                name: Symbol = inst.b.symbol_from_id();
                @fmt(out, "v%.%", inst.a, self.string(name));
            }
            fn Swizzle() => {
                @fmt(out, "v%.", inst.a);
                bits := inst.b;
                range_rev(0, 4) { i |
                    bits :i64= zext bits.shift_right_logical(i*8).bit_and(0xFF);
                    if bits != 0 {
                        c := "xyzw"[bits.trailing_zeros()];
                        out.push(c);
                    }
                };
            }
            @default => @panic("todo: msl %", inst.op);
        };
        
        if first_arg != -1 {
            //for self.body.items().slice(0, i) { it |
            //    @println("% % % %", it.op, it.a, it.b, it.c);
            //};
            @panic("loose args in shader translation. inst %", i);
        }
    };
}

// TODO: same in both
fn emit_bits(out: *List(u8), v: u32, type: Scalar) void = @match(type) {
    fn F32() => {
        v: f32 = v.bitcast();
        if v.cast().int().float().cast() == v {
            @fmt(out, "%.0", v);
        } else {
            @fmt(out, "(%.0/10000.0)", v*10000);  // TODO: correct fractional part
        }
    }
    fn I32()  => @fmt(out, "%", v);
    fn U32()  => @fmt(out, "%", v);
    fn Bool() => @fmt(out, "%", v != 0 );
};

// TODO: mostly same in both
msl_operator :: fn(op: AstOp) Str = @match(op) {
    fn AddrOf() => "&";
    fn Deref() => "*";
    fn add() => "+";
    fn sub() => "-";
    fn mul() => "*";
    fn div() => "/";
    fn neg() => "-";
    fn not() => "~";
    fn and() => "&&";
    fn or() => "||";
    fn bit_and() => "&";
    fn bit_or() => "|";
    fn bit_not() => "~";
    fn eq() => "==";
    fn ne() => "!=";
    fn lt() => "<";
    fn gt() => ">";
    fn le() => "<=";
    fn ge() => ">=";
    fn Index() => "+";
    @default => "";
};

msl_function :: fn(op: AstOp) Str = @match(op) {
    fn u2x16() => "unpack_unorm2x16_to_float";
    fn u4x8() => "unpack_unorm4x8_to_float";
    fn vec2() => "float2";
    fn vec3() => "float3";
    @default => {
        same := @is(op, 
            .min, .max, .clamp, .mix, .atan2, .pow, .sin, .cos, 
            .abs, .fract, .floor, .sqrt, .log, .round, 
        );
        @if(same, op.name_str(), "")
    };
};

msl_function_multi :: fn(op: AstOp) Str = @match(op) {
    fn vec4() => "float4";
    @default => "";
};

MSL_PRELUDE :: """
#include <metal_stdlib>
#include <simd/simd.h>
using namespace metal;
""";
