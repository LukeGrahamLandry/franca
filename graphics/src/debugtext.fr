//! Simple ASCII debug text rendering on top of sokol_gfx.h
//! See ../docs/debugtext.md for usage information. 
//! Adapted from sokol_debugtext.h - https://github.com/floooh/sokol
//! zlib/libpng license. Copyright (c) 2020 Andre Weissflog.

max_fonts   :: 8; 
init_cookie :: 0xACBAABCB;  // purposely different from the c version

/* Describes the initialization parameters of a rendering context. Creating
    * additional rendering contexts is useful if you want to render in
    * different sokol-gfx rendering passes, or when rendering several layers
    * of text. */
ContextDesc :: @struct(
    max_commands:  i32 = 4096,              // max number of draw commands, each layer transition counts as a command
    char_buf_size: i32 = 4096,              // max number of characters rendered in one frame
    canvas_width:  f32 = 640.0,             // the initial virtual canvas width
    canvas_height: f32 = 400.0,             // the initial virtual canvas height
    tab_width:     i32 = 4,                 // tab width in number of characters
    color_format := SgPixelFormat.zeroed(), // color pixel format of target render pass
    depth_format := SgPixelFormat.zeroed(), // depth pixel format of target render pass
    sample_count:  i32 = 0,                 // MSAA sample count of target render pass
);

/* Describes the sokol-debugtext API initialization parameters. 
    * Passed to the sdtx_setup() function. */
Desc :: @struct(
    fonts := Array([]u8, max_fonts).zeroed(), // up to 8 fonts descriptions. see "USING YOUR OWN FONT DATA" in docs for details. 
    context: ContextDesc,                     // the default context creation parameters
    allocator: Alloc,
);

Float2  :: @struct(x: f32, y: f32);
Vertex  :: @struct(x: f32, y: f32, u: u16, v: u16, color: u32);
Command :: @struct(layer_id: i32, first_vertex: i32, num_vertices: i32);

// Set pos/origin/color/font to whatever you like before calling `put` to control how those characters are drawn. 
Context :: @struct(
    common: *Common,
    desc: ContextDesc,
    frame_id: u32,
    update_frame_id: u32,
    vertices: RawList(Vertex),
    commands: RawList(Command),
    vbuf: SgBuffer,
    pip: SgPipeline,
    font: i32,                // index into the fonts array
    cur_layer_id: i32,        // call set_layer instead of changing this directly (it needs to do some command buffer bookkeeping). 
    glyph_size: Float2,  // pixels per character grid unit
    // origin looks useless because you could just offset all coordinates yourself, 
    // but it allows you to control what happens when a new line or line feed control character sets pos.x = 0;
    origin: Float2,      // in character grid coordinates
    pos: Float2,         // in character grid coordinates
    tab_width: f32,
    color: u32,               // 0xAABBGGRR
    franca_dynamic_context: rawptr,
);
Common :: @rec @struct(
    init_cookie: u32,
    desc:     Desc,
    font_img: SgImage,
    font_smp: SgSampler,
    shader:   SgShader,
    // This is not special. It's just some storage you can use to avoid an 
    // extra allocation in the simple case where you only want a single context. 
    default_context: Context,
    font_pixels: []u8,
);

// Builtin fonts (you can provide your own as well).
font :: import("@/graphics/data/fonts.fr");

Shaders :: @struct(
    InV  :: @struct(position: Vec2 #attribute(0), texcoord0: Vec2 #attribute(1), color0: Vec4 #attribute(2)),
    OutV :: @struct(uv: Vec2 #user(locn0), color: Vec4 #user(locn1), pos: Vec4 #position),
    vs   :: fn(in: Shaders.InV) Shaders.OutV = (
        pos = @vec(in.position * (@vec(2.0, -2.0)) + @vec(-1.0, 1.0), 0.0, 1.0),
        uv = in.texcoord0,
        color = in.color0,
    ),
    InF  :: @struct(uv: Vec2 #user(locn0), color: Vec4 #user(locn1)),
    OutF :: @struct(frag_color: Vec4 #color(0)),
    UniF :: @struct(tex: ShaderTexture2f #texture(0), smp: ShaderSampler #sampler(0)),
    fs   :: fn(in: Shaders.InF, uni: Shaders.UniF) Shaders.OutF = (
        frag_color = @swizzle sample(uni.tex, uni.smp, in.uv).xxxx * in.color,
    ),
);

// fills in an empty `ctx` based on settings from `in_desc`.
// ERRORS: if sg_add_commit_listener fails (returns false and text will not be rendered).
fn init_context(sdtx: *Common, ctx: *Context, in_desc: *ContextDesc) bool = {
    sg_push_debug_group("sokol-debugtext");
    ctx.desc = in_desc[];
    ctx.common = sdtx;
    a := sdtx.desc.allocator;
    // NOTE: frame_id must be non-zero, so that updates trigger in first frame
    ctx.frame_id = 1;

    ctx.vertices = init(a, 6 * ctx.desc.char_buf_size.zext());
    ctx.commands = init(a, ctx.desc.max_commands.zext());
    set_layer(ctx, 0);

    vbuf_desc := SgBufferDesc.zeroed();
    vbuf_desc.size = ctx.vertices.cap * size_of(Vertex);
    vbuf_desc.type = .VERTEXBUFFER;
    vbuf_desc.usage = .STREAM;
    vbuf_desc.label = "sdtx-vbuf";
    ctx.vbuf = sg_make_buffer(vbuf_desc&);
    @debug_assert(ctx.vbuf.id != 0);

    pip_desc := SgPipelineDesc.zeroed();
    pip_desc.layout.buffers&[0].stride = size_of(Vertex);
    pip_desc.layout.attrs&[0].format = .FLOAT2;
    pip_desc.layout.attrs&[1].format = .USHORT2N;
    pip_desc.layout.attrs&[2].format = .UBYTE4N;
    pip_desc.shader = sdtx.shader;
    pip_desc.index_type = .NONE;
    pip_desc.sample_count = ctx.desc.sample_count;
    pip_desc.depth.pixel_format = ctx.desc.depth_format;
    pip_desc.colors&[0] = (
        pixel_format = ctx.desc.color_format,
        blend = (
            enabled = true,
            src_factor_rgb   = .SRC_ALPHA,
            dst_factor_rgb   = .ONE_MINUS_SRC_ALPHA,
            src_factor_alpha = .ONE,
            dst_factor_alpha = .ZERO,
        ),
    );
    pip_desc.label = "sdtx-pipeline";
    ctx.pip = sg_make_pipeline(pip_desc&);
    @debug_assert(ctx.pip.id != 0);

    ctx.glyph_size.x = 8.0 / ctx.desc.canvas_width;
    ctx.glyph_size.y = 8.0 / ctx.desc.canvas_height;
    ctx.tab_width = ctx.desc.tab_width.intcast().float().cast();
    ctx.color = 0xFF00FFFF;

    ok := sg_add_commit_listener(make_commit_listener(ctx));
    sg_pop_debug_group();
    ok
}

// Releases the resources owned by this context. 
// You are still responsible for cleaning up the memory holding the Context struct itself. 
fn destroy(ctx: *Context) void = {
    if !ctx.vertices.ptr.is_null() {
        drop(ctx.vertices&, ctx.common.allocator);
    };
    if !ctx.commands.ptr.is_null() {
        drop(ctx.vertices&, ctx.common.allocator);
    };
    sg_push_debug_group("sokol_debugtext");
    sg_destroy_buffer(ctx.vbuf);
    sg_destroy_pipeline(ctx.pip);
    sg_remove_commit_listener(sdtx_make_commit_listener(ctx));
    sg_pop_debug_group();
    ctx[] = Context.zeroed();
}

fn sdtx_setup(sdtx: *Common, desc: *Desc) void = {
    c := desc.context&;
    @debug_assert_gt(c.canvas_width, 0.0, "bad canvas_width");
    @debug_assert_gt(c.canvas_height, 0.0, "bad canvas_height");
    @debug_assert_gt(c.char_buf_size, 0, "bad char_buf_size");
    sdtx[] = zeroed(Common);
    sdtx.init_cookie = init_cookie;
    sdtx.desc = desc[];
    sg_push_debug_group("sokol-debugtext");

    // TODO: sketchy. im using a newer version of debugtext than the rest of the stuff i have so these field names are from a different version than the shaders are. 
    //       but it seems fine so i guess it was just name changes. 
    
    // common shader for all contexts
    shd_desc := SgShaderDesc.zeroed();
    shd_desc.label = "sokol-debugtext-shader";
    shd_desc.attrs&[0] = (glsl_name = "position",  hlsl_sem_name = "TEXCOORD", hlsl_sem_index = 0);
    shd_desc.attrs&[1] = (glsl_name = "texcoord0", hlsl_sem_name = "TEXCOORD", hlsl_sem_index = 1);
    shd_desc.attrs&[2] = (glsl_name = "color0",    hlsl_sem_name = "TEXCOORD", hlsl_sem_index = 2);
    shd_desc.images&[0] = (
        stage = .FRAGMENT, 
        image_type = ._2D, 
        sample_type = .FLOAT, 
        hlsl_register_t_n = 0, 
        msl_texture_n = 0, 
        wgsl_group1_binding_n = 64,
        multisampled = false,
    );
    shd_desc.samplers&[0] = (
        stage = .FRAGMENT,
        sampler_type = .FILTERING,
        hlsl_register_s_n = 0,
        msl_sampler_n = 0,
        wgsl_group1_binding_n = 80,
    );
    shd_desc.image_sampler_pairs&[0] = (
        stage = .FRAGMENT,
        image_slot = 0,
        sampler_slot = 0,
        glsl_name = "tex_smp",
    );
    choose_shader_impl(SOKOL_BACKEND, shd_desc&, Sdtx.Shaders);
    sdtx.shader = sg_make_shader(shd_desc&);
    SG_INVALID_ID: u32 = 0;
    @debug_assert(sdtx.shader.id != SG_INVALID_ID);

    // unpack font data
    unpacked_font_size :: 256 * 8 * 8;
    sdtx.font_pixels = desc.allocator.alloc(u8, max_fonts * unpacked_font_size);
    range(0, max_fonts) { i |
        font_desc := sdtx.desc.fonts&[i];
        out_pixels := sdtx.font_pixels.slice(i * unpacked_font_size, (i + 1) * unpacked_font_size);
        if font_desc.len != 0 {
            unpack_font(font_desc, out_pixels);
        } else {
            out_pixels.set_bytes(0xFF);
        };
    };

    // create font texture and sampler
    img_desc := SgImageDesc.zeroed();
    img_desc.width = 256 * 8;
    img_desc.height = max_fonts * 8;
    img_desc.pixel_format = .R8;
    img_desc.data.subimage&.index(0).index(0)[] = (ptr = u8.raw_from_ptr(sdtx.font_pixels.ptr), size = sdtx.font_pixels.len);
    img_desc.label = "sdtx-font-texture";
    sdtx.font_img = sg_make_image(img_desc&);
    @debug_assert(sdtx.font_img.id != SG_INVALID_ID);

    smp_desc := SgSamplerDesc.zeroed();
    smp_desc.min_filter = .NEAREST;
    smp_desc.mag_filter = .NEAREST;
    smp_desc.wrap_u = .CLAMP_TO_EDGE;
    smp_desc.wrap_v = .CLAMP_TO_EDGE;
    smp_desc.label = "sdtx-font-sampler";
    sdtx.font_smp = sg_make_sampler(smp_desc&);
    @debug_assert(SG_INVALID_ID != sdtx.font_smp.id);

    sg_pop_debug_group();
    
    init_context(sdtx, sdtx.default_context&, sdtx.desc.context&);
}

// If you made multiple contexts, it's your job to destroy them.
fn sdtx_shutdown(sdtx: *Common) void = {
    ::ptr_utils(Common);
    @debug_assert(init_cookie == sdtx.init_cookie);
    if !sdtx.default_context.common.is_null() {
        destroy(sdtx.default_context&);
    };
    sg_push_debug_group("sokol-debugtext");
    sg_destroy_sampler(sdtx.font_smp);
    sg_destroy_image(sdtx.font_img);
    sg_destroy_shader(sdtx.shader);
    sg_pop_debug_group();
    sdtx.init_cookie = 0;
}

/* switch render layer */
// ERRORS: if the command buffer is full (returns false)
fn set_layer(ctx: *Context, layer_id: i32) bool = {
    ctx.cur_layer_id = layer_id;
    first_vertex: i32 = 0;
    if cur_command(ctx) { cur_cmd |
        if cur_cmd.num_vertices == 0 || cur_cmd.layer_id == layer_id {
            // no vertices recorded in current draw command, or layer hasn't changed, can just reuse this
            cur_cmd.layer_id = layer_id;
            return(true);
        };
        // else, layer has changed, need to start a new draw command
        first_vertex = cur_cmd.first_vertex + cur_cmd.num_vertices;
        // fallthrough
    }; 
    // else, first draw command in frame
    
    next_cmd := next_uninit(ctx.commands&) || return(false);
    next_cmd.layer_id = layer_id;
    next_cmd.first_vertex = first_vertex;
    next_cmd.num_vertices = 0;
    true
}

/* (call inside sokol-gfx render pass) */
fn draw_layer(ctx: *Context, layer_id: i32) void = {
    sdtx := ctx.common;
    @debug_assert(init_cookie == sdtx.init_cookie);
    if(ctx.vertices.len <= 0 || ctx.commands.len <= 0, => return());
    sg_push_debug_group("sokol-debugtext");

    if ctx.update_frame_id != ctx.frame_id {
        ctx.update_frame_id = ctx.frame_id;
        range: SgRange = (ptr = Vertex.raw_from_ptr(ctx.vertices.ptr), size = ctx.vertices.len * size_of(Vertex));
        sg_update_buffer(ctx.vbuf, range&);
    };

    sg_apply_pipeline(ctx.pip);
    bindings := SgBindings.zeroed();
    bindings.vertex_buffers&[0] = ctx.vbuf;
    bindings.images&[0] = sdtx.font_img;
    bindings.samplers&[0] = sdtx.font_smp;
    sg_apply_bindings(bindings&);
    each(ctx.commands, fn(cmd) => if cmd.layer_id == layer_id {
        @debug_assert(cmd.num_vertices.mod(6) == 0);
        sg_draw(cmd.first_vertex, cmd.num_vertices, 1);
    });
    sg_pop_debug_group();
}

/* set a new virtual canvas size in screen pixels */
fn canvas(ctx: *Context, w: f32, h: f32) void = {
    @debug_assert(init_cookie == ctx.common.init_cookie);
    @debug_assert(!is_nan(w));
    @debug_assert(!is_nan(h));
    @debug_assert(w > 0.0 && h > 0.0);
    ctx.glyph_size.x = 8.0 / w;
    ctx.glyph_size.y = 8.0 / h;
    ctx.origin.x = 0.0;
    ctx.origin.y = 0.0;
    ctx.pos.x = 0.0;
    ctx.pos.y = 0.0;
}

fn put(ctx: *Context, c: u8) void #inline =
    if(c <= 32, => ctrl_char(ctx, c), => render_char(ctx, c));

// does NOT append newline!
fn put(ctx: *Context, str: CStr) void #inline = 
    for(str, fn(chr) => put(ctx, chr));

fn put(ctx: *Context, str: []u8) void #inline = 
    for(str, fn(chr) => put(ctx, chr));

//////////////////////////////////////////////////////////////////////////////////////////////////////

// unpack linear 8x8 bits-per-pixel font data into 2D byte-per-pixel texture data
unpack_font :: fn(font_desc: []u8, out_pixels: []u8) void #once = {
    @debug_assert(256 * 8 == font_desc.len);
    ptr := font_desc.ptr;
    range(0, 255) { chr |
        range(0, 8) { line |
            bits: i64 = ptr[].zext();
            ptr = ptr.offset(1);
            range(0, 8) { x |
                set := bits.shift_right_logical(7 - x).bit_and(1) == 1;
                out_pixels[line*256*8 + chr*8 + x] = @if(set, 0xFF, 0x00);
            };
        };
    };
};

fn ctrl_char(ctx: *Context, c: u8) void #once = {
    ctx.pos.x = @switch(c) {
        @case("\r".ascii()) => 0.0;
        @case("\n".ascii()) => {
            ctx.pos.y += 1.0;
            0.0
        };
        @case("\t".ascii()) => (ctx.pos.x - fmodf(ctx.pos.x, ctx.tab_width)) + ctx.tab_width;
        @case(" ".ascii())  => ctx.pos.x + 1.0;
        @default            => return();
    };
}

fn next_vertex(ctx: *Context) ?*Vertex #inline = {
    if(ctx.vertices.len + 6 > ctx.vertices.cap, => return(.None));
    ctx.vertices.len += 6;
    (Some = ctx.vertices.index(ctx.vertices.len - 6))
}

fn cur_command(ctx: *Context) ?*Command #inline = {
    if(ctx.commands.len == 0, => return(.None));
    (Some = ctx.commands.index(ctx.commands.len - 1))
}

fn render_char(ctx: *Context, c: u8) void #once = {
    if next_vertex(ctx) { vx | if cur_command(ctx) { cmd |
        // update vertex count in current draw command
        cmd.num_vertices += 6;

        x0 := (ctx.origin.x + ctx.pos.x) * ctx.glyph_size.x;
        y0 := (ctx.origin.y + ctx.pos.y) * ctx.glyph_size.y;
        x1 := x0 + ctx.glyph_size.x;
        y1 := y0 + ctx.glyph_size.y;

        // glyph width and height in font texture space
        // NOTE: the '+1' and '-2' fixes texture bleeding into the neighboring font texture cell
        uvw: u16 = @as(i64) 0x10000 / 0x100;
        uvh: u16 = @as(i64) 0x10000 / max_fonts;
        u0: u16 = (c.zext() * uvw) + 1;
        v0: u16 = (ctx.font.trunc() * uvh) + 1;
        u1 := (u0 + uvw) - 2;
        v1 := (v0 + uvh) - 2;
        c := ctx.color;

        // write 6 vertices
        vx.x=x0; vx.y=y0; vx.u = u0; vx.v = v0; vx.color = c; vx = vx.offset(1);
        vx.x=x1; vx.y=y0; vx.u = u1; vx.v = v0; vx.color = c; vx = vx.offset(1);
        vx.x=x1; vx.y=y1; vx.u = u1; vx.v = v1; vx.color = c; vx = vx.offset(1);

        vx.x=x0; vx.y=y0; vx.u = u0; vx.v = v0; vx.color = c; vx = vx.offset(1);
        vx.x=x1; vx.y=y1; vx.u = u1; vx.v = v1; vx.color = c; vx = vx.offset(1);
        vx.x=x0; vx.y=y1; vx.u = u0; vx.v = v1; vx.color = c; vx = vx.offset(1);
    }};
    ctx.pos.x += 1.0;
}

fn rewind(ctx: *Context) void = {
    // note: this check is not quite as helpful as you'd like because if it got called from the wrong place,
    //       we might not have a valid context setup and will fault trying to panic. 
    @debug_assert_eq(ctx.common.init_cookie, init_cookie, "invalid rewind");
    ctx.frame_id += 1;
    ctx.vertices.len = 0;
    ctx.commands.len = 0;
    set_layer(ctx, 0);
    ctx.font = 0;
    ctx.pos.x = 0.0;
    ctx.pos.y = 0.0;
}

fn make_commit_listener(ctx: *Context) SgCommitListener = {
    ctx.franca_dynamic_context = get_dynamic_context();
    (user_data = Context.raw_from_ptr(ctx), func = fn(userdata: rawptr) void = {
        // called from inside sokol-gfx sg_commit()
        if(userdata.is_null(), => return());
        ctx := Context.ptr_from_raw(userdata);
        set_dynamic_context(ctx.franca_dynamic_context);
        rewind(ctx);
    })
}
