Vec2 :: Vec(f32, 2);
Vec3 :: Vec(f32, 3);
Vec4 :: Vec(f32, 4);

fn vec();

fn Vec($T: Type, $N: i64) Type = {
    Raw  :: Array(T, N);
    Self :: Swizzler(Raw, expand_vector_swizzle);
    
    fn vec(v: []T) Self = {
        @debug_assert_eq(v.len, N);
        ptr_cast_unchecked(T, Self, v.ptr)[]
    }
    
    fn vec(v: Raw) Self     #unsafe_noop_cast;
    fn array(v: Self) Raw   #unsafe_noop_cast;
    fn vec(v: *Raw) *Self   #unsafe_noop_cast;
    fn array(v: *Self) *Raw #unsafe_noop_cast;
    
    fn items(v: *Self) []T =
        (ptr = ptr_cast_unchecked(Self, T, v), len = N);
    
    fn index(v: *Self, i: i64) *T =  // TODO: this should work #redirect(Ty(*Raw, i64), *T); 
        array(v).index(i);
    
    Self
}

expand_vector_swizzle :: fn(e: *SwizzleEvent) CRes(void) = {
    // TODO: draw the rest of the owl
    .Ok
};

fn vec2(x: f32, y: f32) Vec2 = 
    vec(@slice(x, y));

fn vec3(x: f32, y: f32, z: f32) Vec3 = 
    vec(@slice(x, y, z));

fn vec4(x: f32, y: f32, z: f32, w: f32) Vec4 = 
    vec(@slice(x, y, z));
