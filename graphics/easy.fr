// This doesn't do anything interesting but reduces the boilerplate for writting small examples. 
// It's expected that your project may out grow these and you'll have to paste them 
// into your own code and modify as you see fit as soon as you start doing something complicated. 

// TODO: more composable system for linking foreign libraries
// TODO: it's very sad that this driver takes 120ms to compile
build_for_graphics :: fn(vtable: *ImportVTable, input_path: Str) void = {
    start := timestamp();
    opts := vtable.default_build_options();
    opts.retain_function_names = true;
    
    want_jit := false;
    use_a_linker := false;
    for cli_args() { a |
        if a == "-unsafe" {
            s := opts.safety_checks&;
            s.insert(.Bounds, false);
            s.insert(.DebugAssertions, false);
            s.insert(.InvalidTag, false);
        };
        if a == "-keep-names" {
            use_a_linker = true;
        };
        want_jit = want_jit || a == "-jit";
    };
    
    src := @tfmt("""#include_std("lib/core.fr");#include_std("%");""", input_path);
    comp := vtable.new_with_src(src, input_path, opts);
    ctx := vtable.with(comp);
    
    Dyn :: import("@/lib/dynamic_lib.fr");
    
    os: Os = .macos;  // :HardcodeOs
    if os == .macos && query_current_os() == .macos { // && want_jit { // remove this check so you can just put a '::' in main as a demo
        libs :: @const_slice("objc", "CoreGraphics", "Metal", "QuartzCore", "AppKit", "MetalKit", "Cocoa", "CoreFoundation", "CoreVideo", "Foundation");
        
        for libs { name |
            path := import("@/backend/macho/emit.fr")'guess_path(name);
            dyn := Dyn'open(path) || @panic("missing dylib: %", path);
            ctx.add_comptime_library(ctx.intern_string(name), dyn);
        };
    };
    
    if SOKOL_BACKEND == .WGPU {
        // ðŸ¤¡ but it doesn't work yet anyway
        path := "/Users/luke/Downloads/dawn/out/Debug/src/dawn/native/libwebgpu_dawn.dylib"; // TODO
        //path := "/Users/luke/Downloads/wgpu-native/target/debug/libwgpu_native.dylib"; // TODO
        //path := "/Users/luke/Downloads/wgpu-macos-aarch64-debug/lib/libwgpu_native.dylib"; // TODO
        dyn := Dyn'open(path) || @panic("missing dylib: %", path);
        ctx.add_comptime_library(ctx.intern_string("webgpu"), dyn);
    };
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    
    m := QbeModule.zeroed();
    init_default_module_dyn(m&, vtable, (
        arch = query_current_arch(), 
        os = os, 
        type = @if(want_jit, .JitOnly, @if(use_a_linker, .Relocatable, .Exe)),
    )); 
    bytes := emit_qbe_included_dyn(m&, ctx&, @slice(main_f), .WrapMain); 
    
    if want_jit {
        @debug_assert(!use_a_linker);
        ptr := m&.get_addr(ctx.fmt_fn_name(main_f)).unwrap();
        end := timestamp();
        m&.make_exec();
        @eprintln(">>> jitted in %ms", end - start);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
        exit(0);
    };
    
    #use("@/compiler/ast_external.fr", "@/lib/sys/subprocess.fr", "@/lib/sys/fs.fr");
    
    out := open_trunc("a.out").unwrap();
    for(bytes&){bucket|
        out&.write(bucket);
    };
    out.close();
    
    end := timestamp();
    @eprintln(">>> compiled in %ms", end - start);
    
    if use_a_linker {
        SOKOL_MACOS_LINK_ARGS :: @array("-framework", "Metal", "-framework", "MetalKit", "-framework", "Cocoa", "-framework", "QuartzCore");
        a := SOKOL_MACOS_LINK_ARGS;
        args := Str.list(temp());
        args&.push_all(a&.items());
        args&.push_all(@slice ("a.out", "-o", "a.out"));    
        args&.push_all(@slice ("-target", target_triple(m.goal.arch, m.goal.os)));   
        @println("building aot exe: %", args.items());
        success := run_cmd_blocking("clang", args.items());
        assert(success, "clang failed");
    };
    
}

//
// Glue: integration between app.fr and gfx.fr
//

// sokol_glue.h -- glue helper functions for sokol headers
glue_environment :: fn(sapp: *Sapp.Self) SgEnvironment = {
    env := zeroed SgEnvironment;
    env.defaults.color_format = sapp.color_format();
    env.defaults.depth_format = sapp.depth_format(); 
    env.defaults.sample_count = 1;//sapp.sample_count.intcast(); :DEPTH
    @inline_switch(SOKOL_BACKEND) {
        @case(.METAL_MACOS) => {
            env.metal.device = sapp.impl().metal_get_device();
        }
        @case(.WGPU) => {
            env.wgpu.device = sapp.webgpu.device;
        }
        @default => panic("TODO: glue_environment");
    };
    env
}

// sokol_glue.h -- glue helper functions for sokol headers
glue_swapchain :: fn(sapp: *Sapp.Self) SgSwapchain = {
    swapchain := zeroed SgSwapchain;
    swapchain.width = sapp.width().intcast();
    swapchain.height = sapp.height().intcast();
    swapchain.sample_count = 1; // sapp.sample_count.intcast(); :DEPTH
    swapchain.color_format = sapp.color_format();
    swapchain.depth_format = sapp.depth_format(); 
    @inline_switch(SOKOL_BACKEND) {
        @case(.METAL_MACOS) => {
            swapchain.metal = (
                current_drawable = sapp.impl().metal_get_current_drawable(),
                depth_stencil_texture = sapp.impl().metal_get_depth_stencil_texture(),
                msaa_color_texture = sapp.impl().metal_get_msaa_color_texture(),
            );
        }
        @case(.WGPU) => {
            //swapchain.wgpu = (
            //    render_view = ,
            //    resolve_view = ,
            //    depth_stencil_view = ,
            //);
        }
        @default => panic("TODO: glue_swapchain");
    };
    
    swapchain
}

// added this because im lazy. not a high value thing once you start
// doing fancy stuff but it makes simple examples look less confusing. 
glue_begin_pass :: fn(sapp: *Sapp.Self, sg: *Sg.Self, action: SgPassAction) void = {
    desc := SgPass.zeroed();
    desc.action = action;
    desc.swapchain = glue_swapchain(sapp);
    desc.swapchain.width = sapp.width().intcast();
    desc.swapchain.height = sapp.height().intcast();
    sg.begin_pass(desc&);
}

//
// provide overloads for: 
// - on_init(state, sapp, sg)
// - on_event(state, sapp)
// - on_render(state, sapp, sg)
//
start :: fn($UserData: Type) void = {
    State :: @struct {
        app: Sapp.Self;
        sg: Sg.Self;
        user: UserData;
    };
    state := State.zeroed();
    state.app&.run(
        init_cb = easy_init,
        frame_cb = easy_render,
        event_cb = easy_event,
        user_data = State.raw_from_ptr(state&),
        allocator = general_allocator(),
    );
    unreachable();
    
    easy_init :: fn(userdata: rawptr) void = {
        state := State.ptr_from_raw(userdata);
        setup(state.sg&, (
            environment = glue_environment(state.app&),
            allocator = general_allocator(),
        ));
        on_init(state.user&, state.app&, state.sg&);
    };
    
    easy_render :: fn(userdata: rawptr) void = {
        state := State.ptr_from_raw(userdata);
        on_render(state.user&, state.app&, state.sg&);
    };
    
    easy_event :: fn(userdata: rawptr, event: *Sapp.Event) void = {
        state := State.ptr_from_raw(userdata);
        sapp  := state.app&;
        on_event(state.user&, sapp, event);
    
        @if(!has_const_field(UserData, @symbol NO_EXIT_ON_CMD_W))
        if event.type == .KEY_DOWN && event.key_code == .W && event.modifiers.get(.super) != 0 {
            sapp.quit_requested = true;
        }
    };
}
1747090940066