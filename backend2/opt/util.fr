// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>

fn BIT(n: i64) u64 #inline = 1.shift_left(n);
fn SLOT(i: i64) Qbe.Ref #inline = ref(.RSlot, i.bit_and(0x1fffffff));
fn TMP(i: i64)  Qbe.Ref #inline = ref(.RTmp, i);
fn CALL(i: i64) Qbe.Ref #inline = ref(.RCall, i);

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bshas(bs: *Qbe.BSet, elt: i64) bool #inline = {
    @debug_assert(elt < bs.nt.zext() * Qbe.NBit, "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    mask := BIT(elt.mod(Qbe.NBit));
    slot[].bit_and(mask) != 0
}

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bsset(bs: *Qbe.BSet, elt: i64) void #inline = {
    @debug_assert(elt < bsmax(bs), "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    slot[] = slot[].bit_or(BIT(elt.mod(Qbe.NBit)));
}

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bsmax(bs: *Qbe.BSet) i64 #inline =
    bs.nt.zext() * Qbe.NBit;
