// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>

fn BIT(n: i64) u64 #inline = 1.shift_left(n);
fn SLOT(i: i64) Qbe.Ref #inline = ref(.RSlot, i.bit_and(0x1fffffff));
fn TMP(i: i64)  Qbe.Ref #inline = ref(.RTmp, i);
fn CALL(i: i64) Qbe.Ref #inline = ref(.RCall, i);

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bshas(bs: *Qbe.BSet, elt: i64) bool #inline = {
    @debug_assert(elt < bs.nt.zext() * Qbe.NBit, "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    mask := BIT(elt.mod(Qbe.NBit));
    slot[].bit_and(mask) != 0
}

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bsset(bs: *Qbe.BSet, elt: i64) void #inline = {
    @debug_assert(elt < bsmax(bs), "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    slot[] = slot[].bit_or(BIT(elt.mod(Qbe.NBit)));
}

// note: for now the c code still calls its own version of this so you can't change the layout of the bitset!
fn bsmax(bs: *Qbe.BSet) i64 #inline =
    bs.nt.zext() * Qbe.NBit;

// TODO: what are we doing
fn phicls(t: i64, tmp: InsaneVec(Qbe.Tmp)) i64 = {
    t1 := tmp[t].phi.zext();
    if(t1 == 0, => return(t));
    t1 = phicls(t1, tmp);
    tmp[t].phi = t1.intcast();
    t1
}

// note: typecheck still calls the c version of this
fn clsmerge(pk: *Qbe.Cls, k: Qbe.Cls) bool = {
    k1 := pk[];
    if k1 == .Kx {
        pk[] = k;
        return(false);
    };
    xx := (k1 == .Kw && k == .Kl); // TODO: compiler bug. fix overloading when you inline this. 
    if xx || (k1 == .Kl && k == .Kw) {
        pk[] = .Kw;
        return(false);
    };
    k1 != k
}
