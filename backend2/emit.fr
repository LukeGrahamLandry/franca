QbeModule :: @struct(
    segments: EnumMap(SegmentType, SegmentCursor),
    // TODO: i think the high bits of qbe ids are sequential. 
    //       make this a bucket array. they have to live forever anyway because we never know
    //       when we'll get new code that references an old symbol. 
    symbols: HashMap(u32, SymbolInfo), 
    gpa: Alloc,
);

SegmentCursor :: @struct(
    mmapped: []u8,
    next: *u8,
);

SegmentType :: @enum(i64) (
    Code,
    MutableData,
    ConstantData,
);

SymbolInfo :: @tagged(
    Known: @struct(segment: SegmentType, offset: i64),
    PendingRelocations: RsVec(Relocation),
);

// for now patch_at is always adrp+adr. TODO: im immediately going to need data patches too.
Relocation :: @struct(
    patch_at: []u8,
    increment := 0,
);

fn init(segment_size: i64, gpa: Alloc, code_alloc: Alloc) QbeModule = {
    s := EnumMap(SegmentType, SegmentCursor).zeroed();
    mem := code_alloc.alloc(u8, segment_size * 3); // TODO: ask for the alignment we need.
    s&.insert(.Code, (mmapped = mem.slice(0, segment_size), next = mem.index(0)));
    s&.insert(.MutableData, (mmapped = mem.slice(segment_size, segment_size*2), next = mem.index(segment_size)));
    s&.insert(.ConstantData, (mmapped = mem.slice(segment_size*2, segment_size*3), next = mem.index(segment_size*2)));
    (segments = s, symbols = init(gpa), gpa = gpa)
}

fn make_exec(self: *QbeModule) void = {
    panic("TODO: make exec");
}

fn get_addr(self: *QbeModule, name: Str) ?rawptr = {
    name := name.maybe_borrow_cstr(temp());
    id := intern(name);
    if self.symbols&.get_ptr(id) { s | 
        @match(s) {
            fn Known(s) => {
                segment := self.segments&[s.segment];
                addr := segment.mmapped.ptr.offset(s.offset);
                return(Some = u8.raw_from_ptr(addr));
            }
            fn PendingRelocations() => ();
        };
    };
    .None
}
