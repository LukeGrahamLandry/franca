QbeModule :: @struct(
    segments: EnumMap(SegmentType, SegmentCursor),
    // TODO: i think the high bits of qbe ids are sequential. 
    //       make this a bucket array. they have to live forever anyway because we never know
    //       when we'll get new code that references an old symbol. 
    symbols: HashMap(u32, SymbolInfo), 
    gpa: Alloc,
    start_of_writable_code: *u8,
    globals: *Qbe.Globals,
);

SegmentCursor :: @struct(
    mmapped: []u8,
    next: *u8,
);

SegmentType :: @enum(i64) (
    Code,
    MutableData,
    ConstantData,
);

SymbolInfo :: @tagged(
    // We haven't compiled this yet so we've emitted references as lookups into a table in the data section. 
    Pending: @struct(fixups: RsVec(Relocation), jit_lookup_offset: i64),  // :SameFieldOffset
    // We've already compiled this and we know its close to the code and addressable by a static offset. 
    Local:   @struct(segment: SegmentType, offset: i64),
    // This is a dynamic import. 
    // - For jit, references still go through the table because that means we didn't have to make the code memory writeable again if it already started executing. 
    // - For aot, you may want to go through the fixups again and translate them to use a GOT section. 
    //   That way you don't make the loader waste time patching two tables. 
    Dynamic: @struct(fixups: RsVec(Relocation), jit_lookup_offset: i64, aot_lookup_offset: i64),  // :SameFieldOffset
);

RelocationType :: @tagged(
    InReg: @struct(r: i64, increment: i64),
    Call,
);

Relocation :: @struct(
    patch_at: *u8,
    type: RelocationType,
);

fn init(segment_size: i64, gpa: Alloc, code_alloc: Alloc, globals: *Qbe.Globals) QbeModule = {
    s := EnumMap(SegmentType, SegmentCursor).zeroed();
    mem := code_alloc.alloc(u8, segment_size * 3); // TODO: ask for the alignment we need.
    s&.insert(.Code, (mmapped = mem.slice(0, segment_size), next = mem.index(0)));
    s&.insert(.MutableData, (mmapped = mem.slice(segment_size, segment_size*2), next = mem.index(segment_size)));
    s&.insert(.ConstantData, (mmapped = mem.slice(segment_size*2, segment_size*3), next = mem.index(segment_size*2)));
    (segments = s, symbols = init(gpa), gpa = gpa, start_of_writable_code = mem.ptr, globals = globals)
}

fn make_exec(self: *QbeModule) void = {
    prot := bit_or(@as(i64) MapProt.Exec, @as(i64) MapProt.Read);
    end := self.segments&[.Code].next&;
    len := self.start_of_writable_code.ptr_diff(end[]);
    res := mprotect(u8.raw_from_ptr(self.start_of_writable_code), len, prot); 
    assert(res.value.eq(0), "mprotect failed");
    clear_instruction_cache(u8.raw_from_ptr(self.start_of_writable_code), u8.raw_from_ptr(end[]));
        
    PAGE_SIZE :: 16384; // TODO: ask the os for this. we're wasting hella memory on linux. 
    page_start := u8.int_from_ptr(end[]) / PAGE_SIZE * PAGE_SIZE;
    end[] = u8.ptr_from_int(page_start + PAGE_SIZE);
    self.start_of_writable_code = end[];
}

fn get_addr(self: *QbeModule, name: Str) ?rawptr = {
    name := name.maybe_borrow_cstr(temp());
    self.get_addr(name)
}

fn get_addr(self: *QbeModule, name: CStr) ?rawptr = {
    id := intern(name);
    if self.symbols&.get_ptr(id) { s | 
        @match(s) {
            fn Local(s) => {
                segment := self.segments&[s.segment];
                addr := segment.mmapped.ptr.offset(s.offset);
                return(Some = u8.raw_from_ptr(addr));
            }
            @default => ();
        };
    };
    .None
}

// TODO: be able to specify mutable or constant
fn new_emit_data(self: *QbeModule, dat: *Qbe.Dat) void = {
    ::enum(@type dat.type);
    segment := self.segments&[.MutableData]&;
    next := segment.next&;
    @match(dat.type) {
        fn DStart() => {
            extra := u8.int_from_ptr(next[]).mod(8);
            if extra != 0 {
                next[] = next[].offset(8 - extra); // align to 8 bytes.
            };
            id := intern(dat.name);
            self.do_jit_relocations(id, .MutableData, segment.mmapped.ptr.ptr_diff(next[]));
        }
        fn DEnd() => ();
        fn DZ() => {
            range(0, dat.u.num) { _ |
                next[][] = 0;
                next[] = next[].offset(1);
            };
        }
        fn DB() => {
            @debug_assert(!dat.isref, "can't have a byte sized pointer");
            next[][] = dat.u.num.trunc();
            next[] = next[].offset(1);
        }
        fn DL() => {
            @assert_eq(u8.int_from_ptr(next[]).mod(8), 0, "sorry can't do unaligned constants yet");
            ptr := ptr_cast_unchecked(u8, i64, next[]);
            if dat.isref {
                @assert(dat.u.ref.off == 0, "sorry can't do offset refs yet");
                name := dat.u.ref.name;
                value := or self.get_addr(name) {
                    panic("TODO: data relocations")
                };
                ptr[] = int_from_rawptr(value); // TODO: we have to record that we did this somewhere for aot.
            } else {
                ptr[] = dat.u.num;
            };
            next[] = next[].offset(8);
        }
        fn DW() => @panic("sorry DW constants are not supported yet");
        fn DH() => @panic("sorry DH constants are not supported yet");
    }
}

// TODO: have this emit to text too so you don't have to do both
fn add_code_bytes(self: *QbeModule, name: CStr, bytes: []u8) void = {
    name_id := intern(name);
    code := self.segments&[.Code]&;
    code.align_to(4);
    start_offset := ptr_diff(code.mmapped.ptr, code.next);
    self.do_jit_relocations(name_id, .Code, start_offset);
    dest := slice(code.next, bytes.len);
    dest.copy_from(bytes);
    code.next = code.next.offset(bytes.len);
}

fn align_to(s: *SegmentCursor, align: i64) void = {
    extra := u8.int_from_ptr(s.next).mod(align);
    if extra != 0 {
        s.next = s.next.offset(align - extra); 
    };
}

fn put_jit_addr(self: *QbeModule, name: CStr, addr: rawptr) void = {
    // TODO: insert if not already there. 
    if self.symbols&.get_ptr(intern(name)) { it | 
        if it.is(.Dynamic) || it.is(.Pending) {
            self.put_jit_addr_in_table(it.Dynamic.jit_lookup_offset, u8.ptr_from_raw(addr));
            // TODO: if pending make it dynamic. 
            // TODO: error if local
        };
    };
}

// :SLOW insanely inefficient way of doing this. especially when someone tries to add multiple libs. 
// TODO: keep track of which need to be filled
fn fill_pending_dynamic_imports(self: *QbeModule, lib: DlHandle) void = {
    each self.symbols& { id, it | 
        if it.is(.Dynamic) || it.is(.Pending) {
            name := str(id);
            found := lib.dlsym(name);
            if !found.is_null() {
                // :SameFieldOffset
                self.put_jit_addr_in_table(it.Dynamic.jit_lookup_offset, u8.ptr_from_raw(found));
            } else {
                // TODO: remove this and report at the end.
                @eprintln("jit missing symbol %", name); // wrong once they add multiple dylibs
            }
        };
    };
}

fn fill_from_libc(self: *QbeModule) void = {
    if find_os_libc_dylib() { libc_path | 
        libc := dlopen(libc_path, .Lazy);
        if !libc.lib.is_null() { 
            self.fill_pending_dynamic_imports(libc);
        };
    };
}
