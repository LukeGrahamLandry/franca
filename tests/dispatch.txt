fn main(canary: i64) i64 = {

const Add = Unique((lhs: i64, rhs: i64)!struct);
fn eval(self: Ptr(Add)) i64 = add(self.lhs[], self.rhs[]);

const Mul = Unique((lhs: i64, rhs: i64)!struct);
fn eval(self: Ptr(Mul)) i64 = mul(self.lhs[], self.rhs[]);

const Eval = (vtable: FnPtr(VoidPtr, i64), dataptr: VoidPtr)!struct;
fn eval(self: Eval) i64 = (self.vtable[])(self.dataptr[]);

@comptime fn upcast(T: Type) Fn(Ptr(T), Eval) = {
    const T = T;  // TODO: fix constants. without this, the inner func always captures the first value of T? 
    (fn(self: Ptr(T)) Eval = {
        const eval: Fn(Ptr(T), i64) = eval;  // Somewhere to hang the type annotation to resolve the overload.
        (vtable: eval!fn_ptr, dataptr: self)
    })
}

const dyn_add = upcast(Add);
const dyn_mul = upcast(Mul);

var six: Add = (lhs: 2, rhs: 4);
var eight: Mul = (lhs: 2, rhs: 4);

// Static dispatch. 
assert_eq(6, eval(six!addr));
assert_eq(8, eval(eight!addr));

// Dynamic dispatch. 
var unknown: Eval = dyn_add(six!addr);
assert_eq(6, eval(unknown));

unknown = dyn_mul(eight!addr);  // Same variable, same type.
assert_eq(8, eval(unknown));  // But now we call the other method. 

// Can even do crimes by swapping the vtable. This works because we know the values have compatible layout. 
var do_add = dyn_add(six!addr);
var do_mul = dyn_mul(eight!addr);
assert_eq(8, eval(unknown));
unknown.vtable[] = do_add.vtable[]; 
assert_eq(6, eval(unknown));
unknown.vtable[] = do_mul.vtable[]; 
assert_eq(8, eval(unknown));

// dyn_mul(six!addr); // TODO: this needs to be a type error. but i mostly have structural type checking. unique is a bit fishy. 

canary
}
