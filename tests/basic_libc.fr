#test fn allocation() = {
    an_int: rawptr = malloc(size_of(i64));
    an_int := ptr_from_raw(i64, an_int);
    an_int[] = 314159;
    assert_eq(an_int[], 314159);
    free(i64.raw_from_ptr(an_int));
    
    fn slice_sum_test(arr: Slice(i64)) i64 = {
        enumerate(arr, fn(i, ptr) => {
            ptr[] = i;
        });
        sum := 0;
        for arr { (v: i64) |
            sum = sum.add(v);
        };
        sum
    }
    
    size_10 :: size_of(i64).mul(10);
    many: rawptr = malloc(size_10);
    many := ptr_from_raw(i64, many);
    arr: Slice(i64) = slice(many, 10);
    assert_eq(45, arr.slice_sum_test());
    free(i64.raw_from_ptr(many));
    
    // TODO: redo this test now that it correctly uses u8 not i64
    // This just calls mmap
    // arr2 := os_alloc(size_10);
    // assert_eq(45, arr2.slice_sum_test());
}

#test fn open_dynamic_library() = {
    libc_path := find_os_libc_dylib().expect("to know where to find libc for the target env");
    libc := dlopen(libc_path, DlFlag.Lazy);
    
    // TOOD: wrap and return option
    // TODO: need to ask the compiler if we're expecting to have statically linked libc (like blink requires) so this test can't work. 
    if(libc.lib.is_null().not()) {
        s := @symbol("strlen").c_str();
        strlen := dlsym(libc, s);
        assert_eq(true, strlen.int_from_rawptr().ne(0)); // TOOD: wrap and return option
        strlen := assume_types_fn(CStr, i64, strlen); // TOOD: wrap with generic
        assert_eq(6, strlen(s));
        assert_eq(libc_path.str().len(), strlen(libc_path));
    };
}

#test fn c_strings(canary: i64) i64 = {
    ::ptr_utils(u8);
    
    a := "Hello World";
    b := @symbol("Hello World").c_str();
    
    range(0, a.len()) {(i) void|
        a_char := a.get(i);
        b_char := b.get(i);
        c := a_char.eq(b_char);
        assert(c, "fail");
    };
    
    i := 0;
    for(b) {b_char|
        a_char := a.get(i);
        c := a_char.eq(b_char);
        assert(c, "fail");
        i = i.add(1);
    };
    
    ::assert_eq(Str);
    assert_eq(a, b.str());
    
    canary
}

// This is also an important test of #link_rename on macos-x64
#test fn walk_dir() = {
    found := false;
    walk_directory(".".maybe_borrow_cstr(libc_allocator)) {entry|
        if(entry.name.eq("run_tests.fr")){
            found = true;
        };
    };
    assert(found, "didn't find run_tests.fr in cwd");
}

// TODO: port struct layout and magic numbers for linux
// This is similar to what we'd do to print a nice message when you overflow the call-stack. 
//
// mmap a page, remember the address, and then try to access it. 
// we know that will cause a segmentation fault that will be caught by the signal handler. 
// then re-mmap that same page by passing the saved address as a hint. 
// so then when we resume after the signal, the operation will succeed 
fn catch_signal() void #test = {
    the_address :: @static(rawptr);
    handled_a_signal :: @static(bool) false;
    handle_it :: fn(s: i64, info: *SigInfo, idk: rawptr) void = {
        @assert_eq(info.addr.int_from_rawptr(), the_address[].int_from_rawptr(), "faulted on wrong address");
        the_address[] = call_mmap(the_address[]);
        handled_a_signal[] = true;
    };
    old := SigAction.zeroed();
    new: SigAction = (sigaction = handle_it, mask = 0, flags = @as(i32) SignalFlag.Info);
    
    sigaction(SignalNum.Segfault, new&, old&);
    
    the_address[] = call_mmap(0.rawptr_from_int());
    munmap(the_address[], SIZE);
    
    value :: 123456789;
    ptr := i64.ptr_from_raw(the_address[]);
    ptr[] = value;
    assert_eq(ptr[], value);
    assert(handled_a_signal[], "did you not unmap the memory my guy?");
    
    sigaction(SignalNum.Segfault, old&, SigAction.ptr_from_int(0));
    
    SIZE :: 1;
    call_mmap :: fn(hint: rawptr) rawptr = {
        prot := bit_or(@as(i64) MapProt.Write, @as(i64) MapProt.Read);
        n1   := 1.neg();
        mmap_anon(hint, SIZE, prot, 0)
    };
}

fn call_fork() #test = {
    inner :: fn() void = {
        println("A");
    };
    ok, out, err := fork_and_catch(temp(), => inner());
    assert_eq(ok, true);
    assert_eq(out.items(), "A\n");
}
