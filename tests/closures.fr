#test(aarch64, llvm)
fn main(_canary: i64) i64 = {
 
// Branches of a call to if can access variables from the outer scope. 
var a = 10;
(true, fn() Unit = { a = 1; }, fn() Unit = { a = 2; })!if;
assert_eq(a, 1);

var b = 1;
capturing :: fn(n: i64) Unit = {
    b = n;
};
assert_eq(b, 1);
capturing(15);
assert_eq(b, 15);

// Shadowed vars are still local. 
var c = 1;
not_capturing :: fn(n: i64) Unit = {
    var c = n;
};
assert_eq(c, 1);
not_capturing(15);
assert_eq(c, 1);

var c = 7;
capturing_with_const :: fn(n: i64) Unit = {
    const a = 1;
    c = add(n, a);
};
assert_eq(c, 7);
capturing_with_const(18);
assert_eq(c, 19);

// This function takes a function as an argument, pretty meta bro...
fn call_it(n: i64, const f: Fn(i64, i64)) i64 = add(f(n), 1);

// TODO: it doesn't work if you try to pass a function by name. 
const temp = fn(m: i64) i64 = mul(2, m);
assert_eq(9, call_it(4, temp));

// You can pass a capturing closure as an argument
var a = 77;
assert_eq(3, call_it(0, fn(m: i64) i64 = {
    a = 88;
    add(2, m)
}));
assert_eq(a, 88);

var a = 99999;
const set_0 = fn() Unit = { a = 0 };
const set_1 = fn() Unit = { a = 1 };
let c = true;
(c, set_1, set_0)!if;
assert_eq(a, 1);

// TODO: args infer through capturing closure reference. 
// a = 99999;
// if(c, set_1, set_0);
// a ssert_eq(a, 1);

// Nested capture
var a = 123;
l1 :: fn() Unit = {
    l2 :: fn() Unit = {
        a = 7;
    };
    l2();
};
l1();
assert_eq(a, 7);
fn call_arg(const arg: Fn(Unit, Unit)) Unit = {
    arg();
}
// TODO: make this work if its a normal function. needs to not pass the overload set. 
const set6 = fn() Unit = {
    a = 6;
};
call_arg(set6);
assert_eq(a, 6);

//////
/// argument order of evaluation is defined

var shared = 0;
get_and_inc :: fn() i64 = {
    shared = shared.add(1);
    shared
};

fn one_two_three(a: i64, b: i64, c: i64) Unit = {
    assert_eq(a, 1);
    assert_eq(b, 2);
    assert_eq(c, 3);
}

one_two_three(get_and_inc(), get_and_inc(), get_and_inc());

var n = 10; 
add_n :: fn(a: i64) i64 = {
    N :: 5;  // inner constant
    a.add(n).add(N)
};
assert_eq(30, add_n(15));
assert_eq(20, add_n(5));

_canary
}
