#test_broken
fn single_element_struct(canary: i64) i64 = {
    MyStruct :: @struct(field: i64);
    
    value : MyStruct = (field: 123);
    v := value&.field[];
    assert_eq(v, 123);
    
    canary
}

#test_broken 
fn memcpy_wide_values(canary: i64) i64 = {
    // Found with collections.fr:split, narrowed down to resizing a list. then to memcpy when something is larger than one slot. then to calling set. 
    // Worked when my_set is #inline but segfault if not. So its a spilling problem. 
    fn memcpy_wide_values() Unit = {
        T :: Str;
        S :: Slice(T);
        
        #noinline
        fun my_set(var self: S, i: i64, v: T) Unit = {
            self.index(i)[] = v; 
        }
        
        #noinline
        fn my_memcpy(dest: S, src: S) Unit = {
            var i = 0;
            while(fn = lt(i, src.len())) {|
                src_ptr := src.index(i);
                dest.my_set(i, src_ptr[]);
                i = i.add(1);
            };
        }
    
        var a: S = ("a", "a")!slice;
        var b: S = ("b", "b")!slice;
        my_memcpy(a, b);
    }
    
    memcpy_wide_values();
    
    canary
}


#test_broken 
fn aliasing_var_init(canary: i64) i64 = {
    a := {
        a = 123;
        456
    };
    assert_eq(a, 456);
    
    canary
}

#test fn mutual_rec_flat() = {
    fn do_1s(n: i64) Str = if(n.eq(2), fn = do_2s(n), fn = "one");
    fn do_2s(n: i64) Str = if(n.eq(1), fn = do_1s(n), fn = "two");
     
    do_1s(1);
}
