#test_broken
fn single_element_struct(canary: i64) i64 = {
    MyStruct :: @struct(field: i64);
    
    value : MyStruct = (field = 123);
    v := value&.field[];
    assert_eq(v, 123);
    
    canary
}

#test_broken 
fn aliasing_var_init(canary: i64) i64 = {
    a := {
        a = 123;
        456
    };
    assert_eq(a, 456);
    
    canary
}

#test_broken 
fn const_typeof_var() = {
    a := 123;
    T :: @type(a);
    A :: @struct(b: Ptr(T));
    c : A = (b: a&);
    assert_eq(a, c&.b[][]);
}

#test_broken 
fn const_typeof_var_block() = {
    a := 123;
    A :: @struct(b: {
        // Here we need to be able to access two different body contexts: 
        // the runtime one that knows the type of 'a' and the comptime one we're declaring 'T' into. 
        T := @type(a);
        Ptr(T)
    });
    c : A = (b: a&);
    assert_eq(a, c&.b[][]);
}

// - discovered when writing codemap :fall_through_never
#test_broken
fn fall_through_never() = {
    want_zero :: fn(i: i64) Str = {
        ret :: @return;
        if(i.eq(0)) {|
            ret("zero");
        };
        panic("expected zero")
    };
    
    :: assert_eq(Str);
    assert_eq("zero", want_zero(0));
}
