#test_broken
fn single_element_struct(canary: i64) i64 = {
    MyStruct :: @struct(field: i64);
    
    value : MyStruct = (field = 123);
    v := value&.field[];
    assert_eq(v, 123);
    
    canary
}

#test_broken 
fn aliasing_var_init(canary: i64) i64 = {
    a := {
        a = 123;
        456
    };
    assert_eq(a, 456);
    
    canary
}

#test_broken 
fn const_typeof_var() = {
    a := 123;
    T :: @type(a);
    A :: @struct(b: Ptr(T));
    c : A = (b: a&);
    assert_eq(a, c&.b[][]);
}

#test_broken 
fn const_typeof_var_block() = {
    a := 123;
    A :: @struct(b: {
        // Here we need to be able to access two different body contexts: 
        // the runtime one that knows the type of 'a' and the comptime one we're declaring 'T' into. 
        T := @type(a);
        Ptr(T)
    });
    c : A = (b: a&);
    assert_eq(a, c&.b[][]);
}

// - discovered when writing codemap :fall_through_never
#test_broken
fn fall_through_never() = {
    want_zero :: fn(i: i64) Str = {
        ret :: @return;
        if(i.eq(0)) {|
            ret("zero");
        };
        panic("expected zero")
    };
    
    :: assert_eq(Str);
    assert_eq("zero", want_zero(0));
}

// - discovered when writing codemap :return_u32_pair
//   the var version works, but returning the struct directly doesn't. 
// - probably caused by trying to return pairs in registers (because it works if you #inline it), 
//   but idk why it would be different with the var.  
#test_broken
fn return_u32_pair() = {
    II :: @struct(a: u32, b: u32);
    
    through_var :: fn() II #noinline = {
        v: II = (a = @as(u32) 123, b = @as(u32) 456);
        v
    };
    direct :: fn() II #noinline = {
        (a = @as(u32) 123, b = @as(u32) 456)
    };
    
    ::assert_eq(u32);
    v := through_var();
    assert_eq(v.a, @as(u32) 123); assert_eq(v.b, @as(u32) 456);
    v := direct();
    assert_eq(v.a, @as(u32) 123); assert_eq(v.b, @as(u32) 456);
}
