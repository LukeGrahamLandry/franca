fn basic_where_generics() void #test = {
    {
        #where(fn(T) = T == []i64 || T == Str)
        fn length(self: ~T) i64 = {
            self.len
        }
        
        fn length(self: i64) i64 = self;
        
        assert_eq(123.length(), 123);
        
        foo := @slice(123, 456, 789);
        bar := "abc";
        assert_eq(foo.length(), bar.length());  
    };
    {
        #where  /* default with no argument is `=> true` so it just takes any types */
        fn push_it(items: *List(T), e: ~T) void = {
            items.push(e);
        }
        
        #where
        fn push_it(items: *RsVec(T), e: ~T) void = {
            items.push(e, temp());
        }
        
        a := i64.list(temp());
        push_it(a&, 123);
    };
    {
        Apple :: @struct(A: i64);
        Banana :: @struct(B: i64);
        Ardvark :: @struct(make_the_offset_be_different := 0, A: i64);
        Aberdeen :: @struct(A: i64, B: i64);
        
        #where(fn(T) = is_ptr(T) && has_field(Deref(T), @symbol A))
        fn inc_my_field(it: ~T, x: i64) void = {
            it.A += x;
        }
        
        #where(fn(T) = is_ptr(T) && has_field(Deref(T), @symbol B))
        fn inc_my_field(it: ~T, x: i64) void = {
            it.B *= x;
        }
        
        a: Apple = (A = 1);
        inc_my_field(a&, 2);
        assert_eq(a.A, 3);
        a: Banana = (B = 1);
        inc_my_field(a&, 2);
        assert_eq(a.B, 2);
        a: Ardvark = (A = 7);
        inc_my_field(a&, 2);
        assert_eq(a.A, 9);
        
        a: Aberdeen = (A = 0, B = 1);
        @assert_compile_error {  // conflicting overloads
            inc_my_field(a&, 2);
        };
    };
}
