// TODO: im doing overloads dumbly so now calling init means filtering through every struct type ever made even when you already know what type you're looking for. 

@test(aarch64)
fn main(_canary: i64) i64 = {

@struct fn Person(age: i64, gender: i64);
// The above is a macro that expands to: 
// const Person = (age: i64, gender: i64)!struct;
// fn init(age: i64, gender: i64) Person = (age: age, gender: gender)!construct;
// Note, this is not a ~constructor~, its just a function that happens to construct a value of the new type. 
// There's nothing actually special about the init function, its just a convention that seems nice. 
// I think constructors in java/c++ are a bit weird because you have access to a 'this' pointer before you've actually produced a value in a valid state. 
// Instead, here you are forced the figure out all the fields you want and put them in place all at once. 
// TODO: currently (a: b) === (a: b)!construct and there's nothing forcing someone to actually call your nice factory function (private fields, etc.). 

assert_eq(Person!type, Type);

// Create a struct by calling the initializer. 
// We need to specify the type so it can resolve the overload even if there are multiple with the same field names and types. (If they're unique, it can infer).
var bob: Person = init(age: 24, gender: 42);
assert_eq(bob!type, Person);

// dot syntax for computing field offsets. 
// Note: it returns a ptr to the field, not the value of the field. 
let age_ptr: Ptr(i64) = bob&.age; 
assert_eq(24, bob&.age[]);
assert_eq(42, bob&.gender[]);
let next_year = add(bob&.age[], 1);
bob&.age[] = next_year;
assert_eq(bob&.age[], 25);
assert_eq(bob&.gender[], 42);

// Composition
@struct fn Animal(owner: Person, whiskers: bool);
assert_eq(Animal!type, Type);

var cat: Animal = init(
    owner: bob,  // This is a copy of bob.
    whiskers: true,
);
assert_eq(cat&.whiskers[], true);
var bob_again: Ptr(Person) = cat&.owner;
assert_eq(bob_again.age[], 25);
assert_eq(cat&.owner.gender[], 42);  // Auto deref for chained place expressions. 

// Structs are value types. 
bob_again.age[] = 99;
assert_eq(bob_again.age[], 99);
assert_eq(bob&.age[], 25);  // The original has not been mutated. 

// `!deref` or `[]` can load a whole struct from a pointer at once. 
// TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
var bob_part_three: Person = cat&.owner[];  // This is a copy
bob_part_three&.age[] = 5;
assert_eq(bob_part_three&.age[], 5);
assert_eq(cat&.owner.age[], 99);

// Structs can contain pointers. 
@struct fn House(
    tax_payer: Ptr(Person),
    pet: Ptr(Animal),
);
assert_eq(Animal!type, Type);

// Note: this example aliases bob_again. Good luck compiling to rust :)
var tent: House = init(
    tax_payer: cat&.owner,
    pet: cat!addr
);
assert_eq(tent!type, House);
assert_eq(tent&.pet[].owner.age[], 99);
tent&.pet[].owner.age[] = 55;  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
assert_eq(tent&.pet[].owner.age[], 55);
assert_eq(tent&.tax_payer[].age[], 55);
assert_eq(bob_again.age[], 55);
assert_eq(bob&.age[], 25);  // OG bob is still just chillin

var mouse: Animal = init(
    owner: init(
        age: 17,
        gender: 314,
    ),
    whiskers: true,
);
// struct 'var's can be reassigned
// No type annotation needed because it remembers. 
tent = init(
    tax_payer: bob!addr,
    pet: mouse!addr,
);

{ tent = mouse; }!assert_compile_error;  // type check

// Field names are type checked. 
let a = 1;
a.hello!assert_compile_error;  
tent.hello!assert_compile_error;  

// TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
// TODO: Struct declarations are always const.
// { let Thing: Type = (legs: i64)!struct; }!assert_compile_error;

// TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
// A raw map literal is illegal if the compiler can't infer a type. 
{   let Thing = (legs: i64);   }!assert_compile_error;

// Structs are passed by copy (or probably const pointer if you don't mutate)
fn mutate_copy(var who: Person) Unit = {
    who&.age[] = 11;
}
assert_eq(bob&.age[], 25);
mutate_copy(bob);
assert_eq(bob&.age[], 25);

// Pass a pointer if you want to mutate the original. 
// TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
fn mutate_real(who: Ptr(Person)) Unit = {
    who.age[] = 11;
}
assert_eq(bob&.age[], 25);
mutate_real(bob!addr);
assert_eq(bob&.age[], 11);

// TODO: no field mutation through a 'let'

// no implicitly created references. this isnt c++. 
mutate_real(bob)!assert_compile_error;

// Return a struct
fn make_someone(years: i64) Person = init(
     age: years,
     gender: 192741892,
);
var bill = make_someone(17);
assert_eq(bill&.age[], 17);


// TODO: move this to generics test and do a normal version here. 
@comptime
fn Option2(const T: Type) Type = {
    Self :: @enum(Some: T, None: Unit);
    
    fun init(Some: T) Self = (Some: Some); 
    fun init(None: Unit) Self = (None: None); 
    Self
    
    /* // TODO: old version should work too. broken with scan ahead consts. something with renumbering the generated functions wrong? -- Apr 22
    @enum fn Option2(Some: T, None: Unit);
    Option2
    */
}

const Maybe_i64 = Option2(i64);

var yes: Maybe_i64 = init(Some: 12);
var no: Maybe_i64 = init(None: unit);

assert_eq(yes!type, no!type);  // same type even with different payloads

// You can manually check the tag if you try hard enough. (eventually I want macros for nice matching)
// It's illegal to access a non-active field. 
assert_eq(yes&!tag[], tag_value(Maybe_i64, Some!symbol));
assert_eq(no&!tag[], tag_value(Maybe_i64, None!symbol));

// Like structs, dot syntax is a place expression. 
// It's illegal to access a non-active field. // TODO: be able to !assert_runtime_error
assert_eq(yes&.Some[], 12);  
assert_eq(no&.None[], unit);

var things = (1, 2, 3);
things&[2][] = 4;
assert_eq(things&[0][], 1);
assert_eq(things&[1][], 2);
assert_eq(things&[2][], 4);

///////////////

AA :: @enum(a: i64, b: i64); // TODO: crazy error when this is called A too so it shadows. 

let n = 3;
var a: AA = (a: n);
let out = add(a&.a[], 7);
assert_eq(out, 10);

//////
/// Tricky result slot aliasing

@struct fn A(a: i64, b: i64);

var s: A = (a: 1, b: 2);
assert_eq(s&.a[], 1);
// This initilization happens in place... 
s = (a: s&.b[], b: s&.a[]);
assert_eq(s&.a[], 2);
// BUG. Oh shit, you done did aliased! This is kinda a massive problem. 
assert_eq(s&.b[], 2); // You'd expect this to be 1. It would be great if you break this test somehow. 

var s: A = init(a: 1, b: 2);
assert_eq(s&.a[], 1); assert_eq(s&.b[], 2);
// The argument to the function call are evaluated up front so this behaves as expected. 
s = init(a: s&.b[], b: s&.a[]);
assert_eq(s&.a[], 2); assert_eq(s&.b[], 1);

var s: A = init(a: 1, b: 2);
s = {
    let a = 5;
    let b = s&.a[].add(s&.b[]);
    (a: a, b: b)
};
// 'b' would be 7 if it forwarded to the final output location.   
assert_eq(s&.a[], 5); assert_eq(s&.b[], 3);

var s: A = init(a: 1, b: 2);
s = {
    (a: 5, b: s&.a[].add(s&.b[]))
};
// BUG. You'd expect this to be the same as above (b=3)
assert_eq(s&.a[], 5); assert_eq(s&.b[], 7);

// This is what you're really doing
var s: A = init(a: 1, b: 2);
s&.a[] = 5;
s&.b[] = s&.a[].add(s&.b[]);
assert_eq(s&.a[], 5); assert_eq(s&.b[], 7);  // Here it makes sense

var s: A = init(a: 1, b: 2);
s = {
    init(a: 5, b: s&.a[].add(s&.b[]))
};
// Again this is fine because I don't do it for function calls. 
assert_eq(s&.a[], 5); assert_eq(s&.b[], 3);

_canary
}

