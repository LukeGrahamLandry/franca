// TODO: im doing overloads dumbly so now calling  means filtering through every struct type ever made even when you already know what type you're looking for. 

#test(aarch64)
fn main(_canary: i64) i64 = {

const Person = @struct(age: i64, gender: i64);

assert_eq(Person!type, Type);

// Create a struct by calling the ializer. 
// We need to specify the type so it can resolve the overload even if there are multiple with the same field names and types. (If they're unique, it can infer).
var bob: Person = (age: 24, gender: 42);
assert_eq(bob!type, Person);

// dot syntax for computing field offsets. 
// Note: it returns a ptr to the field, not the value of the field. 
let age_ptr: Ptr(i64) = bob&.age; 
assert_eq(24, bob&.age[]);
assert_eq(42, bob&.gender[]);
let next_year = add(bob&.age[], 1);
bob&.age[] = next_year;
assert_eq(bob&.age[], 25);
assert_eq(bob&.gender[], 42);

// Composition
const Animal = @struct(owner: Person, whiskers: bool);
assert_eq(Animal!type, Type);

var cat: Animal = (
    owner: bob,  // This is a copy of bob.
    whiskers: true,
);
assert_eq(cat&.whiskers[], true);
var bob_again: Ptr(Person) = cat&.owner;
assert_eq(bob_again.age[], 25);
assert_eq(cat&.owner.gender[], 42);  // Auto deref for chained place expressions. 

// Structs are value types. 
bob_again.age[] = 99;
assert_eq(bob_again.age[], 99);
assert_eq(bob&.age[], 25);  // The original has not been mutated. 

// `!deref` or `[]` can load a whole struct from a pointer at once. 
// TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
var bob_part_three: Person = cat&.owner[];  // This is a copy
bob_part_three&.age[] = 5;
assert_eq(bob_part_three&.age[], 5);
assert_eq(cat&.owner.age[], 99);

// Structs can contain pointers. 
House :: @struct(
    tax_payer: Ptr(Person),
    pet: Ptr(Animal),
);
assert_eq(Animal!type, Type);

// Note: this example aliases bob_again. Good luck compiling to rust :)
var tent: House = (
    tax_payer: cat&.owner,
    pet: cat!addr
);
assert_eq(tent!type, House);
assert_eq(tent&.pet[].owner.age[], 99);
tent&.pet[].owner.age[] = 55;  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
assert_eq(tent&.pet[].owner.age[], 55);
assert_eq(tent&.tax_payer[].age[], 55);
assert_eq(bob_again.age[], 55);
assert_eq(bob&.age[], 25);  // OG bob is still just chillin

var mouse: Animal = (
    owner: (
        age: 17,
        gender: 314,
    ),
    whiskers: true,
);
// struct 'var's can be reassigned
// No type annotation needed because it remembers. 
tent = (
    tax_payer: bob!addr,
    pet: mouse!addr,
);

{ tent = mouse; }!assert_compile_error;  // type check

// Field names are type checked. 
let a = 1;
a.hello!assert_compile_error;  
tent.hello!assert_compile_error;  

// TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
// TODO: Struct declarations are always const.
// { let Thing: Type = @struct(legs: i64); }!assert_compile_error;

// TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
// A raw map literal is illegal if the compiler can't infer a type. 
{   let Thing = (legs: i64);   }!assert_compile_error;

// Structs are passed by copy (or probably const pointer if you don't mutate)
fn mutate_copy(var who: Person) Unit = {
    who&.age[] = 11;
}
assert_eq(bob&.age[], 25);
mutate_copy(bob);
assert_eq(bob&.age[], 25);

// Pass a pointer if you want to mutate the original. 
// TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
fn mutate_real(who: Ptr(Person)) Unit = {
    who.age[] = 11;
}
assert_eq(bob&.age[], 25);
mutate_real(bob!addr);
assert_eq(bob&.age[], 11);

// TODO: no field mutation through a 'let'

// no implicitly created references. this isnt c++. 
mutate_real(bob)!assert_compile_error;

// Return a struct
fn make_someone(years: i64) Person = (
     age: years,
     gender: 192741892,
);
var bill = make_someone(17);
assert_eq(bill&.age[], 17);


// TODO: move this to generics test and do a normal version here. 
#comptime
fn Option2(const T: Type) Type = @tagged(Some: T, None: Unit);

const Maybe_i64 = Option2(i64);

var yes: Maybe_i64 = (Some: 12);
var no: Maybe_i64 = (None: unit);

assert_eq(yes!type, no!type);  // same type even with different payloads

// You can manually check the tag if you try hard enough. (eventually I want macros for nice matching)
// It's illegal to access a non-active field. 
assert_eq(yes&!tag[], tag_value(Maybe_i64, Some!symbol));
assert_eq(no&!tag[], tag_value(Maybe_i64, None!symbol));

// Like structs, dot syntax is a place expression. 
// It's illegal to access a non-active field. // TODO: be able to !assert_runtime_error
assert_eq(yes&.Some[], 12);  
assert_eq(no&.None[], unit);

var things = (1, 2, 3);
things&[2][] = 4;
assert_eq(things&[0][], 1);
assert_eq(things&[1][], 2);
assert_eq(things&[2][], 4);

///////////////

AA :: @tagged(a: i64, b: i64); // TODO: crazy error when this is called A too so it shadows. 

let n = 3;
var a: AA = (a: n);
let out = add(a&.a[], 7);
assert_eq(out, 10);

//////
/// Tricky result slot aliasing
// (no longer a problem)

A :: @struct(a: i64, b: i64);

var s: A = (a: 1, b: 2);
assert_eq(s&.a[], 1);
s = (a: s&.b[], b: s&.a[]);
assert_eq(s&.a[], 2);
assert_eq(s&.b[], 1); 

var s: A = (a: 1, b: 2);
assert_eq(s&.a[], 1); assert_eq(s&.b[], 2);
// The argument to the function call are evaluated up front so this behaves as expected. 
s = (a: s&.b[], b: s&.a[]);
assert_eq(s&.a[], 2); assert_eq(s&.b[], 1);

var s: A = (a: 1, b: 2);
s = {
    let a = 5;
    let b = s&.a[].add(s&.b[]);
    (a: a, b: b)
};
// 'b' would be 7 if it forwarded to the final output location.   
assert_eq(s&.a[], 5); assert_eq(s&.b[], 3);

var s: A = (a: 1, b: 2);
s = {
    (a: 5, b: s&.a[].add(s&.b[]))
};

assert_eq(s&.a[], 5); assert_eq(s&.b[], 3);

// This is what you're really doing
var s: A = (a: 1, b: 2);
s&.a[] = 5;
s&.b[] = s&.a[].add(s&.b[]);
assert_eq(s&.a[], 5); assert_eq(s&.b[], 7);  // Here it makes sense

var s: A = (a: 1, b: 2);
s = {
    (a: 5, b: s&.a[].add(s&.b[]))
};
// Again this is fine because I don't do it for function calls. 
assert_eq(s&.a[], 5); assert_eq(s&.b[], 3);

_canary
}

