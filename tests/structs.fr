// TODO: im doing overloads dumbly so now calling  means filtering through every struct type ever made even when you already know what type you're looking for. 

#test fn simple_structs(_canary: i64) i64 = {
    const Person = @struct(age: i64, gender: i64);
    
    assert_eq(@type Person, Type);
    
    // Create a struct by calling the ializer. 
    // We need to specify the type so it can resolve the overload even if there are multiple with the same field names and types. (If they're unique, it can infer).
    var bob: Person = (age = 24, gender = 42);
    assert_eq(@type bob, Person);
    
    // dot syntax for computing field offsets. 
    let age_ptr: Ptr(i64) = bob.age&; 
    assert_eq(24, bob.age);
    assert_eq(42, bob.gender);
    let next_year = add(bob.age, 1);
    // but assignment does auto-deref for you. 
    bob.age = next_year;
    assert_eq(bob.age, 25);
    assert_eq(bob.gender, 42);
    
    // Composition
    const Animal = @struct(owner: Person, whiskers: bool);
    assert_eq(@type Animal, Type);
    
    var cat: Animal = (
        owner = bob,  // This is a copy of bob.
        whiskers = true,
    );
    assert_eq(cat.whiskers, true);
    var bob_again: Ptr(Person) = cat.owner&;
    assert_eq(bob_again.age, 25); // Auto deref through the pointer. 
    assert_eq(cat.owner.gender, 42);  
    
    // Structs are value types. 
    bob_again.age = 99;
    assert_eq(bob_again.age, 99);
    assert_eq(bob.age, 25);  // The original has not been mutated. 
    
    // `!deref` or `[]` can load a whole struct from a pointer at once. 
    // TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
    var bob_part_three: Person = cat.owner;  // This is a copy
    bob_part_three.age = 5;
    assert_eq(bob_part_three.age, 5);
    assert_eq(cat.owner.age, 99);
    
    // Structs can contain pointers. 
    House :: @struct(
        tax_payer: Ptr(Person),
        pet: Ptr(Animal),
    );
    assert_eq(@type Animal, Type);
    
    // Note: this example aliases bob_again. Good luck compiling to rust :)
    var tent: House = (
        tax_payer = cat.owner&,
        pet = cat!addr
    );
    assert_eq(@type tent, House);
    assert_eq(tent.pet.owner.age, 99);
    tent.pet.owner.age = 55;  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
    assert_eq(tent.pet.owner.age, 55);
    assert_eq(tent.tax_payer.age, 55);
    assert_eq(bob_again.age, 55);
    assert_eq(bob.age, 25);  // OG bob is still just chillin
    
    ptr_to_ptr_field : **Person = tent.tax_payer&;
    val_of_ptr_field : *Person = tent.tax_payer;
    @assert_compile_error {
        load_ptr_field: Person = tent.tax_payer;  // No extra level of auto deref. once you get to the type of the field, you're done.
    };
    
    var mouse: Animal = (
        owner = (
            age = 17,
            gender = 314,
        ),
        whiskers = true,
    );
    // struct 'var's can be reassigned
    // No type annotation needed because it remembers. 
    tent = (
        tax_payer = bob!addr,
        pet = mouse!addr,
    );
    
    @assert_compile_error { tent = mouse; };  // type check
    
    // Field names are type checked. 
    let a = 1;
    @assert_compile_error a.hello;  
    @assert_compile_error tent.hello;  
    
    // TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
    // TODO: Struct declarations are always const.
    // @assert_compile_error { let Thing: Type = @struct(legs: i64); };
    
    // TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
    // A raw map literal is illegal if the compiler can't infer a type. 
    // @assert_compile_error {   let Thing = (legs = i64);   };
    
    // Structs are passed by copy (or probably const pointer if you don't mutate)
    fn mutate_copy(var who: Person) Unit = {
        who.age = 11;
    }
    assert_eq(bob.age, 25);
    mutate_copy(bob);
    assert_eq(bob.age, 25);
    
    // Pass a pointer if you want to mutate the original. 
    // TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
    fn mutate_real(who: *Person) Unit = {
        who.age = 11; // Note: we auto deref through the pointer
    }
    assert_eq(bob.age, 25);
    mutate_real(bob!addr);
    assert_eq(bob.age, 11);
    
    // no implicitly created references. this isnt c++. 
    @assert_compile_error mutate_real(bob);
    
    // Return a struct
    fn make_someone(years: i64) Person = (
        age = years,
        gender = 192741892,
    );
    var bill = make_someone(17);
    assert_eq(bill.age, 17);
    
  
    
    constant : A : (a = 9, b = 8);
    // TODO: because of how fields/places work, you can't read an individual field because you can't take its address. 
    //       this used to work but i took it out because it was unreachable after i switched enums from just being a constant struct. -- May 4
    
    
    _canary
}

#test fn tagged_unions() = {
    // TODO: move this to generics test and do a normal version here. 
    fn Option2(const T: Type) Type = @tagged(Some: T, None: Unit);
    
    const Maybe_i64 = Option2(i64);
    
    var yes: Maybe_i64 = (Some = 12);
    var no: Maybe_i64 = (None = unit);
    
    assert_eq(@type yes, @type no);  // same type even with different payloads
    
    // You can manually check the tag if you try hard enough. (eventually I want macros for nice matching)
    // It's illegal to access a non-active field. 
    assert_eq(yes&!tag[], tag_value(Maybe_i64, @symbol Some));
    assert_eq(no&!tag[], tag_value(Maybe_i64, @symbol None));
    
    // Like structs, dot syntax is a place expression. 
    // It's illegal to access a non-active field. // TODO: be able to !assert_runtime_error
    assert_eq(yes.Some, 12);  
    assert_eq(no.None, unit);
    
    var things = (1, 2, 3);
    things._2 = 4;
    assert_eq(things._0, 1);
    assert_eq(things._1, 2);
    assert_eq(things._2, 4);
    
    ///////////////
    
    AA :: @tagged(a: i64, b: i64); // TODO: crazy error when this is called A too so it shadows. 
    
    let n = 3;
    var a: AA = (a = n);
    let out = add(a.a, 7);
    assert_eq(out, 10);
}

/// Tricky result slot aliasing
#test fn rls_aliasing(_canary: i64) i64 = {
    A :: @struct(a: i64, b: i64);
    
    var s: A = (a = 1, b = 2);
    assert_eq(s.a, 1); assert_eq(s.b, 2);
    s = (a = s.b, b = s.a);
    assert_eq(s.a, 2);
    assert_eq(s.b, 2);  // CORRECT: assert_eq(s.b, 1); 
    
    var s: A = (a = 1, b = 2);
    s = {
        let a = 5;
        let b = s.a.add(s.b);
        (a = a, b = b)
    };
    assert_eq(s.a, 5); 
    assert_eq(s.b, 3);  // 'b' would be 7 if it forwarded to the final output location.   
    
    var s: A = (a = 1, b = 2);
    s = {
        (a = 5, b = s.a.add(s.b))
    };
    
    assert_eq(s.a, 5); 
    assert_eq(s.b, 7); // CORRECT: assert_eq(s.b, 3);
    
    // This is what you're really doing
    var s: A = (a = 1, b = 2);
    s.a = 5;
    s.b = s.a.add(s.b);
    assert_eq(s.a, 5); assert_eq(s.b, 7);  // Here it makes sense
    
    var s: A = (a = 1, b = 2);
    s = {
        (a = 5, b = s.a.add(s.b))
    };
    assert_eq(s.a, 5); 
    assert_eq(s.b, 7);   // CORRECT: assert_eq(s.b, 3);
   
    _canary
}

#test fn field_default_values() = {
    Car :: @struct(colour: Str, windows: i64 = 4, trunks := 1);
    
    my_car: Car = (colour = "red");
    assert_eq(my_car.windows, 4);
    my_car = (colour = "red", windows = 7);
    assert_eq(my_car.windows, 7);
}

// here you need to be able to infer from an expression in infer_pattern which used to mean you had to thread a result context all the way through. 
#test fn field_default_infer_type() = {
    Car :: @struct(colour: Str, trunks := 1);
    
    my_car: Car = (colour = "red");
    assert_eq(my_car.trunks, 1);
    my_car = (colour = "red", trunks = 2);
    assert_eq(my_car.trunks, 2);
}

#test fn discard_tagged_padding() = {
    Data :: @tagged(small: i64, big: Ty(i64, i64));
    d: Data = (small = 123);
    small := @match(d) {
        (fn small(v) i64 => v);
        (fn big() => 456);
    };
    assert_eq(small, 123);
}

#test_broken fn cyclic_indirection() = {
    Node :: @struct(next: ?*Node, data: i64);
    
    a: Node = (next = (None = unit), data = 123);
}


#test fn fixed_arrays() = {
    arr: Array(i64, 3) = init((7, 8, 9)!slice);
    assert_eq(arr&[0], 7);
    assert_eq(arr&[1], 8);
    assert_eq(arr&[2], 9);
    
    arr_view := arr&.slice();
    assert_eq(arr_view&[0], 7);
    assert_eq(arr_view&[1], 8);
    assert_eq(arr_view&[2], 9);
    
    arr2: ?*Array(i64, 3) = arr_view.as_array();
    assert(eq(arr, arr2.unwrap()[]), "failed");
    
    wrong_len: ?*Array(i64, 4) = arr_view.as_array();
    assert_eq(wrong_len.is_none(), true);
}

#test fn nominal_sturcts() = {
    potato :: @struct(tomato: i64);
    potÀto :: @struct(tomato: i64);
    assert_eq(false, eq(potato, potÀto));
    
    a: potato = (tomato = 123);
    b: potÀto = (tomato = 456);
    @assert_compile_error {
        a = b;
    };
}
