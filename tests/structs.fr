// TODO: im doing overloads dumbly so now calling  means filtering through every struct type ever made even when you already know what type you're looking for. 

#test fn simple_structs(_canary: i64) i64 = {
    Person :: @struct(age: i64, gender: i64);
    
    assert_eq(@type Person, Type);
    
    // Create a struct by calling the ializer. 
    // We need to specify the type so it can resolve the overload even if there are multiple with the same field names and types. (If they're unique, it can infer).
    bob: Person = (age = 24, gender = 42);
    assert_eq(@type bob, Person);
    
    // dot syntax for computing field offsets. 
    age_ptr: *i64 = bob.age&; 
    assert_eq(24, bob.age);
    assert_eq(42, bob.gender);
    next_year := add(bob.age, 1);
    // but assignment does auto-deref for you. 
    bob.age = next_year;
    assert_eq(bob.age, 25);
    assert_eq(bob.gender, 42);
    
    // Composition
    Animal :: @struct(owner: Person, whiskers: bool);
    assert_eq(@type Animal, Type);
    
    cat: Animal = (
        owner = bob,  // This is a copy of bob.
        whiskers = true,
    );
    assert_eq(cat.whiskers, true);
    bob_again: *Person = cat.owner&;
    assert_eq(bob_again.age, 25); // Auto deref through the pointer. 
    assert_eq(cat.owner.gender, 42);  
    
    // Structs are value types. 
    bob_again.age = 99;
    assert_eq(bob_again.age, 99);
    assert_eq(bob.age, 25);  // The original has not been mutated. 
    
    // `!deref` or `[]` can load a whole struct from a pointer at once. 
    // TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
    bob_part_three: Person = cat.owner;  // This is a copy
    bob_part_three.age = 5;
    assert_eq(bob_part_three.age, 5);
    assert_eq(cat.owner.age, 99);
    
    // Structs can contain pointers. 
    House :: @struct(
        tax_payer: *Person,
        pet: *Animal,
    );
    assert_eq(@type Animal, Type);
    
    // Note: this example aliases bob_again. Good luck compiling to rust :)
    tent: House = (
        tax_payer = cat.owner&,
        pet = cat&
    );
    assert_eq(@type tent, House);
    assert_eq(tent.pet.owner.age, 99);
    tent.pet.owner.age = 55;  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
    assert_eq(tent.pet.owner.age, 55);
    assert_eq(tent.tax_payer.age, 55);
    assert_eq(bob_again.age, 55);
    assert_eq(bob.age, 25);  // OG bob is still just chillin
    
    ptr_to_ptr_field : **Person = tent.tax_payer&;
    val_of_ptr_field : *Person = tent.tax_payer;
    @assert_compile_error {
        load_ptr_field: Person = tent.tax_payer;  // No extra level of auto deref. once you get to the type of the field, you're done.
    };
    
    mouse: Animal = (
        owner = (
            age = 17,
            gender = 314,
        ),
        whiskers = true,
    );
    // struct 'var's can be reassigned
    // No type annotation needed because it remembers. 
    tent = (
        tax_payer = bob&,
        pet = mouse&,
    );
    
    @assert_compile_error { tent = mouse; };  // type check
    
    // Field names are type checked. 
    a := 1;
    @assert_compile_error a.hello;  
    @assert_compile_error tent.hello;  
    
    // TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
    // TODO: Struct declarations are always const.
    // @assert_compile_error { let Thing: Type = @struct(legs: i64); };
    
    // TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
    // A raw map literal is illegal if the compiler can't infer a type. 
    // @assert_compile_error {   let Thing = (legs = i64);   };
    
    // Structs are passed by copy (or probably const pointer if you don't mutate)
    fn mutate_copy(who: Person) void = {
        who.age = 11;
    }
    assert_eq(bob.age, 25);
    mutate_copy(bob);
    assert_eq(bob.age, 25);
    
    // Pass a pointer if you want to mutate the original. 
    // TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
    fn mutate_real(who: *Person) void = {
        who.age = 11; // Note: we auto deref through the pointer
    }
    assert_eq(bob.age, 25);
    mutate_real(bob&);
    assert_eq(bob.age, 11);
    
    // no implicitly created references. this isnt c++. 
    @assert_compile_error mutate_real(bob);
    
    // Return a struct
    fn make_someone(years: i64) Person = (
        age = years,
        gender = 192741892,
    );
    bill := make_someone(17);
    assert_eq(bill.age, 17);
    
  
    
    constant : A : (a = 9, b = 8);
    // TODO: because of how fields/places work, you can't read an individual field because you can't take its address. 
    //       this used to work but i took it out because it was unreachable after i switched enums from just being a constant struct. -- May 4
    
    
    _canary
}

#test fn tagged_unions() = {
    // TODO: move this to generics test and do a normal version here. 
    fn Option2($T: Type) Type = @tagged(Some: T, None: void);
    
    Maybe_i64 :: Option2(i64);
    
    yes: Maybe_i64 = (Some = 12);
    no: Maybe_i64 = (None = unit);
    
    assert_eq(@type yes, @type no);  // same type even with different payloads
    
    // You can manually check the tag if you try hard enough. (I also have macros for nice matching)
    // It's illegal to access a non-active field. 
    :: tagged(Maybe_i64); // instantiate the polymorphic function we're about to use. 
    assert_eq(yes&.tag().ordinal(), tag_value(Maybe_i64, @symbol Some));
    assert_eq(no&.tag().ordinal(), tag_value(Maybe_i64, @symbol None));
    
    // Like structs, dot syntax is a place expression. 
    // It's illegal to access a non-active field. // TODO: be able to !assert_runtime_error
    assert_eq(yes.Some, 12);  
    assert_eq(no.None, unit);
    
    things := (1, 2, 3);
    things._2 = 4;
    assert_eq(things._0, 1);
    assert_eq(things._1, 2);
    assert_eq(things._2, 4);
    
    ///////////////
    
    AA :: @tagged(a: i64, b: i64); // TODO: crazy error when this is called A too so it shadows. 
    
    n := 3;
    a: AA = (a = n);
    out := add(a.a, 7);
    assert_eq(out, 10);
}

/// Tricky result slot aliasing
#test fn rls_aliasing(_canary: i64) i64 = {
    A :: @struct(a: i64, b: i64);
    
    s: A = (a = 1, b = 2);
    assert_eq(s.a, 1); assert_eq(s.b, 2);
    s = (a = s.b, b = s.a);
    assert_eq(s.a, 2);
    assert_eq(s.b, 2);  // CORRECT: assert_eq(s.b, 1); 
    
    s: A = (a = 1, b = 2);
    s = {
        a := 5;
        b := s.a.add(s.b);
        (a = a, b = b)
    };
    assert_eq(s.a, 5); 
    assert_eq(s.b, 3);  // 'b' would be 7 if it forwarded to the final output location.   
    
    s: A = (a = 1, b = 2);
    s = {
        (a = 5, b = s.a.add(s.b))
    };
    
    assert_eq(s.a, 5); 
    assert_eq(s.b, 7); // CORRECT: assert_eq(s.b, 3);
    
    // This is what you're really doing
    s: A = (a = 1, b = 2);
    s.a = 5;
    s.b = s.a.add(s.b);
    assert_eq(s.a, 5); assert_eq(s.b, 7);  // Here it makes sense
    
    s: A = (a = 1, b = 2);
    s = {
        (a = 5, b = s.a.add(s.b))
    };
    assert_eq(s.a, 5); 
    assert_eq(s.b, 7);   // CORRECT: assert_eq(s.b, 3);
   
    _canary
}

#test fn field_default_values() = {
    Car :: @struct(colour: Str, windows: i64 = 4, trunks := 1);
    
    my_car: Car = (colour = "red");
    assert_eq(my_car.windows, 4);
    my_car = (colour = "red", windows = 7);
    assert_eq(my_car.windows, 7);
}

// here you need to be able to infer from an expression in infer_pattern which used to mean you had to thread a result context all the way through. 
#test fn field_default_infer_type() = {
    Car :: @struct(colour: Str, trunks := 1);
    
    my_car: Car = (colour = "red");
    assert_eq(my_car.trunks, 1);
    my_car = (colour = "red", trunks = 2);
    assert_eq(my_car.trunks, 2);
}

#test fn discard_tagged_padding() = {
    Data :: @tagged(small: i64, big: Ty(i64, i64));
    d: Data = (small = 123);
    small := @match(d) {
        (fn small(v) i64 => v);
        (fn big() => 456);
    };
    assert_eq(small, 123);
}

#test 
fn cyclic_indirection() = {
    Node :: @rec @struct(next: ?*Node, data: i64);
    
    a: Node = (next = (None = unit), data = 123);
}


#test fn fixed_arrays() = {
    arr: Array(i64, 3) = init(@slice (7, 8, 9));
    assert_eq(arr&[0], 7);
    assert_eq(arr&[1], 8);
    assert_eq(arr&[2], 9);
    
    arr_view := arr&.items();
    assert_eq(arr_view&[0], 7);
    assert_eq(arr_view&[1], 8);
    assert_eq(arr_view&[2], 9);
    
    arr2: ?*Array(i64, 3) = arr_view.as_array();
    assert(eq(arr, arr2.unwrap()[]), "failed");
    
    wrong_len: ?*Array(i64, 4) = arr_view.as_array();
    assert_eq(wrong_len.is_none(), true);
}

// TODO
#test_broken fn nominal_sturcts() = {
    potato :: @struct(tomato: i64);
    potÀto :: @struct(tomato: i64);
    assert_eq(false, eq(potato, potÀto));
    
    a: potato = (tomato = 123);
    b: potÀto = (tomato = 456);
    @assert_compile_error {
        a = b;
    };
}

#test fn destructuring() = {
    (a: i64, b: i64) := (1, 2); // tuple
    fn get_pair() Ty(i64, i64) #noinline = (2, 3);
    (c: i64, d: i64) := get_pair(); // one expr
    assert_eq(c, 2);
    assert_eq(d, 3);
    (g: i64, h) := get_pair(); // not all have annotations
    assert_eq(g, 2);
    assert_eq(h, 3);
    (e, f) := get_pair(); // no annotations so left is a tuple
    assert_eq(e, 2);
    assert_eq(f, 3);
}


// Trying to debug weird behaviour with fork_and_catch. -- Jul 1
// but this doesn't reproduce anything odd... 
#test fn destructuring_align() = {
    fn get_thing_with_gap($force_inline: @Fn() bool ) Ty(bool, List(u8), List(u8)) = {
        a := "hello world".clone(temp());
        b := "aaa".clone(temp());
        (force_inline(), a, b)
    }
    
    (b, txt, another) := get_thing_with_gap() {| false };
    assert_eq(b, false);
    assert_eq(txt.items(), "hello world");
    assert_eq(another.items(), "aaa");
}

// TODO: test that ambiguity with actual named arg is an error.
#test fn aggragate_literals_as_kwarg() = {
    things: List(?i64) = list(temp());
    things&.push(Some = 123);
    assert_eq(things.len, 1);
    
    Many :: @struct(a: i64, b: i64);
    things: List(Many) = list(temp());
    things&.push((a = 1, b = 2));
    assert_eq(things.len, 1);
    things&.push(a = 3, b = 4);
    assert_eq(things.len, 2);
}
