@import((lib, interp_builtins), expand, all);  // TODO be able to parse annotation as a stmt so dont need the {}

;;;;;;; // allow no op stmts at top level

// TODO: move to prelude
// TODO: better error for `Ptr(Fn(Any, Any), Any)` vs `Ptr((Fn(Any, Any), Any))`. consistantly cope with single tuple. 
const FnArg: Type = (Fn(Any, Any), Any);  // TODO: make this work without the annotation and intermediate variable. 
fn call_comptime_cached(func_arg_addr: Ptr(FnArg)) Any = {
    let f = get_i(func_arg_addr, 0);
    let a = get_i(func_arg_addr, 1);
    let prev = comptime_cache_get(f, a);
    let found = get_i(prev!addr, 0);
    let value = get_i(prev!addr, 1);
    if(found, fn() Any = { value }, fn() Any = {
        let func = get_i(func_arg_addr, 0);
        let arg = get_i(func_arg_addr, 1);
        let ret = func(arg);
        comptime_cache_insert(func, arg, ret);
        ret
    })
}

fn main(unused: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

// TODO: test block comments are also a thing but they dont work

// empty statements are allowed. 
;;;;;;;

{   };  // empty block treated as expression TODO: allow without ;

assert_eq(1, 1);  // assert_eq exists
let fff = fn(u: Unit) i64 = { 15 };
assert_eq(15, fff(unit));  // closure in a variable. 

// TODO: give an error for the ambigous case without the brackets. are you calling the block or the function?. i dont want to just pick a predidence 
//       blocks return values so theres never a reason to actually want to do this. 
assert_eq(25, (fn(u: Unit) i64 = { 25 })(unit));  // closure called inline
assert_eq(35, (fn() i64 = { 35 })());  // no arguments (not even Unit).
assert_eq(unit, (fn() Unit = { unit })()); // return unit
assert_eq(unit, (fn() Unit = { let x = 0; })());  // implicit trailing `unit` 
// assert_ eq(unit, (fn() Unit = {})()); // empty body allowed 

/// simple_variables ///

assert_eq(5, (fn(n: i64) i64 = { let x = 10; n })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; x })(5));
assert_eq(25, (fn(n: i64) i64 = { let x = n; x })(25));
assert_eq(50, (fn(n: i64) i64 = { var x = n; x = 50; x })(5));
assert_eq(16, (fn(n: i64) i64 = { var x = n; x = add(1, add(add(x, x), n)); x })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; let y = x; y })(5));

let one: i64 = 1;  // variables can have type annotations 
assert_eq(one, 1);

/// simple if /// 

assert_eq(5, (fn(n: i64) i64 = {
    if(eq(n, 1), fn() i64 = { 5 }, fn() i64 = { 10 })
})(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, (fn(n: int(unit)) int(unit) = { add(add(n, n), n) }) (5));

@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();

////////////////
/// Pointers ///
////////////////

var v = 10;
let ptr = v!addr;  // Get the adddress of v's stack slot
assert_eq(10, get(ptr));
v = 5;
assert_eq(5, get(ptr));  // writes though var observed by ptr
set(ptr, 15);
assert_eq(15, v); // writes though ptr observed by var
assert_eq(15, get(ptr));
assert_eq(len(ptr), 1);  // v is not a tuple
assert_eq(false, is_uninit(ptr));  // there's a value in v

// It is legal to take pointer to uninitilized memory, as long as you write before you read. 
let bad: i64;
let bad_ptr = bad!addr;
assert_eq(true, is_uninit(bad_ptr));
set(bad_ptr, 1);  // initialize the memory 
assert_eq(false, is_uninit(bad_ptr));
assert_eq(get(bad_ptr), 1);  // now we can read it
assert_eq(bad, 1);

// You can pass functions pointers to your own stack. 
fn increment(ptr_arg: Slice(i64)) Unit = {
    let old = get(ptr_arg);
    set(ptr_arg, add(old, 1));
}

let m = 3;
increment(m!addr);
assert_eq(m, 4);

// TODO: this is broken by closures inlining everything. easy fix with @noinline
// The interpreter can catch some basic mistakes. 
fn mistake(i: i64) Slice(i64) = {
    let my_value = add(i, i);
    my_value!addr  // oops, call frame went away
}
let very_bad_ptr = mistake(1);  // it is illegal to dereference this pointer 
// is_oob_stack: Only supported in the interp
assert_eq(true, is_oob_stack(very_bad_ptr));
assert_eq(false, is_oob_stack(very_bad_ptr!addr));

// You can take the address of function arguments. 
// TODO: want to pass by const reference if big so be careful about mutating (or disallow). 
fn twice(arg: i64) i64 = {
    let arg_ptr = arg!addr;
    mul(get(arg_ptr), 2)
}
let three = 3;
assert_eq(6, twice(three));

//////////////
/// Tuples ///
//////////////

let arr = (1, 2, 3);
let arr_ptr = arr!addr;
// a tuple isn't treated as one *thing*, you're pointing to a range of the stack containing three values
assert_eq(len(arr_ptr), 3);  

// you can create a pointer to a sub-slice of a tuple
let second_ptr = slice(arr_ptr, 1, 2);  // start at index 1, end before index 2
assert_eq(1, len(second_ptr));  // pointing at one element
assert_eq(2, get(second_ptr)); // we can dereference as normal.
set(second_ptr, 123);
// TODO: length of slice as part of pointer type
// The type annotation for a tuple is written as a tuple of types. 
// TODO: comptime variadic functions.
// let have: (i64, i64, i64) = get(arr_ptr);
// let expected: (i64, i64, i64) = (1, 123, 3);
// assert_ eq(have, expected);
// asser t_eq(get(arr_ptr), (1, 123, 3)); // the type annotations are unnessisary 

// in fact, tuples aren't real at all. they're just the way i represent multiple arguments and return values 
fn flip_1(args: (i64, i64)) (i64, i64) = { 
    let arr = args!addr;
    let a1 = slice(arr, 0, 1);
    let a2 = slice(arr, 1, 2);
    (get(a2), get(a1))
}
//assert_ eq((3, 2), flip_1((2, 3)));
//assert_ eq((3, 2), flip_1(2, 3));
//assert_ eq(3, 2, flip_1(2, 3));

// Maybe this is a bit unfortunate. It doesnt care where the brackets go, just sees two pairs (a, b) (c, d)
//assert_ eq(2, flip_1(2, 2), 2);

// This is indistinguishable from flip_1.
fn flip_2(a: i64, b: i64) (i64, i64) = (b, a);
//assert_ eq((3, 2), flip_2((2, 3)));
//assert_ eq((3, 2), flip_2(2, 3));
//assert_ eq(3, 2, flip_2(2, 3));
//assert_ eq(2, flip_2(2, 2), 2);

let x = (1, 2);
// let (y, z) = x;

//////////////////
/// Allocation ///
//////////////////

// Use `alloc` to create space that outlives the current stack frame. 
fn dont_leak(size: i64) Slice(i64) = alloc(i64, size);

let on_the_heap = dont_leak(10); 
let first = slice(on_the_heap, 0, 1);
// is_uninit: Only supported in the interp
assert_eq(true, is_uninit(first));
set(first, 15);
assert_eq(false, is_uninit(first));
assert_eq(get(first), 15);

// Don't need to pass count because its in the slice. 
dealloc(i64, on_the_heap);
// TODO: interpreter dealloc frees the value (if its a vec or whatever) but reference counts the allocation to catch use after free

/////////////////////
/// Lexical Scope ///
/////////////////////

let x = 5;
assert_eq(x, 5);
{  // Variables declared in a block shadow old ones
    let x = 10;
    {
        let x = 15;
        assert_eq(x, 15);
    };
    assert_eq(x, 10);
};  // but after the block you can see the old again. 
assert_eq(x, 5);

// Same in functions. 

let aaaa = 20;
let ttt = fn(n: i64) i64 = {
    let aaaa = 25;
    assert_eq(aaaa, 25);
    
    assert_eq(n, 35);
    let n = 30;  // You can shadow arguments, but now you can't get it back. 
    assert_eq(n, 30);
};
ttt(35);
assert_eq(aaaa, 20);

// infact, you can shadow anything
let shadow = 40;
assert_eq(shadow, 40);
let shadow = 45;  // but the old one's gone forever. 
assert_eq(shadow, 45);

////////////////
/// Inlining ///
////////////////

// print_callstack: Only supported in the interp
@inline fn test_call_1(n: i64) i64 = {
    print(1);
    print_callstack(); 
    let important_value = add(n, 1);
    mul(important_value, 2)
}

@noinline fn test_call_2(n: i64) i64 = {
    print(2);
    print_callstack(); 
    let important_value = add(n, 1);
    mul(important_value, 2)
}

let important_value = 42;
assert_eq(test_call_1(2), 6);
assert_eq(important_value, 42);  // Inlining doesn't stomp variables
assert_eq(test_call_2(2), 6);
assert_eq(important_value, 42);  // Trivial

////////////////
/// Closures ///
////////////////

// Branches of a call to if can access variables from the outer scope. 
var a = 10;
if(true, fn() Unit = { a = 1; }, fn() Unit = { a = 2; });
assert_eq(a, 1);

var b = 1;
fn capturing(n: i64) Unit = {
    b = n;
}
assert_eq(b, 1);
capturing(15);
assert_eq(b, 15);

// Shadowed vars are still local. 
var c = 1;
fn not_capturing(n: i64) Unit = {
    var c = n;
}
assert_eq(c, 1);
not_capturing(15);
assert_eq(c, 1);

// TODO: force inline 
fn call_it(n: i64, f: Fn(i64, i64)) i64 = {
    print_callstack(); 
    add(f(n), 1)
}
// TODO: its an ice if you dont have brackets around the block (even before i was calling callstack() )
assert_eq(9, call_it(4, fn(m: i64) i64 = { print_callstack(); mul(2, m) }));

// var a = 77;
// assert_ eq(3, call_it(0, fn temp(m: i64) i64 = { print_callstack(); a = 88; add(2, m) }));
// assert_ eq(a, 88);

/////////////////
/// Constants ///
/////////////////

fn identity(arg: Any) Any = arg;
let arg = (identity, 1);
assert_eq(1, call_comptime_cached(arg!addr));

let x = 10;
assert_eq(x!type, i64);
let xa = x!addr;
// TODO: you can't directly pass the argument because it wont relize its a constexpr
const int_ptr = Ptr(i64);
assert_eq(xa!type, int_ptr);

// I'm not sure I like this. 
// side effects of expressions in macros don't run. 
// but at least it's consistant and theres a special symbol to tell you when its happening. 
// its not as bad as `size_of(blow_up_moon()`
// for `!addr` to be initiative it needs to put you in magic place expression mode 
// so a chain isnt actually copying everything out of the pointers on to the stack to compute an offset. 
// TODO: this should be a compile error. no side effects in macros that dont want them. 
fn do_side_effect(to: Ptr(i64)) bool = {
    let the = 1234;
    set(to, the);
    true
}
let my_secret_value = 5;
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value!addr)!type, bool);
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value!addr), true);
assert_eq(my_secret_value, 1234);

//////////////////////////////
/// Inspecting Compilation ///
//////////////////////////////

{
    print(this_is_not_the_var_youre_looking_for);
}!assert_compile_error;

fn hello(n: this_too()) this_too() = { n }!assert_compile_error;

// Note: this doesn't mess up the vm state. Make sure you keep it that way. 
{
     { let valid = x; }!assert_compile_error;  // this assertion fires
}!assert_compile_error;  // and is caught here

{
    let int_ptr = Ptr(i64);
}!assert_compile_error;
// TODO: specify the reson for the error so its not accidently passing. 

{ let bad; }!assert_compile_error;  // Uninit vars require type annotation. 

// TODO: this doesnt work because it doesnt know its const when checking if vm leaked locals? idk
// const a = i64;

// static_array(i64, 5);

// TODO! this needs to be an error!!!
let h = fn(a: i64) (i64, i64) = (a, a);
fn call_any(f: Any) i64 = {
    f(1)
}
let r = call_any(h);
assert_eq(r, 1);

unused
}

// I've heard it said that quickly selfhosting leads to a language thats just good for writing compilers...
// that's exactly what I want. 

1234!comptime_print;
