@import(interp);

;;;;;;; // allow no op stmts at top level

fn main(_canary: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

/* }}}}} block comments are also a thing  */

/* /* }}} you can */ }}}} nest them */

// empty statements are allowed. 
;;;;;;;

{   };  // empty block treated as expression TODO: allow without ;

assert_eq(1, 1);  // assert_eq exists
const fff = fn(u: Unit) i64 = 15;
assert_eq(15, fff(unit));  // closure in a variable. 

assert_eq(1, /* hello */ 1);

// TODO: give an error for the ambigous case without the brackets. are you calling the block or the function?. i dont want to just pick a predidence 
//       blocks return values so theres never a reason to actually want to do this. 
assert_eq(25, (fn(u: Unit) i64 = { 25 })(unit));  // closure called inline
assert_eq(35, (fn() i64 = { 35 })());  // no arguments (not even Unit).
assert_eq(unit, (fn() Unit = { unit })()); // return unit
assert_eq(unit, (fn() Unit = { let x = 0; })());  // implicit trailing `unit`

/// simple_variables ///

assert_eq(5, (fn(n: i64) i64 = { let x = 10; n })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; x })(5));
assert_eq(25, (fn(n: i64) i64 = { let x = n; x })(25));
assert_eq(50, (fn(n: i64) i64 = { var x = n; x = 50; x })(5));
assert_eq(16, (fn(n: i64) i64 = { var x = n; x = add(1, add(add(x, x), n)); x })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; let y = x; y })(5));

let one: i64 = 1;  // variables can have type annotations 
assert_eq(one, 1);

/// simple if /// 

assert_eq(5, (fn(n: i64) i64 = {
    (eq(n, 1), fn() i64 = { 5 }, fn() i64 = { 10 })!if
})(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, (fn(n: int(unit)) int(unit) = { add(add(n, n), n) }) (5));

@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();

assert_eq(5, mod(15, 10));
assert_eq(2, mod(32, 3));

////////////////
/// Pointers ///
////////////////

var v = 10;
let ptr = v!addr;  // Get the adddress of v's stack slot
assert_eq(10, get(ptr));
v = 5;
assert_eq(5, get(ptr));  // writes though var observed by ptr
set(ptr, 15);
assert_eq(15, v); // writes though ptr observed by var
assert_eq(15, get(ptr));
assert_eq(raw_len(ptr), 1);  // v is not a tuple  // TODO: does this still make sense now that i have slices
assert_eq(false, is_uninit(ptr));  // there's a value in v

// It is legal to take pointer to uninitilized memory, as long as you write before you read. 
let bad: i64;
let bad_ptr = bad!addr;
assert_eq(true, is_uninit(bad_ptr));
set(bad_ptr, 1);  // initialize the memory 
assert_eq(false, is_uninit(bad_ptr));
assert_eq(get(bad_ptr), 1);  // now we can read it
assert_eq(bad, 1);

// You can pass functions pointers to your own stack. 
fn increment(ptr_arg: Ptr(i64)) = {
    let old = get(ptr_arg);
    set(ptr_arg, add(old, 1));
}

let m = 3;
increment(m!addr);
assert_eq(m, 4);

// TODO: this is broken by closures inlining everything. easy fix with @noinline
// The interpreter can catch some basic mistakes. 
fn mistake(i: i64) Ptr(i64) = {
    let my_value = add(i, i);
    my_value!addr  // oops, call frame went away
}
let very_bad_ptr = mistake(1);  // it is illegal to dereference this pointer 
// is_oob_stack: Only supported in the interp
assert_eq(true, is_oob_stack(very_bad_ptr));
assert_eq(false, is_oob_stack(very_bad_ptr!addr));

// You can take the address of function arguments. 
// TODO: want to pass by const reference if big so be careful about mutating (or disallow). 
fn twice(arg: i64) i64 = {
    let arg_ptr = arg!addr;
    mul(get(arg_ptr), 2)
}
let three = 3;
assert_eq(6, twice(three));

var a = 10;
var aa: Ptr(i64) = a!addr;
aa[] = 15;
assert_eq(a, 15);

{ aa[] = unit; }!assert_compile_error;  // typechecking

//////////////
/// Tuples ///
//////////////

let arr = (1, 2, 3);
let arr_ptr = arr!addr;
// a tuple isn't treated as one *thing*, you're pointing to a range of the stack containing three values
assert_eq(raw_len(arr_ptr), 3);  

// you can create a pointer to a sub-slice of a tuple
let second_ptr = raw_slice(arr_ptr, 1, 2);  // start at index 1, end before index 2
assert_eq(1, raw_len(second_ptr));  // pointing at one element
assert_eq(2, get(second_ptr)); // we can dereference as normal.
set(second_ptr, 123);
// TODO: length of slice as part of pointer type
// The type annotation for a tuple is written as a tuple of types. 
// TODO: comptime variadic functions so !deref is just get.
let have: (i64, i64, i64) = arr_ptr!deref;
let expected: (i64, i64, i64) = (1, 123, 3);
// assert_ eq(have, expected);
// asser t_eq(get(arr_ptr), (1, 123, 3)); // the type annotations are unnessisary 

// in fact, tuples aren't real at all. they're just the way i represent multiple arguments and return values 
fn flip_1(args: (i64, i64)) (i64, i64) = { 
    let arr = args!addr;
    let a1 = raw_slice(arr, 0, 1);
    let a2 = raw_slice(arr, 1, 2);
    (get(a2), get(a1))
}
//assert_ eq((3, 2), flip_1((2, 3)));
//assert_ eq((3, 2), flip_1(2, 3));
//assert_ eq(3, 2, flip_1(2, 3));

// Maybe this is a bit unfortunate. It doesnt care where the brackets go, just sees two pairs (a, b) (c, d)
//assert_ eq(2, flip_1(2, 2), 2);

// This is indistinguishable from flip_1.
fn flip_2(a: i64, b: i64) (i64, i64) = (b, a);
//assert_ eq((3, 2), flip_2((2, 3)));
//assert_ eq((3, 2), flip_2(2, 3));
//assert_ eq(3, 2, flip_2(2, 3));
//assert_ eq(2, flip_2(2, 2), 2);

let x = (1, 2);
// let (y, z) = x;

//////////////////
/// Allocation ///
//////////////////

// Use `alloc` to create space that outlives the current stack frame. 
fn dont_leak(size: i64) Ptr(i64) = alloc(i64, size);

let on_the_heap = dont_leak(10); 
assert_eq(raw_len(on_the_heap), 10);
let first = raw_slice(on_the_heap, 0, 1);
assert_eq(raw_len(first), 1);
// is_uninit: Only supported in the interp
assert_eq(true, is_uninit(first));
set(first, 15);
assert_eq(false, is_uninit(first));
assert_eq(get(first), 15);

let three_heap = raw_slice(on_the_heap, 0, 3);
let three_stack = (7, 8, 9);
// set(three_heap, three_stack);

// Don't need to pass count because its in the slice. 
dealloc(i64, on_the_heap);
// TODO: interpreter dealloc frees the value (if its a vec or whatever) but reference counts the allocation to catch use after free

/////////////////////
/// Lexical Scope ///
/////////////////////

let x = 5;
assert_eq(x, 5);
{  // Variables declared in a block shadow old ones
    let x = 10;
    {
        let x = 15;
        assert_eq(x, 15);
    };
    assert_eq(x, 10);
};  // but after the block you can see the old again. 
assert_eq(x, 5);

// Same in functions. 

let aaaa = 20;
const ttt = fn(n: i64) i64 = {
    let aaaa = 25;
    assert_eq(aaaa, 25);
    
    assert_eq(n, 35);
    let n = 30;  // You can shadow arguments, but now you can't get it back. 
    assert_eq(n, 30);
    n
};
assert_eq(30, ttt(35));
assert_eq(aaaa, 20);

// infact, you can shadow anything
let shadow = 40;
assert_eq(shadow, 40);
let shadow = 45;  // but the old one's gone forever. 
assert_eq(shadow, 45);

////////////////
/// Inlining ///
////////////////

// print_callstack: Only supported in the interp
@inline fn test_call_1(n: i64) i64 = {
    print(1);
    print_callstack(); 
    let important_value = add(n, 1);
    mul(important_value, 2)
}

@noinline fn test_call_2(n: i64) i64 = {
    print(2);
    print_callstack(); 
    let important_value = add(n, 1);
    mul(important_value, 2)
}

let important_value = 42;
assert_eq(test_call_1(2), 6);
assert_eq(important_value, 42);  // Inlining doesn't stomp variables
assert_eq(test_call_2(2), 6);
assert_eq(important_value, 42);  // Trivial

let x = 10;
assert_eq(x!type, i64);
let xa = x!addr;
// TODO: you can't directly pass the argument because it wont relize its a constexpr
const int_ptr = Ptr(i64);
assert_eq(xa!type, int_ptr);

// I'm not sure I like this. 
// side effects of expressions in macros don't run. 
// but at least it's consistant and theres a special symbol to tell you when its happening. 
// its not as bad as `size_of(blow_up_moon()`
// for `!addr` to be initiative it needs to put you in magic place expression mode 
// so a chain isnt actually copying everything out of the pointers on to the stack to compute an offset. 
// TODO: this should be a compile error. no side effects in macros that dont want them. 
fn do_side_effect(to: Ptr(i64)) bool = {
    let the = 1234;
    set(to, the);
    true
}
let my_secret_value = 5;
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value!addr)!type, bool);
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value!addr), true);
assert_eq(my_secret_value, 1234);

//////////////////////////////
/// Inspecting Compilation ///
//////////////////////////////

{
    print(this_is_not_the_var_youre_looking_for);
}!assert_compile_error;

// TODO: with my new overload stuff, this fully crashes instead of the nice compile error stuff? 
// { fn hello(n: this_too()) this_too() = { n } }!assert_compile_error;

// Note: this doesn't mess up the vm state. Make sure you keep it that way. 
{
     { let valid = x; }!assert_compile_error;  // this assertion fires
}!assert_compile_error;  // and is caught here

// {  // TODO: no comptime call at runtime
//    let int_ptr = Ptr(i64);
// }!assert_compile_error;
// TODO: specify the reson for the error so its not accidently passing. 

{ let bad; }!assert_compile_error;  // Uninit vars require type annotation. 

// TODO: this doesnt work because it doesnt know its const when checking if vm leaked locals? idk
// const a = i64;

// static_array(i64, 5);

{
    let h = fn(a: i64) (i64, i64) = (a, a);
    fn call_any(f: Any) i64 = {
        f(7)
    }
    let r = call_any(h);
}!assert_compile_error;

/////////////
/// While ///
/////////////

var a = 0;
(fn() bool = { lt(a, 3) }, fn() Unit = { a = add(a, 1); })!while;
assert_eq(a, 3);


///////////////
/// Strings ///
///////////////

let s = "hello";
assert_eq(raw_len(s), 5);

_canary
}

// I've heard it said that quickly selfhosting leads to a language thats just good for writing compilers...
// that's exactly what I want. 

1234!comptime_print;
