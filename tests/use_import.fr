fn use_on_function() void #test = {
    MyUsefulNamespace :: fn() = {
        a :: 123;
        b :: 456;
    };
    
    use_something();
    use_something :: fn() void #use(MyUsefulNamespace) = {
        assert_eq(a, 123);
        {
            a := 10;
            assert_eq(a, 10);
            assert_eq(b, 456);
        };
        assert_eq(a, 123);
        assert_eq(a, 123);
    };
    
    Cfg :: import("{ foo :: 17; };");
    
    get_foo :: fn() i64 #use(Cfg) = {
        foo
    };
    
    assert_eq(Cfg.foo, 17);
    assert_eq(get_foo(), 17);
    assert_eq(Cfg.foo, 17);
}

fn use_stmt_level() void #test = {
    Foo :: fn() = {
        a :: 5;
    };
    
    // Easier case is when the thing being used is not in the same function as the #use. 
    foo :: fn() void = {
        #use(Foo);
        assert_eq(a, 5);
    };
    foo();
    
    // Should be just as easy as the above... right? right? 
    // (new one just to make sure it doesn't cheat by having been used before)
    Bar :: fn() = {
        a :: 7;
    };
    {
        #use(Bar);
        assert_eq(a, 7);
    };
    
    // same thing but with a struct instead of a function
    TypeNamespace :: @struct(
        c :: 4,
    );
    {
        #use(TypeNamespace);
        assert_eq(c, 4);
    };
}

// #reexport means `pub use`
fn chained_use() void #test = {
    // simpile chaining reexport
    {
        A :: fn() = {
            a :: 5;
        };
        B :: fn() = {
            #reexport(A);
            b :: 5;
        };
        {
            #use(B);
            //assert_eq(c, 5);
            assert_eq(a, 5);
        };
    };
    
    // mutually recursive. don't get stuck in a loop!
    {
        A :: fn() = {
            #reexport(B);
            a :: 8;
        };
        B :: fn() = {
            #reexport(A);
            
            b :: 1;
        };
        {
            #use(B);
            assert_eq(a, 8);
            assert_eq(b, 1);
        };
    };
}
