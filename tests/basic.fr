;;;;;;; // allow no op stmts at top level

fn main(_canary: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

/* }}}}} block comments are also a thing  */

/* /* }}} you can */ }}}} nest them */

// empty statements are allowed. 
;;;;;;;

{   };  // empty block treated as expression TODO: allow without ;

assert_eq(1, 1);  // assert_eq exists
const fff = fn(u: Unit) i64 = 15;
assert_eq(15, fff(unit));  // closure in a variable. 

assert_eq(1, /* hello */ 1);

// TODO: give an error for the ambigous case without the brackets. are you calling the block or the function?. i dont want to just pick a predidence 
//       blocks return values so theres never a reason to actually want to do this. 
assert_eq(25, (fn(u: Unit) i64 = { 25 })(unit));  // closure called inline
assert_eq(35, (fn() i64 = { 35 })());  // no arguments (not even Unit).
assert_eq(unit, (fn() Unit = { unit })()); // return unit
assert_eq(unit, (fn() Unit = { let x = 0; })());  // implicit trailing `unit`

/// Binary Literals (useful for low level binary formats) ///
assert_eq(@as(i64) 0b101, 5);
assert_eq(@as(i64) 0b0000010100, 20);
assert_eq(@as(i64) 0x5, 5);
assert_eq(@as(i64) 0xF, 15);
assert_eq(@as(i64) 0xFF, 255);
assert_eq(@as(i64) 0x0F0, 240);

/// simple_variables ///

assert_eq(5, (fn(n: i64) i64 = { let x = 10; n })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; x })(5));
assert_eq(25, (fn(n: i64) i64 = { let x = n; x })(25));
assert_eq(50, (fn(n: i64) i64 = { var x = n; x = 50; x })(5));
assert_eq(16, (fn(n: i64) i64 = { var x = n; x = add(1, add(add(x, x), n)); x })(5));
assert_eq(10, (fn(n: i64) i64 = { let x = 10; let y = x; y })(5));

let one: i64 = 1;  // variables can have type annotations 
assert_eq(one, 1);

/// simple if /// 

assert_eq(5, (fn(n: i64) i64 = {
    (eq(n, 1), fn() i64 = { 5 }, fn() i64 = { 10 })!if
})(1));

let five = (true, fn() i64 = 5, fn() i64 = 10)!if;
assert_eq(5, five);
// asser t_eq(5, (true, fn() i64 = 5, fn() i64 = 5)!if);  // TODO: doesnt parse right somehow?

// infer types
let five = (true, fn() = 5, fn() = 10)!if;
assert_eq(5, five);

/// call_in_type_annotation ///

fn get_int(u: Unit) Type = { i64 }
assert_eq(15, (fn(n: get_int(unit)) get_int(unit) = { add(add(n, n), n) }) (5));

/*  // TODO: track for asm
@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    asser t_eq(c, false);
    1
};

let a = rt();
*/

assert_eq(5, mod(15, 10));
assert_eq(2, mod(32, 3));

// I live in fear of the condition code encoding.
assert_eq(false, eq(2, 3));
assert_eq(true, eq(3, 3));
assert_eq(true, ne(2, 3));
assert_eq(false, ne(3, 3));
assert_eq(false, ge(2, 3));
assert_eq(true, ge(3, 2));
assert_eq(true, ge(3, 3));
assert_eq(false, le(3, 2));
assert_eq(true, le(3, 3));
assert_eq(true, le(2, 3));
assert_eq(true, lt(2, 3));
assert_eq(false, lt(3, 3));
assert_eq(false, lt(3, 2));
assert_eq(false, gt(2, 3));
assert_eq(false, gt(3, 3));
assert_eq(true, gt(3, 2));

assert_eq(neg(5), mul(5, neg(1)));
assert_eq(true, eq(neg(5), mul(5, neg(1))));
assert_eq(false, eq(5, mul(5, neg(1))));
assert_eq(1, mul(neg(1), neg(1)));

////////////////
/// Pointers ///
////////////////

var v = 10;
let ptr = v&;  // Get the adddress of v's stack slot
assert_eq(10, ptr[]);
v = 5;
assert_eq(5, ptr[]);  // writes though var observed by ptr
ptr[] = 15;
assert_eq(15, v); // writes though ptr observed by var
assert_eq(15, ptr[]);

// TODO: fn default() T; fn undefined() T; and fn zeroed() T; instead of allowing implicitly uninitialized variables.
// It is legal to take pointer to uninitilized memory, as long as you write before you read. 
/* TODO: need undefined() for asm because otherwise it doesnt know to give it stack space
var bad: i64;
let bad_ptr = bad&;
bad_ptr[] = 1;  // initialize the memory
asser t_eq(bad_ptr[], 1);  // now we can read it
asser t_eq(bad, 1);
*/

// You can pass functions pointers to your own stack. 
fn increment(ptr_arg: Ptr(i64)) = {
    let old = ptr_arg[];
    ptr_arg[] = add(old, 1);
}

var m = 3;
increment(m&);
assert_eq(m, 4);


// TODO: this is broken by closures inlining everything. easy fix with @noinline
// The interpreter can catch some basic mistakes. 
fn mistake(i: i64) Ptr(i64) = {
    var my_value = add(i, i);
    my_value&  // oops, call frame went away
}
var very_bad_ptr = mistake(1);  // it is illegal to dereference this pointer

// is_oob_stack: Only supported in the interp
// TODO: asm could check against the stack pointer i guess?
// asser t_eq(true, is_oob_stack(very_bad_ptr));
// asser t_eq(false, is_oob_stack(very_bad_ptr&));

// You can take the address of function arguments. 
// TODO: want to pass by const reference if big so be careful about mutating (or disallow). 

fn twice(arg: i64) i64 = {
    let arg_ptr = arg&;
    mul(arg_ptr[], 2)
}
let three = 3;
assert_eq(6, twice(three));

var a = 10;
var aa: Ptr(i64) = a&;
aa[] = 15;
assert_eq(a, 15);

{ aa[] = unit; }!assert_compile_error;  // typechecking

/////////////////////
/// Lexical Scope ///
/////////////////////

let x = 5;
assert_eq(x, 5);
{  // Variables declared in a block shadow old ones
    let x = 10;
    {
        let x = 15;
        assert_eq(x, 15);
    };
    assert_eq(x, 10);
};  // but after the block you can see the old again. 
assert_eq(x, 5);

// Same in functions. 

let aaaa = 20;
const ttt = fn(n: i64) i64 = {
    let aaaa = 25;
    assert_eq(aaaa, 25);
    
    assert_eq(n, 35);
    let n = 30;  // You can shadow arguments, but now you can't get it back. 
    assert_eq(n, 30);
    n
};
assert_eq(30, ttt(35));
assert_eq(aaaa, 20);

// infact, you can shadow anything
let shadow = 40;
assert_eq(shadow, 40);
let shadow = 45;  // but the old one's gone forever. 
assert_eq(shadow, 45);

////////////////
/// Inlining ///
////////////////

@inline fn test_call_1(n: i64) i64 = {
    //print(1);
    let important_value = add(n, 1);
    mul(important_value, 2)
}

@noinline fn test_call_2(n: i64) i64 = {
    //print(2);
    let important_value = add(n, 1);
    mul(important_value, 2)
}

let important_value = 42;
assert_eq(test_call_1(2), 6);
assert_eq(important_value, 42);  // Inlining doesn't stomp variables
assert_eq(test_call_2(2), 6);
assert_eq(important_value, 42);  // Trivial


var x = 10;
assert_eq(x!type, i64);
let xa = x&;
// TODO: you can't directly pass the argument because it wont relize its a constexpr
const int_ptr = Ptr(i64);
assert_eq(xa!type, int_ptr);

// I'm not sure I like this. 
// side effects of expressions in macros don't run. 
// but at least it's consistant and theres a special symbol to tell you when its happening. 
// its not as bad as `size_of(blow_up_moon()`
// for `&` to be initiative it needs to put you in magic place expression mode 
// so a chain isnt actually copying everything out of the pointers on to the stack to compute an offset. 
// TODO: this should be a compile error. no side effects in macros that dont want them. 
fn do_side_effect(to: Ptr(i64)) bool = {
    let the = 1234;
    to[] = the;
    true
}
var my_secret_value = 5;
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value&)!type, bool);
assert_eq(my_secret_value, 5);
assert_eq(do_side_effect(my_secret_value&), true);
assert_eq(my_secret_value, 1234);

//////////////////////////////
/// Inspecting Compilation ///
//////////////////////////////

{
    print(this_is_not_the_var_youre_looking_for);
}!assert_compile_error;

// TODO: with my new overload stuff, this fully crashes instead of the nice compile error stuff? 
// { fn hello(n: this_too()) this_too() = { n } }!assert_compile_error;

// Note: this doesn't mess up the vm state. Make sure you keep it that way. 
{
     { let valid = x; }!assert_compile_error;  // this assertion fires
}!assert_compile_error;  // and is caught here

// {  // TODO: no comptime call at runtime
//    let int_ptr = Ptr(i64);
// }!assert_compile_error;
// TODO: specify the reson for the error so its not accidently passing. 

{ let bad; }!assert_compile_error;  // Uninit vars require type annotation. 

// TODO: this doesn't work if its 'a' because its shadowed in the !assert_compile_error and that confuses some debug check I'm doing.
const z = i64;
fn hi(z: bool) = ();  // this shadows but its fine.
hi(false);

// static_array(i64, 5);

///////////////////

// TODO: fix overload collission error reporting when you name this 'hello'
fn thing(one: i64, two: i64) i64 = add(one, two);
assert_eq(thing(1, 2), 3);
assert_eq(thing((1, 2)), 3);
let aaaa = (1, 2);
assert_eq(thing(aaaa), 3);
let three = (fn(one: i64, two: i64) i64 = add(one, two))(aaaa);
assert_eq(three, 3);
assert_eq((fn(one: i64, two: i64) i64 = add(one, two))(aaaa), 3);


// While
var a = 0;
(fn() bool = { lt(a, 3) }, fn() Unit = { a = add(a, 1); })!while;
assert_eq(a, 3);

// Recursion TODO
/*
fn fib(n: i64) i64 = {
    (le(n, 1),
        fn() i64 = 1,  // TODO: make vm properly Drop the unit arg without ().
        fn() i64 = add(fib(sub(n, 1)), fib(sub(n, 2))),
    )!if
}
asse rt_eq(fib(5), 8);
*/

// You can do named arguments
fn hello(a: i64, b: i64) i64 = div(a, b);
assert_eq(hello(6, 3), 2);  // It's just a normal function, you can still pass positionally.
assert_eq(hello(a: 6, b: 3), 2);  // But you can also repeat the names at the call-site.
assert_eq(hello(b: 3, a: 6), 2);  // When all arguments are passed by name, the order doesn't matter.

/////
// Dot syntax for function calls. Not dynamic dispatch. 
// TODO: think about precidence. see devlog Mar-15. 

assert_eq(3, 1.add(2));  // this, 
assert_eq(3, add(1, 2)); // desugars to this. 

fn twice2(n: i64) i64 = mul(n, 2);
assert_eq(6, 3.twice2());

fn adds(a: i64, b: i64, c: i64) i64 = a.add(add(b, c));
let n = 1;
assert_eq(6, n.adds(2, 3));

/////
// Constant folding for conditional compilation. 
// If the condition wasn't const known, these would be compile errors.
// Exhaustiveness of checking is more like Zig than like Rust. 

let _: Unit = (true, fn() = (), fn() = 123)!if;
(false, fn() = "hello".add(5), fn() = ())!if;
(true, fn() = (), fn() = this_var_does_not_exist)!if;
const compute_true = 1.gt(0);  // Currently you must explicitly declare more complex expressions const. 
(compute_true, fn() = (), fn() = no_compile_this_branch_pls)!if;

// Ifs stay constant if body is constant
((true, fn() = false, fn() = no_compile_me)!if,
     fn() = no_compile_me, fn()=())!if;

fn ret_1() i64 = 1;
let v = (true, ret_1, no_compile_me)!if; // TODO: make this work without the type binding
assert_eq(1, v);

// fn call in a branch works when not const cond. 
let t = true;
let v = (t, ret_1, fn() = 123)!if;
assert_eq(1, v);

_canary
}

1234!comptime_print;
