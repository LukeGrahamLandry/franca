
// this might just be the same as memcpy_wide_values? 
// but i dont think so cause that was fixed by inlining, 
// and switching to !if instead of fn if doesn't fix this even tho it always inlines. 
// and its a closure so would have to inline regardless. 
// gets a random pointer as the enum tag for a VarType. 
// UPDATE: not the same as memcpy_wide_values. fixed with basic block rework. -- May 6
#test 
fn call_if_in_unquote(canary: i64) i64 = {
    E :: @tagged(aaa: i64, bbb: Str);
    e : E = (aaa = 123);
    // note: the closure-ness here is not the problem, just to make the cases more clear
    broken :: fn() i64 => @get_tag(e);
    working :: fn() i64 => @get_tag(e&);
    assert_eq(broken(), 0);
    
    #macro 
    fn get_tag(var arg: FatExpr) FatExpr = {
        arg = compile_ast(arg);
        enum_type := arg.ty;
        info := get_type_info(enum_type);
        is_ptr := false;
        if(eq(info&!tag[], tag_value(TypeInfo, @symbol Ptr))){|
            enum_type = (@as(*Type) info.Ptr&)[];
            info = get_type_info(enum_type);
            is_ptr = true;
        };
        ptr_ty := *enum_type;
        
        ::if(FatExpr);
        '{
            var arg_val = @[if(is_ptr, =>'@as(void)unit', =>arg)];
            var arg_ptr = @[if(is_ptr, =>arg, => 'arg_val&')];
            let tag_val = arg_ptr!tag[];
            @as(i64) tag_val
        }'
    }

    canary
}

// need to add flat_call if ret is big early enough that you havent already emitted one before noticing. 
#test
fn mutual_rec_flat() = {
    fn do_1s(n: i64) Str = if(n.eq(2), => do_2s(n), => "one");
    fn do_2s(n: i64) Str = if(n.eq(1), => do_1s(n), => "two");
     
    do_1s(1);
}

/// - this started happening with my first rework to use stack bc (before basic blocks)
/// - Found with collections.fr:split, narrowed down to resizing a list. then to memcpy when something is larger than one slot. then to calling set. 
///   Worked when my_set is #inline but segfault if not. So its a spilling problem. 
/// - this was because of stack_to_ccall_reg leaving first registers on the stack as it worked on next so they'd get spilled in a weird way sometimes. 
///   like you want to assign x0 and its already in place so you move on but x0 is still on the stack, 
///   so if you need an extra free register later you think its ok to spill x0. -- May 8
/// - it was the same problem as mmap saying errno=22 after basic blocks change. 
///   for this example, it happened on wide values because they're passed in multiple registers to my_set. 
#test
fn memcpy_wide_values(canary: i64) i64 = {
    fn memcpy_wide_values() void = {
        T :: Str;
        S :: Slice(T);
        
        #noinline
        fn my_set(var self: S, i: i64, v: T) void = {
            self.index(i)[] = v; 
        }
        
        #noinline
        fn my_memcpy(dest: S, src: S) void = {
            var i = 0;
            while(=> lt(i, src.len())) {|
                src_ptr := src.index(i);
                dest.my_set(i, src_ptr[]);
                i = i.add(1);
            };
        }
    
        var a: S = ("a", "a")!slice;
        var b: S = ("b", "b")!slice;
        my_memcpy(a, b);
    }
    
    memcpy_wide_values();
    
    canary
}

/// :UnquotePlaceholders
/// it looks like this should work but unquote doesn't look in constants because they don't get renumbered. 
/// constants in that quote block act like constants in the macro body. 
/// there's no reason you shouldn't be able to make a macro that expands to constant declarations tho. 
/// so, unquote_macro_apply_placeholders needs to see the constant body and mutate it, 
/// so it needs to have already been renumbered by the time you get there. 
/// but also you need to not renumber inside the <placeholder>... unless you're actually renumbering the macro function itsel (like if its a closure for some reason).
/// in this example, you just need to worry about the first part. 
///
/// this was actually super easy to fix by delaying constant hoisting out of scope.rs and just doing it right before you try to compile each block. 
#test
fn unquote_in_const() = {
    #macro fn as_constant(arg: FatExpr) FatExpr = '{
        value :: @[arg];
        value
    }';
    
    four := @as_constant(4);
    assert_eq(four, 4);
    // now do it again with a different type, so there need to be two unrelated versions of the 'value' variable in different scopes!
    name := @as_constant("bob");
    assert_eq(true, eq(name, "bob"));
}

#test
fn const_closure_arg() = {
    a := 0;
    add_it :: fn(const n: i64) void => {
        a += n;
    };
    add_it(5);
    assert_eq(a, 5);
    add_it(10); // this will err re-save const if you didnt renumber. 
    assert_eq(a, 15);
    
    // These should be cached. 
    add_it(5);add_it(5);add_it(5);add_it(5);
}

// found with binary_op in lox/vm.fr
// the fix was making compile_call inline '=>' even without rt_captures. really i should track capturing control flow as well. 
#test fn capture_control_but_no_rt_vars() = {
    fn do_it(cond: bool) i64 = {
        return :: @return; 
        check_something(cond);
        check_something :: fn(n: bool) void => if(n){|
            return(123); 
        };
        456
    }
    do_it(true);
}

#test fn infer_enum_overload(canary: i64) i64 = {
    A :: @enum(hello, world);
    B :: @enum(hello, bye);
    
    fn do_stuff(self: i64, extra: A) i64 = self;
    fn do_stuff(self: bool, extra: B) i64 = 1;
    
    // We know arg is i64 so we should know we're calling the first one and that the second arg is A. 
    arg := 123;
    do_stuff(arg, .hello);
    
    canary
}

// - discovered when writing codemap :return_u32_pair
//   the var version works, but returning the struct directly doesn't. 
// - probably caused by trying to return pairs in registers (because it works if you #inline it), 
//   but idk why it would be different with the var.  
#test fn return_u32_pair() = {
    II :: @struct(a: u32, b: u32);
    
    through_var :: fn() II #noinline = {
        v: II = (a = @as(u32) 123.trunc(), b = @as(u32) 456.trunc());
        v
    };
    direct :: fn() II #noinline = {
        (a = @as(u32) 123.trunc(), b = @as(u32) 456.trunc())
    };
    
    ::assert_eq(u32);
    //v := through_var();
    //assert_eq(v.a, @as(u32) 123.trunc()); assert_eq(v.b, @as(u32) 456.trunc());
    v := direct();
    assert_eq(v.a, @as(u32) 123.trunc()); assert_eq(v.b, @as(u32) 456.trunc());
}

// When emitted to c, it has to know to take the whole cstr, not follow the pointer one byte. 
#test fn const_c_str() = {
    hello_c :: @symbol("Hello World").c_str();
    
    hello_s := hello_c.str();
    ::assert_eq(Str);
    assert_eq(hello_s, "Hello World");
}

#test fn single_element_struct(canary: i64) i64 = {
    MyStruct :: @struct(field: i64);

    value : MyStruct = (field = 123);
    v := value.field;
    assert_eq(v, 123);
    
    canary
}

#test fn const_typeof_var() = {
    a := 123;
    T :: @type(a);
    A :: @struct(b: Ptr(T));
    c : A = (b = a&);
    assert_eq(a, c.b[]);
}

#test fn const_typeof_var_block() = {
    a := 123;
    A :: @struct(b: {
        // Here we need to be able to access two different body contexts: 
        // the runtime one that knows the type of 'a' and the comptime one we're declaring 'T' into. 
        T := @type(a);
        Ptr(T)
    });
    c : A = (b = a&);
    assert_eq(a, c.b[]);
}

#test fn self_referencial_type() = {
    L :: (@struct(next: ?*L, data: i64))!rec; // TODO: fix the need for dumb brackets to parse
    
    fst: L = (next = (None = unit), data = 123);
}
