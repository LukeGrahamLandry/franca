//! Functions and types are first class values during compilation. 
//! That allows a simple (but verbose) form of generics without relying on the overloading system. 
//! This is not how the standard library generally defines its generic types. 

#test fn tuple_return() = {
    // TODO: better error message if you forget to put the #generic
    // TODO: fix needing to call Ty(_, _) to group the args. 
    #generic
    fn dup(const T: Type) Fn(T, Ty(T, T)) = {
        // TODO: without the leading '(' it treats it as a statement and gets mad that there's no name. 
        (fn(value: T) Ty(T, T) = (value, value))
    }
    
    // dont do this! i probably want tuples to have undefined layout. 
    #generic
    fn get_index(const T: Type) Fn(Ty(*Ty(T, T), i64), T) = {
        // TODO: without the leading '(' it treats it as a statement and gets mad that there's no name. 
        (fn(tuple: *Ty(T, T), i: i64) T = {
            tuple := raw_from_ptr(Ty(T, T), tuple);
            let start = mul(i,:: size_of(T));
            let ptr: rawptr = offset(tuple, start);
            ptr := ptr_from_raw(T, ptr);
            ptr[]
        })
    }
    
    
    const get_i = get_index(i64);
    const get_t = get_index(Type);
    
    const dup_i64 = dup(i64);
    var one_one = dup_i64(1);
    assert_eq(1, get_i(one_one!addr, 0));
    assert_eq(1, get_i(one_one!addr, 1));
    
    const dup_ty = dup(Type);
    var tt = dup_ty(void);
    /* // TODO: this doesn't'
    assert_eq(void, get_t(tt!addr, 0));
    assert_eq(void, get_t(tt!addr, 1));
    */
    
    @assert_compile_error dup_ty(1);
    @assert_compile_error dup_i64(void);
}

#test fn poly_struct() = {
    fn MySlice(const T: Type) Type = @struct(ptr: Ptr(T), len: i64);
    
    #generic
    fn get_first(const T: Type) @Fn(s: MySlice(T)) T = 
        (fn(var s: MySlice(T)) T = s.ptr[]);
    
    const i64_s = MySlice(i64);
    let things = temp().alloc(i64, 5);
    var a: i64_s = (ptr = things.ptr, len = 5);
    a.ptr[] = 12;
    const get_first_i64 = get_first(i64);
    assert_eq(get_first_i64(a), 12);
}

#test fn memo_instantiations(_canary: i64) i64 = {
    fn Either(const Left: Type, const Right: Type) Type = 
        @tagged(left: Left, right: Right);
    
    #generic
    fn is_left(const Self: Type) Fn(Self, bool) = 
        (fn(var self: Self) bool = eq(self&!tag[], tag_value(Self, @symbol left)));
    
    const E1 = Either(i64, Ptr(i64));
    let e1: E1 = (left = 15);
    const il1 = is_left(E1); // TODO: should be able to inline this and call any expr without the extra binding, even if its comptime.
    assert_eq(true, il1(e1));
    
    // types are memoized 
    assert_eq(Either(i64, Ptr(i64)), Either(i64, Ptr(i64)));
    assert_eq(E1, Either(i64, Ptr(i64)));  
    assert_eq(@type e1, Either(i64, Ptr(i64)));  
    assert_eq(@type e1, E1);  
    
    const E2 = Either(bool, i64);
    let e2: E2 = (left = false);
    const il2 = is_left(E2);
    assert_eq(true, il2(e2));
    assert_eq(@type e2, E2);
    
    _canary
}

#test fn nested_specialize(canary: i64) i64 = {
    fn two() void = unit;
    fn sum_size() void = unit;

    fn one(const A: Type) void = {
        // this needs the extra argument to disambiguate which version of 'one' you meant to call. 
        fn two(const B: Type, a: A) void = {
            fn sum_size(a: A, b: B) i64 = A.size_of().add(B.size_of());
        }
    }
    
    fn use() void = assert_eq(12, sum_size(i64, 1));
    
    // currently you need to make sure these instantiations get compiled before the uses of them. -- Apr 26
    // but it's not lexical so the 'fn use' above is fine because it doesn't get compiled until later. 
    ::one(i64);
    ::two(Type, 0);
    ::one(Type);
    ::two(i64, i64);
    
    assert_eq(12, sum_size(1, i64));
    use();
    
    canary
}

#test fn arg_generic_left_to_right() = {
    push_thing :: fn(const Entry: Type, self: *List(Entry), v: Entry) void #generic = self.push(v);
    arr: List(i64) = list(temp());
    i64.push_thing(arr&, 123);
    i64.push_thing(arr&, 456);
    i64.push_thing(arr&, 789);
    
    arr: List(Type) = list(temp());
    Type.push_thing(arr&, void);
    Type.push_thing(arr&, i64);
}

#test fn generic_closure() = {
    count := 0;
    sum_len_get_first :: fn(const T: Type, arr: Slice(T)) T #generic => {
        count += arr.len();
        arr[0]
    };
    ::assert_eq(Str);
    v := i64.sum_len_get_first((1, 2, 3)!slice);
    assert_eq(1, v);
    v := Str.sum_len_get_first(("a", "b")!slice);
    assert_eq("a", v);
    assert_eq(count, 5);
}

// Here it needs to know the return type of the get_first call to resolve which assert_eq overload is being called. 
//#test fn generic_call_in_arg() = {
//    get_first :: fn(const T: Type, arr: Slice(T)) T #generic = arr[0];
//    assert_eq(1, i64.get_first((1, 2, 3)!slice));
//}

// idea
//#test fn match_type() = {
//    fn push_thing(self: *List($T), v: T) void = self.push(v);
//    arr: List(i64) = list();
//    arr&.push_thing(123);
//}

#test fn const_field() = {
    S :: @struct(a: i64, const b := bool);
    
    s: S = (a = 123);
    assert_eq(s.a, 123);
    assert_eq(s.b, bool);
    
    // You can also access it on the type. 
    assert_eq(S.b, bool);
    
    // Since its constant, you can use types.
    bb: S.b = true;
    bbb :: S.b;
}

#test fn generic_args_sum() = {
    // TODO: put this in the lib so the docs example works? 
    fn zero() i64 = 0;
    fn zero() f64 = 0.0;
    
    // Requires overloads for `fn zero() T` and `fn add(T, T) T`
    sum :: fn(const T: Type, lst: Slice(T)) T #generic = {
        n: T = zero();
        for(lst, fn(x) => { n += x; });
        n
    };
    
    assert_eq(6, i64.sum((1, 2, 3)!slice));
    assert_eq(6.0, f64.sum((1.0, 2.0, 3.0)!slice));
}