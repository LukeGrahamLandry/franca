fn main(_input: i64) i64 = {

// const Person = Struct(.{
//     age: i64,
//     gender: i64,
// });
// asser t_eq(Thing!type, Type);

// @struct Animal = .{
//     owner: Person,
//     whiskers: bool,
// };
// asser t_eq(Animal!type, Type);

// {  // A raw map literal is illegal if the compiler can't infer a type. 
//     const Thing = .{
//         legs: i64,
//     };
// }!assert_compile_error;

// Create a struct from a map literal. 
// var bob: Person = .{
//     age: 24,
//     gender: 42,
// };
// asser t_eq(bob!type, Person);

// dot syntax for accessing fields. 
// asser t_eq(bob.age, 24);
// asser t_eq(bob.gender, 42);
// let next_year = add(bob.age, 1);
// bob.age = next_year;
// asser t_eq(bob.age, 25);
// asser t_eq(bob.gender, 42);

// Structs are passed by copy (or probably const pointer if you don't mutate)
// fn mutate_copy(who: Person) Unit = {
//     who.age = 99;
// }
// mutate_copy(bob);
// asser t_eq(bob.age, 25);

// Pass a pointer if you want to mutate the original. 
// Now field accesses give you pointers that you have to dereference to use. 
// fn mutate_real(who: Ptr(Person)) Unit = {
//     asser t_eq(who!type, Ptr(i64));
//     set(who.age, 99);
// }
// mutate_real(bob!addr);
// asser t_eq(bob.age, 99);

// {  // no implicitly created references. this isnt c++. 
//     mutate_real(bob);
// }!assert_compile_error;

// I like this one because it fits well with the macro system I'm imagining. But it looks pretty ugly. 
// @match({ let age; let gender; }, bob);

// @let({ age, gender }, bob);

// This looks better but im kinda meh about adding new syntax. 
// let { age, gender } = bob; 

// {  // relying on field order is probably a bad idea. 
//     let (age, gender) = bob;
// }!assert_compile_error;

_input
}
