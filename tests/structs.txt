@import(interp);

fn main(_canary: i64) i64 = {

const Person = .{
     age: i64,
     gender: i64,
}!struct;
assert_eq(Person!type, Type);

// Create a struct from a map literal. 
var bob: Person = .{
     age: 24,
     gender: 42,
};
assert_eq(bob!type, Person);

// dot syntax for computing field offsets. 
// Note: it returns a ptr to the field, not the value of the field. 
let age_ptr: Ptr(i64) = bob.age; 
assert_eq(24, bob.age[]);
assert_eq(42, bob.gender[]);
let next_year = add(bob.age[], 1);
bob.age[] = next_year;
assert_eq(bob.age[], 25);
assert_eq(bob.gender[], 42);

// Composition
const Animal = .{
    owner: Person,
    whiskers: bool,
}!struct;
assert_eq(Animal!type, Type);

var cat: Animal = .{
    owner: bob,  // This is a copy of bob.
    whiskers: true,
};
assert_eq(cat.whiskers[], true);
let bob_again: Ptr(Person) = cat.owner;
assert_eq(bob_again.age[], 25);
assert_eq(cat.owner.gender[], 42);  // Auto deref for chained place expressions. 

// Structs are value types. 
bob_again.age[] = 99;
assert_eq(bob_again.age[], 99);
assert_eq(bob.age[], 25);  // The original has not been mutated. 

// `!deref` or `[]` can load a whole struct from a pointer at once. 
// TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
var bob_part_three: Person = cat.owner[];  // This is a copy
bob_part_three.age[] = 5;
assert_eq(bob_part_three.age[], 5);
assert_eq(cat.owner.age[], 99);

// Structs can contain pointers. 
const House = .{
    tax_payer: Ptr(Person),
    pet: Ptr(Animal),
}!struct;
assert_eq(Animal!type, Type);

// Note: this example aliases bob_again. Good luck compiling to rust :)
var tent: House = .{
    tax_payer: cat.owner,
    pet: cat!addr
};
assert_eq(tent!type, House);
assert_eq(tent.pet.owner.age[], 99);
tent.pet.owner.age[] = 55;  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
assert_eq(tent.pet.owner.age[], 55);
assert_eq(tent.tax_payer.age[], 55);
assert_eq(bob_again.age[], 55);
assert_eq(bob.age[], 25);  // OG bob is still just chillin

let mouse: Animal = .{
    owner: .{ 
        age: 17,
        gender: 314,
    },
    whiskers: true,
};
// struct 'var's can be reassigned
// No type annotation needed because it remembers. 
tent = .{
    tax_payer: bob!addr,
    pet: mouse!addr,
};



{ tent = mouse; }!assert_compile_error;  // type check

let a = 1;
a.hello!assert_compile_error;  // Field names are type checked. 

// TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
// TODO: Struct declarations are always const.
// { let Thing: Type = .{ legs: i64, }!struct; }!assert_compile_error;

// TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
// {  // A raw map literal is illegal if the compiler can't infer a type. 
// const Thing = .{
//    legs: i64,
// }; }!assert_compile_error;

// Structs are passed by copy (or probably const pointer if you don't mutate)
fn mutate_copy(who: Person) Unit = {
    set(who.age, 11);
}
assert_eq(bob.age[], 25);
mutate_copy(bob);
assert_eq(bob.age[], 25);

// Pass a pointer if you want to mutate the original. 
// TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
fn mutate_real(who: Ptr(Person)) Unit = {
    set(who.age, 11);
}
assert_eq(bob.age[], 25);
mutate_real(bob!addr);
assert_eq(bob.age[], 11);

// TODO: no field mutation through a 'let'

// no implicitly created references. this isnt c++. 
mutate_real(bob)!assert_compile_error;

@comptime
fn Option(T: Type) Type = {
    let E: Type = .{ Some: T, None: Unit }!enum;
    E
}

const Maybe_i64 = Option(i64);

let yes: Maybe_i64 = .{ Some: 12 };
let no: Maybe_i64 = .{ None: unit };

assert_eq(yes!type, no!type);  // same type even with different payloads

// You can manually check the tag if you try hard enough. 
// It's illegal to access a non-active field. 
assert_eq(yes!tag[], tag_value(Maybe_i64, Some!symbol));
assert_eq(no!tag[], tag_value(Maybe_i64, None!symbol));

// Like structs, dot syntax is a place expression. 
// It's illegal to access a non-active field. // TODO: be able to !assert_runtime_error
assert_eq(yes.Some[], 12);  
assert_eq(no.None[], unit);

_canary
}
