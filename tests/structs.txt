fn main(_input_s: i64) i64 = {

const Person = .{
     age: i64,
     gender: i64,
}!struct;
assert_eq(Person!type, Type);

// Create a struct from a map literal. 
var bob: Person = .{
     age: 24,
     gender: 42,
};
assert_eq(bob!type, Person);

// dot syntax for computing field offsets. 
// Note: it returns a ptr to the field, not the value of the field. 
let age_ptr: Ptr(i64) = bob.age; 
assert_eq(24, get(bob.age));
assert_eq(42, get(bob.gender));
let next_year = add(get(bob.age), 1);
set(bob.age, next_year);
assert_eq(get(bob.age), 25);
assert_eq(get(bob.gender), 42);

// Composition
const Animal = .{
    owner: Person,
    whiskers: bool,
}!struct;
assert_eq(Animal!type, Type);

var cat: Animal = .{
    owner: bob,  // This is a copy of bob.
    whiskers: true,
};
assert_eq(get(cat.whiskers), true);
let bob_again: Ptr(Person) = cat.owner;
assert_eq(get(bob_again.age), 25);
assert_eq(get(cat.owner.gender), 42);  // Auto deref for chained place expressions. 

// Structs are value types. 
set(bob_again.age, 99);
assert_eq(get(bob_again.age), 99);
assert_eq(get(bob.age), 25);  // The original has not been mutated. 

// !deref can load a whole struct from a pointer at once. 
// TODO: this should just be the same as get() but that's not using generics yet so can only do scalars. 
var bob_part_three: Person = cat.owner!deref;  // This is a copy
set(bob_part_three.age, 5);
assert_eq(get(bob_part_three.age), 5);
assert_eq(get(cat.owner.age), 99);

// Structs can contain pointers. 
const House = .{
    tax_payer: Ptr(Person),
    pet: Ptr(Animal),
}!struct;
assert_eq(Animal!type, Type);

// Note: this example aliases bob_again. Good luck compiling to rust :)
var tent: House = .{
    tax_payer: cat.owner,
    pet: cat!addr
};
assert_eq(tent!type, House);
assert_eq(get(tent.pet.owner.age), 99);
set(tent.pet.owner.age, 55);  // Raw pointers can lead to spooky action at a distance... then again so can gc-ed pointers
assert_eq(get(tent.pet.owner.age), 55);
assert_eq(get(tent.tax_payer.age), 55);
assert_eq(get(bob_again.age), 55);
assert_eq(get(bob.age), 25);  // OG bob is still just chillin

let mouse: Animal = .{
    owner: .{ 
        age: 17,
        gender: 314,
    },
    whiskers: true,
};
// struct 'var's can be reassigned
// No type annotation needed because it remembers. 
tent = .{
    tax_payer: bob!addr,
    pet: mouse!addr,
};



{ tent = mouse; }!assert_compile_error;  // type check

let a = 1;
a.hello!assert_compile_error;  // Field names are type checked. 

// TODO: same lexical sanity check for assert_compile_error as asser t_eq (just use the word assert). 
// TODO: Struct declarations are always const.
// { let Thing: Type = .{ legs: i64, }!struct; }!assert_compile_error;

// TODO: assert_compile_error of consts doesnt work because they get hoisted out of the block. 
// {  // A raw map literal is illegal if the compiler can't infer a type. 
// const Thing = .{
//    legs: i64,
// }; }!assert_compile_error;

// Structs are passed by copy (or probably const pointer if you don't mutate)
fn mutate_copy(who: Person) Unit = {
    set(who.age, 11);
}
assert_eq(get(bob.age), 25);
mutate_copy(bob);
assert_eq(get(bob.age), 25);

// Pass a pointer if you want to mutate the original. 
// TODO: maybe field access should just maintain you the same level of indirection instead of always being pointers. 
fn mutate_real(who: Ptr(Person)) Unit = {
    set(who.age, 11);
}
assert_eq(get(bob.age), 25);
mutate_real(bob!addr);
assert_eq(get(bob.age), 11);

// TODO: no field mutation through a 'let'

// no implicitly created references. this isnt c++. 
mutate_real(bob)!assert_compile_error;

// I like this one because it fits well with the macro system I'm imagining. But it looks pretty ugly. 
// @match({ let age; let gender; }, bob);

// @let({ age, gender }, bob);

// This looks better but im kinda meh about adding new syntax. 
// let { age, gender } = bob; 

// {  // relying on field order is probably a bad idea. 
//     let (age, gender) = bob;
// }!assert_compile_error;
; ;
_input_s
}
