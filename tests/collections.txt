@import(interp);

// fn split(haystack: Str, needle: Str) Ptr(Str);

// TODO: fix scope resolution for generics 
fn list() Unit = {unit};
fn push() Unit = {unit};
fn items() Unit = {unit};
fn drop() Unit = {unit};
fn addr() Unit = {unit};

// TODO: scope resolution for recursion. 
fn memcpy() Unit = {unit};

fn max(a: i64, b: i64) i64 = {
    (lt(a, b), fn()=b, fn()=a)!if
}

fn assert(cond: bool, msg: Str) Unit = (cond, fn()=(), fn()=panic(msg))!if;

@comptime fn List(T: Type) Type = {
    const Self: Type = .{ maybe_uninit: Ptr(T), len: i64 }!struct;
    // TODO: it doesnt realize that arguments are const if its @comptime, 
    //       so it thinks fn vec runtime captures T so it uses emit_capturing_call
    //       which doesn't handle constants in general yet (and is wrong here regardless)
    const T = T;
    
    fn get(self: Ptr(T), i: i64) T = {
        assert(lt(i, len(self)), "OOB");
        slice(self, i, add(i, 1))[]
    }
    
    fn set(self: Ptr(T), i: i64, v: T) Unit = {
        assert(lt(i, len(self)), "OOB");
        slice(self, i, add(i, 1))[] = v
    }
    
    fn subslice(ptr: Ptr(T), first: i64, count: i64) Ptr(T) = {
        slice(ptr, first, add(first, count))
    }
    
    // you don't need loops if your computer has infinite memory :)
    fn memcpy(dest: Ptr(T), src: Ptr(T)) Unit = { 
        (gt(len(dest), 0), fn()={
            let v = get(src, 0);
            set(dest, 0, v);
            (gt(len(dest), 1), fn()={  // TODO: it doesnt let you make an empty slice. 
                memcpy(subslice(dest, 1, sub(1, len(src))), subslice(src, 1, sub(1, len(src))));
            }, fn()=())!if;
        }, fn()=())!if
    }

    fn list(cap: i64) Self = {
        let self: Self = .{ maybe_uninit: alloc(T, cap), len: 0 };
        self  // TODO: infer from return type so this can be one expression
    }
    
    fn items(self: Ptr(Self)) Ptr(T) = {
        slice(self.maybe_uninit[], 0, self.len[])
    }
    
    fn addr(self: Ptr(Self), i: i64) Ptr(T) = {
        subslice(self.maybe_uninit[], i, 1)
    }
    
    fn reserve(self: Ptr(Self), extra: i64) Unit = {
        let total = add(self.len[], extra);
        let old_cap = len(self.maybe_uninit[]);
        (lt(old_cap, total), fn() = {
            let cap = max(max(add(old_cap, extra), mul(old_cap, 2)), 4);
            var new: Self = list(cap);
            let dest = subslice(new.maybe_uninit[], 0, self.len[]);
            memcpy(dest, self.maybe_uninit[]);
            new.len[] = self.len[];
            drop(self);
            self[] = new;
        }, fn()=())!if
    }
    
    fn push(self: Ptr(Self), v: T) = {
        reserve(self, 1);
        let last = slice(self.maybe_uninit[], self.len[], add(self.len[], 1)); 
        last[] = v;
        self.len[] = add(self.len[], 1);
    }
    
    fn drop(self: Ptr(Self)) = dealloc(T, self.maybe_uninit[]);
    
    Self
}

fn main(_canary: i64) i64 = {
    var v: List(i64) = list(1);
    assert_eq(len(v.maybe_uninit[]), 1);
    push(v!addr, 6);  // TODO: fix error message for missing !addr from being ""abbigous call", thats not true, its not declared func
    assert_eq(len(v.maybe_uninit[]), 1);
    push(v!addr, 8);
    assert_eq(len(v.maybe_uninit[]), 4);
    push(v!addr, 9);
    assert_eq(v.len[], 3);
    assert_eq(len(v.maybe_uninit[]), 4);
    assert_eq(addr(v!addr, 0)[], 6);
    assert_eq(addr(v!addr, 1)[], 8);
    assert_eq(addr(v!addr, 2)[], 9);
    drop(v!addr);
    
    _canary
}
 