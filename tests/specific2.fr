// TODO: ! the only reason this is in a different file is because i cant actually specify different targets with my hack. 

@hacktest(interp, aarch64)
fn fields(c: i64) i64 = {
    fn inner(n: i64) i64 = {
        const A = (a: i64, b: i64)!struct;
        var a: A = (a: n, b: 0);
        a&.b[] = add(a&.a[], 7);
        a&.b[]
    }
    
    assert_eq(inner(3), 10);
    c
}

@hacktest(interp, aarch64)
fn varient(c: i64) i64 = {
    fn inner(n: i64) i64 = {
        const A = (a: i64, b: i64)!enum;
        var a: A = (a: n);
        add(a&.a[], 7)
    }
    
    assert_eq(inner(3), 10);
    c
}

// Requires being able to write constant heap values.
@hacktest(interp, aarch64)
fn use_str(c: i64) i64 = {
    let s: Str = "hello";
    assert_eq(len(s), 5);
    c
}

@hacktest(interp, aarch64)
fn nested_struct(canary: i64) i64 = {
    const A = (a: i64, b: i64)!struct;
    const B = (fst: A, snd: i64)!struct;
    
    assert_eq(A.size_of(), i64.size_of().mul(2));
    assert_eq(B.size_of(), i64.size_of().mul(3));
    
    let f: A = (a: 1, b: 2);
    var thing: B = (fst: f, snd: 3);
    
    let c = thing&.snd[];
    assert_eq(c, 3);
    let a = thing&.fst.a[];
    assert_eq(a, 1);
    let b = thing&.fst.b[];
    assert_eq(b, 2);
    
    canary
}

@hacktest(interp, aarch64)
fn single_nested_struct(canary: i64) i64 = {
    const A = (a: i64, b: i64)!struct;
    const B = (c: A)!struct;
    
    assert_eq(A.size_of(), B.size_of());
    
    let f: A = (a: 1, b: 2);
    var thing: B = (c: f);
    
    let a = thing&.c.a[];
    assert_eq(a, 1);
    let b = thing&.c.b[];
    assert_eq(b, 2);
    
    canary
}


// This caused interp to drop Poison when I just added to result.to_drop for !slice,
// because the branch that wasn't taken didn't get initilized. 
// Originally found much more confusing case in @switch,
// because !unquote uses !slice to pass the placeholder arguments to the compiler. 
// Fixed by having !slice backing slots dropped at the end of the block, not the function.
@hacktest(interp, aarch64)
fn branching_slice(c: i64) i64 = {
    if(true, fn = {
        let a = (1, 2, 3)!slice;
    }, fn = {
       let b = (4, 5, 6)!slice;
    });
    c
}

@test(interp, aarch64)
fn main(c: i64) i64 = {
    assert_eq(c, fields(c));
    assert_eq(c, varient(c));
    assert_eq(c, use_str(c));
    assert_eq(c, nested_struct(c));
    assert_eq(c, single_nested_struct(c));
    assert_eq(c, branching_slice(c)); 
    c
}
