// TODO: make the var kind specifier carry forward to the arg

#test(aarch64)
fn main(canary: i64) i64 = {

// Here we pass a closure as an argument to a function.
var sum = 0;
range(0, 4, fn(i: i64) = {
    sum = add(sum, i);
});
assert_eq(sum, 6);

// You can write the same thing using back-passing syntax.
var sum = 0;
{
    // This means take the whole rest of the block as the body of a closure with the variable 'i' as its argument,
    // and pass that as the last argument to the 'range' call.
    let i: i64 <- range(0, 4);
    sum = add(sum, i);
};
assert_eq(sum, 6);

// TODO: this didn't work either (liek below) but if you put Unit ret annotionaon on the outer closure it works 
//       so the problem is that its trying to typechek too soon to decide which fn range to call (even tho theres only one). 
//       maybe i need overloading based on partial argument types. if you can narrow it down, you can pick what to call and just typecehck later. 

// Same as below but in normal syntax.
var acc = 0;
range(0, 4, fn(n: i64) Unit = {
    range(0, 4, fn(m: i64) Unit = {
        acc = add(acc, mul(n, m));
    })
});
assert_eq(acc, 36);

/* !!! BROKEN !!!
// TODO: this broke when I changed overload resolution because it can't figure out the return type of the closures. 
// So you can do nested loops in an unindented style.
var acc = 0;
{
    let n: i64 <- range(0, 4);
    let m: i64 <- range(0, 4);
    acc = add(acc, mul(n, m));
};
a ssert_eq(acc, 36);
*/

fn try() Unit = unit;

#comptime
fn Option3(const T: Type) Type = {
    const Self: Type = @tagged(Some: T, None: Unit);

    fn try(var maybe: Self, const yield: Fn(T, Unit)) Unit = {
        (eq(maybe&!tag[], tag_value(Self, @symbol Some)),
            fn= yield(maybe&.Some[]),
            fn= (),
        )!if;
        // TODO: its too easy to forget the !if. I want prefix anyway.
        //       but why did it compile? that tuple (bool, fn(()) (), fn(()) ()) isn't unit.
        //       and I wasn't referencing the field access.
    }

    Self
}

:: Option3(i64);  // TODO

// TODO: pass required type from fn ret through if branches.
fn if_multiple(i: i64, divisor: i64) Option3(i64) =
    (eq(mod(i, divisor), 0),
        fn() Option3(i64) = (Some: i),
        fn() Option3(i64) = (None: ())
)!if;

{
    let n: i64 <- try(if_multiple(12, 2));
    assert_eq(n, 12);
};

{
    let n: i64 <- try(if_multiple(5, 2));
    panic("unreachable");
};

/* !!! BROKEN !!!
// TODO: broken with new overloading becuase it cant figure out the return type
// You can use back-passing for early returns.
var passed = false;
{
    // TODO: choose an overload based on partially known argument types, so you can infer other argument types,
    //       so it would know 'i' is the argument to yield so must be i64.
    let n: i64 <- try(if_multiple(12, 2));
    a ssert_eq(n, 12);
    let n: i64 <- try(if_multiple(n, 3));
    a ssert_eq(n, 12);
    let n: i64 <- try(if_multiple(n, 4));
    a ssert_eq(n, 12);
    passed = true;
    let n: i64 <- try(if_multiple(n, 5));
    passed = false;
};
a ssert_eq(passed, true);
*/



canary
}

