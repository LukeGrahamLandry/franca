//! Userspace single dynamic dispatch.
//! The idea is the boilerplate could be generated by an annotation.
#test(aarch64)
fn main(canary: i64) i64 = {


Add :: Unique$ @struct(lhs: i64, rhs: i64);

fn eval(self: Ptr(Add)) i64 = add(self.lhs[], self.rhs[]);

const Mul = Unique((lhs: i64, rhs: i64)!struct);
fn eval(self: Ptr(Mul)) i64 = mul(self.lhs[], self.rhs[]);

const Eval = (vtable: FnPtr(VoidPtr, i64), dataptr: VoidPtr)!struct;
fn eval(var self: Eval) i64 = (self&.vtable[])(self&.dataptr[]);

#comptime
fn upcast(const T: Type) Unit = {
    /// Forget the type and create a trait object. 
    fn upcast(self: Ptr(T)) Eval = {
        // TODO: fix new constant shadowing old constant of same name. or at least give error -- Apr 22
        const e: Fn(Ptr(T), i64) = eval;  // Somewhere to hang the type annotation to resolve the overload.
        (vtable: e!fn_ptr, dataptr: self)
    }
}

// TODO: for const arg to work instead of #generic, this needs to do the call right now if all args are const instead of waiting so ti instantiates the generics 
// Instantiate the generics. 
upcast(Add);
upcast(Mul);

var six: Add = (lhs: 2, rhs: 4);
var eight: Mul = (lhs: 2, rhs: 4);

// Static dispatch. 
assert_eq(6, six!addr.eval());
assert_eq(8, eight!addr.eval());

// Dynamic dispatch. 
var unknown = six!addr.upcast();
assert_eq(6, unknown.eval());
unknown = eight!addr.upcast();  // Same variable, same type.
assert_eq(8, unknown.eval());  // But now we call the other method. 

// Can even do crimes by swapping the vtable. This works because we know the values have compatible layout. 
var do_add = six!addr.upcast();
var do_mul = eight!addr.upcast();
assert_eq(8, unknown.eval());
unknown&.vtable[] = do_add&.vtable[]; 
assert_eq(6, unknown.eval());
unknown&.vtable[] = do_mul&.vtable[]; 
assert_eq(8, unknown.eval());

// dyn_mul(six!addr); // TODO: this needs to be a type error. but i mostly have structural type checking. unique is a bit fishy. (changed how i did upcast() anyway so doesnt come up in this example)

const AddDyn = Unique((lhs: Eval, rhs: Eval)!struct);
fn eval(self: Ptr(AddDyn)) i64 = add(self.lhs[].eval(), self.rhs[].eval());
upcast(AddDyn);

var fourteen: AddDyn = (lhs: do_add, rhs: do_mul);
assert_eq(14, fourteen!addr.eval());  // TODO: currently you need to call it once manually so the compiler knows its needed. 
unknown = fourteen!addr.upcast();
assert_eq(14, unknown.eval());

// Note: at this point, <unknown> holds a reference to <fourteen>'s stack slot. 
// I probably want to provide some sort of noalias assertions eventually. 
fourteen = (lhs: do_add, rhs: do_add);
assert_eq(12, unknown.eval());  // We call different implementations through AddDyn without changing <unknown>'s vtable. 

canary
}
