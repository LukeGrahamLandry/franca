@import(interp);

fn main(_canary: i64) i64 = {


fn who_is(value: i64) i64 = {
    len("int")
}

fn who_is(value: Ptr(i64)) i64 = {
    len("ptr_int")
}

fn who_is(value: (i64, i64)) i64 = {
    len("tuple_int")
}

assert_eq(3, who_is(10));
let an_int = 1;
assert_eq(7, who_is(an_int!addr));
let ints = (1, 2);  // TODO: infer type on raw tuple expr so dont need to put it in a variable
assert_eq(9, who_is(ints));
assert_eq(3, who_is(10));  // just to make sure im not cheating and doing them in order or something 

const Bin = .{ a: i64, b: i64 }!struct;
const DoAdd = Unique(Bin);
const DoMul = Unique(Bin);
// asser t_eq(false, eq(DoAdd, DoMul));  // TODO: allow eq(Type, Type)

// Dispite DoAdd and DoMul having the same sturucture, they are unique types so can have different overloads. 
fn eval(e: DoAdd) i64 = add(e.a[], e.b[]);
fn eval(e: DoMul) i64 = mul(e.a[], e.b[]);

let three: DoAdd = .{ a: 1, b: 2, };
assert_eq(3, eval(three));

const DoMath1 = Unique(.{ DoAdd: DoAdd, DoMul: DoMul, }!enum);

// This is kinda sad to write...
fn eval(e: DoMath1) i64 = { 
    let is_add = eq(e!tag[], tag_value(DoMath1, DoAdd!symbol));
    // TODO: fix fn vs fn().
    (is_add, fn()=eval(e.DoAdd[]), fn()=eval(e.DoMul[]))!if
}

let three: DoMath1 = .{ DoAdd: .{ a: 1, b: 2, } };
assert_eq(3, eval(three));

/*
// This is an annotation so it can get the identifiers. 
// TODO: once types reliably have names it could just be a function. 
const DoMath2 = (DoAdd, DoMul)!enum;
// TODO: I think this would be a good first macro. 
//       Maybe once I have implicit casts it should be more like "derive enum cast to cases" instead of specific functions. 
//       But doing casts requires overloading on return type which I can't do yet. 
// @derive_polymorph(DoMath2, eval);
*/

_canary
}
