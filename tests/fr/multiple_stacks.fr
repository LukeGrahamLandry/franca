call_in_stack :: AsmFunction(fn(new_sp: *i64, callback: @FnPtr(ctx: rawptr) void, ctx: rawptr) void = (), @const_slice(
    // setup new stack
    add_im(.X64, x16, sp, @as(u12) 0, 0b0),  // mov can't encode sp!
    sub_im(.X64, sp, x0, @as(u12) 32, 0b0),
    // save the old stack and our return info on the new stack.
    str_uo(.X64, x16, sp, @as(u12) 0),
    str_uo(.X64, lr, sp, @as(u12) 1), // units are i64s, not bytes!
    str_uo(.X64, fp, sp, @as(u12) 2),
    // call a user function
    mov(.X64, x0, x2),
    br(x1, 0b1),
    // restore return info
    ldr_uo(.X64, x16, sp, @as(u12) 0),
    ldr_uo(.X64, lr, sp, @as(u12) 1), // units are i64s, not bytes!
    ldr_uo(.X64, fp, sp, @as(u12) 2),
    // restore original stack
    add_im(.X64, sp, x16, @as(u12) 0, 0b0),  // mov can't encode sp!
    ret(),
), fn(out: *List(u8)) => @asm_x64(  // rdi, rsi, rdx
    // setup new stack
    encode_bin(PrimaryOp.MovReg, X86Reg.rcx, X86Reg.rsp),
    encode_bin(PrimaryOp.MovReg, X86Reg.rsp, X86Reg.rdi),
    
    // save the old stack on the new stack.
    encode_op_reg(PrimaryOp.PushBase, X86Reg.rcx),
    
    // call a user function
    encode_bin(PrimaryOp.MovReg, X86Reg.rdi, X86Reg.rdx),
    encode_call_reg(ModrmMode.Direct, X86Reg.rsi),
    
    // restore original stack
    encode_op_reg(PrimaryOp.PopBase, X86Reg.rsp),
    PrimaryOp.Ret,
) out, fn(out: *List(u8)) => {
    out.push_all(@slice(0x00, 0x0B)); // 0 locals. end.
}, @const_slice(
    I(0, RvReg.SP.bits(), @as(u3) OpI.add, RvReg.T0.bits(), .op_imm),
    I(s_trunc(-16, 12), RvReg.A0.bits(), @as(u3) OpI.add, RvReg.SP.bits(), .op_imm),
    
    store(.RA, .SP, 0, 8, false),
    store(.T0, .SP, 8, 8, false),

    I(0, RvReg.A2.bits(), @as(u3) OpI.add, RvReg.A0.bits(), .op_imm),
    jalr(.A1, 0, .RA),
    
    load(.RA, .SP, 0, 8, false, false),
    load(.SP, .SP, 8, 8, false, false),
   
    jalr(.RA, 0, .Zero),
));

#use("@/backend/amd64/bits.fr");
#use("@/backend/arm64/bits.fr");
#use("@/backend/rv64/bits.fr");

SECRET :: 31415926535897;
write_secret :: fn(ctx: rawptr) void = {
    my_secret_value := @slice (SECRET, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
    // new backend does stack slot liveness so trick it into thinking we actually use the array. 
    escape_this_memory :: fn(s: []i64) void #noinline = (); // nop
    escape_this_memory(my_secret_value); 
};

fn multistack() #test = {
    #use("@/lib/sys/process.fr");
    @if(query_current_arch() == .wasm32) return();  // SKIP: TODOWASM

    stack_size := 30;
    new_stack  := page_allocator.alloc_zeroed(i64, stack_size);
    new_sp := new_stack.ptr.offset(stack_size);     // the stack grows downword, so this has to point to the *end* of the memory.
    assert_eq(@as(i64) i64.int_from_ptr(new_sp).mod(16), 0); // arm wants sp to be 16 byte aligned. malloc should give us that. 

    count_secrets :: fn() i64 => {
        found := 0;
        for(new_stack) { v |
            if (v.eq(SECRET)) {
                found += 1;
            };
        };
        found
    };
    
    assert_eq(count_secrets(), 0);
    x: @FnPtr(rawptr) void = write_secret;  // TODO: this works without the extra binding when there's only one arch but not when two. 
    call_in_stack(new_sp, x, 0.rawptr_from_int());
    // now we should be able to read the callee's leftover variables. 
    assert_eq(count_secrets(), 1);
}
