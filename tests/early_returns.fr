#test fn simple_return() = {
    is_even :: fn(i: i64) bool = {
        ret :: __return;
        if(i.mod(2).eq(0)){|
            ret(true);
        };
        
        false
    };
    
    a := is_even(4);
    a := is_even(5);
    
    assert_eq(true, is_even(4));
    assert_eq(false, is_even(5));
}

#test fn break_from_loop() = {
    numbers := (1, 2, 3, 4, 5, 6)!slice;
    
    index_of :: fn(self: Slice(i64), goal: i64) i64 = {
        ret :: __return;
        self.enumerate {(i: i64, v: *i64)|
            if(goal.eq(v[])){|
                ret(i);
            };
        };
        
        1.neg()
    };
    
    assert_eq(numbers.index_of(3), 2);
    assert_eq(numbers.index_of(10), 1.neg());
}

fn whileb(const cond: Fn(Unit, bool), const body: Fn(Label(Unit), Unit)) Unit = {
    break :: __return;
    while(cond) {|
        body(break);
    };
}

/// constants dont get renumbered so they dont work well with closures. 
#test fn fancy_while_break() = {
    i := 0;
    whileb(=> i.lt(100)){(const break: Label(Unit))|
        i += 1;
        if(i.ge(5)){|
            break();
        };
    };
    assert_eq(i, 5);
}

#test fn fancy_while_continue() = {
    i := 0;
    while(=> i.lt(10)){|
        continue :: __return;
        i += 1;
        if(i.ge(5)){|
            continue();
        };
        
        assert(i.lt(5), "continue didn't exit");
    };
    assert_eq(i, 10); // the loop should still have done all iterations. 
}

#test #skip_cranelift
fn tail_calls(canary: i64) i64 = {
    fn add_slow(a: i64, b: i64) i64 = 
        if(b.eq(0), => a, => add_slow(a.add(1), b.sub(1)));
    
    N :: 174490;
    assert_eq(N, add_slow(0, N));
    
    canary
}
