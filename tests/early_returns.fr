#test fn simple_return() = {
    is_even :: fn(i: i64) bool = {
        ret :: @return;
        if(i.mod(2).eq(0)){|
            ret(true);
        };
        
        false
    };
    
    a := is_even(4);
    a := is_even(5);
    
    assert_eq(true, is_even(4));
    assert_eq(false, is_even(5));
}

#test fn break_from_loop() = {
    numbers := (1, 2, 3, 4, 5, 6)!slice;
    
    index_of :: fn(self: Slice(i64), goal: i64) i64 = {
        ret :: @return;
        self.enumerate {i, v|
            if(goal.eq(v[])){|
                ret(i);
            };
        };
        
        1.neg()
    };
    
    assert_eq(numbers.index_of(3), 2);
    assert_eq(numbers.index_of(10), 1.neg());
}

/// constants dont get renumbered so they dont work well with closures. 
#test fn fancy_while_break() = {
    i := 0;
    whileb(=> i.lt(100)){const break|
        i += 1;
        if(i.ge(5)){|
            break();
        };
    };
    assert_eq(i, 5);
}

#test fn fancy_while_continue() = {
    i := 0;
    whilec(=> i.lt(10)){const continue|
        i += 1;
        if(i.ge(5)){|
            continue();
        };
        
        assert(i.lt(5), "continue didn't exit");
    };
    assert_eq(i, 10); // the loop should still have done all iterations. 
}

#test #skip_cranelift
fn tail_calls(canary: i64) i64 = {
    fn add_slow(a: i64, b: i64) i64 = 
        if(b.eq(0), => a, => add_slow(a.add(1), b.sub(1)));
    
    N :: 174490;
    assert_eq(N, add_slow(0, N));
    
    canary
}

#test fn write_while_with_loop() = {
    fn new_while(const cond: Fn(Unit, bool), const body: Fn(Unit, Unit)) Unit = {
        break :: @return;
        loop(=> if(cond(), body, => break()));
    }
    
    i := 0;
    new_while(=> i.lt(10)) {|
        j := 0;
        new_while(=> j.lt(10), => { j += 1; });
        assert(eq(j, 10), "fail");
        i += 1;
    };
    assert_eq(i, 10);
}
