#test fn simple_return() = {
    is_even :: fn(i: i64) bool = {
        ret :: __return;
        if(i.mod(2).eq(0)){|
            ret(true);
        };
        
        false
    };
    
    a := is_even(4);
    a := is_even(5);
    
    assert_eq(true, is_even(4));
    assert_eq(false, is_even(5));
}

#test fn break_from_loop() = {
    numbers := (1, 2, 3, 4, 5, 6)!slice;
    
    index_of :: fn(self: Slice(i64), goal: i64) i64 = {
        ret :: __return;
        self.enumerate {(i: i64, v: *i64)|
            if(goal.eq(v[])){|
                ret(i);
            };
        };
        
        1.neg()
    };
    
    assert_eq(numbers.index_of(3), 2);
    assert_eq(numbers.index_of(10), 1.neg());
}

fun whileb(const cond: Fn(Unit, bool), const body: Fn(Label(Unit), Unit)) Unit = {
    break :: __return;
    while(cond) {|
        body(break);
    };
}

/// constants dont get renumbered so they dont work well with closures. 
#test fn fancy_while_break() = {
    i := 0;
    whileb(=> i.lt(100)){(const break: Label(Unit))|
        i += 1;
        if(i.ge(5)){|
            break();
        };
    };
    assert_eq(i, 5);
}

#test fn fancy_while_continue() = {
    i := 0;
    while(=> i.lt(10)){|
        continue :: __return;
        i += 1;
        if(i.ge(5)){|
            continue();
        };
        
        assert(i.lt(5), "continue didn't exit");
    };
    assert_eq(i, 10); // the loop should still have done all iterations. 
}

/*
#test_broken
fn tail_loop(canary: i64) i64 = {
    fn tail_while(const cond: Fn(Unit, bool), const body: Fn(Unit, Unit)) Unit = {
        if(cond()){()Unit|
            body();
            tail_while(cond, body);
        }
    }
    
    i := 0;
    tail_while(=> i.lt(100)) {|
        i += 1;
    };
    assert_eq(i, 100);
    
    canary
}
*/