fn main(canary: i64) i64 = {

fn range(start: i64, end: i64, yield: Fn(i64, Unit)) Unit = {
    var i = start;
    (fn()=lt(i, end), fn()={  // TODO: fix vm poison when no brackets.
        yield(i);
        i = add(i, 1);
    })!while;
}

let zero = 0; // TODO: fully const arg

// Here we pass a closure as an argument to a function.
var sum = 0;
range(zero, 4, fn(i: i64) = {
    sum = add(sum, i);
});
assert_eq(sum, 6);

// You can write the same thing using back-passing syntax.
var sum = 0;
{
    // This means take the whole rest of the block as the body of a closure with the variable 'i' as its argument,
    // and pass that as the last argument to the 'range' call.
    let i: i64 <- range(zero, 4);
    sum = add(sum, i);
};
assert_eq(sum, 6);

// So you can do nested loops in an unindented style.
var acc = 0;
{
    let n: i64 <- range(zero, 4);
    let m: i64 <- range(zero, 4);
    acc = add(acc, mul(n, m));
};
assert_eq(acc, 36);


canary
}