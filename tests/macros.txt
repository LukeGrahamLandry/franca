fn main(canary: i64) i64 = {

//////////////////////
/// Trivial Macros ///
//////////////////////

@annotation
fn first_expr(arg: FatExpr, target: FatExpr) FatExpr = arg;

@annotation
fn second_expr(arg: FatExpr, target: FatExpr) FatExpr = target;

assert_eq(177, @first_expr(177) 277);
assert_eq(288, @second_expr(188) 288);

// puts(dump_ffi_types());

const _totototo: Type = List(FatExpr);

@annotation
fn last_thing(_: FatExpr, target: FatExpr) FatExpr = {
    let parts: Ptr(FatExpr) = target.expr.Tuple[];
    let count = len(parts);
    let last: FatExpr = get(parts, sub(count, 1));
    last
}

// TODO: !! at the very least, warn when it gets put on a stmt instead of treated as an expression until i implement that. 

let x = @last_thing() (a, b, c, d, 18);
assert_eq(x, 18);

@annotation
fn is_declared(_: FatExpr, target: FatExpr) FatExpr = {
    (eq(target.expr!tag[], tag_value(Expr, GetVar!symbol)), fn() = {
        target.expr[] = .{ Value: true };
    }, fn() = 
        (eq(target.expr!tag[], tag_value(Expr, GetNamed!symbol)), fn() = {
            target.expr[] = .{ Value: false };
        }, fn() = {
            panic("@is_declared expected identifier");
        })!if
    )!if;
    target
}

assert_eq(true, @is_declared() x);
assert_eq(false, @is_declared() not_an_ident);
assert_eq(false, @is_declared() hello);
let hello = 4;
assert_eq(true, @is_declared() hello);
{ let _ = @is_declared() 12; }!assert_compile_error;  // TODO: it still prints the msg to the log even though we catch it. 

assert_eq(false, @is_declared() in_a_block);
{ let in_a_block = 0; assert_eq(true, @is_declared() in_a_block); };
assert_eq(false, @is_declared() in_a_block);

// Note: This will misbehave around ffi identifiers currently. 
//       It's an artifact of my awkward choices, its fine if you break this part of the test. 
assert_eq(false, @is_declared() FatExpr);
assert_eq(true, @is_declared() i64);

//////////////////
/// Match Test ///
//////////////////

@comptime
fn Option(T: Type) Type = .{ Some: T, None: Unit }!enum;

let yes: Option(i64) = .{ Some: 12 };
let no: Option(i64) = .{ None: unit };


const _todotodo: Type = List(FatStmt);

// TODO
@annotation
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Ptr(FatStmt) = target.expr.Block.body[];
    let first: Ptr(FatStmt) = index(stmts, 0);
    let f = first.stmt.Eval;
    f!reflect_print;
    arg
}

let x = @match(yes) {
    (fn Some(x: i64) i64 = x);
    (fn None(x: Unit) i64 = 99);
};

/*
asser t_eq(x, 12);

let x = @match(no) {
    fn Some(x: i64) i64 = x;
    fn None(x: Unit) i64 = 99;
};
asser t_eq(x, 99);
*/

canary
}
