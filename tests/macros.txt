fn main(canary: i64) i64 = {

//////////////////////
/// Trivial Macros ///
//////////////////////

@annotation
fn first_expr(arg: FatExpr, target: FatExpr) FatExpr = arg;

@annotation
fn second_expr(arg: FatExpr, target: FatExpr) FatExpr = target;

assert_eq(177, @first_expr(177) 277);
assert_eq(288, @second_expr(188) 288);

const _totototo: Type = List(FatExpr);

@annotation
fn last_thing(_: FatExpr, target: FatExpr) FatExpr = {
    let parts: Slice(FatExpr) = target.expr.Tuple[];
    let count: i64 = len(parts);
    let last: Ptr(FatExpr) = index(parts, sub(count, 1));
    last[]
}

// TODO: !! at the very least, warn when it gets put on a stmt instead of treated as an expression until i implement that. 

let x = @last_thing() (a, b, c, d, 18);
assert_eq(x, 18);

@annotation
fn is_declared(unit: FatExpr, target: FatExpr) FatExpr = {
    (eq(target.expr!tag[], tag_value(Expr, GetVar!symbol)), fn() = {
        target.expr[] = .{ Value: .{ ty: type_id(bool), value: .{ One: true }} };
    }, fn() = 
        (eq(target.expr!tag[], tag_value(Expr, GetNamed!symbol)), fn() = {
            // This does the same thing as above but looks prettier. It does lose the location info on the ast node tho. 
            target = clone_ast(false!quote);
            target.loc[] = unit.loc[]; // report errors at the caller not here. 
        }, fn() = {
            panic("@is_declared expected identifier");
        })!if
    )!if;
    target
}

assert_eq(true, @is_declared() x);
assert_eq(false, @is_declared() not_an_ident);
assert_eq(false, @is_declared() hello);
let hello = 4;
assert_eq(true, @is_declared() hello);
{ let _ = @is_declared() 12; }!assert_compile_error;  

assert_eq(false, @is_declared() in_a_block);
{ let in_a_block = 0; assert_eq(true, @is_declared() in_a_block); };
assert_eq(false, @is_declared() in_a_block);

// Note: This will misbehave around ffi identifiers currently. 
//       It's an artifact of my awkward choices, its fine if you break this part of the test. 
assert_eq(false, @is_declared() FatExpr);
assert_eq(true, @is_declared() i64);

////////////////////
/// Placeholders ///
////////////////////

// Note: this sucks because it can't use @match because that implementation wants to use this function. 
fn visit_expr(start: Ptr(FatExpr), f: Fn(Ptr(FatExpr), Unit)) Unit = {
    var stack: List(Ptr(FatExpr)) = list(1);
    push(stack!addr, start);
    
    (fn() bool = gt(stack.len[], 0), fn() Unit = {
        let e: Ptr(FatExpr) = pop_last(stack!addr);
        f(e);
        
        let tag: Symbol = tag_symbol(Expr, e.expr!tag[]);
        (eq(tag, Call!symbol), fn()={
            (fn(func: Ptr(FatExpr), arg: Ptr(FatExpr)) Unit = {
                push(stack!addr, func);
                push(stack!addr, arg);
            })(e.expr.Call[]);
        }, fn()={
           (eq(tag, Tuple!symbol), fn() Unit ={
                let parts: Slice(FatExpr) = e.expr.Tuple[];  // TODO: shouldnt need binding
                foreach(parts, fn(part: Ptr(FatExpr)) Unit = {
                    push(stack!addr, part);
                });
            }, fn() Unit ={
                (eq(tag, PrefixMacro!symbol), fn() Unit ={
                    let arg: Ptr(FatExpr) = e.expr.PrefixMacro.arg[];
                    let target: Ptr(FatExpr) = e.expr.PrefixMacro.target[];
                    push(stack!addr, arg);
                    push(stack!addr, target);
                }, fn() Unit ={
                    (eq(tag, Closure!symbol), fn() Unit ={
                        const OptExpr: Type = (i64, FatExpr);
                        let body: Ptr(OptExpr) = e.expr.Closure.body;  // TODO: better option ffi
                        (fn(a: i64, b: FatExpr) Unit = { assert(eq(a, 0), "missing body"); })(body[]);
                        let body: Ptr(FatExpr) = raw_slice(body, 1, size_of(OptExpr));
                        push(stack!addr, body);
                    }, fn() Unit ={
                        (eq(tag, SuffixMacro!symbol), fn() Unit ={
                            (fn(a: Symbol, arg: Ptr(FatExpr)) Unit = { 
                                push(stack!addr, arg);
                             })(e.expr.SuffixMacro[]);
                        }, fn() Unit ={
                            // @todo
                        })!if
                    })!if
                })!if
            })!if
        })!if
    })!while;
    drop(stack!addr);
}

const Subst: Type = (Symbol, FatExpr);
const ___dasdasddsfe = List(Subst);
// TODO: instead of this, extend `!quote` to capture ast vars? 
fn apply_placeholders(template: Ptr(FatExpr), replacements: Slice(Subst)) Unit = {
    visit_expr(template, fn(expr: Ptr(FatExpr)) Unit = {
        (eq(expr.expr!tag[], tag_value(Expr, GetNamed!symbol)), fn()={
            let found: Symbol = expr.expr.GetNamed[];
            foreach(replacements, fn(key: Symbol, value: FatExpr) Unit = 
                (eq(key, found), fn()={
                    expr[] = value;
                }, fn()=())!if
            );
        }, fn()=())!if;
    });
}

@annotation
fn apply_func_with_five(number: FatExpr, func: FatExpr) FatExpr = {
    // The following is equvilent to rust's `quote!{ #func(5, #number) }`.
    // Ask the compiler to give us the ast for the expression "function_placeholder(5, number_placeholder)"
    var template: FatExpr = clone_ast((function_placeholder(5, number_placeholder))!quote);
    // Traverse our new expression and replace specific variables with the macro invocation's arguments. 
    let replacements: Slice(Subst) = (
        (number_placeholder!symbol, number),
        (function_placeholder!symbol, func),
    )!slice;
    // Note: this is not equivilent to a simple string find-and-replace on the source code.
    // It only replaces free variables in the ast. Overlapping names in the macro args should be unaffected. 
    // The `!quote` macro runs name resolution relitive to the instantiation of quote (the body of this function), 
    // and the arguments of the macro are resolved before calling the macro handler.
    apply_placeholders(template!addr, replacements);
    template
}

let seven = @apply_func_with_five(2) add;
assert_eq(seven, 7);

//////////////////
/// Match Test ///
//////////////////

@comptime
fn Option(T: Type) Type = .{ Some: T, None: Unit }!enum;

// puts(dump_ffi_types());

const _todotodo: Type = List(FatStmt);
const CasePayload: Type = (Symbol, TypeId);
const __asda: Type = List(CasePayload);


@comptime
fn box(T: Type) Fn(T, Ptr(T)) = {
    const T = T;
    (fn(t: T) Ptr(T) = {
        let ptr = alloc(T, 1);
        ptr[] = t;
        ptr
    })
}

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
@annotation
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Slice(FatStmt) = target.expr.Block.body[];
    let enum_type: TypeInfo = infer_raw_deref_type(arg);
    let enum_type: TypeId = intern_type(enum_type);
    
    // Declaring variables is weird because name resolution has already run.
    let handler = clone_ast((@with_var(arg_var, arg_init) @with_var(tag_val, arg_var!tag!deref) body_placeholder)!quote);
    var body = (if_false)!quote;
    
    foreach(stmts, fn(stmt: Ptr(FatStmt)) Unit = {
        // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
        (eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol)), fn()={
            let handler_body: FatExpr = stmt.stmt.Eval[];
            let name: Symbol = handler_body.expr.Closure.name[];
            
            // TODO: infer output type instead of just forcing int. 
            let new_branch = clone_ast((eq(tag_val, tag_value(enum_type_placeholder, case_tag_name)), 
                fn() i64 = (case_handler)(case_access_placeholder!deref), 
                fn() i64 = if_false_temp
            )!if!quote);
            
            var case_access: FatExpr = clone_ast((arg_var.___)!quote);
            raw_slice(case_access.expr.FieldAccess, 1, 2)[] = name;
            
            let new_rep = (
                (case_tag_name!symbol, literal_ast(Symbol, name!addr)),
                (case_handler!symbol, handler_body),
                (enum_type_placeholder!symbol, literal_ast(Type, enum_type!addr)),
                (case_access_placeholder!symbol, case_access)
            )!slice;
            apply_placeholders(new_branch!addr, new_rep);
            
            // TODO: single element slice. really just want to addr rvalue?
            let body_rep = (
                (if_false!symbol, new_branch),
                (asklsaklsalk!symbol, new_branch),
            )!slice;
            apply_placeholders(body!addr, body_rep);
            
            let body_rep = (
                (if_false_temp!symbol, clone_ast(if_false!quote)),
                (asklsaklsalk!symbol, new_branch),
            )!slice;
            apply_placeholders(body!addr, body_rep);
            
        }, fn()=())!if;
    });
    let body_rep = (  // TODO: single element slice
        (if_false!symbol, panic("unhandled match case")!quote),
        (lmdksdsalmkdasklm!symbol, panic("unhandled match case")!quote),
    )!slice;
    apply_placeholders(body!addr, body_rep);
    
    let handler_rep = (
        (arg_init!symbol, arg),
        (body_placeholder!symbol, body),
        (enum_type_placeholder!symbol, literal_ast(Type, enum_type!addr))
    )!slice;
    apply_placeholders(handler!addr, handler_rep);
    
    handler
}

const StupidEnum = .{ Only: i64 }!enum;


let useless: StupidEnum = .{ Only: 18 };
let y: i64 = @match(useless) {
    (fn Only(inner: i64) i64 = inner);  // TODO: error if you dont put it in a closure
};
assert_eq(18, y);


// TODO: you can't put the match in the function because it does close over the constants the match needs to call. 
//      but it shouldn't need to. the anotation handler should have grabbed them at its declaration like any other function.
//      it shouldn't be emitting a call to `intern_type`, it should be baking the result. 
// fn unwrap_or_99(m: Option(i64)) i64 = @todo();

let yes: Option(i64) = .{ Some: 12 };
let no: Option(i64) = .{ None: unit };
let res = @match(yes) {
    (fn Some(payload: i64) i64 = payload);
    (fn None(payload: Unit) i64 = 99);
};
assert_eq(res, 12);

let res = @match(no) {
    (fn Some(payload: i64) i64 = payload);
    (fn None(payload: Unit) i64 = 99);
};
assert_eq(res, 99);

canary
}
