fn main(canary: i64) i64 = {

//////////////////////
/// Trivial Macros ///
//////////////////////

@annotation
fn first_expr(arg: FatExpr, target: FatExpr) FatExpr = arg;

@annotation
fn second_expr(arg: FatExpr, target: FatExpr) FatExpr = target;

assert_eq(177, @first_expr(177) 277);
assert_eq(288, @second_expr(188) 288);

const _totototo: Type = List(FatExpr);

@annotation
fn last_thing(_: FatExpr, target: FatExpr) FatExpr = {
    let parts: Ptr(FatExpr) = target.expr.Tuple[];
    let count = div(raw_len(parts), size_of(FatExpr));
    let last: Ptr(FatExpr) = index(parts, sub(count, 1));
    last[]
}

// TODO: !! at the very least, warn when it gets put on a stmt instead of treated as an expression until i implement that. 

let x = @last_thing() (a, b, c, d, 18);
assert_eq(x, 18);

@annotation
fn is_declared(unit: FatExpr, target: FatExpr) FatExpr = {
    (eq(target.expr!tag[], tag_value(Expr, GetVar!symbol)), fn() = {
        target.expr[] = .{ Value: .{ ty: type_id(bool), value: .{ One: true }} };
    }, fn() = 
        (eq(target.expr!tag[], tag_value(Expr, GetNamed!symbol)), fn() = {
            // This does the same thing as above but looks prettier. It does lose the location info on the ast node tho. 
            target = false!quote;
            target.loc[] = unit.loc[]; // report errors at the caller not here. 
        }, fn() = {
            panic("@is_declared expected identifier");
        })!if
    )!if;
    target
}

assert_eq(true, @is_declared() x);
assert_eq(false, @is_declared() not_an_ident);
assert_eq(false, @is_declared() hello);
let hello = 4;
assert_eq(true, @is_declared() hello);
{ let _ = @is_declared() 12; }!assert_compile_error;  // TODO: it still prints the msg to the log even though we catch it. 

assert_eq(false, @is_declared() in_a_block);
{ let in_a_block = 0; assert_eq(true, @is_declared() in_a_block); };
assert_eq(false, @is_declared() in_a_block);

// Note: This will misbehave around ffi identifiers currently. 
//       It's an artifact of my awkward choices, its fine if you break this part of the test. 
assert_eq(false, @is_declared() FatExpr);
assert_eq(true, @is_declared() i64);

////////////////////
/// Placeholders ///
////////////////////

fn tag_symbol(E: Type, value: i64) Symbol;
fn print_ast(v: FatExpr) Unit;

// Note: this sucks because it can't use @match because that implementation wants to use this function. 
fn visit_expr(start: Ptr(FatExpr), f: Fn(Ptr(FatExpr), Unit)) Unit = {
    var stack: List(Ptr(FatExpr)) = list(1);
    push(stack!addr, start);
    
    (fn() bool = gt(stack.len[], 0), fn() Unit = {
        puts("stack len:");
        print(stack.len[]);
        let e: Ptr(FatExpr) = pop_last(stack!addr);
        print_ast(e[]);
        f(e);
        
        let tag: Symbol = tag_symbol(Expr, e.expr!tag[]);
        (eq(tag, Call!symbol), fn()={
            (fn(func: Ptr(FatExpr), arg: Ptr(FatExpr)) Unit = {
                push(stack!addr, func);
                push(stack!addr, arg);
            })(e.expr.Call[]);
        }, fn()={
           (eq(tag, Tuple!symbol), fn() Unit ={
                let parts: Ptr(FatExpr) = e.expr.Tuple[];  // TODO: shouldnt need binding
                foreach(parts, fn(part: Ptr(FatExpr)) Unit = {
                    push(stack!addr, part);
                });
            }, fn() Unit ={
                (eq(tag, PrefixMacro!symbol), fn() Unit ={
                    let arg: Ptr(FatExpr) = e.expr.PrefixMacro.arg[];
                    let target: Ptr(FatExpr) = e.expr.PrefixMacro.target[];
                    push(stack!addr, arg);
                    push(stack!addr, target);
                }, fn() Unit ={
                    (eq(tag, Closure!symbol), fn() Unit ={
                        puts("a");
                        const OptExpr: Type = (i64, FatExpr);
                        let body: Ptr(OptExpr) = e.expr.Closure.body;  // TODO: better option ffi
                        (fn(a: i64, b: FatExpr) Unit = { assert_eq(a, 0); })(body[]);
                        body!reflect_print;
                        let body: Ptr(FatExpr) = raw_slice(body, 1, size_of(OptExpr));
                        body!reflect_print;
                        push(stack!addr, body);
                        puts("b");
                    }, fn() Unit ={
                        // @todo
                    })!if
                })!if
            })!if
        })!if
    })!while;
    drop(stack!addr);
}

const Subst: Type = (Symbol, FatExpr);
const ___dasdasddsfe = List(Subst);
// TODO: instead of this, extend `!quote` to capture ast vars? 
fn apply_placeholders(template: Ptr(FatExpr), replacements: Ptr(Subst)) Unit = {
    visit_expr(template, fn(expr: Ptr(FatExpr)) Unit = {
        (eq(expr.expr!tag[], tag_value(Expr, GetNamed!symbol)), fn()={
            let found: Symbol = expr.expr.GetNamed[];
            foreach(replacements, fn(key: Symbol, value: FatExpr) Unit = 
                (eq(key, found), fn()={
                    expr[] = value;
                }, fn()=())!if
            );
        }, fn()=())!if;
    });
}

@annotation
fn apply_func_with_five(number: FatExpr, func: FatExpr) FatExpr = {
    // The following is equvilent to rust's `quote!{ #func(5, #number) }`.
    // Ask the compiler to give us the ast for the expression "function_placeholder(5, number_placeholder)"
    var template: FatExpr = (function_placeholder(5, number_placeholder))!quote;
    // Traverse our new expression and replace specific variables with the macro invocation's arguments. 
    let replacements = (
        (number_placeholder!symbol, number),
        (function_placeholder!symbol, func),
    )!slice;
    // Note: this is not equivilent to a simple string find-and-replace on the source code.
    // It only replaces free variables in the ast. Overlapping names in the macro args should be unaffected. 
    // The `!quote` macro runs name resolution relitive to the instantiation of quote (the body of this function), 
    // and the arguments of the macro are resolved before calling the macro handler.
    apply_placeholders(template!addr, replacements);
    template
}

let seven = @apply_func_with_five(2) add;
assert_eq(seven, 7);

//////////////////
/// Match Test ///
//////////////////

@comptime
fn Option(T: Type) Type = .{ Some: T, None: Unit }!enum;

let yes: Option(i64) = .{ Some: 12 };
let no: Option(i64) = .{ None: unit };

// puts(dump_ffi_types());

const _todotodo: Type = List(FatStmt);
const CasePayload: Type = (Symbol, TypeId);
const __asda: Type = List(CasePayload);


@comptime
fn box(T: Type) Fn(T, Ptr(T)) = {
    const T = T;
    (fn(t: T) Ptr(T) = {
        let ptr = alloc(T, 1);
        ptr[] = t;
        ptr
    })
}

// Convert a pointer to a value into an ast that will produce that value when evaluated. 
fn literal_ast(ty: Type, ptr: Any) FatExpr;
fn intern_type(ty: TypeInfo) TypeId;

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
@annotation
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Ptr(FatStmt) = target.expr.Block.body[];
    let enum_type: TypeInfo = infer_raw_deref_type(arg);
    let enum_type: TypeId = intern_type(enum_type);
    
    // Declaring variables is weird because name resolution has already run.
    let handler = (@with_var(arg_var, arg_init) @with_var(tag_val, arg_var!tag!deref) body)!quote;
    var body = (if_false)!quote;
    
    foreach(stmts, fn(stmt: Ptr(FatStmt)) Unit = {
        // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
        (eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol)), fn()={
            let expr: FatExpr = stmt.stmt.Eval[];
            let name: Symbol = expr.expr.Closure.name[];
            let handler_body: (i64, FatExpr) = expr.expr.Closure.body[];  // TODO: better option ffi
            let handler_body = (fn(a: i64, b: FatExpr) FatExpr = { assert_eq(a, 0); b })(handler_body);
            
            let new_branch = (eq(tag_val, tag_value(enum_type_placeholder, case_tag_name)), fn() Unit = case_handler, fn() Unit = if_false)!quote;
            
            let new_rep = (
                (case_tag_name!symbol, literal_ast(Symbol, name!addr)),
                (case_handler!symbol, handler_body),
            )!slice;
            apply_placeholders(new_branch!addr, new_rep);
            
            // TODO: single element slice. really just want to addr rvalue?
            let body_rep = (
                (if_false!symbol, new_branch),
                (asklsaklsalk!symbol, new_branch),
            )!slice;
            apply_placeholders(body!addr, body_rep);
            
            
        }, fn()=())!if;
    });
    let body_rep = (  // TODO: single element slice
        (if_false!symbol, panic("unhandled match case")!quote),
        (lmdksdsalmkdasklm!symbol, panic("unhandled match case")!quote),
    )!slice;
    apply_placeholders(body!addr, body_rep);
    
    let handler_rep = (
        (arg_init!symbol, arg),
        (body!symbol, body),
        (enum_type_placeholder!symbol, literal_ast(Type, enum_type!addr))
    )!slice;
    apply_placeholders(handler!addr, handler_rep);
    
    handler
}

fn unwrap_or_99(m: Option(i64)) i64 = @match(m) {
    (fn Some(x: i64) i64 = x);
    (fn None(x: Unit) i64 = 99);
}

let x = unwrap_or_99(yes);

/*
asser t_eq(x, 12);
let x =  unwrap_or_99(no);
asser t_eq(x, 99);
*/

canary
}
