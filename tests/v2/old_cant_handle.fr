
// old sema can't do this!
// symptom: `arr: Array(i64, 3) = init(@slice (7, 8, 9));` choosing the overload for `Array(i64, 5)`
// It works with the arg being i64 but not []i64 or *i64,
// so i think its about suspending in the argument type.
#test fn choosing_the_wrong_array_init() = {
    fn thing();
    fn Thing($T: Type, $t: T) Type #generic #log_bc = {
        S :: @struct(fst: T);
        fn thing(x: *i64) S = @as(S) (fst = t);
        S
    }
    
    x := 123;
    x := x&;
    a: Thing(i64, 0) = thing(x);
    b: Thing(i64, 1) = thing(x);
}

// TODO
// This is one the old system can't do! tho it can if you swap the order of declarations.
// but the new system can handle either which is very pleasing. 
//#test 
fn overloading_cycle() = {
    fn do_stuff() Type = i64;
    fn do_stuff(a: do_stuff()) do_stuff() = a;
    x := do_stuff(123);
    simple_eq(x, 123);
}
