@import(interp);

fn main(_canary: i64) i64 = {

// TODO: !!! fix the thing where it sees a tuple of types as just the first. 
const P: Type = (Any, Any);

// TODO: better error message if you forget to put the @comptime
@comptime
fn dup(T: Type) Fn(T, P) = {
    // TODO: without the leading '(' it treats it as a statement and gets mad that there's no name. 
    (fn(value: T) (T, T) = (value, value))
}

const P_i64: Type = (i64, i64);
const dup_i64: Fn(i64, P_i64) = dup(i64);
let one_one = dup_i64(1);
assert_eq(1, get_i(one_one!addr, 0));
assert_eq(1, get_i(one_one!addr, 1));

const P_ty: Type = (Type, Type);
const dup_ty: Fn(Type, P_ty) = dup(Type);
let tt = dup_ty(Unit);
assert_eq(Unit, get_i(tt!addr, 0));
assert_eq(Unit, get_i(tt!addr, 1));

dup_ty(1)!assert_compile_error;
dup_i64(Unit)!assert_compile_error;

// TODO: make this less dumb when i support non-slice ptrs.
@comptime
fn MySlice(T: Type) Type = {
    // TODO: better error message when you forget the dot.
    .{
        ptr: Ptr(T),
        len: i64,
    }!struct
}

// TODO: get constants inside functions to work and require that closure literals be const. 
//       or maybe not, cause it would mean const in its comptime which maybe it isnt because it doesnt know the arg yet. 
//       which sounds reasonable except that it does know the arg cause its just inlined cause thats how generics work. 
//       in any case, need to be able to return multiple things that refer to prev in one generic call. 
@comptime
fn get_first(T: Type) Fn(Any, Any) = {
    (fn(s: MySlice(T)) T = { get(s.ptr) })
}

const i64_s = MySlice(i64);
let things = alloc(i64, 5);
let a: i64_s = .{ ptr: things, len: 5 };
set(slice(a.ptr, 0, 1), 12);
const get_first_i64 = get_first(i64);
assert_eq(get_first_i64(a), 12);

// TODO: fix this. currently you need any overloaded functions provided by a generic to exist lexiclly as constants in the outer scope,
//       because the name resolution is done too early. 
fn is_left() Unit = unit;

@comptime 
fn Either(Left: Type, Right: Type) Type = {
    const Self: Type = .{ left: Left, right: Right, }!enum;
    
    fn is_left(self: Self) bool = {
        eq(self!tag[], tag_value(Self, left!symbol))
    }
    
    Self
}

const E1 = Either(i64, Ptr(i64));
let e1: E1 = .{ left: 15 };
assert_eq(true, is_left(e1));

// types are memoized 
assert_eq(Either(i64, Ptr(i64)), Either(i64, Ptr(i64)));
assert_eq(E1, Either(i64, Ptr(i64)));  
assert_eq(e1!type, Either(i64, Ptr(i64)));  
assert_eq(e1!type, E1);  

const E2 = Either(bool, i64);
let e2: E2 = .{ left: false };
assert_eq(true, is_left(e2));
assert_eq(e2!type, E2);

_canary
}
