// #requires(raw_ptr);
// #import(lib/codegen/aarch64/instructions); #import(lib/collections);

const BoxMmap = VoidPtr;
const CodePtr = VoidPtr;
fn copy_to_mmap_exec(insts: Slice(u32)) (BoxMmap, CodePtr);

const x0: u5 = 0;
const x1: u5 = 1;

fn call_jit(input: i64, code: Slice(u32)) i64 = {
    var map_and_ptr = copy_to_mmap_exec(code);
    let ptr: Ptr(CodePtr) = raw_slice(map_and_ptr!addr, size_of(VoidPtr), mul(size_of(VoidPtr), 2));
    let f: FnPtr(i64, i64) = ptr[];
    f(input)
}

fn main(canary: i64) i64 = {
    // TODO: fix typecheck. 
    // { let a: u5 = 0b10101010101010; }!assert_compile_error;
    // ((fn(a: u1) u1 = 0x1)(0b11))!assert_compile_error;
    add_i(Bits.X64[], x0, x1, x0, Shift.LSL[], 0x0000)!assert_compile_error;  // TODO: why does this one work but not the above? 
    
    let code = (
        movz(Bits.X64[], x1, 0b0000000000001010, Hw.Left0[]), 
        add_i(Bits.X64[], x0, x1, x0, Shift.LSL[], 0), 
        ret()
    )!slice;
    assert_eq(call_jit(90, code), 100);
    
    // Decimal literals auto cast to any bit size. 
    // TODO: bounds checking for constants. 
    let code = (
        movz(Bits.X64[], x1, 120, Hw.Left0[]), 
        add_i(Bits.X64[], x0, x1, x0, Shift.LSL[], 0), 
        ret()
    )!slice;
    assert_eq(call_jit(80, code), 200);
    
    canary
}
