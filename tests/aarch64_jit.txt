const BoxMmap = VoidPtr;
const CodePtr = VoidPtr;
fn copy_to_mmap_exec(insts: Slice(u32)) (BoxMmap, CodePtr);

const X0: u5 = 0;
const X1: u5 = 1;

fn call_jit(input: i64, code: Slice(u32)) i64 = {
    var map_and_ptr = copy_to_mmap_exec(code);
    let ptr: Ptr(CodePtr) = raw_slice(map_and_ptr!addr, size_of(VoidPtr), mul(size_of(VoidPtr), 2));
    let f: FnPtr(i64, i64) = ptr[];
    f(input)
}

fn main(canary: i64) i64 = {
    let code = (
        movz(Bits.X64[], X1, 0b0000000000001010, Hw.Left0[]), 
        add_i(Bits.X64[], X0, X1, X0, Shift.LSL[], 0), 
        ret()
    )!slice;
    assert_eq(call_jit(90, code), 100);
    
    let code = (
        movz(Bits.X64[], X1, 0b0000000001111000, Hw.Left0[]), 
        add_i(Bits.X64[], X0, X1, X0, Shift.LSL[], 0), 
        ret()
    )!slice;
    assert_eq(call_jit(80, code), 200);
    
    canary
}

/*
#[rustfmt::skip]
#[test]
fn add() {
    let result: u64 = call_jit(90, &[
        Inst::MOVZ { dest: X1, imm: 10 },
        Inst::Three { op: Three::ADD, dest: X0, lhs: X0, rhs: X1 },
        Inst::Ret
    ], &[]);
    assert_eq!(result, 100);
    let result: u64 = call_jit(80, &[
        Inst::MOVZ { dest: X1, imm: 120 },
        Inst::Three { op: Three::ADD, dest: X0, lhs: X1, rhs: X0 },
        Inst::Ret
    ], &[]);
    assert_eq!(result, 200);
}
*/
