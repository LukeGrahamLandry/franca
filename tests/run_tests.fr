HUSH :: @static(bool) false;

S :: const_slice;

bins :: @S(
    ("examples/import_c/cc.fr",     "target/cc.out"),
    ("backend/meta/qbe_frontend.fr", "target/q.out"),
    ("examples/import_wasm/run.fr",  "target/w.out"),
);

// TODO: pass in ./cc.out and ./w.out instead of assuming
test_cmds :: @S(
    @S("tests/compiler.fr"),
    @S("tests/backend.fr", "all", "-bin", "./target/q.out", "-jit"),
    @S("tests/backend.fr", "all", "-bin", "./target/q.out", "-w"),
    @S("tests/backend.fr", "all", "-bin", "./target/q.out", "-frc"),
    @S("tests/backend.fr", "all", "-bin", "./target/q.out", "-frc_inlinable"),
    @S("tests/exe/check_opt.fr"),
    @S("tests/exe/folding.fr"),
    @S("tests/exe/sys.fr"),
    @S("tests/c.fr", "-w", "target/w.out"),
    @S("examples/chess/perft.fr", "-fast", "-hush"),
    @S("examples/os/build.fr"),
    @S("tests/exe/cli_args.fr", "a", "b", "c", "d"),
    @S("tests/exe/c_ffi.fr"),
    @S("tests/c.fr"),
    @S("tests/exe/errors.fr"),
    @S("tests/exe/ffi_c.fr"),
    @S("tests/exe/dylibs.fr"),
    @S("examples/minijinja.fr"),
);

with_deps :: @S(
    @S("tests/backend.fr", "all", "-bin", "./target/q.out", "-cc", "-force_linker"), // dep:clang
    @S("tests/backend.fr", "all", "-bin", "./target/q.out"),  // dep:clang
    @S("tests/external/lox.fr", "-pass", "-hush"), // dep:lox
    @S("tests/external/lox.fr", "-pass", "-hush", "-clox"),
    @S("examples/import_wuffs/test.fr"),
    @S("tests/exe/generate.fr"),
    @S("tests/external/tcc.fr", "-ddc"),
    @S("tests/external/lua.fr"),
    // TODO: this only has deps because it runs webgpu_api.fr but don't really need that
    @S("tests/exe/wasm.fr"),
);

with_deps_skip_rv :: @S(
    // TODO: rv: lzip, lzma, xz: fault
    //       rv: json: FAIL test_wuffs_strconv_parse_number_f64_options
    @S("tests/external/wuffs.fr"),  // dep:wuffs
);

fn driver(vtable: *ImportVTable) void = {
    @run(inline_for cli_args() { $it |
        @if(@run(it[] == "fetch")) reach_all_deps();
    });

    c := cli_args();
    for c {s: CStr|
        do_it(vtable, s.str());
    };
}

do_it :: fn(vtable: *ImportVTable, s: Str) void = {
    #use("@/lib/sys/process.fr");
    #use("@/lib/sys/fs.fr");
    driver_path := "examples/default_driver.fr";
    franca_path := get_executable_path(temp());
    ::display_slice(Str);
    run :: fn(args) => {
        @println("%", args);
        run_cmd_blocking(franca_path, args) || @panic("failed %", args);
    };
    
        @switch(s) {
            @case("--") => ();
            @case("strap") => {
                if IS_BOOTSTRAPPING {
                    run_boot(vtable);
                    franca_path = "./target/franca.out";
                };
                sh(@slice(franca_path, "tests/run_tests.fr", "boot2"));  // note: re-exec not recurse until :updateboot
                sh(@slice("./target/f.out", driver_path, "build", "compiler/main.fr", "-o", "target/release/f.out", 
                    "-unsafe", "-keep-names", "-debug-info"));
            };
            @case("-hush") => {
                HUSH[] = true;
            };
            @case("boot") => run_boot(vtable);
            @case("stage0_driver") => stage0_driver(vtable);
            @case("boot2") => {
                make_dirs_or_crash("target/release");
                // f0 - new source built by old compiler
                // f  - new source built by new compiler
                sh(@slice(franca_path, driver_path, "build", "compiler/main.fr", "-o", "./target/f0.out"));
                sh(@slice("./target/f0.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f1.out"));
                // TODO: f1 is an extra layer that started being required when i did staticmemmove
                //       should debug why and get rid of it if possible 
                // TODO: now ./boot/temporary/macos-amd64.sh crashes if you don't -keep-names here ?? but everything else is fine. 
                sh(@slice("./target/f1.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f.out", "-keep-names"));
                // one more to bump __driver_abi_version and stop emitting for old tls abi
                sh(@slice("./target/f.out", driver_path, "build", "compiler/main.fr", "-o", "./target/f.out", "-keep-names"));
            };
            @case("core") => {
                if IS_BOOTSTRAPPING {
                    run_boot(vtable);
                    franca_path = "./target/franca.out";
                };
                sh(@slice(franca_path, "tests/run_tests.fr", "boot2"));
                println("=== re-exec ===");
                sh(@slice("./target/f.out", "tests/run_tests.fr", "run"));
            };
            @case("release") => build_release(vtable);
            @case("run") => {
                do_it(vtable, "run-no-deps");
                // the rules are everything before this must not download dependencies or exec system binaries. 
                println("=== end of dependency free tests ===");
                do_it(vtable, "run-yes-deps");
            };
            @case("run-no-deps") => {
                for bins { code, dest |
                    sh(@slice(franca_path, driver_path, "build", code, "-o", dest, "-keep-names"));
                };
                
                for test_cmds { cmd | 
                    run(cmd);
                };
                
                ::import("@/examples/testing.fr");
                build_aoc(franca_path);
                test_static_repro(franca_path);
                
                for dylib_compile_only { file |
                    sh(@slice(franca_path, "examples/default_driver.fr", "build", file, "-dynamiclib", "-o", "target/out/compileonly.dylib"));
                };
                
                // TODO: this is a source of confusion if you had run run_tests.fr with the release compiler
                do_it(vtable, "release");
            };
            @case("emit-c") => {
                run(@slice("examples/emit_c.fr", "-i", "compiler/main.fr", "-o", "target/a.c", "-unsafe"));
                run(@slice("examples/import_c/cc.fr", "target/a.c", "-o", "target/a.out"));
                check();
                Syscall'remove("target/a.out").unwrap();
                hack := @if(query_current_os() == .macos, Foreign.EXE.cc, Foreign.EXE.clang);
                sh(@slice(hack, "target/a.c", "-O0", "-o", "target/a.out", "-Wl,-undefined,dynamic_lookup", "-lm"));
                check();
                check :: fn() => {
                    // TODO: should FRANCA_NO_CACHE=1 
                    ok, o, e := exec_and_catch("target/a.out", @slice("examples/toy/hello2.fr"), temp());
                    @assert_eq(o.items(), "Hello World!\n", "%", e.items());
                    @assert(ok);
                    print(o.items());
                };
            };
            @case("run-yes-deps") => {
                prospero(franca_path);
                for(with_deps, fn(it) => run(it));
                build_graphics(franca_path);
                for deps_compile_only { file |
                    run(@slice("examples/default_driver.fr", "build", file, "-o", "target/a.out"));
                };

                if query_current_arch() != .rv64 {
                    for(with_deps_skip_rv, fn(it) => run(it));
                };
                
                do_it(vtable, "emit-c");
                ci := Foreign.ENV.GITHUB_REPOSITORY.get_environment_variable().is_some();
                if current_os() == .linux {
                    run(@slice("tests/external/hare.fr"));
                    
                    @if(query_current_arch() != .rv64)  // TODO: doesn't work with my multiarch situation so idk if it actually works. this is why we can't be depending on the system headers. 
                    if ci {
                        // github actions can't actually run it (sr.ht works tho)
                        // "bwrap: loopback: Failed RTM_NEWADDR: Operation not permitted"
                        run(@slice("tests/external/bubblewrap.fr"));
                    } else {
                        run(@slice("tests/external/bubblewrap.fr", "-fr", "examples/toy/hello2.fr"));
                    };
                    if query_current_arch() != .rv64 {
                        run(@slice("tests/external/curl.fr"));
                    };
                    print("SKIP: (TODO) raylib.\n");
                } else {
                    print("SKIP: 'Hare does not and will not officially support proprietary operating systems upstream.'\n");
                    print("SKIP: bubblewrap does linux specific sandboxing stuff.\n");
                    print("SKIP: (TODO) curl.\n");
                };
                
                // SKIP: these dynamically link to apple's frameworks (metal and virtualization respectively).  
                if current_os() == .macos {
                    run(@slice("examples/gpu/trivial_compute.fr", "-jit"));  // only supports metal so far
                    
                    @if(!ci || query_current_arch() == .aarch64)  // TODO: should make it work but debugging when it only dies in github actions is ass
                    if dir_exists("/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk") {
                        run(@slice("tests/external/raylib.fr", "-compileonly"));
                    } else {
                        print("SKIP: compile raylib (didn't find xcode sdk)\n");
                    };
                };
                @if(false)
                if current_os() == .macos && current_arch() == .aarch64 && !ci {
                    // TODO: -smp 1 frequently hangs
                    // TODO: need to error if it errors (host/vzf.fr doesn't know if you crashed) 
                    //       but still occasionally get: `panic! some sort of corruption is going on`
                    run(@slice("examples/os/build.fr", "-vzf", "-smp", "2", "-append", "nocache on; kaleidoscope; quit;"));
                };
            };
            @default => @eprintln("IGNORE: %", s);
        };
};

#use("@/backend/lib.fr")
build_release :: fn(vtable: *ImportVTable) void = {
    @if(IS_BOOTSTRAPPING) unreachable();
    make_dirs_or_crash("target/release");
    
    unsafe := true;
    keep_names := false;
    
    opts := vtable.default_build_options();
    if unsafe {
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    opts.retain_function_names = keep_names;
    opts.debug_info = false;  // TODO: this being true breaks repro because it embeds source with #comptime_addr
    c := new_with_src(vtable, """#include_std("lib/core.fr");#include_std("compiler/main.fr");""", opts);
    c := vtable.with(c);
    m := @ref zeroed(Qbe.Module);
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, c.vtable, (
        arch = .aarch64, os = .macos, type = .CachedEarly, 
        exe_debug_symbol_table = opts.retain_function_names, 
    ));
    fid := c.get_unique_named("main").expect("'main' when building the compiler");
    chunks := {c.vtable.emit_qbe_included}(QbeModule.raw_from_ptr(m), c&, @slice(fid), .WrapMain);
    bytes := concat(chunks&, temp());
    c'vtable'drop_qbe_module(QbeModule.raw_from_ptr(m));
    
    ;{
        // don't have to do this. just a little test that dump doesn't crash on nontrivial program.
        out := u8.list(bytes.len, temp());
        import("@/backend/meta/dump_bin.fr")'dump(out&, bytes);
    };

    targets := @S((Os.macos, Arch.aarch64), (.macos, .x86_64), (.linux, .aarch64), (.linux, .x86_64), (.linux, .rv64));
    
    // TODO: this is still takes like 200ms each. 
    //       it would be nice if i could just compile functions once per architecture if they don't depend on varargs abi. 
    for targets { os, arch |
        m := c'vtable'get_alloc(c.data).box_uninit(QbeModule);  // for good luck
        init_default_module_dyn(m, c.vtable, (
            arch = arch, os = os, type = .Exe, 
            exe_debug_symbol_table = opts.retain_function_names, 
        ));
        
        ::Result(*Incremental.Header, Str);
        header: *Incremental.Header = or check(bytes) { e |
            @panic("generated an invalid frc file: %", e)
        };
        compile_all_symbols(header, m);
        
        // TODO: this is confusing. 
        //       the module has its own debug info so need to not touch that 
        //       but do need to fill the import of base_address so franca_runtime_init can do relocations. 
        seal_debug_info(m, "", false, "");  // :AnnoyingDoubleSeal
        
        chunks := {vtable.finish_qbe_module}(QbeModule.raw_from_ptr(m));
        
        bytes := concat(chunks&, temp());
        arch := @match(arch) {
            fn x86_64() => "amd64";
            fn aarch64() => "arm64";
            @default => @tfmt("%", arch);
        };
        @println("%-%", arch, os);
        path := @tfmt("target/release/franca-%-%", os, arch);
        write_entire_file_or_crash(path, bytes);
        if os == .linux {
            import("@/backend/elf/emit.fr")'patch_out_interp_header(bytes);
            write_entire_file_or_crash(@tfmt("%-sta", path), bytes);
        };
        
        c'vtable'drop_qbe_module(QbeModule.raw_from_ptr(m));
    };
};

// these are annoying to actually test for various reasons but at least make sure they compile. 
dylib_compile_only :: @const_slice(
    "examples/default_driver.fr",  // so meta, many wow
    "examples/60fps.fr",  // interactive
    "examples/soft_draw.fr", // interactive & no aot so just make sure the driver still compiles
    "examples/parsegen/main.fr",  // TODO: bootstrapping decision
);

deps_compile_only :: @S(
    "examples/view_image.fr",  // dep:wuffs
    "examples/ascii_table.fr",  // dep:stb
);

// seperate because they need the build_for_graphics driver. 
// (also they have deps: stb, fonts, dawn.json)
// interactive so we just compile them. 
// TODO: run one frame and show screen shot as a sanity check? 
graphics_demos :: @S(
    "examples/terminal.fr",  // dep:stb
    "examples/farm_game.fr",
    "examples/app_events.fr",
    "examples/geo/main.fr",
    "examples/hello_triangle.fr",
    "examples/depth_test.fr",
    "examples/epicycles.fr",
    "examples/lambda.fr",
    "examples/chess/gui.fr",  // dep:stb
    "examples/mandelbrot_ui.fr",
    "examples/gpu/trivial_compute.fr",
    "examples/gpu/playground.fr",
    "examples/gpu/viewer.fr",
);

build_graphics :: fn(franca: Str) void = {
    sh(@slice(franca, "graphics/web/webgpu_api.fr"));
    run_tests_main_threaded(Str, Str, franca, graphics_demos, fn(_, a) = a[], fn(franca, it) = {
        ok, out, err := exec_and_catch(franca, @slice(it[], "-arch", "aarch64", "-os", "macos", "-o", "target/gfx.out"), temp());
        if it[] != "examples/terminal.fr" && it[] != "examples/gpu/viewer.fr" {  // TODO
            ok, out, err := exec_and_catch(franca, @slice(it[], "-arch", "wasm32", "-wgpu", "-o", "target/gfx.out"), temp());
            if !ok {
                return(ok, out, err, "");
            };
        };
        (ok, out, err, "")
    });
};

test_static_repro :: fn(franca_path: Str) void = {
    @if(IS_BOOTSTRAPPING) return();
    // If running linux with libc, can still run the compiler built without libc and make sure it repros. 
    if !(query_current_os() == .linux && is_linking_libc()) {
        println("SKIP: linux_native_no_libc(): native target is not linux+libc");
        return();
    };
    
    // TODO: have default_driver do -syscalls the same way as build_release so sta0==target/release/franca-linux-x-x-sta
    sta0, sta1 := ("target/sta0.out", "target/sta1.out");
    sh(@slice(franca_path, "examples/default_driver.fr", "build", "compiler/main.fr", "-unsafe", "-syscalls", "-o", sta0));
    _ := Syscall'remove(sta1.as_cstr());
    sh(@slice(sta0, "examples/default_driver.fr", "build", "compiler/main.fr", "-unsafe", "-syscalls", "-o", sta1));
    diff(sta0, sta1);
    println("OK: linux_native_no_libc");
};

build_aoc :: fn(franca: Str) void = {
    // TODO: aoc/2025 too
    files := collect_with_extension("examples/aoc/2024", ".fr").unwrap();
    run_tests_main_threaded(Str, Str, franca, files.items(), fn(_, a) = a[], fn(franca, file) = {
        ok, out, err := exec_and_catch(franca, @slice("examples/default_driver.fr", "build", @tfmt("examples/aoc/2024/%", file[]), "-o", Foreign.PATH.dev_null), temp());
        (ok, out, err, "")
    });
};

prospero :: fn(franca_path: Str) void = {
    args := @slice("examples/prospero.fr", "-width", "64", "-hush");
    ok, o, e := exec_and_catch(franca_path, args, temp());
    @assert(ok && e.items().contains("23/253:3578\nok!"), "failed prospero\n%%", o.items(), e.items());
    print(e.items());
};

// TODO: do this and then run the tests in bubblewrap
// TODO: threads but fetch_git_commit uses chdir
reach_all_deps :: fn() void = {
    inline_for get_constants(Foreign) { $n |
        it :: get_constant(Foreign, n[]).unwrap();
        // get_constant(Foreign, FuncId, n[]) doesn't work because :ThisIsTheProblemIdiot
        // so this is ugly instead of being ?FuncId
        @if(@run !n[].str().starts_with("doom"))  // don't need these in the bubblewrap test for now
        @if(@run { it := it; it._1 == FuncId }) {
            @run println(n[].str());
            _ := (@run { it := it; FuncId.ptr_from_raw(it._0)[] })();
        };
    };
};

// :UpdateBoot this can go away if i replace boot/franca-macos-arm64
fn run_boot(vtable: *ImportVTable) void = {
    make_dirs_or_crash("target/out");
    make_dirs_or_crash("target/franca");

    // :UpdateBoot
    // this is stupid... the version of the compiler i committed 11 months ago had bugs 
    // that have since been fixed in later versions but its not worth it to me to update it yet. 
    // so for now just try it in a loop a few times. its nondeterministic so it tends to work eventually. 
    franca := get_executable_path(temp());
    n, limit := (0, 15);
    dowhile {
        ok, out, err := exec_and_catch(franca, @slice("tests/run_tests.fr", "stage0_driver"), temp());
        n += 1;
        !ok && n < limit
    };
    @if(n == limit) stage0_driver(vtable);
    println(n);
    
    rename(@as(CStr) "a.out", @as(CStr) "target/franca/b.out");
    sh(@slice("./target/franca/b.out", "examples/default_driver.fr", "build", "compiler/main.fr", "-o", "target/franca.out"));
    println("ok!");
}

#use("@/backend/lib.fr")
fn stage0_driver(vtable: *ImportVTable) void = {
    opts := vtable.default_build_options();
    opts.safety_checks&.insert(SafetyCheck.Bounds, false);
    opts.safety_checks&.insert(SafetyCheck.DebugAssertions, false);
    
    path := "compiler/main.fr";
    src := "\n#include_std(\"lib/core.fr\");\n#include_std(\"compiler/main.fr\");";
    c := vtable.with(vtable.new_with_src(src, path, opts));
    fid := c.get_unique_named("main").expect("did not find exactly one function called 'main'");
    fid := @slice(fid);
    
    // Allocating more than size_of(QbeModule) need so it's fine that it shrank since boot was compiled (becuase we stopped using pthread_mutex_t). 
    m := u8.raw_from_ptr(page_allocator.alloc_zeroed(u8, 4096).as_ptr());
    goal: QbeTargetEnv = (os = query_current_os(), arch = query_current_arch(), type = .Exe);
    {vtable.init_default_qbe_module}(m, QbeTargetEnv.raw_from_ptr(goal&));
    
    #use("@/lib/collections/bucket_array.fr");
    F :: @FnPtr(mm: rawptr, comp: *CompCtx, fns: [] FuncId, entry: ProgramEntry) BucketArray(u8);
    emit_qbe_included_old := bit_cast_unchecked(rawptr, F, c.vtable.emit_qbe_included_old);
    
    bytes := emit_qbe_included_old(m, c&, fid, .WrapMain);
    asm_out: CStr = "a.out"; 
    ir_out := open_trunc(asm_out).unwrap(); 
    for bytes& { bucket |
        ir_out&.write(bucket) || panic("write failed");
    };
    ir_out.Syscall'close();
}

fn sh(a: []Str) void = {
    show :: fn() => {
        for a { a |
            @print("% ", a);
        };
        println("");
    };
    show();
    ok := if HUSH[] {
        ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
        if !ok {
            print(out.items());
            print(err.items());
        };
        ok
    } else {
        run_cmd_blocking(a[0], a.slice(1, a.len))
    };
    if !ok {
        print("Failed to run: ");
        show();
        panic("sh failed");
    };
}

diff :: fn(path0: Str, path1: Str) void = {
    a := read_entire_file_or_crash(temp(), path0);
    b := read_entire_file_or_crash(temp(), path1);
    @assert(a == b, "diff % %", path0, path1);
};

#use("@/lib/sys/subprocess.fr");
