//! This stuff used to be in basic but got split off because the rest already works on LLVM. 

@test(interp, aarch64)
fn main(canary: i64) i64 = {
    //////////////////
    /// Allocation ///
    //////////////////
    
    // Use `alloc` to create space that outlives the current stack frame. 
    fn dont_leak(size: i64) VoidPtr = alloc(i64, size);
    
    let on_the_heap = dont_leak(10);
    let first: VoidPtr = raw_slice(on_the_heap, 0, size_of(i64));
    let first: Ptr(i64) = first;
    first[] = 15;
    assert_eq(first[], 15);
    
    let three_heap = raw_slice(on_the_heap, 0, mul(3, size_of(i64)));
    let three_stack = (7, 8, 9);
    // set(three_heap, three_stack);
    
    dealloc(i64, on_the_heap, 10);
    // TODO: interpreter dealloc frees the value (if its a vec or whatever) but reference counts the allocation to catch use after free
    
    //////////////
    /// Tuples ///
    //////////////
    
    var arr = (1, 2, 3);
    let arr_ptr = arr&; 
    
    // you can create a pointer to an element of a tuple (constant index only)
    let second_ptr: *i64 = arr_ptr[1]; 
    assert_eq(2, second_ptr[]); // we can dereference as normal.
    second_ptr[] = 123;
    // TODO: comptime variadic functions so !deref is just get.
    // The type annotation for a tuple is written as a tuple of types. 
    var have: (i64, i64, i64) = arr_ptr[];
    var expected: (i64, i64, i64) = (1, 123, 3);
    
    assert_eq(have&[0][], expected&[0][]);
    assert_eq(have&[1][], expected&[1][]);
    assert_eq(have&[2][], expected&[2][]);
    
    canary
}
