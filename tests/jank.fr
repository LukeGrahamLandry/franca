#test fn tried_to_call_uncompiled() = {
    :: {
        fn ___this_function_is_not_real_im_just_testing_the_franca_compiler(one: i64, two: i64, three: i64) i64 #libc;
        result := ___this_function_is_not_real_im_just_testing_the_franca_compiler(1, 2, 3);
        assert_eq(result, 6);
    };
}

#test fn minimal_inline_bc() = {
    ::enable_inline_bc(); // TODO: this is a pain
    
    fn add7(a: i64) i64 #asm #bc = (fn(body) = {
        body.push_block(ast_alloc());
        block := body.blocks[0].insts&;
        block.push((PushConstant = (value = 7, ty = .I64)), ast_alloc());
        block.push((Intrinsic = .Add), ast_alloc());
        block.push((Ret1 = .I64), ast_alloc());
    });
    
    assert_eq(10, 3.add7());
}

// TODO: tried to call uncompiled!
//       should also update that error message to say we're confused about how you got that function pointer. 
#test fn call_const_fid_from_bc() = {
    ::enable_inline_bc(); // TODO: this is a pain
    
    get_one :: fn() i64 = 1;
    
    fn call_get_one() i64 #asm #bc = (fn(body) = {
        body.push_block(ast_alloc());
        code := body.blocks[0].insts&;
        sig: PrimSig = (
            args = empty(),
            ret1 = (Some = .I64),
            ret2 = .None,
        );
        get_one_sig: u32 = body.sig_payloads.len.trunc();
        body.sig_payloads&.push(sig, ast_alloc());
        fid: FuncId = get_one; // Somehow we need to know that this becomes live!
        code.push((CallDirect = (sig = get_one_sig, f = fid, tail = false)), ast_alloc());
        code.push((Ret1 = .I64), ast_alloc());
    });
    
    assert_eq(call_get_one(), 1);
}
