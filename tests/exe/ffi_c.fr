// make frc file from franca and import it from c (reverse of c_ffi.fr), then import it back to franca. 
main :: fn() void = {
    @run {
        fr := current_compiler_context();
        path := @tfmt("@/%", @source_file_name());
        opts := get_build_options();
        s := fr'vtable'cached_compile_module(path, opts, ast_alloc());
        s := s.or(fn(err) => fr.report_error(err));
        // TODO: allow including the bytes without writing to a file and hardcoding the path
        #use("@/lib/sys/fs.fr");
        write_entire_file_or_crash("target/ffi_c_exports_fr.frc", s);
    };

    c :: import("@/examples/import_c/ffi.fr")'include(C_SRC);
    @assert_eq(c'test_callback(), 10);
    @assert_eq(c'use_franca_types(123), 123);
}

C_SRC :: """
    #include "target/ffi_c_exports_fr.frc"
    
    int add7(int a) { return a + 6 + sizeof(invoke_callback); }
    int test_callback() {
        use_char(0);
        get_nothing();
        set_callback(add7);
        int three = one_va(3);
        return invoke_callback(three);
    }
    
    // some franca types don't have a direct c equivilent. 
    // - Array(T, N)   => struct { T data[N]; };
    // - @tagged(A: T) => struct { long tag; struct { T A; }; }; 
    long use_franca_types(long a) {
        typeof(get_array(0)) b = get_array(a);
        long c = b.data[0];
        typeof(get_tuple(0)) d = get_tuple(c);
        long e = d._0;
        typeof(get_tagged(0)) t = get_tagged(e);
        switch(t.tag) {
            case 0: return t.A;
            case 1: return t.B.len;
            default: return -1;
        };
    }
""";

F :: @FnPtr(a: i64) i64;
callback :: @static(F);
Empty :: @struct();

// TODO: allow exporting types and data. rn build_the_exports_scope only does functions. 
exports :: Type.scope_of(@struct {
    set_callback :: fn(f: F) void = {
        callback[] = f;
    };
    invoke_callback :: fn(a: i64) i64 = callback[](a);
    use_char :: fn(a: i8) i8 = a;
    one_va :: fn(va: CVariadic) i32 = va&.start().next(i32);
    get_nothing :: fn() Empty = ();
    
    get_tagged :: fn(a: i64) (@tagged(A: i64, B: Str)) = (A = a);
    get_array :: fn(a: i64) Array(i64, 2) = (a, a);
    get_tuple :: fn(a: i64) Ty(i64, Str) = (a, "");
});

#use("@/lib/variadic.fr");
