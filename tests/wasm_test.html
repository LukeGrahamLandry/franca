<!doctype html>
<html>
    <body>
        see dev console. <br>
        <div id="time"></div>
        <pre id="out"></pre>
        <script>
            let Franca;
            let FrancaXXX = {};
            let module_bytes;
            let line = ""; // TODO: have write() use this too (its only for putchar rn)
            let start_load = performance.now();
            function handleWasmLoaded(wasm) {
                Franca = wasm.instance.exports;
                console.log(Franca);
                console.log(module_bytes);
                
                // TODO: something more official than this.
                //       might be better to have page_allocator do something different instead? 
                FrancaXXX.__heap_base = BigInt(Franca.memory.buffer.byteLength);
                FrancaXXX.__heap_end = FrancaXXX.__heap_base;
                
                let a = performance.now();
                if (Franca.main !== undefined) {
                  Franca.main(0n, 0n, 0n, 0n);
                } else {
                  let length = module_bytes.byteLength;
                  console.log(length);
                  let p = Franca.allocate(BigInt(length));
                  let dest = new Uint8Array(Franca.memory.buffer, Number(p), length);
                  dest.set(new Uint8Array(module_bytes));
                  document.getElementById("time").innerText += "Loaded in " + Math.round(a - start_load) + "ms.";
                  Franca.disassemble(p, BigInt(length));
                }
                let b = performance.now();
                document.getElementById("time").innerText += " Ran in " + Math.round(b - a) + "ms.";
            }
            
            function do_stuff(it) {
              it.then((it) => {
                  module_bytes = it;
                  WebAssembly.instantiate(it, callbacks).then(handleWasmLoaded)
              });
            }
            
            let bump = 0n;
            const page_size = 1n << 16n;
            const callbacks = {
                env: {
                    puts: (ptr) => {
                        let len = 0;
                        let buf = new DataView(Franca.memory.buffer);
                        while (buf.getInt8(Number(ptr) + len) != 0) {
                            len += 1;
                        };
                        let line = get_wasm_string(ptr, len);
                        // console.log(line);
                        document.getElementById("out").innerText += line + "\n";
                        return 0;
                    },
                    write: (fd, ptr, len) => {
                        const msg = get_wasm_string(ptr, len);
                        switch (fd) {
                            case 1:
                                document.getElementById("out").innerText += msg;
                                // console.log(msg);
                                break;
                            case 2:
                                document.getElementById("out").innerText += msg;
                                // console.error(msg);
                                break;
                            default:
                                alert("todo: write non-stdout: " + msg);
                        }
                        return len;
                    },
                    clock_gettime: (clock_id, ptr) => {
                        const ms = performance.now();
                        // @struct(seconds: i64, nanoseconds: i64);
                        const time_spec = new BigInt64Array(
                            Franca.memory.buffer,
                            Number(ptr),
                            2,
                        );
                        time_spec[0] = BigInt(Math.floor(ms / 1000));
                        time_spec[1] = BigInt(Math.floor(ms * 1000000));
                    },
                    abort: () => {
                        alert("called abort");
                        throw "called abort";
                    },
                    exit: (status) => {
                        alert("called exit " + status);
                        throw "called exit " + status;
                        // better: instead, return and hit unreachable instruction 
                        // so the stack trace shows wasm functions
                    },
                    mmap: (addr, len_, prot, flags, fd, offset) => {
                        const start = FrancaXXX.__heap_base + bump;
                        
                        const len = (len_);
                        bump += len;
                        if (start + len >= FrancaXXX.__heap_end) {
                            const pages = len / page_size + 1n;
                            Franca.memory.grow(Number(pages));
                            FrancaXXX.__heap_end += pages * page_size;
                        }
                        return start;
                    },
                    munmap: (addr, len) => {
                      // alert("todo: munmap"),
                      return 0n;
                    },
                    putchar: (c) => {
                        if (c == 10) {
                            // console.log(line);
                            document.getElementById("out").innerText += line + "\n";
                            line = "";
                            return;
                        }
                        line += String.fromCharCode(c);
                    },
                    malloc: (len) => { throw "weak"; },
                    free: (p) => { throw "weak"; },
                    __libc_start_main: () => { throw "weak"; },
                    mprotect: (a, b, c) => { return 0; },
                    __clear_cache: (a, b) => { return 0; },
                    pthread_jit_write_protect_np: (a) => { return 0; },
                },
            };
            // WebAssembly.instantiateStreaming(
            //     fetch("../a.wasm"),
            //     callbacks,
            // ).then(handleWasmLoaded);
            
            fetch("../a.wasm").then((it) => do_stuff(it.arrayBuffer()));

            function get_wasm_string(ptr, len) {
                if (len == 0) {
                    return "";
                }
                const buffer = new Uint8Array(
                    Franca.memory.buffer,
                    Number(ptr),
                    Number(len),
                );
                return new TextDecoder().decode(buffer);
            }
        </script>
    </body>
</html>
