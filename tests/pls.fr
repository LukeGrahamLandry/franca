
// this works with `=> b()` instead of `b`
// it also works if you instantiate the bool one first. 
// i think the problem is that you pass arg hints when resolving the overload and it remembers those on the func as tho they were true.
// so when checking the int overload it tells the closure that it returns int and then it remembers even once it fails. 
// but it should only do that if the type is infer so that doesn't quite make sense
//
#test fn or_wrong_type() = {
    fn my_if($T: Type) void = {
        fn my_if(cond: bool, $then: @Fn() T, $else: @Fn() T) T = @if(cond, then(), else());
    }
    
    my_or :: fn(a: bool, $b: @Fn() bool) bool = {
        a.my_if(=> true, b)
    };
    
    ::my_if(i64);
    ::my_if(bool);
    
    my_or(true, => false);
}
