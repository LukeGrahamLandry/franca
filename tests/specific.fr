#test #test_llvm
fn trivial(c: i64) i64 = {
    assert_eq(42, 42);
    println("Hello World!");
    c
}

#test #test_llvm
fn trivial_indirect(c: i64) i64 = {
    #c_call fn get_42() i64 = { 42 }
    
    assert_eq(get_42(), 42);
    c
}

#test #test_llvm
fn test_ifa(c: i64) i64 = {
    let a = true;
    let b = if(a, =>123, =>456);
    assert_eq(b, 123);
    c
}

#test #test_llvm
fn test_ifb(c: i64) i64 = {
    let a = false;
    let b = (a, =>123, =>456)!if;
    assert_eq(b, 456);
    c
}

#test #test_llvm
fn math(c: i64) i64 = {
    assert_eq(20, add(5, 15));
    c
}

#test #test_llvm
fn test_while(c: i64) i64 = {
    var n = 4;
    var a = 0;
    while(=>ne(n, 0), =>{
        a = add(a, n);
        n = sub(n, 1);
    });
    assert_eq(a, 10);
    c
}

#test #test_llvm
fn var_addr(c: i64) i64 = {
    var n = 3;
    var a = n;
    var b = 0;
    let a_ptr = a!addr;
    let b_ptr = b!addr;
    b_ptr[] = add(a_ptr[], 7);
    assert_eq(b, 10);
    c
}

#test #test_llvm
fn nested(c: i64) i64 = {
    let a = add(add(add(add(add(add(add(add(add(1, 2), 3), 4), add(5, 6)), 7), 8), add(9, add(10, 11))), 12), 13);
    assert_eq(a, 91);
    c
}

#test
fn use_ptr(c: i64) i64 = {
    fn inner(a: *i64, b: *i64) i64 = {
        b[] = add(a[], 1);
        add(b[], 4)
    }
    
    var a = 5;
    var b = 0;
    let ret = inner(a&, b&);
    assert_eq(ret, 10);
    assert_eq(a, 5);
    assert_eq(b, 6);
    
    c
}

#test
fn float_calling_conv1(c: i64) i64 = {
    fn inner(a: f64, b: f64) f64 = a;
    assert_eq(inner(1.0, 2.0), 1.0);
    c
}

#test
fn float_calling_conv2(c: i64) i64 = {
    fn inner(a: f64, b: f64) f64 = b;
    assert_eq(inner(1.0, 2.0), 2.0);
    c
}

#test
fn add_floats(c: i64) i64 = {
    assert_eq(add(1.0, 2.5), 3.5);
    c
}

#test #test_llvm
fn branching_uninit_var(c: i64) i64 = {
    var t: i64 = ()!uninitialized;
    let a = true;
    if(a, => {
        t = 123;
    }, => {
        t = 456;
    });
    c
}

// TODO: explicit @runtime(E) so I can force tests to not constant fold even when that gets smarter,
//       and #comptime so you can assert that there's no runtime branch.
// TODO: 'fn if' never folds anyway so you can't use that for conditional compilation. 
//       putting @inline on it would fix if I folded through 'let' which I probably want anyway. 
// TODO: it would be cool if you could overload on const-ness of args. 
//       ie. `fn mod` could become a bit shift if it was a const known power of two. 

// this failed on interp when it dropped the shadowed var to early. 
#test #test_llvm
fn shadow_aliased(c: i64) i64 = {
    var b = 123;
    let b = b&;
    assert_eq(b[], 123);
    c
}

#test #test_llvm
fn an_uninit_var(c: i64) i64 = {
    var t: i64 = ()!uninitialized;
    c
}

#test #test_llvm
fn fields(c: i64) i64 = {
    fn inner(n: i64) i64 = {
        const A = @struct(a: i64, b: i64);
        var a: A = (a = n, b = 0);
        a.b = add(a.a, 7);
        a.b
    }
    
    assert_eq(inner(3), 10);
    c
}

#test #test_llvm
fn single_nested_struct(canary: i64) i64 = {
    const A = @struct(a: i64, b: i64);
    const B = @struct(c: A);
    
    assert_eq(A.size_of(), B.size_of());
    
    let f: A = (a = 1, b = 2);
    var thing: B = (c = f);
    
    let a = thing.c.a;
    assert_eq(a, 1);
    let b = thing.c.b;
    assert_eq(b, 2);
    
    canary
}

#test #test_llvm
fn nested_struct(canary: i64) i64 = {
    const A = @struct(a: i64, b: i64);
    const B = @struct(fst: A, snd: i64);
    
    assert_eq(A.size_of(), i64.size_of().mul(2));
    assert_eq(B.size_of(), i64.size_of().mul(3));
    
    let f: A = (a = 1, b = 2);
    var thing: B = (fst = f, snd = 3);
    
    let c = thing.snd;
    assert_eq(c, 3);
    let a = thing.fst.a;
    assert_eq(a, 1);
    let b = thing.fst.b;
    assert_eq(b, 2);
    
    canary
}

// This caused interp to drop Poison when I just added to result.to_drop for !slice,
// because the branch that wasn't taken didn't get initilized. 
// Originally found much more confusing case in @switch,
// because !unquote uses !slice to pass the placeholder arguments to the compiler. 
// Fixed by having !slice backing slots dropped at the end of the block, not the function.
#test #test_llvm
fn branching_slice(c: i64) i64 = {
    if(true, => {
        let a = (1, 2, 3)!slice;
    }, => {
       let b = (4, 5, 6)!slice;
    });
    c
}

#test #test_llvm
fn escaping_pointer(c: i64) i64 = {
    fn use_it(old: **i64, p: *i64) Unit = {
        p[] = old[][];
        old[] = p;
    };
    var x = 123;
    var y = 456;
    var z = 789;
    var old = x&;
    use_it(old&, y&);
    use_it(old&, z&);
    assert_eq(y, 123);
    assert_eq(z, 123);
    
    c
}

#test
fn varient(c: i64) i64 = {
    fn inner(n: i64) i64 = {
        const A = @tagged(a: i64, b: i64);
        var a: A = (a = n);
        add(a.a, 7)
    }
    
    assert_eq(inner(3), 10);
    c
}

#test #test_llvm
fn use_str(c: i64) i64 = {
    let s: Str = "hello";
    assert_eq(len(s), 5);
    c
}

#test fn normal_recursion() = {
    fn fib(n: i64) i64 = {
        (le(n, 1),
            fn() i64 => 1,
            fn() i64 => add(fib(n.sub(1)), fib(n.sub(2))),
        )!if
    }
    
    assert_eq(fib(5), 8);
}

#test fn mutual_recursion() = {
    fn do_1(n: i64) i64 = if(n.eq(2), => do_2(n), => 1);
    fn do_2(n: i64) i64 = if(n.eq(1), => do_1(n), => 2);

    assert_eq(do_2(2), 2);
    assert_eq(do_1(1), 1);
    assert_eq(do_1(2), 2);
}

#test fn out_of_order(canary: i64) i64 = {
    assert_eq(two(), 5);
    
    fn two() i64 = one();
    fn one() i64 = FIVE;
    const FIVE = FOUR.add(1);
    const FOUR = THREE.add(1);
    
    canary
}

const THREE = three;
const three = 3;

#test #test_llvm
fn return_an_if(c: i64) i64 = {
    // This makes you do a jump to the return block. so have to tell cranelift about block parameters correctly. 
    fn hhhh(a: i64) i64 = if(a.gt(2), => 123, => 456);
    assert_eq(hhhh(1), 456);
    assert_eq(hhhh(3), 123);
    c
}

#test #test_llvm
fn if_return_panic() = {
    // this makes sure you can spoof a Never being the right type. 
    // ie. cranelift: arguments of return must match function signature
    fn require_zero(i: i64) i64 =
        if(i.eq(0), => 0, => @as(i64) panic("non-zero"));
    
    assert_eq(0, require_zero(0));
}

#test fn dot_field_init_tagged() = {
    // since payload is unit, don't have to do (None = unit).
    a: ?i64 = .None; 
    assert_eq(true, a.is_none());
    
    MixedPayloads :: @tagged(b: i64, c, d: bool);
    e: MixedPayloads = .c; 
    assert_eq(tag_value(MixedPayloads, @symbol c), e&!tag[]);
    f := MixedPayloads.c;
    assert_eq(tag_value(MixedPayloads, @symbol c), f&!tag[]);
    
    // TODO: this is a footgun. it doesn't change the tag. and currently it doesn't even do a tag check! -- Jun 4
    // e.b = 123;
    //assert_eq(0, e&!tag[]);
}

#test fn vs_qbe() = {
    fn get_two() Ty(f64, f64) = (123.0, 456.0);
    
    a := get_two();
}
