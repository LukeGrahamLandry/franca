fun sum(self: *i64) i64 = self[];

#macro
fn derive_sum_body(ty: AstExpr, target: AstExpr) AstExpr = {
    ty := const_eval_type(ty);
    info := get_type_info(ty);
    // TODO: @default for match like switch
    //(@match(info){ //});
    
    let value = @switch(info&!tag[]){
        @case(tag_value(TypeInfo, @symbol Int)) => '()';
        @case(tag_value(TypeInfo, @symbol Struct)) fn()AstExpr => {  // TODO: better type inference. 
            var total = '0'; // its a bit sad that this looks like rust but means something totally different 
            // TODO: ffi cant refer to Slice so its just a (ptr, len) tuple. 
            let fields: Slice$Field = info&.Struct.fields[];
            for(fields) {(f: *Field)Unit|
                // TODO: be able to !unquote an identifier somehow so don't have to do this. 
                var field_ptr = '<target>.__name';
                field_ptr&.expr.FieldAccess[1][] = f.name[];
                total = 'sum(<field_ptr>).add(<total>)';
            };
            total
        };
        // TODO: better error message if you forget the arg
        // TODO: HACK: this should panic at comptime but never asm isn't handled properly -- May 6 TODO: add regresssion 
        @default() fn(_: i64) = 'panic("TODO: derive_sum")';
    };

    value
}

#test(aarch64)
fn main(canary: i64) i64 = {
    const Thing = @struct(a: i64, b: i64);
    const Other = @struct(t: Thing, b: i64);
    
    // TODO: the macro can't expand to a function declaration, because that's seen as a constant in the macro function.
    //       so it gets hoisted there instead of being ignored until the expansion. 
    fun sum(self: *Thing) i64 = (@derive_sum_body(Thing) self);
    fun sum(self: *Other) i64 = (@derive_sum_body(Other) self);
    
    var t: Thing = (a: 1, b: 2);
    let s: i64 = t&.sum();
    assert_eq(3, s);
    var t: Other = (t: t, b: 7);
    let s: i64 = t&.sum();
    assert_eq(10, s);

    canary
}
