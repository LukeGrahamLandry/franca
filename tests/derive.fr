fun sum(self: *i64) i64 = self[];

@annotation
fn derive_sum_body(ty: AstExpr, target: AstExpr) AstExpr = {
    // TODO: change how name resolution works so don't have to do this. 
    let add_fn = @literal(OverloadSet) add; 
    let sum_fn = @literal(OverloadSet) sum; 
    
    let ty: Type = const_eval_type(ty);
    var info: TypeInfo = get_type_info(ty);
    // TODO: @default for match like switch
    //(@match(info){ //});
    
    let info_tag: *i64 = info&!tag; // TODO: just debugging. should inline this. 
    let value = @switch(info_tag[]){
        (@case(tag_value(TypeInfo, Int!symbol)) fn='()');
        (@case(tag_value(TypeInfo, Struct!symbol)) fn()AstExpr = {  // TODO: better type inference. 
            var body = '0'; // its a bit sad that this looks like rust but means something totally different 
            // TODO: ffi cant refer to Slice so its just a (ptr, len) tuple. 
            let fields: Slice$Field = info&.Struct.fields[];
            for(fields) {(f: *Field)Unit|
                // TODO: be able to !unquote an identifier somehow so don't have to do this. 
                var field_ptr = '<target>.__name';
                field_ptr&.expr.FieldAccess[1][] = f.name[];
                body = '<add_fn>(<body>, <sum_fn>(<field_ptr>))';
            };
            body
        });
        // TODO: better error message if you forget the arg
        (@default() fn(_: i64)={
            panic("TODO: derive_sum");
            target // TODO: Never can't coerce because its a different size. 
        });
    };

    value
}

@test(aarch64)
fn main(canary: i64) i64 = {
    const Thing = (a: i64, b: i64)!struct;
    const Other = (t: Thing, b: i64)!struct;
    
    // TODO: the macro can't expand to a function declaration, because that's seen as a constant in the macro function.
    //       so it gets hoisted there instead of being ignored until the expansion. 
    fun sum(self: *Thing) i64 = (@derive_sum_body(Thing) self);
    fun sum(self: *Other) i64 = (@derive_sum_body(Other) self);
    
    var t: Thing = (a: 1, b: 2);
    let s: i64 = t&.sum();
    assert_eq(3, s);
    var t: Other = (t: t, b: 7);
    let s: i64 = t&.sum();
    assert_eq(10, s);

    canary
}
