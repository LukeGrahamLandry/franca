@import(interp);

fn main(_canary: i64) i64 = {
 
// Branches of a call to if can access variables from the outer scope. 
var a = 10;
(true, fn() Unit = { a = 1; }, fn() Unit = { a = 2; })!if;
assert_eq(a, 1);

var b = 1;
fn capturing(n: i64) Unit = {
    b = n;
}
assert_eq(b, 1);
capturing(15);
assert_eq(b, 15);

// Shadowed vars are still local. 
var c = 1;
fn not_capturing(n: i64) Unit = {
    var c = n;
}
assert_eq(c, 1);
not_capturing(15);
assert_eq(c, 1);


// TODO: deal with closing over constants
// TODO: force inline 
fn call_it(n: i64, f: Fn(i64, i64)) i64 = {
    print_callstack(); 
    add(f(n), 1)
}
// TODO: its an ice if you dont have brackets around the block (even before i was calling callstack() )
// TODO: hoist inline constant arguments
const temp = fn(m: i64) i64 = { print_callstack(); mul(2, m) };
// asser t_eq(9, call_it(4, temp));


// var a = 77;
// assert_ eq(3, call_it(0, fn temp(m: i64) i64 = { print_callstack(); a = 88; add(2, m) }));
// assert_ eq(a, 88);

_canary
}