
#test 
fn load_store_u8() = {
    // a word with lsb = 1
    a := 257;
    ptr := ptr_cast_unchecked(From = i64, To = u8, ptr = a&);  // pointer to lsb
    
    // now load lsb and put it in word sized stack slot. so this should be a truncation of a.
    // but we know the var is type u8 so loads should be 1 byte, so don't have to zero the slot. 
    b := ptr[]; 
    assert_eq(@as(i64) b.zext(), 1);
    
    assert_eq(a, 257); // read the whole word
    ptr[] = @as(u8) 2.trunc(); // store lsb = 2
    assert_eq(a, 258); // read the whole word
    
    // TODO: #fold to force size_of to be evaluated at compile time when possible. 
    //       rn it doesn't work on cranelift without :: because it doesn't know about #ct,
    //       but really you don't want to allow #ct at runtime at all and it should notice that this is constant. 
    assert_eq(:: u8.size_of(), 1); 
}

#test fn unit_field() = {
    Data :: @struct(a: i64, b: Unit, c: i64);
    d: Data = (a = 123, b = (), c = 456);
    assert_eq(d.a, 123);
    assert_eq(d.b, unit);
    assert_eq(d.c, 456);
}

#test fn u8_field() = {
    Data :: @struct(a: u8, b: i64);  // Note: wierd alignment :)
    d: Data = (a = @as(u8) 5.trunc(), b = 456);
    assert_eq(true, eq(d.a, @as(u8) 5.trunc()));
    assert_eq(d.b, 456);
}

// Its probably fine if you break this test for a better enum repr, but not if its by accident!
// If this stops being well defined behaviour, should give reflection info so you can do similar things. 
#test fn dont_change_tagged_padding() = {
    Data :: @tagged(small: u8, big: i64, extra_big: Str);
    d: Data = (big = 0xFFFFFFFFFFFFFFFF);
    
    d&!tag[] = tag_value(Data, @symbol small);
    d.small = @as(u8) 0.trunc();  // Here we only set one byte
    assert_eq(@as(i64) d.small.zext(), 0);
    
    d&!tag[] = tag_value(Data, @symbol big);
    assert_eq(d.big, @as(i64) 0xFFFFFFFFFFFFFF00); // So the padding should be unchanged. 
    
    // even if we do a copy while its in small mode. 
    d&!tag[] = tag_value(Data, @symbol small);
    d2 := d;
    d2&!tag[] = tag_value(Data, @symbol big);
    assert_eq(d2.big, @as(i64) 0xFFFFFFFFFFFFFF00);
}

#test fn redirect_fn_ptr_deduplicated() = {
    load_u8   :: @resolve(Fn(*u8, u8))     load;
    load_bool :: @resolve(Fn(*bool, bool)) load; 
    load_unit :: @resolve(Fn(*Unit, Unit)) load;
    
    // TODO: typo-ing  @as(raw_ptr) has the most deranged error message -- May 18
    a := (@as(rawptr) erase_types_fn(*u8, u8, load_u8!fn_ptr)).ptr_to_int();
    b := (@as(rawptr) erase_types_fn(*bool, bool, load_bool!fn_ptr)).ptr_to_int();
    c := (@as(rawptr) erase_types_fn(*Unit, Unit, load_unit!fn_ptr)).ptr_to_int();
    assert_eq(a, b);
    assert_eq(false, eq(b, c));
}

::assert_eq(u64);
::assert_eq(u32);
::ptr_utils(u32);
 
#test 
fn load_store_u32() = {
    high := 0x12345678;
    low  := 0x90ABCDEF;
    both := bit_or(low.zext(), high.zext().shift_left(32));
    assert_eq(both, 0x1234567890ABCDEF);
    
    low_ptr: *u32 = ptr_cast_unchecked(From = u64, To = u32, ptr = both&); // TODO: probably shouldn't be allowed to cast like this.
    assert_eq(low_ptr[], low);
    high_ptr := low_ptr.offset(1); 
    assert_eq(high_ptr[], high);
    
    // Storing a u32 should only change 4 bytes. 
    high_ptr[] = @as(u32) 0.trunc();
    assert_eq(low_ptr[], low);
    assert_eq(both, low.zext());
}

#test fn int_parts_struct() = {
    S :: @struct(low: u32, a: u8, b: u8, c: u16);
    s: S = (low = 0x12345678, a = 0x90, b = 0xAB, c = 0xEFCD);
    assert_eq(size_of(S), size_of(i64));
    as_int := ptr_cast_unchecked(From = S, To = u64, ptr = s&);
    assert_eq(as_int[], 0xEFCDAB9012345678);
    SS :: @struct(low: u32, high: u32);
    ss: SS = (low = 0x12345678, high = 0xEFCDAB90);
    ss_i := ptr_cast_unchecked(From = SS, To = u64, ptr = ss&);
    assert_eq(as_int[], ss_i[]);
}
