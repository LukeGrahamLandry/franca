// it's kinda hard to choose if i want to allow this. 
// i don't like reading code that projects fields as references.
// but the second thing (returning by value) 
// not working without an extra binding is pretty dumb. 
// problem is that sema doesn't insert storage so doesn't have a pointer to offset. 

//fn auto_deref_return() #test = {
main :: fn() = {
    S :: @struct(a: i64);
    s: S = (a = 123);
    identity :: fn(it: ~T) T #where = it;
    
    // this works:
    // assert_eq(123, identity(s&)[].a);
    
    // Compile Error: Place expression of type *@struct(a: i64,) expected pointer dereference.
    assert_eq(123, identity(s&).a);
    
    // Compile Error: Place expression of type @struct(a: i64,) expected pointer dereference.
    assert_eq(123, identity(s).a);
}
