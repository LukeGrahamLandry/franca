// TODO: have a less dumb register allocator. 
//       this needs to not use an O.swap (3 instruction on arm)
//       (this is a code quality problem, not a compiler bug)
// 
// This specific example is fixed by ADD_TO_REG_WAIT_LIST=true
// but that causes a net increase in code size. 
// (with =false, it guesses random registers at the end of the block and then has to fix it)
// 
// the general problem im trying to show here 
// is that do_parallel_moves assumes swap is as cheap as a move

main :: fn() void = {
    test :: fn(x: i64, y: i64, z: i64, w: i64) i64 #noinline #log_ir("RDSh") = {
        test2(y, x, w, z)
    };
    test2 :: fn(x: i64, y: i64, z: i64, w: i64) i64 #noinline #log_ir("RDSh") = {
        test3(y, w, z, x)
    };
    test3 :: fn(x: i64, y: i64, z: i64, w: i64) i64 #noinline #log_ir("RDSh") = {
        //x+y+z+w  // one swap
        x+z+y+w  // two swaps
    };
    test(1,1,1,1);
}
