main :: fn() void = {
    f :: fn(T: Type) bool #fold = false;
    
    // this one works
    fn b();
    fn b() void = ();
    @if(f(i64)) {
        fn b() void = ();  // never gets added so no conflict
    };
    b();
    
    // :DoubleConstLateFold
    // this extra '::' breaks it (unless you add another one inside the @if condition). 
    // not trivial because often you're better off not doing each #fold expression seperatly, 
    // if you need to jit a function and call it to do the evaluation, you might as well just have one. 
    // ie. a := @run { a := 1+2; a=a+3+4; a=a+5+6; a=a+7+8+9; a };
    // so maybe just declare that the semantic and say just don't put any `::` at all 
    // and make @if do it implicitly when possible? that adds even more order dependence which is sad. 
    // doing this with overload sets is kinda niche anyway. 
    fn c();
    fn c() void = ();
    ::@if(f(i64)) {
        fn c() void = ();
    };
    c();
    
    // simple case: invalid code without making an overload conflict. 
    // this one needs an extra `::` in the condition or the fold doesn't happen 
    // before trying to compile the invalid code. 
    // currently @if only implicitly folds early if the condition is trivial. 
    aa :: @if(f(i64), invalid + 1, "A");
    bb: Str = aa;
    
    // TODO: also annoying precedence, these aren't the same:
    //   :: @if(foo()) { [...];
    // @run @if(foo()) { [...];
}
