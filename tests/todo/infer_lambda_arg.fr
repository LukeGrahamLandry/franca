
main :: fn() void = {
    // not using Result to prove the problem isn't having or() overloads for both E and void. 
    MyResult :: fn($T: Type, $E: Type) Type = {
        Self :: @tagged(Ok: T, Err: E);
    
        fn or(self: Self, $else: @Fn(e: E) T) T = 
            @if(self&.is(.Ok), self.Ok, else(self.Err));
        
        Self
    };

    e: MyResult(void, Str) = (Err = "a");
    // panic! Compile Error: function argument (msg) must have type annotation (cannot be inferred unless you say #where)
    err :: fn(msg) => return();
    e.or(err);
    // works if you call it directly:
    //     err(e.Err);
    // works if you inline the lambda manually: 
    //     e.or(fn(msg) => return());
    // works if you add the type annotation: 
    //     err :: fn(msg: Str) => return();
    // but what the the error message suggests doesn't work:
    //     // Compile Error: ICE: tried to infer on bound generic placeholder
    //     err :: fn(msg) #where => return();
    unreachable();
}
