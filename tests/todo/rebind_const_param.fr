main :: fn() void = {
    @run enable_franca_ir_types(Ty(Qbe.O, Qbe.Cls));
    
    // Poison expression Argument.
    eval0 :: fn($o: Qbe.O, a0: f32, a1: f32) f32 => {
        f :: fn(a0: f32, a1: f32) f32 #ir({ (o, .Ks) });  
        f(a0, a1)
    };
    
    eval1 :: fn($o: Qbe.O, a0: f32, a1: f32) f32 => {
        XXX :: o;  // this extra binding fixes it
        f :: fn(a0: f32, a1: f32) f32 #ir({ (XXX, .Ks) });  
        f(a0, a1)
    };
    
    // and so does not being an inline lambda    !
    eval2 :: fn($o: Qbe.O, a0: f32, a1: f32) f32 = {
        f :: fn(a0: f32, a1: f32) f32 #ir({ (o, .Ks) });  
        f(a0, a1)
    };
    
    r := eval0(.mul, 1.5, 10.0);
    @assert_eq(r, 15.0);
}

Qbe :: import("@/backend/ir.fr");
