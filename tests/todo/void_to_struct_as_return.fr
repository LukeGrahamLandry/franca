// problem is probably that short circuiting when the function body 
// reduces to a constant value happens before coercing the expression to the return type. 

main :: fn() void = {
    A :: @struct {
        a := 0;
        b: i64;  // note: no default. should compile error when you try to make one from `()`
    };
    
    f :: fn() A = ();
    a: A = f();   // should error but crashes
    f(); // should error but compiles fine
    
    // debug assertions: 
    // panic! Assertion Failed: zero_padding of @struct(a: i64,b: i64,) wants 16 bytes but found 0
    // panic! value size mismatch. Assertion Failed. Expected (0 == 16
    // idk how i was getting the first one, now its always the second. 
    //
    // non-debug:
    // panic! Assertion Failed: slot %s is read but never stored to
    
// even when all fields have defaults, it doesn't work
    B :: @struct {
        a := 0;
    };
    
    g :: fn() B = ();
    b := g();
    @println("%", b.a);
}