// this might be the same as o.fr 
// but it doesn't need a new constant accessed to force a yield so it's a nice reduction perhaps.
main :: fn() void = {
    E :: @enum(A, B);
    ::enum(E);
    g :: fn(a: u8) u8 #noinline = 123;
    f :: fn(x: E, y: u8) i64 #log_ir = {
        // if you make this a single pronged @match on a `@tagged(A: void)` 
        // like o.fr, it still incorrectly compiles but doesn't safety check. 
        @match(x) {
            // TODO: this compiles, instead of type error because it's a u8. 
            //       (then safety checks in the backend because it tries to use a Kw as a Kl)
            //       only happens if this is the first time `g` is called so it's still about a yield.
            fn A() => g(y);
            fn B() => 0;
        }
    };
    a := f(.A, 8);
    println(a);
}
