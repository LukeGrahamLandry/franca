#test(aarch64)
fn main(canary: i64) i64 = {

    // The problem here was after switching to stack based ir, I would try to load a pointer into seperate stack slots
    // but i assigned the register outside the loop so each part of the typeinfo struct would stomp each other 
    // and then the last one would get spread to all slots when tried to put it on the real stack. 
    // and it would segfault on something. this was in fact not the problem I was actually looking for. -- May 1
    #comptime
    fn my_int() Type = {
        info := get_type_info(i64);
        i64
    }
    T :: my_int();
    debug_log_type(T);
    
    canary
}

/*

    
    #comptime // attempt to subtract with overflow in emit_asm but above is enoug hto trigger current bug
    fn my_int_2() Type = {
        t := IntType(32, true);
        info := get_type_info(t);
        intern_type(t);
    }
    
    */
