// TODO: this should show up in the stack trace. 
fn collect_backtrace() List(ResolvedFn) = {
    trace: List(ResolvedFn) = list(libc_allocator);
    walk_backtrace {f|
        trace&.push(f);
    };
    trace
}

#no_tail #noinline
fn thing2() i64 = {
    trace := collect_backtrace();
    
    assert_eq(trace&.index(0)[].Franca.name, @symbol thing2);
    assert_eq(trace&.index(1)[].Franca.name, @symbol thing1);
    assert_eq(trace&.index(2)[].Franca.name, @symbol backtrace_t);
    assert_eq(true, trace.len.gt(3)); // must have got some functions from the rust side. 
    
    if RUNTIME_STACK_TRACE {|
        ctx := get_context();
        
        fn f_name(i: u32) Symbol = {
            fid := i.zext().index_to_func_id();
            fid.name()
        }
        
        assert_eq(ctx.stack_trace[2].f_name(), @symbol thing2);
        assert_eq(ctx.stack_trace[1].f_name(), @symbol thing1);
        assert_eq(ctx.stack_trace[0].f_name(), @symbol backtrace_t);
    };
    
    123
}

#noinline 
fn thing1() i64 = {
    _ := 1.add(2);
    thing2()
}

//#test #skip_cranelift
fn backtrace_t(canary: i64) i64 = {
    assert_eq(123, thing1());
    canary
}
