// TODO: this should show up in the stack trace. 
fn collect_backtrace() List(ResolvedFn) = {
    var trace: List(ResolvedFn) = list(libc_allocator);
    walk_backtrace {f|
        trace&.push(f);
    };
    trace
}

#no_tail #noinline
fn thing2() i64 = {
    trace := collect_backtrace();
    assert_eq(trace&.index(0)[].Franca.name, @symbol thing2);
    assert_eq(trace&.index(1)[].Franca.name, @symbol thing1);
    assert_eq(trace&.index(2)[].Franca.name, @symbol take_stacktrace);
    assert_eq(true, trace.len.gt(3)); // must have got some functions from the rust side. 
    123
}

#noinline 
fn thing1() i64 = {
    let _ = 1.add(2);
    thing2()
}

#test #skip_cranelift
fn take_stacktrace(canary: i64) i64 = {
    assert_eq(123, thing1());
    canary
}

#test #skip_cranelift
fn exceptional(canary: i64) i64 = {
    buf := JumpBuf.zeroed();
    my_value := 0;
    
    @switch(try(buf&)) {
        @case(.Try) => {
            assert_eq(my_value, 0);
            my_value = 1;
            throw(buf&);
        };
        @case(.Catch) => {
            assert_eq(my_value, 1);
            my_value = 2;
        };
    };
    assert_eq(my_value, 2);
    
    canary
}