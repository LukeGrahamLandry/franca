#test fn allocation() = {
    let an_int: rawptr = malloc(size_of(i64));
    let an_int: *i64 = an_int;
    an_int[] = 314159;
    assert_eq(an_int[], 314159);
    free(@as(rawptr) an_int);
    
    fn slice_sum_test(arr: Slice(i64)) i64 = {
        enumerate(arr, fn(i: i64, ptr: *i64) Unit = {
            ptr[] = i;
        });
        var sum = 0;
        arr.for { (v: i64) |
            sum = sum.add(v);
        };
        sum
    }
    
    let size_10 = size_of(i64).mul(10);
    let many: rawptr = malloc(size_10);
    let many: *i64 = many;
    let arr: Slice(i64) = slice(many, 10);
    assert_eq(45, arr.slice_sum_test());
    free(@as(rawptr) many);
    
    // TODO: redo this test now that it correctly uses u8 not i64
    // This just calls mmap
    // let arr2 = os_alloc(size_10);
    // assert_eq(45, arr2.slice_sum_test());
}

#test fn open_dynamic_library() = {
    const RTLD_LAZY = 0; // TODO: check
    let libc_path = "/usr/lib/libc.dylib";
    let libc_cstr = @symbol("/usr/lib/libc.dylib").c_str(); // TODO: you cant use !symbol on the variable because then you get the var name. add a .symbol() on str
    let libc = dlopen(libc_cstr, RTLD_LAZY);
    
    // TOOD: wrap and return option
    // TODO: need to ask the compiler if we're expecting to have statically linked libc (like blink requires) so this test can't work. 
    if(libc.ptr_to_int().ne(0)) {|
        let s = @symbol("strlen").c_str();
        let strlen = dlsym(libc, s);
        assert_eq(true, strlen.ptr_to_int().ne(0)); // TOOD: wrap and return option
        let strlen: FnPtr(CStr, i64) = strlen; // TOOD: wrap with generic
        assert_eq(6, strlen(s));
        assert_eq(libc_path.len(), strlen(libc_cstr));
    };
}

#test fn c_strings(canary: i64) i64 = {
    ::ptr_utils(u8);
    
    a := "Hello World";
    b := @symbol("Hello World").c_str();
    
    range(0, a.len()) {(i: i64) Unit|
        a_char := a.get(i);
        b_char := b.get(i);
        c := a_char.eq(b_char);
        assert(c, "fail");
    };
    
    var i = 0;
    for(b) {(b_char: u8)|
        a_char := a.get(i);
        c := a_char.eq(b_char);
        assert(c, "fail");
        i = i.add(1);
    };
    
    ::assert_eq(Str);
    assert_eq(a, b.str());
    
    canary
}
