// TODO: this doesn't work on the interpreter because it can't handle real pointers. 
@test(aarch64)
fn main(canary: i64) i64 = {
    // TODO: need to mul 8 because its measured in stack slots instead of bytes. 
    let an_int: VoidPtr = malloc(size_of(i64).mul(8));
    let an_int: *i64 = an_int;
    an_int[] = 314159;
    assert_eq(an_int[], 314159);
    free(@as(VoidPtr) an_int);
    
    fn slice_sum_test(arr: Slice$i64) i64 = {
        enumerate(arr, fn(i: i64, ptr: *i64) Unit = {
            ptr[] = i;
        });
        var sum = 0;
        arr.for { (v: i64) |
            sum = sum.add(v);
        };
        sum
    }
    
    let size_10 = size_of(i64).mul(8).mul(10);
    let many: VoidPtr = malloc(size_10);
    let many: *i64 = many;
    let arr: Slice(i64) = slice(many, 10);
    assert_eq(45, arr.slice_sum_test());
    free(@as(VoidPtr) many);
    
    // This just calls mmap
    let arr2 = os_alloc(size_10);
    assert_eq(45, arr2.slice_sum_test());
    
    
    const RTLD_LAZY = 0; // TODO: check
    let libc_path = "/usr/lib/libc.dylib";
    let libc_cstr = "/usr/lib/libc.dylib"!symbol.c_str(); // TODO: you cant use !symbol on the variable because then you get the var name. add a .symbol() on str
    let libc = dlopen(libc_cstr, RTLD_LAZY);
    assert_eq(true, libc.ptr_to_int().ne(0));  // TOOD: wrap and return option
    let s = "strlen"!symbol.c_str();
    let strlen = dlsym(libc, s);
    assert_eq(true, strlen.ptr_to_int().ne(0)); // TOOD: wrap and return option
    let strlen: FnPtr(CStr, i64) = strlen; // TOOD: wrap with generic
    assert_eq(6, strlen(s));
    assert_eq(libc_path.str().len(), strlen(libc_cstr));
    
    let a: i64 = @as(Str) 1;
    
    
    
    // Test my insane calling convention
    let res = test_flat_call_fma(5, 2, 3);
    assert_eq(res, 13);
    
    canary
}
