#test fn simple_allocation() = {
    // Use `alloc` to create space that outlives the current stack frame. 
    fn dont_leak(size: i64) Slice(i64) = temp().alloc(i64, size);
    
    let on_the_heap = dont_leak(10);
    first: *i64 = on_the_heap.ptr;
    first[] = 15; // just setting the first in the array of 10
    assert_eq(first[], 15);
    
    temp().dealloc(i64, on_the_heap);
}

#test fn tuple_ptr() = {
    var arr = (1, 2, 3);
    let arr_ptr = arr&; 
    
    // you can create a pointer to an element of a tuple (constant index only)
    let second_ptr: *i64 = arr_ptr[]._1&; 
    assert_eq(2, second_ptr[]); // we can dereference as normal.
    second_ptr[] = 123;
    // TODO: comptime variadic functions so !deref is just get.
    // The type annotation for a tuple is written as a tuple of types. 
    var have: Ty(i64, i64, i64) = arr_ptr[];
    var expected: Ty(i64, i64, i64) = (1, 123, 3);
    
    assert_eq(have._0, expected._0);
    assert_eq(have._1, expected._1);
    assert_eq(have._2, expected._2);
}

#test fn indexing() = {
    let s: Str = "hello";
    assert_eq(len(s), 5);
    
    var v: List(i64) = list(1, temp());
    assert_eq(v.maybe_uninit.len, 1);
    push(v&, 6);  // TODO: fix error message for missing & from being ""abbigousss call", thats not true, its not declared func
    assert_eq(v.maybe_uninit.len, 1);
    push(v&, 8);
    assert_eq(v.maybe_uninit.len, 4);
    push(v&, 9);
    assert_eq(v.len, 3);
    assert_eq(v.maybe_uninit.len, 4);
    assert_eq(v[0], 6);
    assert_eq(v[1], 8);
    assert_eq(v[2], 9);
    drop(v&);
}

#test fn comparing_strings_eq() = {
    assert_eq(true, eq("abcd", "abcd"));
    assert_eq(false, eq("abcd", "dcba"));
    assert_eq(false, eq("abcd", "abcde"));
    assert_eq(false, eq("aaab", "aaac"));
    assert_eq(true, eq("", ""));
}

// note: this is a good one to fix first when verbose_assert is broken.
#test fn stringify_int() = {
    output: List(u8) = list(temp());
    5.display(output&);
    assert_eq(true, eq(output.items(), "5"));
    output&.clear();
    12.display(output&);
    assert_eq(true, eq(output.items(), "12"));
    output&.clear();
    345.display(output&);
    assert_eq(true, eq(output.items(), "345"));
}

#test fn cmp_prefix_suffix() = {
    assert_eq(true, starts_with("abcd", "ab"));
    assert_eq(true, starts_with("abcd", "abcd"));
    assert_eq(false, starts_with("abcd", "cd"));
    assert_eq(false, starts_with("ab", "abcd"));
    assert_eq(false, starts_with("aab", "ab"));
    assert_eq(true, ends_with("abcd", "cd"));
    assert_eq(true, ends_with("abcd", "abcd"));
    assert_eq(false, ends_with("abcd", "ab"));
    assert_eq(false, ends_with("ab", "abcd"));
    
    let multiline = """aaa
    bbb""";
    assert_eq(true, starts_with(multiline, "aaa"));
    assert_eq(true, ends_with(multiline, "bbb"));
}

#test fn splitting_strings() = {
    var parts: List(Str) = split("Hello world. This is words.", " ", temp());
    assert_eq(5, parts.len);
    assert_eq(true, eq(parts[0], "Hello"));
    assert_eq(true, eq(parts[1], "world."));
    assert_eq(true, eq(parts[2], "This"));
    assert_eq(true, eq(parts[3], "is"));
    assert_eq(true, eq(parts[4], "words."));
    assert_eq(false, eq(parts[1], "Hello"));  // i live in fear
    
    // Count start and end as empty strings
    var parts: List(Str) = split("%a%b%", "%", temp());
    assert_eq(4, parts.len);
    assert_eq(true, eq(parts[0], ""));
    assert_eq(true, eq(parts[1], "a"));
    assert_eq(true, eq(parts[2], "b"));
    assert_eq(true, eq(parts[3], ""));
    
    parts&.drop();
}

#test fn parsing_hex() = {
    assert_eq(4294983856, hex("00000001000040b0"));
    assert_eq(4294983856, hex("00000001000040B0"));
    var lst = concat("00000001", "000040B0", temp());
    assert_eq(4294983856, hex(lst&.items()));
}

#test fn parsing_float() = {
    assert_eq(123.456, float("123.456"));
}

#test fn escape_characters() = {
    ::assert_eq(Str);
    
    a := """hello
world""";
    assert_eq(a, "hello\nworld");
    assert_eq(""" " """, " \" ");
    assert_eq("""\""", "\\");
    assert_eq(10, "\n".char());  // Note: .char is const so this relies on #fold. 
    assert_eq(@as(i64) 0xAB.zext(), "\xAB".char());
}

#test fn big_list() = {
    S :: @struct(a: i64 = 0, b: i64 = 0, c: i64 = 0, d: u32 = 0.trunc());
    
    things: List(S) = list(temp());
    
    things&.push((a = 1));
    things&.push((a = 2));
    things&.push((a = 3));
    things&.push((a = 4));
    things&.push((a = 5));
    things&.push((a = 6));
}

#test fn buckets() = {
    arr: BucketArray(i64) = init(128, temp());
    pointers: List(*i64) = list(1000, temp());
    total := 0;
    range(0, 1000) { i |
        ptr := arr&.push(i);
        pointers&.push(ptr);
        total += i;
    };
    pointers.enumerate { i, p |
        assert(eq(i, p[][]), "fail");
    };
    
    arr2: BucketArray(*i64) = init(128, temp());
    chunks: List(Slice(*i64)) = list(20, temp());
    i := 0;
    chunk_size :: 50;  // not a factor of the bucket size!
    while(=> i.lt(1000)) {|
        chunk := pointers&.items().subslice(i, chunk_size); 
        ref := arr2&.push_all(chunk);
        chunks&.push(ref);
        i += chunk_size;
    };
    
    sum := 0;
    for(chunks){ chunk |
        for(chunk){ i |
            sum += i[];
        };
    };
    
    assert_eq(sum, total);
}

#test fn zero_values() = {
    assert_eq(0, i64.zeroed());  // TODO: fix overloading.rs so you can swap the order of these arguments if you wanted. 
    
    arr := Array(i64, 3).zeroed();
    for(arr&, fn(e) => assert_eq(e, 0));
    
    s := Slice(i64).zeroed(); // null pointer! jail!
    assert_eq(s.len, 0);
}
