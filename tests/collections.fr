#test fn simple_allocation() = {
    // Use `alloc` to create space that outlives the current stack frame. 
    fn dont_leak(size: i64) rawptr = alloc(i64, size);
    
    let on_the_heap = dont_leak(10);
    first: *i64 = on_the_heap;
    first[] = 15; // just setting the first in the array of 10
    assert_eq(first[], 15);
    
    dealloc(i64, on_the_heap, 10);
}

#test fn tuple_ptr() = {
    var arr = (1, 2, 3);
    let arr_ptr = arr&; 
    
    // you can create a pointer to an element of a tuple (constant index only)
    let second_ptr: *i64 = arr_ptr[].(1)&; 
    assert_eq(2, second_ptr[]); // we can dereference as normal.
    second_ptr[] = 123;
    // TODO: comptime variadic functions so !deref is just get.
    // The type annotation for a tuple is written as a tuple of types. 
    var have: (i64, i64, i64) = arr_ptr[];
    var expected: (i64, i64, i64) = (1, 123, 3);
    
    assert_eq(have.(0), expected.(0));
    assert_eq(have.(1), expected.(1));
    assert_eq(have.(2), expected.(2));
}

#test fn indexing() = {
    let s: Str = "hello";
    assert_eq(len(s), 5);
    
    var v: List(i64) = list(1);
    assert_eq(v.maybe_uninit.len, 1);
    push(v&, 6);  // TODO: fix error message for missing & from being ""abbigousss call", thats not true, its not declared func
    assert_eq(v.maybe_uninit.len, 1);
    push(v&, 8);
    assert_eq(v.maybe_uninit.len, 4);
    push(v&, 9);
    assert_eq(v.len, 3);
    assert_eq(v.maybe_uninit.len, 4);
    assert_eq(index(v&, 0)[], 6);
    assert_eq(index(v&, 1)[], 8);
    assert_eq(index(v&, 2)[], 9);
    drop(v&);
    
    let s: Slice$Str = ("1", "2", "3")!slice;
    // multi_println(s);  // This is annoying cause it prints
}

#test fn comparing_strings_eq() = {
    assert_eq(true, eq("abcd", "abcd"));
    assert_eq(false, eq("abcd", "dcba"));
    assert_eq(false, eq("abcd", "abcde"));
    assert_eq(false, eq("aaab", "aaac"));
    assert_eq(true, eq("", ""));
}

// note: this is a good one to fix first when verbose_assert is broken.
#test fn stringify_int() = {
    assert_eq(true, eq(str(5), "5"));
    assert_eq(true, eq(str(12), "12"));
    assert_eq(true, eq(str(345), "345"));
}


#test fn cmp_prefix_suffix() = {
    assert_eq(true, startswith("abcd", "ab"));
    assert_eq(true, startswith("abcd", "abcd"));
    assert_eq(false, startswith("abcd", "cd"));
    assert_eq(false, startswith("ab", "abcd"));
    assert_eq(false, startswith("aab", "ab"));
    assert_eq(true, endswith("abcd", "cd"));
    assert_eq(true, endswith("abcd", "abcd"));
    assert_eq(false, endswith("abcd", "ab"));
    assert_eq(false, endswith("ab", "abcd"));
    
    let multiline = """aaa
    bbb""";
    assert_eq(true, startswith(multiline, "aaa"));
    assert_eq(true, endswith(multiline, "bbb"));
}

#test fn splitting_strings() = {
    var parts: List$Str = split("Hello world. This is words.", " ");
    assert_eq(5, parts.len);
    assert_eq(true, eq(get(parts, 0), "Hello"));
    assert_eq(true, eq(get(parts, 1), "world."));
    assert_eq(true, eq(get(parts, 2), "This"));
    assert_eq(true, eq(get(parts, 3), "is"));
    assert_eq(true, eq(get(parts, 4), "words."));
    assert_eq(false, eq(get(parts, 1), "Hello"));  // i live in fear
    
    // Count start and end as empty strings
    var parts: List$Str = split("%a%b%", "%");
    assert_eq(4, parts.len);
    assert_eq(true, eq(get(parts, 0), ""));
    assert_eq(true, eq(get(parts, 1), "a"));
    assert_eq(true, eq(get(parts, 2), "b"));
    assert_eq(true, eq(get(parts, 3), ""));
    
    parts&.drop();
}

#test fn parsing_hex() = {
    assert_eq(4294983856, hex("00000001000040b0"));
    assert_eq(4294983856, hex("00000001000040B0"));
    var lst = concat("00000001", "000040B0");
    assert_eq(4294983856, hex(lst&.items()));
}
