// https://harelang.org
// this program is equivalent to running "make check" for harec and hare. 
// it uses my import_c to compile harec and my backend to compile the text ir it outputs. 

// TODO: their backtrace printer doesn't like my symbol table
//       (changing .dynsym to .symtab wasn't enough in elf/emit)
// TODO: it would be nice to patch_out_interp_header since they do their own syscalls 
//       but i don't think they do their own relocations? 
// TODO: don't depend on system clang for assembling/linking the .s files. 
clang :: Foreign.EXE.clang; 

main :: fn() void = {
    start := get_working_directory(temp()).items();

    root := Foreign'harec();
    
    Syscall'chdir(root.as_cstr());
    
    @assert_eq(query_current_os(), .linux, "TODO: hare os");
    
    mark := temp().mark();
    compile_harec();
    temp().reset(mark);
    test_harec();
    Syscall'chdir(start.as_cstr());
    temp().reset(mark);
    
    verbose := cli_args().contains(fn(it) => it[].str() == "-verbose");
    test_hare(@tfmt("%/.bin/harec", root), verbose);
    temp().reset(mark);
}

// the output path (.bin/harec) matters because the tests exec it
compile_harec :: fn() void = {
    files := collect_directory_ordered("src", temp(), temp()).unwrap();

    start_time := timestamp();
    arch := to_harec_arch(query_current_arch());
    files2 := Str.list(temp());
    
    for files { it |
        if it.name.ends_with(".c") {
            files2&.push(@tfmt("src/%", it.name));
        };
    };
    
    // TODO: use it through import_module
    C :: import("@/examples/import_c/lib.fr");
    
    c := @ref zeroed(C.Compile.Ctx);
    m := @ref zeroed(Qbe.Module);
    Qbe'backend'init_module(m, (
        arch = query_current_arch(),
        os = query_current_os(),
        type = .Exe,
        wrap_entry_for_linux_libc = true,
        exe_debug_symbol_table = true,
    ));
    ctx := init_codegen_worker(m, true);
    C'init_ctx(c, m, ctx);
    c.include_paths&.push("include");
    
    for files2 { it |
        // :discard_static_scope
        c.macros&.clear();
        C'Preprocess'init_macros(c);
        c.define_macro("VERSION", "\"xxx\"");
        c.define_macro("DEFAULT_TARGET", @tfmt("\"%\"", arch));
        c.scope.vars&.clear();
        c.pragma_once&.clear();
    
        src := read_entire_file_or_crash(temp(), it);
        result := C'catch_call(c, void) {
            tok := c.tokenize_string(it, src);
            tok  = c.C'Preprocess'preprocess(tok);
            c.C'Compile'parse(tok);
        };
        @if_let(result) fn Err(msg) => {
            @panic("failed to compile %\n%", "", msg);
        };
    };
    
    ctx.join_codegen_thread();
    chunks := {m.target.finish_module}(m);
    @assert make_dir(".bin");
    write_chunks_or_crash(".bin/harec", chunks);
    c.arena_storage&.deinit();
    drop(m);
    @println("compiled harec in %ms", timestamp() - start_time);
}

// the "harec" repo has a minimal rt implementation and some tests. 
// each test is an exe with a main() function (not @test functions). 
// TODO: share more code with the hare tests? when i wrote this i was being extra linker-y
test_harec :: fn() void = {
    arch := to_harec_arch(query_current_arch());
    rt_hare := @slice(
        "rt/abort.ha", 
        "rt/compile.ha",
        "rt/cstrings.ha",
        "rt/ensure.ha",
        "rt/itos.ha",
        "rt/memcpy.ha",
        "rt/memmove.ha",
        "rt/memset.ha",
        "rt/strcmp.ha",
        "rt/+linux/errno.ha",
        "rt/+linux/syscalls.ha",
        "rt/+linux/start.ha",
        "rt/malloc.ha",
        @tfmt("rt/+linux/syscallno+%.ha", arch),
        "rt/+linux/segmalloc.ha",
    );
    
    @assert make_dir(".out");
    td :: @const_slice(
        ("rt", ".out/rt.td.tmp"),
        ("testmod", ".out/testmod.td.tmp"),
    );
    
    env := build_env_vars(td);
push_as_tls(.environment_variables, env) {
    rt_ssa := run((
        a = query_current_arch(), 
        input = rt_hare,
        t = (Some = ".out/rt.td.tmp"),
        N = (Some = "rt"),
    ), "./.bin/harec", temp())
        .or(fn(msg) => @panic("failed to compile rt\n%", msg.items()));
    
    testmod_ssa := run((
        a = query_current_arch(), 
        input = @slice("testmod/measurement.ha", "testmod/testmod.ha"),
        t = (Some = ".out/testmod.td.tmp"),
        N = (Some = "testmod"),
    ), "./.bin/harec", temp()).unwrap();
    
    tests := collect_directory_ordered("tests", temp(), temp()).unwrap();
    tests&.ordered_retain(fn(it) => it.name.ends_with(".ha"));
    
    // SKIP
    // (orb) 17-alloc.ha rosetta error: could not find free space for allocation size 1c6bf52635000
    // they're trying to test allocation failure and rosetta cannot cope i guess?
    if query_current_arch() == .x86_64 {
        // on macos it's `sysctl -n sysctl.proc_translated` but that doesn't work in orb and hare doesn't support macos anyway. 
        ok, o, e := exec_and_catch("sysctl", @slice("-n", "fs.binfmt_misc.rosetta"), temp());
        if ok && o.items().contains("enabled\ninterpreter [rosetta]") {
            tests&.ordered_retain(fn(it) => !it.name.ends_with("17-alloc.ha"));
            @eprint("Skipped 17-alloc.ha: confuses rosetta\n");
        };
    };
    
    Ctx :: @struct(rt_ssa: Str, testmod_ssa: Str);
    ctx: Ctx = (rt_ssa = rt_ssa.items(), testmod_ssa = testmod_ssa.items());
    // TODO: if you say => instead of =, the error should say expected fnptr not expected type annotation. :compilerbug
    run_tests_main_threaded(Ctx, DirEntry, ctx, tests.items(), fn(_, it) = it.name, fn(c, it) = {
        yield :: return;
        exe := @tfmt(".out/%.out", it.name);
        in := run((
            a = query_current_arch(), 
            input = @slice(@tfmt("tests/%", it.name)),
        ), "./.bin/harec", temp()).or(fn(err) => yield(false, list(u8, temp()), err, ""));
        
        ssa := @slice((c.rt_ssa, "rt"), (c.testmod_ssa, "testmod"), (in.items(), it.name));
        have_assembler := query_current_arch() == .aarch64;
        m, sections := start_module(@if(have_assembler, .Exe, .Relocatable));
        arch := to_harec_arch(query_current_arch());
        if have_assembler {
            asm_blob := @ref u8.list(temp());
            read_and_push_or_crash(asm_blob, @tfmt("rt/+linux/start+%.s", arch));
            read_and_push_or_crash(asm_blob, @tfmt("rt/+linux/syscall+%.s", arch));
            import("@/examples/import_c/assemble.fr")'parse_and_emit(m, asm_blob.items());
            m.goal.entry_point = "_start";
        };
        ctx := init_codegen_worker(m, false);
        for ssa { ssa, name |
            load_ir_text(ctx, ssa, sections, name)
                .or(fn(msg) => {
                    msg := @tfmt("failed to backend %\n%", name, msg);
                    yield(false, list(u8, temp()), msg.assume_owned(temp()), "")
                });
        };
        ctx.join_codegen_thread();
        obj := end_module(m, sections);

        if have_assembler {
            write_entire_file_or_crash(exe, obj);
        } else {
            o := @tfmt(".out/%.o", it.name);
            write_entire_file_or_crash(o, obj);
            clang_triple := import("@/examples/default_driver.fr")'target_triple(query_current_arch(), query_current_os());
            sh(@slice(clang, "-target", clang_triple, o, @tfmt("rt/+linux/start+%.s", arch), @tfmt("rt/+linux/syscall+%.s", arch), "-o", exe, "-nostartfiles"));
        };
        general_allocator().dealloc(u8, obj);
        // compile() in the tests execs harec so need to give it the td files
        ok, out, err := exec_and_catch(exe, empty(), temp()); 
        (ok, out, err, "")
    });
};
}

// like qbe_frontend.fr but collects section directives
// and uses them to makes init,fini,test arrays

Sections :: HashMap(Str, List(Qbe.Dat2));
start_module :: fn(t: Qbe.OutputPurpose) Ty(*Qbe.Module, *Sections) #inline /*semantic*/ = {
    sections: Sections = init(temp());
    m := @ref zeroed(Qbe.Module);
    Qbe'backend'init_module(m, (
        arch = query_current_arch(),
        os = query_current_os(),
        type = t,
        wrap_entry_for_linux_libc = false,
        exe_debug_symbol_table = true,
    ));
    for @slice("init", "fini", "test") { s |
        insert(sections&, @tfmt(".%_array", s), list(m.forever&.borrow()));
    };
    (m, sections&)
}

// :ugly
load_ir_text :: fn(shared: *Qbe.CodegenShared, ssa: []u8, sections: *Sections, mangle_prefix: Str) Result(void, Str) = {
    #use("@/backend/meta/parse.fr");
    m := shared.m;
    self: QParseCtx = init(m, ssa);
    section: ?Section = .None;
    result: ?Result(void, Str ) = .None;
    while => result&.is_none() {
    enter_task shared { e |
        yield :: local_return;
        loop {
        @match(self&.parse_one()) {
            fn Func(f) => {
                section = .None;
                if mangle_prefix.len > 0 {
                    mangle(m, f.lnk.id&, mangle_prefix);
                    each f.con.slice(0, f.ncon.zext()) { it |
                        mangle(m, it.sym&, mangle_prefix);
                    };
                };
                e.task = (Func = f);
                yield();
            }
            fn Data(d) => {
                continue :: local_return;
                if mangle_prefix.len > 0 {
                    mangle(m, d.id&, mangle_prefix);
                    each d.relocations { it |
                        mangle(m, it.id&, mangle_prefix);
                    };
                };
                
                if section { s |
                    if sections.get_ptr(s.name) { it |
                        d.relocations = d.relocations.shallow_copy(m.forever&.borrow());
                        @if_let(d.template&) fn Bytes(it) => {
                            it[] = it[].shallow_copy(m.forever&.borrow());
                        };
                        it.push(d);
                        continue();
                    }
                };
                
                section = .None;
                e.task = (AotVar2 = temp().alloc_init(Qbe.Dat2, 1, fn(_) => d));
                yield();
            };
            fn Type() => ();
            fn Err(msg) => {
                result = (Some = (Err = msg));
                e.task = (AotVar2 = empty());
                yield();
            }
            fn Section(s) => {
                section = (Some = s);
            }
            fn Eof() => {
                result = (Some = .Ok);
                e.task = (AotVar2 = empty());
                yield();
            }
        };
        }
    };
    };
    .Ok
}

// i don't support sections. 
// to make the init/fini tests work, add the array symbols manually. 
// this works without thier linker script but relies on there only being 
// one compilation unit that wants to add things to the arrays. 
seal_array_sections :: fn(m: *Qbe.Module, sections: *Sections) void = {
    each sections { name, values |
        continue :: local_return;
        name := name.subslice(1, 4);
        // rt/+linux/start.ha looks for these symbols
        start := m.intern(@tfmt("__%_array_start", name));
        end := m.intern(@tfmt("__%_array_end", name));
        
        if values.len == 0 {
            Qbe'backend'compile_dat(m, (
                id = start,
                template = (Zeroes = 0),
                relocations = empty(),
                export = true,
            ));
            Qbe'backend'compile_dat(m, (
                id = end,
                template = (Zeroes = 0),
                relocations = empty(),
                export = true,
            ));
            continue();
        };
        ids := @ref Qbe.Sym.list(values.len + 1, temp());
        
        // HACK: need it to put start..end sequentially
        //       and rn i don't use bss if there are relocations 
        //       so can't use (Zeroes=_) because that would go to bss. 
        
        values[0].id = start;
        values[0].export = true;
        
        for values { d |
            @if_let(d.template) fn Zeroes(size) => {
                d.template = (Bytes = temp().alloc_init(u8, size, fn(_) => 1));
            };
            ids.push(d.id);
            Qbe'backend'compile_dat(m, d);
        };
        
        Qbe'backend'compile_dat(m, (
            id = end,
            template = (Bytes = @slice(@as(u8) 1)),
            relocations = empty(),
            export = true,
        ));
        ids.push(end);
        assert_sequential(m, ids.items()); 
    };
}

end_module :: fn(m: *Qbe.Module, sections: *Sections) []u8 = {
    seal_array_sections(m, sections);
    m.Qbe'backend'compile_suspended();
    chunks := {m.target.finish_module}(m);
    out := concat(chunks, general_allocator());
    drop(m);
    out
}

// :discard_static_scope
// i want to do it all in one compilation unit and that mostly works because 
// harec mangles symbols by prepending the module name, except for local 
// data that doesn't correspond to a symbol in the user program (like string literals, etc.). 
// have to be careful not to disrupt exports/imports. 
// HACK: rn all the synthetic names harec uses have these prefixes but it's dumb to break if they add some
synthetic_prefix :: @const_slice(
    "strliteral.", "strdata.", "sldata.", "static.", 
    "testfunc", "initfunc", "finifunc",
    ".test.", ".init.", ".fini.",
);

fn mangle(m: *Qbe.Module, id: *Qbe.Sym, prefix: Str) void = {
    @if(id[] == Qbe.no_symbol_S) return();
    old := m.str(id[]);
    @if(!synthetic_prefix.contains(fn(it) => old.starts_with(it[]))) return();
    id[] = m.intern(@tfmt("%.%", prefix, old));
}

// the "hare" repo has another rt implementation and modules with @test functions. 
// :ugly
test_hare :: fn(harec: Str, verbose: bool) void = {
    root := Foreign'hare();
    
    have_assembler := query_current_arch() == .aarch64;
    start_time := timestamp();
    // TODO: respect HAREPATH
    modules, po := collect_ordered_deps(root);
    
    // i want to be able to run it in a sandbox that doesn't have a shell. 
    have_shell := file_exists(Foreign.PATH.bin_sh);
    skip_msg := @ref u8.list(temp());
    @if(!have_shell) if modules.find(fn(it) => it.name == "/wordexp") { it |
        ::display_slice(Str);
        @fmt(skip_msg, "Skipped %: Requires /bin/sh\n", it.hare);
        it.hare.len = 0;
    };
    
    if verbose {
        ::display_slice(Str);
        ::display_slice(i64);
        out := @ref u8.list(temp());
        for po { i |
            it := modules[i]&;
            @fmt(out, "[%] %\n", i, it.name);
            @fmt(out, "- %\n- %\n- use %\n", it.hare, it.asm, it.use);
        };
        print(out.items());
    }
    
    arch := to_harec_arch(query_current_arch()); 
    active_tags := @slice("linux", arch, "test");
    
    make_dirs_or_crash(@tfmt("%/.out", root));
    start_time := timestamp();
    m, sections := start_module(@if(have_assembler, .Exe, .Relocatable));
    
    asm_blob := @ref u8.list(temp());
    each modules { it |
        asm := filter_tags(it.asm, active_tags);
        for asm { it |
            @fmt(asm_blob, "// (include %)\n", it);
            @assert(it.starts_with("/"));
            read_and_push(asm_blob, @tfmt("%%", root, it));
        };
    };
    
    if have_assembler {
        import("@/examples/import_c/assemble.fr")'parse_and_emit(m, asm_blob.items());
        m.goal.entry_point = "_start";
    };
    
    send: TaskTube = (ring = m.forever&.borrow().alloc_zeroed(Ty(Str, Str), 4));
    
    Worker :: @struct {
        m: *Qbe.Module;
        sections: *Sections;
        send: *TaskTube;
        count: i64;
    };
    thread := Worker.start_thread_data(@ref @as(Worker) (
        m = m,
        sections = sections, 
        send = send&,
        count = modules.len,
    ), work);
    compile_to_ssa(modules, po, active_tags, harec, root, send&, verbose);
    
    work :: fn(self: *Worker) void = {
        ctx := init_codegen_worker(self.m, true);
        while => self.count > 0 {
            name, ssa := self.send.pop();
            self.count -= 1;            
            // :discard_static_scope throwing away QParseCtx.types each time is intentional
            load_ir_text(ctx, ssa, self.sections, name)
                .or(fn(msg) => @panic("failed to compile ssa: %\n%", name, msg));
        };
        ctx.join_codegen_thread();
    };
    
    thread.join();
    m.flush_debug();
    
    exe := @tfmt("%/.out/test.out", root);
    
    if have_assembler {
        obj := end_module(m, sections);
        write_entire_file_or_crash(exe, obj);
    } else {
        obj := end_module(m, sections);
        obj_o := @tfmt("%/.out/test.o", root);
        write_entire_file_or_crash(obj_o, obj);
        asm_s := @tfmt("%/.out/test_asm.s", root);
        write_entire_file_or_crash(asm_s, asm_blob.items());
        clang_triple := import("@/examples/default_driver.fr")'target_triple(query_current_arch(), query_current_os());
        sh(@slice(clang, "-target", clang_triple, asm_s, obj_o, "-o", exe, "-nostartfiles"));
    };
    
    @println("frontend+backend wall: %ms", timestamp() - start_time);
    println(exe);
    success := run_cmd_blocking(exe, empty());
    eprint(skip_msg.items());
    @assert(success);
}

// SAFETY: don't reset(temp()) here because strings of ssa are passed to the other thread
// 
// it's a bit dumb that im just blocking on the first one. 
// it might be a big thing at the end of a chain 
// and the next thing could already be done and unblock a lot of new things. 
// but im already getting more threads than i have p-cores. 
// the problem isn't that it's not parallel, the problem is that it spends 60% of its time 
// re-parsing the .td files every 128 times you exec it. 
fn compile_to_ssa(modules: []HareModule, po: []i64, active_tags: []Str, harec: Str, root: Str, send: *TaskTube, verbose: bool) void = {
    #use("@/lib/sys/subprocess.fr");
    
    td, names, out_td := build_td(modules, root);
    td := build_env_vars(td);  // wasteful to allocate td just to reallcoate here
push_as_tls(.environment_variables, td) {
    
    Task :: @struct(i: i64, p: RunningProcess);
    work: RawDeque(Task) = init(temp(), 32);
    err := u8.list(temp());
    done := init_bitset(po.len);
    started := init_bitset(po.len);
    start(po[0]);
    while => work&.pop_front() { it |
        out := u8.list(temp());
        status := poll_until_exit(it.p&, out&, err&, "");
        if status != 0 {
            @panic("failed to compile % (status %)\n%", names[it.i], status, err.items());
        };
        @if(err.len > 0) eprint(err.items());
        err&.clear();
        
        ssa := out.items();
        push(send, (names[it.i], ssa));
        
        if verbose && ssa.len > 0 {
            write_entire_file_or_crash(@tfmt("%/.out/%.ssa", root, it.i), ssa);
        };
        
        done&.bsset(it.i);
        // start running any whose last dependency was this one. 
        // silly to recheck everything every time but if you can't see it in the profile it doesn't matter. 
        po_i := po.len - modules[it.i].id - 1;
        for po.rest(po_i) { i |
            break :: local_return;
            for modules[i].use { j |
                if !done&.bshas(j) {
                    break();
                };
            };
            
            start(i);
        };
    };
    
    start :: fn(i: i64) void => {
        break :: local_return;
        @if(started&.bshas(i)) break();
        started&.bsset(i);
        it := modules[i]&;
        hare := filter_tags(it.hare, active_tags);
        input := temp().alloc_init(Str, hare.len, fn(i) => @tfmt("%%", root, hare[i]));
        if hare.len == 0 || it.name.len == 0 {
            done&.bsset(i);
            // need to send even when empty because the other side is counting to know when we're done. 
            push(send, ("", ""));
            break();
        };
        args := build_args(
            a = query_current_arch(), 
            input = input,
            N = (Some = names[i]),
            t = (Some = out_td[i]),
            tests = true,
        ); 
        args := make_args_for_exec(harec, args, temp());
        ::Result(RunningProcess, Str);
        work&.push_back((
            p = sys_capture_exec(args)
                .or(fn(msg) => @panic("failed to spawn harec. %", msg)),
            i = i, 
        ), temp());
    };
};
}

HareModule :: @struct {
    name: Str;
    hare: []Str;
    asm: []Str;
    use: []i64;
    id := -1;
};

collect_ordered_deps :: fn(root: Str) Ty([]HareModule, []i64) = {
    modules := collect_modules(root);
    
    // make everything reachable. 
    @assert_eq(modules[0].name, "");  // root
    modules[0].use = temp().alloc_init(i64, modules.len - 1, fn(i) => i + 1);
    
    // need to compile them in order because harec needs a .td file for each dependency. 
    fillrpo(modules);
    po := temp().alloc_zeroed(i64, modules.len);
    enumerate modules { i, it |
        po[po.len - it.id - 1] = i;
        
        for it.use { u |
            uu := modules[u]&;
            @assert_lt(it.id, uu.id, "cyclic dependency: % uses %", it.name, uu.name);
        };
    };

    (modules, po)
}

// TODO: should seperate out the part where i collect use
//       and do it after filtering out tags so don't add false dependencies. 
//       (plus then don't have to read files that won't be used)

// a module is a folder of hare and assembly files. 
// in each module, find all the lines like `use foo::bar`. 
collect_modules :: fn(root: Str) []HareModule = {
    stack := Str.list(temp());
    stack&.push("");
    scratch := u8.list(temp());
    out := HareModule.list(temp());
    ids: HashMap(Str, i64) = init(temp());
    dirs := Str.list(temp());
    while => stack&.pop() { name |
        asm, use, hare := (Str.list(temp()), ..Str.list(temp()));
        dirs&.push(name);
        
        while => dirs&.pop() { name |
            walk_directory_unordered(@fmt_cstr("%/%", root, name)) { entry |
                continue :: local_return;
                name := @tfmt("%/%", name, entry.name);
                @match(entry.type) {
                    fn File() => {
                        if name.ends_with(".ha") {
                            hare&.push(name);
                            // TODO: don't read the whole file just to look at the first few bytes
                            scratch&.read_and_push_or_crash(@tfmt("%/%", root, name));
                            collect_use(use&, scratch.items());
                            scratch&.clear();
                        }
                        if name.ends_with(".s") {
                            asm&.push(name);
                        }
                    }
                    fn Directory() => {
                        @if(entry.name.starts_with(".")) continue();  // notably .git,.bin
                        
                        if !(entry.name.starts_with("+")) {
                            stack&.push(name);
                            continue();
                        };
                        
                        // directories named with a tag like +platform are not new modules, 
                        // instead treat all the files inside as having that tag (flattened into the parent). 
                        // (importantly all symbols of the module are still implicitly available). 
                        
                        dirs&.push(name);
                    }
                    @default => continue();
                };
            };
        };
        
        // compiler inserts calls to rt functions so it's implicitly used by everything. 
        if name != "/rt" && name != "" && !use.contains("/rt") {
            use&.push("/rt");
        };
        
        find :: fn(name) => 
            ids&.get_or_insert(name, => { out&.push(zeroed(HareModule)); out.len - 1 })[];
        u := temp().alloc_init(i64, use.len, fn(i) => find(use[i]));
        i := find(name);
        out[i] = ( 
            name = name,
            hare = hare.items(),
            asm = asm.items(),
            use = u,
        );
    };
    
    // TODO: sort out,hare,asm,use so repro regardless of file system order. 
    //       use matters because there are multiple topological orders and which is chosen is arbitrary. 
    
    enumerate out { i, it |
        if it.id != -1 {
            each ids& { k, v |
                @if(v[] == i) @panic("ERROR: module % is used but not declared", k);
            };
            unreachable();
        };
    };
    
    out.items()
}

fn fillrpo(it: []HareModule) void = {
    n := rporec(it, 0, it.len - 1) + 1;
    @assert_eq(n, 0);
    rporec :: fn(it: []HareModule, i: i64, x: i64) i64 = {
        @if(it[i].id != -1) return(x);
        it[i].id = 1;
        for it[i].use { i |
            x = rporec(it, i, x);
        };
        it[i].id = x;
        x - 1
    }
}

// HACK: relies on all `use` being at the top 
//       and */{} only refering to functions not nested modules. 
collect_use :: fn(out: *List(Str), in: Str) void = {
    while => in.len > 0 {
        continue :: local_return;
        if in.starts_with("\n") {
            in = in.rest(1);
            continue();
        };
        if in.starts_with("//") {
            while => !in.starts_with("\n") {
                in = in.rest(1);
            };
            continue();
        };
        prefix := "use ";
        if in.starts_with(prefix) {
            in = in.rest(prefix.len);
            i := 0;
            while => !in.rest(i).starts_with(";") && !in.rest(i).starts_with("::{") && !in.rest(i).starts_with("::*") {
                i += 1;
            };
            name := in.slice(0, i);
            
            o := replace_slice(name, "/", "::", "/");
            if !out.items().contains(o) {
                out.push(o);
            };
            in = in.rest(i + 1);
            while => !in.starts_with("\n") {
                in = in.rest(1);
            };
            continue();
        };
        return();
    }
}

filter_tags :: fn(files: []Str, active_tags: []Str) []Str = {
    Case :: @struct(name: Str, tags: []Str);
    cases: HashMap(Str, Case) = init(temp());
    
    for files { it |
        continue :: local_return;

        base, tags := split_tags(it);
        
        for tags { tag |
            if !active_tags.contains(tag) {
                continue();
            }
        };
        
        new: Case = (name = it, tags = tags);
        old := cases&.get_or_insert(base, => new);
        if old.tags.len < new.tags.len {
            // the new one is more specific so override 
            old[] = new;
        };
        // TODO: what happens if you have a conflict like [/foo/bar+linux, /foo/bar+aarch64]? do you get both? 
    };
    
    out := Str.list(cases.raw.len_including_tombstones, temp());
    each cases& { _, case |
        out&.push(case.name);
    };
    out.items()
}

split_tags :: fn(it: Str) Ty(Str, []Str) = {
    base, tags := (u8.list(temp()), Str.list(temp()));
    i := 0;
    while => i < it.len {
        continue :: local_return;
        // TODO: there's also -libc
        if it[i] != "+".ascii() {
            base&.push(it[i]);
            i += 1;
            continue();
        };
        i += 1;
        start := i;
        while => i < it.len && !"/+-.".contains(it[i]) {
            i += 1;
        };
        tag := it.slice(start, i);
        tags&.push(tag);
    };
    (base.items(), tags.items())
}

replace_slice :: fn(in: Str, prefix: Str, old: Str, new: Str) Str = {
    o := @ref u8.list(in.len, temp());
    o.push_all(prefix);
    while => in.len > 0 {
        if in.starts_with(old) {
            o.push_all(new);
            in = in.rest(old.len);
        } else {
            o.push(in[0]);
            in = in.rest(1);
        }
    }
    o.items()
}

HareCmd :: @struct {
    N: ?Str = .None;
    o: ?Str = .None;
    t: ?Str = .None;
    a: Arch;
    input: []Str;
    tests := false;
};

fn build_td(modules: []HareModule, root: Str) Ty([]Ty(Str, Str), []Str, []Str) = {
    // future modules may depend on this one
    // modules may only depend on ones compiled after themselves, 
    // but it's fine to build the whole td env vars up front 
    // because it only looks for ones you `use` in the program. 
    td := Ty(Str, Str).list(temp());
    names := temp().alloc_zeroed(Str, modules.len);
    out_td := temp().alloc_zeroed(Str, modules.len);
    enumerate modules& { i, it |
        if it.name != "" {
            @assert(it.name.starts_with("/"));
            name := it.name.rest(1);
            name := replace_slice(name, "", "/", "::");
            names[i] = name;
            out_td[i] = @tfmt("%/.out/%.td", root, i);
            push(td&, (names[i], out_td[i]));
        }
    };
    (td.items(), names, out_td)
}

fn run(cmd: HareCmd, bin: Str, a: Alloc) Result(List(u8), List(u8)) = {
    args := build_args(cmd);
    ok, out, err := exec_and_catch(bin, args, a);
    if ok {
        @if(err.len > 0) eprintln(err.items());
        return(Ok = out);
    };
    @if(out.len > 0) eprintln(out.items());
    (Err = err)
}

fn build_args(cmd: HareCmd) []Str = {
    args := Str.list(temp());
    args&.push("-a");
    args&.push(to_harec_arch(cmd.a));
    if cmd.N { N |
        args&.push("-N");
        args&.push(N);
    };
    if cmd.t { t |
        args&.push("-t");
        args&.push(t);
    };
    if cmd.o { o |
        args&.push("-o");
        args&.push(o);
    };
    if cmd.tests { 
        args&.push("-T");
    };
    for cmd.input { it |
        args&.push(it);
    };
    args.items()
}

build_env_vars :: fn(td: []Ty(Str, Str)) *CStr = {
    envp := tls(.environment_variables)[];
    i := 0;
    while => !envp.offset(i)[].ptr.is_null() {
        i += 1;
    };
    new := @ref CStr.list(i + td.len + 1, temp());
    new.push_all(envp.slice(i));
    for td { it |
        new.push(@fmt_cstr("HARE_TD_%=%", it._0, it._1));
    };
    new.push(zeroed(CStr));
    new.as_ptr()
};

fn to_harec_arch(a: Arch) Str = @match(a) {
    fn x86_64()  => "x86_64";
    fn aarch64() => "aarch64";
    fn rv64()    => "riscv64";
    @default     => @panic("invalid harec architecture: %", a);
};

sh :: hush;

#use("@/lib/collections/map.fr");
#use("@/lib/sys/fs.fr");
Qbe :: import("@/backend/lib.fr").Qbe;
#use("@/examples/testing.fr");
#use("@/lib/sys/sync/qring.fr");
#use("@/lib/sys/threads.fr");
TaskTube :: Tube(Ty(Str, Str));
