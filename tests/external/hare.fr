// #foreign("harec");
// TODO: this is only the 'harec' tests, should run the 'hare' ones as well
// TODO: flag to use tcc instead of clang
main :: fn() void = {
    franca := get_executable_path(temp());
    start := get_working_directory(temp()).items();
    backend := @tfmt("%/target/q.out", start);
    sh(@slice(franca, "examples/default_driver.fr", "build", "backend/meta/qbe_frontend.fr", "-o", backend));

    root := fetch_git_commit("bc75c323739c390026cf5052cd108bd23106769b", "harec", "https://git.sr.ht/~sircmpwn/harec");
    Syscall'chdir(root.as_cstr());
    
    arch := to_harec_arch(query_current_arch());
    @assert_eq(query_current_os(), .linux, "TODO: hare os");
    
    files := collect_directory_ordered("src", temp(), temp()).unwrap();
    cmd := Str.list(temp());
    cmd&.push("clang");
    cmd&.push("-o");
    cmd&.push(".bin/harec");  // this path matters because the tests exec it
    @assert make_dir("out");
    @assert make_dir(".bin");
    for files { it |
        if it.name.ends_with(".c") {  // if you had run the harec makefile there it shits .o files everywhere
            dest := @tfmt("out/%.o", it.name.slice(0, it.name.len - 2));
            sh(@slice(
                "clang", "-Iinclude", "-c", @tfmt("-DDEFAULT_TARGET=\"%\"", arch), "-DVERSION=\"xxx\"", 
                @tfmt("src/%", it.name), "-o", dest,
            ));
            cmd&.push(dest);
        }
    };
    sh(cmd.items());
    
    rt_hare := @slice(
        "rt/abort.ha", 
        "rt/compile.ha",
        "rt/cstrings.ha",
        "rt/ensure.ha",
        "rt/itos.ha",
        "rt/memcpy.ha",
        "rt/memmove.ha",
        "rt/memset.ha",
        "rt/strcmp.ha",
        "rt/+linux/errno.ha",
        "rt/+linux/syscalls.ha",
        "rt/+linux/start.ha",
        "rt/malloc.ha",
        @tfmt("rt/+linux/syscallno+%.ha", arch),
        "rt/+linux/segmalloc.ha",
    );
    
    rt_o := "out/rt.o";
    run((
        a = query_current_arch(), 
        input = rt_hare,
        o = (Some = "out/rt.ssa"),
        t = (Some = "out/rt.td.tmp"),
        N = (Some = "rt"),
        td = empty(),
    ), "./.bin/harec", temp()).unwrap();
    sh(@slice(backend, "out/rt.ssa", "-o", rt_o, "-c", "-force_static_builtin_memmove"));
    
    tests := collect_directory_ordered("tests", temp(), temp()).unwrap();
    tests&.ordered_retain(fn(it) => it.name.ends_with(".ha") && !(@const_slice(
        "09-funcs.ha", // TODO: init,fini
        // TODO: testmod
        "15-enums.ha", "06-structs.ha", "24-imports.ha", "10-binarithms.ha", "37-annotations.ha", "34-declarations.ha"
    )).contains(it.name));
    run_tests_main(@type tests[0], tests.items(), fn(it) => it.name, fn(it) => {
        ssa := @tfmt("out/%.ssa", it.name);
        o := @tfmt("out/%.o", it.name);
        exe := @tfmt("out/%.out", it.name);
        td := ("rt", "out/rt.td.tmp");
        run((
            a = query_current_arch(), 
            input = @slice(@tfmt("tests/%", it.name)),
            o = (Some = ssa),
            td = td&.slice(1),
        ), "./.bin/harec", temp()).unwrap();
        sh(@slice(backend, ssa, "-o", o, "-c", "-force_static_builtin_memmove"));
        sh(@slice("clang", o, rt_o, @tfmt("rt/+linux/start+%.s", arch), @tfmt("rt/+linux/syscall+%.s", arch), "-o", exe, "-nostartfiles"));
        sh(@slice("env", "HARE_TD_rt=out/rt.td.tmp", exe));  // compile() in the tests execs harec
        (true, list(u8, temp()), list(u8, temp()), "")
    });
}

#use("@/examples/testing.fr");

HareCmd :: @struct {
    N: ?Str = .None;
    o: ?Str = .None;
    t: ?Str = .None;
    a: Arch;
    input: []Str;
    td: []Ty(Str, Str);
};

fn run(cmd: HareCmd, bin: Str, a: Alloc) Result(List(u8), List(u8)) = {
    args := Str.list(temp());
    for cmd.td { it |
        @debug_assert(!it._0.contains("="));
        args&.push(@tfmt("HARE_TD_%=%", it._0, it._1));
    };
    args&.push(bin);
    args&.push("-a");
    args&.push(to_harec_arch(cmd.a));
    if cmd.N { N |
        args&.push("-N");
        args&.push(N);
    };
    if cmd.t { t |
        args&.push("-t");
        args&.push(t);
    };
    if cmd.o { o |
        args&.push("-o");
        args&.push(o);
    };
    for cmd.input { it |
        args&.push(it);
    };
    
    // TODO: use execvpe instead of the env binary ðŸ¤¡
    ok, out, err := exec_and_catch("env", args.items(), a);
    if ok {
        return(Ok = out);
    };
    (Err = err)
}

fn to_harec_arch(a: Arch) Str = @match(a) {
    fn x86_64()  => "x86_64";
    fn aarch64() => "aarch64";
    fn rv64()    => "riscv64";
    @default     => @panic("invalid harec architecture: %", a);
};

sh :: hush;
