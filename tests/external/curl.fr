// #foreign("this example requires system headers");
// TODO: macos (need to fix config_h and deal with system includes)
// TODO: the decompression stuff?
// TODO: run their tests
//       - seperate out the ones that don't need network to play nice with my sandboxing
// TODO: fetch.fr should use the libcurl i compile here instead of exec system installed curl. bootstrapping problem tho. 
// TODO: this is far too much build-system-ish code for this :(
// TODO: rv64 is untested

main :: fn() void = {
    enable_tls := true;
    mbedtls := @if(enable_tls, Foreign'mbedtls(), "");
    tfpsa := @if(enable_tls, Foreign'tfpsa(), "");
    root := Foreign'curl();
    
    c := @ref zeroed(C.Compile.Ctx);
    m := @ref zeroed(Qbe.Module);
    Qbe'backend'init_module(m, (
        arch = query_current_arch(),
        os = .linux,
        type = .Exe,
        wrap_entry_for_linux_libc = true,
        exe_debug_symbol_table = true,
    ));
    ctx := init_codegen_worker(m, true);
    C'init_ctx(c, m, ctx);
    c.allow_builtin_headers = false;
    
    if enable_tls {
        start := timestamp();
        strip_driver_templates(tfpsa);
        empty_files := @slice(
            "mbedtls_config_check_before", "mbedtls_config_check_final", "mbedtls_config_check_user",
            "tf_psa_crypto_config_check_before", "tf_psa_crypto_config_check_final", "tf_psa_crypto_config_check_user", 
        );
        for empty_files { name |
            write_entire_file_or_crash(@tfmt("%/library/%.h", mbedtls, name), "/* @generated */");
        };
        write_entire_file_or_crash(@tfmt("%/library/userconfigfile.h", mbedtls), """
            /* @generated */
            #undef MBEDTLS_DEBUG_C
            #undef MBEDTLS_SELF_TEST
            #undef MBEDTLS_AESNI_C   // amd: needs asm/intrinsics
        """);
        write_entire_file_or_crash(@tfmt("%/library/error.c", mbedtls), """
            /* @generated */
            void mbedtls_strerror(int ret, char *buf, long buflen) {
                if (buflen > 0) buf[0] = 0;
            }
        """);
        
        make_dirs_or_crash("target/curl");
        library := collect_with_extension(@tfmt("%/library", mbedtls), ".c").unwrap();
        drivers := collect_with_extension(@tfmt("%/drivers/builtin/src", tfpsa), ".c").unwrap();
        core := collect_with_extension(@tfmt("%/core", tfpsa), ".c").unwrap();
        parts := @slice( (library, "library"), (drivers, "drivers"), (core, "core"));
        
        for parts { files, prefix |
            for files { it |
                src := @ref u8.list(temp());
                src.push_all(prelude);
                @fmt(src, "#add_include_path \"%/include\"\n", mbedtls);
                @fmt(src, "#add_include_path \"%/include\"\n", tfpsa);
                @fmt(src, "#add_include_path \"%/drivers/builtin/include\"\n", tfpsa);
                
                @fmt(src, "#add_include_path \"%/library\"\n", mbedtls);
                @fmt(src, "#add_include_path \"%/core\"\n", tfpsa);
                @fmt(src, "#add_include_path \"%/drivers/builtin/src\"\n", tfpsa);
                
                @fmt(src, "#define MBEDTLS_USER_CONFIG_FILE \"userconfigfile.h\"\n");
                @fmt(src, "#define TF_PSA_CRYPTO_USER_CONFIG_FILE \"userconfigfile.h\"\n");
               
                @fmt(src, "#include \"%\"\n", it);
                
                result := C'catch_call(c, void) {
                    tok := c.tokenize_string("prelude", src.items());
                    tok  = c.C'Preprocess'preprocess(tok);
                    c.C'Compile'parse(tok);
                };
                @if_let(result) fn Err(msg) => {
                    @panic("failed to compile %\n%", it, msg);
                };
                
                // :discard_static_scope
                c.macros&.clear();
                C'Preprocess'init_macros(c);
                c.scope.vars&.clear();
                c.pragma_once&.clear();
                c.include_paths&.clear();  // because src adds it back. don't want it to get redundantly long or it gets slow
                // TODO: make it possible to reset temp() here
            };
            
            // ie. version.c exists in both mbedtls and curl and they have different include paths
            c.filename_cache&.clear();  
        };
        @println("mbedtls: %ms", timestamp() - start);
    };
    
    src_files := collect_with_extension(@tfmt("%/src", root), ".c").unwrap();
    toolx := collect_with_extension(@tfmt("%/src/toolx", root), ".c").unwrap();
    @assert(query_current_arch() != .rv64 && query_current_os() == .linux, "TODO: move include path stuff into the compiler");
    
    src := @ref u8.list(temp());
    src.push_all(prelude);
    src.push_all(config_h);
    
    @fmt(src, "#add_include_path \"%/src\"\n", root);
    @fmt(src, "#add_include_path \"%/lib\"\n", root);
    @fmt(src, "#add_include_path \"%/include\"\n", root);
    
    if enable_tls {
        @fmt(src, "#define USE_MBEDTLS\n");
        @fmt(src, "#define CURL_CA_PATH \"/etc/ssl/certs\"\n");
        
        @fmt(src, "#add_include_path \"%/include\"\n", mbedtls);
        @fmt(src, "#add_include_path \"%/include\"\n", tfpsa);
        @fmt(src, "#add_include_path \"%/drivers/builtin/include\"\n", tfpsa);
    };
    
    dirs := @slice("", "curlx/", "vtls/", "vauth/", "vssh/", "vquic/");
    for dirs { dir |
        files := collect_with_extension(@tfmt("%/lib/%", root, dir), ".c").unwrap();
        for files { it |
            @fmt(src, "#include \"%%\"\n", dir, it);
        };
    };
    @fmt(src, "#discard_static_scope\n");
    for src_files { it |
        @if(it != "curlinfo.c")
        @fmt(src, "#include \"%\"\n", it);
    };
    for toolx { it |
        @fmt(src, "#include \"toolx/%\"\n", it);
    };
    
    out_path := "target/curl.out";
    start := timestamp();
    
    result := C'catch_call(c, void) {
        tok := c.tokenize_string("prelude", src.items());
        tok  = c.C'Preprocess'preprocess(tok);
        c.C'Compile'parse(tok);
    };
    @if_let(result) fn Err(msg) => {
        @panic("failed to compile curl\n%", msg);
    };
    
    ctx.join_codegen_thread();
    chunks := {m.target.finish_module}(m);
    data := concat(chunks, temp());
    write_entire_file_or_crash(out_path, data);
    c.arena_storage&.deinit();
    drop(m);
    
    @println("curl: %ms", timestamp() - start);
    @println("enable_tls = %, bin = %", enable_tls, out_path);
    
    ;{  // make sure the exe loads successfully (no undefined imports)
        ok, o, e := exec_and_catch(out_path, @slice("--help"), temp());
        @assert(ok && o.contains("Usage: curl [options...] <url>"), "failed to run my curl --help\n%%", o.items(), e.items());
        @print("[ok] --help\n");
    };
    
    if !file_exists(Foreign.PATH.bin_sh) { 
        // :HACK the point of the sandboxing is kinda defeated if i have to change the programs to accommodate it 
        println("SKIP: built successfully but looks like running in a sandbox so not going to try network");
        return();
    };
    
    paths := @slice("http://franca.lukegrahamlandry.ca/", "https://franca.lukegrahamlandry.ca/");
    if !enable_tls {
        paths = paths.slice(0, 1);
    };
    for paths { it |
        ok, o, e := exec_and_catch(out_path, @slice("-f", it), temp());
        @assert(ok && o.contains("<html"), "failed to run my curl\n%%", o.items(), e.items());
        @print("[ok] fetched (%) = % bytes\n", it, o.len);
    };
}

// curl uses mbedtls which uses tf-psa-crypto which uses jinja to generate c code.
// i want to compile curl from source without depending on a python interpreter. 
// the code being added to the template is only for "p256-m" and tests, both of which are optional. 
// so it's sufficent to just strip out the jinja tags to get the default scaffolding code. 
// in the end these files have functions like psa_driver_wrapper_FOO that call psa_FOO_builtin. 
strip_driver_templates :: fn(tfpsa: Str) void = {
    #use("@/examples/minijinja.fr");  // only 57 lines of this: [eat_tag, eat_ident, parse_top_level]
    dir := @tfmt("%/scripts/data_files/driver_templates", tfpsa);
    gen := @slice("psa_crypto_driver_wrappers.h", "psa_crypto_driver_wrappers_no_static.c");
    out := @ref u8.list(102000, temp());
    tags := @ref Str.list(temp());
    for gen { name |
        @fmt(out, """
            // @generated %
            #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT) || MBEDTLS_PSA_P256M_DRIVER_ENABLED || defined(PSA_CRYPTO_DRIVER_TEST)
            #error "[franca] see tests/external/curl.fr strip_driver_templates"
            #endif
        """, name);
        src := read_entire_file_or_crash(temp(), @tfmt("%/%.jinja", dir, name));
        parts := parse_top_level(src, temp());
        depth := 0;
        for parts { it |
            @match(it.kind) {
                fn Tag() => {
                    tag, _ := eat_tag(it.src);
                    standalone := tag == "include" || tag == "else";
                    @if(!standalone)
                    if tag.starts_with("end") {
                        tags.pop();
                    } else {
                        tags.push(tag);
                    };
                }
                fn String() => if tags.len == 0 || tags[tags.len - 1].starts_with("with") {
                    out.push_all(it.src);
                }
                @default => ();
            };
        };
        dest := @tfmt("%/core/%", tfpsa, name);
        write_entire_file_or_crash(dest, out.items());
        out.clear();
        @debug_assert_eq(tags.len, 0);
    };
};

prelude :: """
#define __unix__

// TODO: echo | clang -E -Wp,-v -
//       but then have to filter out the one with arg,def,bool etc. because the builtin ones are always last but makes more sense to use them
#add_include_path "/usr/local/include"
#if __aarch64
#add_include_path "/usr/include/aarch64-linux-gnu"
#elif __x86_64
#add_include_path "/usr/include/x86_64-linux-gnu"
// :NoDoubleUnderscoreArch
#define __x86_64__
#define __LP64__ 1
#define __asm__ asm
#endif
#add_include_path "/usr/include"

// TODO: this is a paste of what makes the system headers work for bubblewrap. it should all be in the compiler
#define __signed__ signed

// i don't implement u128 math but it's used in the arm mcontext structs. 
typedef struct __attribute__((aligned(16))) { long _[2]; } __uint128_t;  

/// TODO: these should be in the compiler 
typedef unsigned long __SIZE_TYPE__;
typedef unsigned long __UINTPTR_TYPE__;
typedef long __INTMAX_TYPE__;
typedef unsigned long __UINTMAX_TYPE__;
typedef short __WCHAR_TYPE__;
typedef long __INTPTR_TYPE__;
typedef long __PTRDIFF_TYPE__;
#define __SIZE_MAX__ ((unsigned long) ~0)
#define __LONG_MAX__ ((long) ~(1<<63))

#define __inline__ inline 
#define _GNU_SOURCE 1

// TODO
#define __builtin_constant_p(_) 0
""";

// TODO: use it through import_module
C :: import("@/examples/import_c/lib.fr");
CCC :: import("@/examples/import_c/cc.fr");
Qbe :: C.Compile.Qbe;
#use("@/examples/testing.fr");
#use("@/examples/fetch.fr");
#use("@/lib/sys/fs.fr");

config_h :: """
#define HAVE_ATOMIC 1
// #define HAVE_STDATOMIC_H 1
// #define HAVE_REALPATH 1  // see bubblewrap.fr for symbol versioning nightmare when they want NULL as second arg

#define CURL_DISABLE_LDAP
#define CURL_EXTERN_SYMBOL 
#define USE_IPV6 1
#define HAVE_ALARM 1
#define HAVE_ARPA_INET_H 1
#define HAVE_ACCEPT4 1
#define HAVE_FNMATCH 1
#define HAVE_BASENAME 1
#define HAVE_BOOL_T 1
#define HAVE_CLOCK_GETTIME_MONOTONIC 1
#define HAVE_CLOCK_GETTIME_MONOTONIC_RAW 1
#define HAVE_DIRENT_H 1
#define HAVE_OPENDIR 1
#define HAVE_FCNTL 1
#define HAVE_FCNTL_H 1
#define HAVE_FCNTL_O_NONBLOCK 1
#define HAVE_FREEADDRINFO 1
#define HAVE_FSEEKO 1
#define HAVE_DECL_FSEEKO 1
#define HAVE_FTRUNCATE 1
#define HAVE_GETADDRINFO 1
#define HAVE_GETADDRINFO_THREADSAFE 1
#define HAVE_GETEUID 1
#define HAVE_GETPPID 1
#define HAVE_GETHOSTBYNAME_R 1
#define HAVE_GETHOSTBYNAME_R_6 1
#define HAVE_GETHOSTNAME 1
#define HAVE_GETIFADDRS 1
#define HAVE_GETPEERNAME 1
#define HAVE_GETSOCKNAME 1
#define HAVE_IF_NAMETOINDEX 1
#define HAVE_GETPWUID 1
#define HAVE_GETPWUID_R 1
#define HAVE_GETRLIMIT 1
#define HAVE_GETTIMEOFDAY 1
#define HAVE_GLIBC_STRERROR_R 1
#define HAVE_GMTIME_R 1
#define HAVE_IFADDRS_H 1
#define HAVE_INET_NTOP 1
#define HAVE_INET_PTON 1
#define HAVE_SA_FAMILY_T 1
#define HAVE_IOCTL_FIONBIO 1
#define HAVE_IOCTL_SIOCGIFADDR 1
#define HAVE_LIBGEN_H 1
#define HAVE_LOCALE_H 1
#define HAVE_LOCALTIME_R 1
#define HAVE_SUSECONDS_T 1
#define HAVE_MSG_NOSIGNAL 1
#define HAVE_NETDB_H 1
#define HAVE_NETINET_IN_H 1
#define HAVE_NETINET_TCP_H 1
#define HAVE_NETINET_UDP_H 1
#define HAVE_LINUX_TCP_H 1
#define HAVE_NET_IF_H 1
#define HAVE_PIPE 1
#define HAVE_PIPE2 1
#define HAVE_EVENTFD 1
#define HAVE_POLL 1
#define HAVE_POLL_H 1
#define HAVE_PTHREAD_H 1
#define HAVE_PWD_H 1
#define HAVE_RECV 1
#define HAVE_SELECT 1
#define HAVE_SEND 1
#define HAVE_SENDMSG 1
#define HAVE_SENDMMSG 1
#define HAVE_STDINT_H 1
#define HAVE_FSETXATTR 1
#define HAVE_FSETXATTR_5 1
#define HAVE_SETLOCALE 1
#define HAVE_SETRLIMIT 1
#define HAVE_SIGACTION 1
#define HAVE_SIGINTERRUPT 1
#define HAVE_SIGNAL 1
#define HAVE_SIGSETJMP 1
#define HAVE_SNPRINTF 1
#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1
#define HAVE_SOCKET 1
#define HAVE_SOCKETPAIR 1
#define HAVE_STDBOOL_H 1
#define HAVE_STRERROR_R 1
#define HAVE_STRUCT_SOCKADDR_STORAGE 1
#define HAVE_STRUCT_TIMEVAL 1
#define HAVE_SYS_EVENTFD_H 1
#define HAVE_SYS_IOCTL_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_SYS_POLL_H 1
#define HAVE_SYS_RESOURCE_H 1
#define HAVE_SYS_SELECT_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_UN_H 1
#define HAVE_TERMIOS_H 1
#define HAVE_TERMIO_H 1
#define HAVE_UNISTD_H 1
#define HAVE_UTIME 1
#define HAVE_UTIMES 1
#define HAVE_UTIME_H 1
#define HAVE_WRITABLE_ARGV 1
#define CURL_OS "franca"
#define SIZEOF_INT 4
#define SIZEOF_LONG 8
#define SIZEOF_OFF_T 8
#define SIZEOF_CURL_OFF_T 8
#define SIZEOF_CURL_SOCKET_T 4
#define SIZEOF_SIZE_T 8
#define SIZEOF_TIME_T 8
#define STDC_HEADERS 1
#define USE_THREADS_POSIX 1
#define USE_UNIX_SOCKETS 1
#define _FILE_OFFSET_BITS 64
""";
