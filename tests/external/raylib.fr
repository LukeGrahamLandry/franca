// #foreign("this example requires system headers");
// 
// This program compiles raylib and its examples with my c compiler (import_c). 
// Examples run one at a time. Press escape to exit the program and run the next. 
// cli arguments: -filter <string> -skip_to <integer> -compileonly
// 
// TODO: do it on linux too. i can't test it until i figure out how to make xquartz+orb work. 
// TODO: autotest this somehow. could just do it with -compileonly 
//       but it's kinda prone to failing at runtime (like it does now 
//       for many of the examples) so that's not a big reassurance. 
//       also it annoys me because its a big blob of resources and depends on a big blob of xcode. 
// TODO: could use this to make cross compiling from linux work
//       https://github.com/hexops/xcode-frameworks/archive/8a1cfb373587ea4c9bb1468b7c986462d8d4e10e.tar.gz 8ed818e25f2ed3bb77dc8202d003ecd0efa2be198962eca1452e545cbe17aac8
//       - doesn't have OpenGL so not enough. does https://github.com/hexops/opengl-headers work for apple too?
//       they have a linux one too https://github.com/hexops/x11-headers opengl-headers linux-audio-headers wayland-headers
//       which might be less painful than apt install 10 libFOO-dev that raylib's docs want you to do. 
//       not everything raylib wants is on that list tho. 
//       idk why they feel the need to lie: "NO external dependencies, all required libraries are included into raylib". false!
// TODO: the audio examples need atomics
// TODO: first class support for using system headers instead of beeding to add all these defines manually for each program
// TODO: end goal is a gui that lets you click an example program to run it. 
// TODO: wasm but i loathe emscripten so that ain't gonna happen
// 
// i can't use PLATFORM_DESKTOP_GLFW on macos because part of it is written in 
// objective c (src/external/glfw/src/*.m) so doesn't work with only using my c compiler. 
// but it seems a bunch of things don't work on macos with PLATFORM_DESKTOP_RGFW.
// i'm reassured that it's not my fault because`cmake -DPLATFORM=RGFW . && make`
// spews linker errors and if i manually compile with clang it behaves the same way as mine.    
// - core_highdpi_demo pressing n just makes the window move around randomly instead of going to other monitor. 
// - core_scissor_test the red square is tiny and doesn't work
// - "Linking ES shaders with non-ES shaders is not supported." so most of the shaders/ ones don't work
// - core_window_flags full screen makes my whole computer blurry until you exit 
// - core_render_texture is tiny and in the corner
// - rlgl_compute_shader crashes
// - shapes_ball_physics once you press ctrl once it thinks its always pressed
// - it plays the unaccepted keybind pop noise when you hold down a key
// - etc.
// 
// TODO: broken on mine but works with clang (even with RGFW)
//     70. models_loading_gltf is like crazy flat mesh not a creature 
//     88. models_directional_billboard it looks tilted?
//     89. models_animation_gpu_skinning its flat not 3d
//    162. shaders_shadowmap_rendering
//

fetch_and_compile :: fn(arch: Arch) Ty(Str, Str) = {
    // TODO: should go in deps.fr but it's big and i don't autotest it yet
    root := group(
        url = "https://github.com/raysan5/raylib/archive/cfb81e4a0000b1ad1bd5726a697aaa66c82ba73d.tar.gz", 
        legacy = "c554e0e31cd9095331918114b560181f21c185f93742d19ea4efeaf32bc60e42",
        discard = @const_slice("cmake", "projects", "logo", "examples/other/external/lib", "tools/rlparser/output", "tools/rexm/VS2022", "tools/rexm/reports"),
    );
    write_entire_file_or_crash(@tfmt("%/src/emmintrin.h", root), "");  // HACK
    
    raylib := "target/franca/cache/raylib.frc";
    compile_lib(root, arch, raylib);
    _ := include_bytes(raylib);
    (root.shallow_copy(ast_alloc()), raylib)
};

main :: fn() void = {
    arch :: query_current_arch();  // can cross compile: Arch.x86_64 / Arch.aarch64
    root, raylib := @run fetch_and_compile(arch);
    
    examples := collect_examples(root);
    skip_to, compileonly := parse_args_and_filter(examples&, cli_args());
    exe_path :: "target/raylib_example.out";
    
    if compileonly {
        Ctx :: @struct(root: Str, raylib: Str, arch: Arch);
        ctx: Ctx = (root = root, raylib = raylib, arch = arch);
        #use("@/examples/testing.fr");
        run_tests_main_threaded(Ctx, Str, ctx, examples.rest(skip_to), fn(_, it) = it[], fn(ctx, it) = {
            run_example(ctx.root, it[], ctx.raylib, ctx.arch, exe_path);
            (true, u8.list(temp()), u8.list(temp()), "")
        });
        return();
    };
    
    enumerate examples.rest(skip_to) { i, it |
        @println("[%/%] %/%", i + skip_to, examples.len, root, it);
        start := timestamp();
        run_example(root, it[], raylib, arch, exe_path);
        @println("%ms", timestamp() - start);
        // it wants to access the resources folder by relative path
        start := get_working_directory(temp()).items().as_cstr();
        dir := pop_path_segment(@tfmt("%/%", root, it[])).as_cstr();
        Syscall'chdir(dir).unwrap();
        ok := run_cmd_blocking(@tfmt("%/%", start, exe_path), empty());
        Syscall'chdir(start).unwrap();
        @assert(ok, "failed run");
    };
}

compile_lib :: fn(root: Str, arch: Arch, outfile: Str) void = {
    c_source := @tfmt("""
            /* prelude */ %
            
            #add_include_path "%"
            #add_include_path "%/src"
            
            #define PLATFORM_DESKTOP_RGFW
            #define GRAPHICS_API_OPENGL_33
            #define STBIR_NO_SIMD 
            #define STBI_NO_SIMD
                
            #include "rcore.c"
            #undef RLGL_IMPLEMENTATION      // because later ones include it again
            #undef RCAMERA_IMPLEMENTATION   // "
            #include "rtext.c"
            #include "rtextures.c"
            #include "rmodels.c"
            #include "rshapes.c"
            // #include "raudio.c"  // TODO: atomics
        """, prelude, root, root);

    #use("@/examples/import_c/ffi.fr");
    name := "raylib";
    fr := current_compiler_context();
    
    // note: late Cached so not the same as init_fr. avoids redoing rega every time
    Qbe :: CCC.Qbe;
    FTy :: Qbe.Incremental.FTy;
    m := fr.get_alloc().box_uninit(Qbe.Module);
    c := fr.get_alloc().box_zeroed(C'Compile.Ctx);
    init_default_module_dyn(m, fr.vtable, (arch = arch, os = .macos, type = .Cached));
    ctx := init_codegen_worker(m, false, fr.vtable);
    import_c'init_ctx(c, m, ctx);
    range(0, FTy.COUNT) { _ |
        m.save.unwrap()[].fty&.push(zeroed FTy);   // skip builtin types so offsets work out
    };
    
    bytes := import_c'compile_fr(fr, c_source, c, "raylib");
    write_entire_file_or_crash(outfile, bytes);
    println(outfile);
    // TODO: cache this like include() does
    // TODO: have the bytes in the exe and write at runtime?
    // TODO: don't reexport all the system imports. 
    // TODO: go through h.deps and make sure each header is there only once. 
    //       the duplicates are places where the include-guard detection didn't work? 
    //       or if they actually don't have include guards, still don't count them multiple times. 
    // TODO: do run_example through the franca compiler so get dce
}   

run_example :: fn(root: Str, file: Str, raylib: Str, arch: Arch, exe_path: Str) void = {
    // note: when compiling exes like this you don't get deadcode elimination (that lives in the franca frontend so only dce if the entry point is in franca and you import_c the c part)
    CCC'compile(
        output_path = exe_path,
        input_path = empty(),
        target = (
            type = .Exe,
            os = .macos,  // TODO 
            arch = arch,
            exe_debug_symbol_table = true,
        ),
        prelude = @tfmt("""
            #include "%"
            #define PLATFORM_DESKTOP_RGFW
            #define GRAPHICS_API_OPENGL_33
            #define STBIR_NO_SIMD 
            #define SINFL_NO_SIMD
            #define STBI_NO_SIMD
            
            #add_include_path "%"
            #add_include_path "%/src"
            // note: don't need xcode here. only the lib does. 

            // they want the lib to export and the exe to use the inline functions as forward declarations? 
            // TODO: if it's just `inline` am i supposed to allow conflicting definitions and just pick one at random?
            #define RAYMATH_H  // already in the .frc
            
            // even tho not using any functions from it, 
            // need to say it's a dependency to allow subclassing its objc classes. 
            #link_macos_framework "Cocoa"
            
            #include "%"
        """, raylib, root, root, file),
    ).or(fn(msg) => @panic("failed to compile raylib\n%", msg));
    // TODO: return error so threaded -compileonly can report all fails
}

collect_examples :: fn(root: Str) []Str = {
    dirs := collect_directory_ordered(@tfmt("%/examples", root), temp(), temp()).unwrap();
    examples := Str.list(temp());
    for dirs { it |
        #use("@/examples/testing.fr");
        if it.type == .Directory {
            c := collect_with_extension(@tfmt("%/examples/%", root, it.name), ".c").unwrap();
            for c { file |
                examples&.push(@tfmt("examples/%/%", it.name, file));
            };
        };
    };
    examples.items()
}

parse_args_and_filter :: fn(examples: *[]Str, args: []CStr) Ty(i64, bool) = {
    examples.ordered_retain(fn(it) => !(false 
        || it[].contains("audio/audio_")                 // TODO: raudio
        || it[].ends_with("rlgl_standalone.c")           // needs glfw
        || it[].ends_with("rlgl_compute_shader.c")       // crashes
        || it[].ends_with("embedded_files_loading.c")    // TODO: raudio
        || it[].ends_with("textures_sprite_button.c")    // TODO: raudio
        || it[].ends_with("textures_sprite_explosion.c") // TODO: raudio
        // (clang agrees): headers are setup wrong so doesn't work with RGFW unless you do one compilation unit (even when xcode on include path for exe too)
        || it[].ends_with("raylib_opengl_interop.c") 
    ));
    
    i := 0;
    skip_to := 0;
    compileonly := false;
    while => i < args.len {
        @switch(args[i].str()) {
            @case("-filter") => {
                keep := args[i + 1].str(); i += 1;
                old := examples.len;
                examples.ordered_retain(fn(it) => it.contains(keep));
                @println("filter(%): % => %", keep, old, examples.len);
            };
            @case("-skip_to") => {
                n := args[i + 1].str(); i += 1;
                n := parse_int(n);
                skip_to = n;
                @println("skip_to(%)", n);
            };
            @case("-compileonly") => {
                compileonly = true;
                @println("compileonly()");
            };
            @default => ();
        };
        i += 1;
    };
    
    (skip_to, compileonly)
}

#use("@/lib/sys/process.fr");
#use("@/examples/fetch.fr");
CCC :: import("@/examples/import_c/cc.fr");

// TODO: this stuff should move into the c compiler so it's easy to use the system headers
prelude :: """
    // TODO: be less hacky!
    #include "__builtin://float.h"  // apple's one just does #define FOO __FOO__
    #define __FLOAT_H  // pretend already included apple's
    
    #define __APPLE__ 1
    #define TARGET_OS_OSX 1 
    #define MAC_OS_X_VERSION_MIN_REQUIRED MAC_OS_X_VERSION_10_5
    
    #define __LITTLE_ENDIAN__ 1
    #define __FP__
    #define CF_INLINE inline 
    #define UC_INLINE inline
    #define ATS_UNAVAILABLE
    #define XPC_DEBUGGER_EXCL
    #define __BLOCKS__ 1 
    #define TYPE_LONGLONG 1
    #define XPC_GIVES_REFERENCE
    #define _POSIX_C_SOURCE 200809L
    
    typedef short _Float16;
    typedef struct __attribute__((aligned(16))) { long _[2]; } __uint128_t;  
    #define __asm asm 
    #define __asm__ asm 
    #define __inline__ inline 
    
    #ifdef __x86_64
    #define _OS_OSBYTEORDERMACHINE_H 
    typedef __uint128_t __m128;
    typedef __uint128_t __m128i;
    typedef __uint128_t __m128d;
    #define __FIXMATH__
    #else 
    #define __nan() (0.0/0.0)
    #endif 
    
    #if __aarch64
        #define __arm64__ 1
        #define TARGET_CPU_ARM64 1
    #else
        #define __x86_64__ 1
        #define TARGET_CPU_X86_64 1
    #endif
    
    #add_include_path "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include"
""";
