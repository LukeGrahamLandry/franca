// #foreign("wasm/spec", "wabt/wast2json");

main :: fn() void = {
    #use("@/examples/testing.fr");
    root := fetch_or_crash("https://github.com/WebAssembly/spec/archive/6e4c4bcaf7a4747f7a13623889727ee117550336.tar.gz", 12781429, "c525ed66f56e6b49b53e466beee2dd5af6dca905c84b3cc9caa609e5163db1da", "spec-6e4c4bcaf7a4747f7a13623889727ee117550336");
    start := get_working_directory(temp()).items();
    tests_dir := @fmt_cstr("%/test/core", root);
    Syscall'chdir(tests_dir).unwrap();
    println(root);
        
    wast_files := collect_with_extension(".", ".wast") 
        || panic("failed to collect wast files");
    
    ordered_retain wast_files& { name |
        raw_name := name[].slice(0, name.len - ".wast".len());
        !skip.contains(raw_name)
    };
    any_fails := false;
    enumerate wast_files { i, name |
        mark := temp().mark();
        name := name[];
        raw_name := name.slice(0, name.len - ".wast".len());
        json_name := @tfmt("%.json", raw_name);
        if !file_exists(json_name) {
            // TODO: we can't be execing shit, but also i don't care enough to write a wat parser
            hush(@slice("wast2json", "--enable-all", name));
        };
        contents := read_entire_file_or_crash(temp(), json_name);
        json: JsonParser = new_json(contents, temp());
        it := zeroed Wast;
        ok := parse_json(json&, it&);
        if !ok {
            // TODO: this and the thing in @error_tok and fmt_error_loc are all very similar. factor something out? 
            line := 1; // zero indexed is unintuative for error messages
            col  := 0;
            line_start := 0;
            range(0, min(contents.len, json.current)) {i|
                col += 1;
                if contents[i] == "\n".ascii() {
                    line_start = i + 1; // dont include the new line
                    line += 1;
                    col = 0;
                };
            };
            // TODO: do this as part of JsonParser.error()
            @panic("error at byte % of %/%:%:%%", json.current, tests_dir, json_name, line, col, json.error);
        };
        
        @println("=== % (%/%) ===", raw_name, i, wast_files.len);
        @println("%/%", tests_dir, name);
        rt: Rt.Engine = init_for_jit(temp(), ""); rt := rt&;
        instance: ?*Rt.Instance = .None;
        passed, total := (0, 0);
        each it.commands { it |
            continue :: local_return;
            @match(it.type) {
                fn module() => {
                    @println("module %/%", tests_dir, it.filename.unwrap());
                    wasm := read_entire_file_or_crash(temp(), it.filename.unwrap());
                    mod := rt.compile(wasm);
                    exports: Rt.ExportsEnv = (_ = init(temp()));
                    it := instantiate(rt, mod, exports&);
                    instance = (Some = it);
                }
                fn register() => {
                    
                }
                fn action() => {
                    a := it.action.unwrap();
                    @println("action %(...)", a.field);
                }
                fn assert_return() => {
                    a := it.action&.unwrap();
                    instance := instance.unwrap();
                    ok := assert_return(instance, a, it.expected);
                    passed += int(ok);
                    total += 1;
                    if !ok {
                        @print("at %/%:%:1\n\n", tests_dir, name, it.line);
                    };
                }
                // i don't do verification or traps yet so don't try to compile the ones that aren't supposed to work
                @default => continue();
            };
        };
        @print("passed %/% tests in %\n", passed, total, name);
        if passed != total {
            any_fails = true;
        };
        drop(rt);
        temp().reset(mark);
    };
    Syscall'chdir(start.as_cstr()).unwrap();
    @assert(!any_fails, "didn't pass all tests");
}

fn assert_return(instance: *Rt.Instance, action: *Wast.Action, expected: []Wast.Value) bool = {
    @match(action.type) {
        fn invoke() => {
            args := SafeValue.list(temp());
            expect := SafeValue.list(temp());
            for action.args { it |
                args&.push(it.parse_value());
            };
            for expected { it |
                expect&.push(it.parse_value());
            };
            out := expect.items().shallow_copy(temp());
            each out { it |
                it._1.i64 = 7777;
            };
            
            out := instance.invoke(action.field, args.items(), out)
                || @panic("failed to call %", action.field);
            
            ::display_slice(SafeValue);
            if out != expect.items() {
                @print("% %\nexpect: %\nreturn: %\n", action.field, args.items(), expect.items(), out);
                return false;
            }
        }
        fn get() => {
            panic("TODO: get");
        }
    };
    true
}

skip :: @const_slice(
    // wast2json --version 1.0.39 doesn't work on these 
    "id", "ref", "elem", "align", "br_if", "table", 
    "global", "memory", "select", "linking", "br_table", 
    "call_ref", "instance", "ref_null", "type-rec", "local_tee", 
    "br_on_null", "local_init", "type-canon", "annotations", "ref_is_null", 
    "br_on_non_null", "ref_as_non_null", "return_call_ref", "unreached-valid", 
    "type-equivalence", "unreached-invalid", 
    // i haven't bothered with string escapes in json.fr yet
    "names", 
    // multiple return values
    "br", "if", "fac", "call", "func",
    // if without else
    "if", "stack", "labels", "local_get",
    // more instructions. ceil, etc.
    "f32", "f64", "float_misc", "f32_bitwise", "f64_bitwise", 
    // 0x1B select
    "nop", "loop", "block", "left-to-right", 
    // complex constant expressions
    "data",
    // br_table
    "load", "store", "return", "switch", "unwind", 
    // idk. it wants me to change the bits of infinities/subnormals from what strtod gives me?
    "const",
    // might be the same as "const" but maybe i do it wrong, idk
    "f64_cmp", "f32_cmp", "float_exprs", 
    // start section
    "start",
    // give it the host imports it expects 
    "token", "func_ptrs", 
    // parse more Element kinds. currently only flags=0 is supported.
    "binary", "ref_func", "table_get", "table_set", "return_call_indirect",
    // i spam "skipping custom section"
    "custom",
    // no point since i don't run assert_trap/assert_malformed/etc. anyway also  don't parse the wast myself. 
    "traps", "skip-stack-guard-page", 
    "comments", "obsolete-keywords", "inline-module", 
    "utf8-invalid-encoding", "utf8-custom-section-id", "utf8-import-module", "utf8-import-field", 
    // keep multiple modules around in the host
    "exports",
    // !! i crash
    "forward",
    // exceptions
    "imports",
    // zero init undefined local
    "local_set",
    // "invalid instruction output type Kl in storeh" my "this being Kl is subtle" hack
    "endianness",
    // externref table.size
    "table_grow", "table_size",
    // saturating
    "conversions", 
    // memory.size
    "memory_grow", "memory_size", "memory_trap", 
    // tail call
    "return_call", 
    // float globals
    "unreachable", "call_indirect", 
    // !! safety check
    "binary-leb128", 
    // !! fails
    "memory_redundancy", "float_literals", "float_memory", "address", 
);

Wast :: @struct {
    commands: []Command;
    Command :: @struct {
        Tag :: @enum(
            module, action, register, 
            assert_unlinkable, assert_return, assert_trap, assert_invalid,
            assert_malformed, assert_exhaustion, assert_uninstantiable, 
        );
        type: Tag;
        filename: ?Str;
        action: ?Action;
        as: ?Str;
        line: i64;
        expected: []Value = empty();
    };
    Action :: @struct {
        Tag :: @enum(invoke, get);
        type: Tag;
        field: Str;
        args: []Value = empty();
    };
    Value :: @struct {
        Tag :: @enum(i32, i64, f32, f64, externref, funcref);
        type: Tag;
        value: Str = "";
    };
};

SafeValue :: Ty(Qbe.Cls, Rt.GlobalValue);
fn invoke(self: *Rt.Instance, name: Str, args: []SafeValue, out: []SafeValue) ?[]SafeValue = {
    it := self.exports&.get(name) || return(.None);
    @if(!it&.is(.Function)) return(.None);
    // TODO: typecheck
    
    // these arguments fit in registers so you can call any subset of this signeture without knowing the types
    I :: @FnPtr(i: rawptr, a: i64, b: i64, c: i64, d: i64, e: i64, fa: f64, fb: f64, fc: f64, fd: f64, fe: f64) i64;
    F :: @FnPtr(i: rawptr, a: i64, b: i64, c: i64, d: i64, e: i64, fa: f64, fb: f64, fc: f64, fd: f64, fe: f64) f64;
    
    int := @ref(zeroed Array(i64, 5)); i := 0;
    flo := @ref(zeroed Array(f64, 5)); f := 0;
    for args { k, v |
        if k.is_int() {
            int[i] = v.i64;
            i += 1;
        } else {
            flo[f] = v.f64;
            f += 1;
        };
    };
    
    f, c := (it.Function.callee, it.Function.context);
    @if(out.len > 1) return(.None);
    if out.len == 0 || out[0]._0.is_int() {
        f := bit_cast_unchecked(rawptr, I, f);
        v := f(c, 
            int[0], int[1], int[2], int[3], int[4], 
            flo[0], flo[1], flo[2], flo[3], flo[4], 
        );
        if out.len > 0 {
            out[0]._1.i64 = v;
        };
    } else {
        f := bit_cast_unchecked(rawptr, F, f);
        v := f(c, 
            int[0], int[1], int[2], int[3], int[4], 
            flo[0], flo[1], flo[2], flo[3], flo[4], 
        );
        out[0]._1.f64 = v;
    };
    (Some = out)
}

fn parse_value(it: Wast.Value) SafeValue = {
    k := it.type.cls();
    if k.is_int() {
        value: i64 = if it.value.starts_with("0x") {
            hex(it.value.rest(2)).unwrap()
        } else {
            parse_int(it.value)
        };
        value: Rt.GlobalValue = (i64 = value);
        return(k, value);
    };
    strtod :: fn(str: CStr, end_out: *CStr) f64 #weak #libc;    // TODO: write my own 
    end := zeroed(CStr);
    f := strtod(it.value.as_cstr(), end&);
    if end.ptr[] != 0 {
        @panic("didn't parse whole float: %", it.value);
    };
    value: Rt.GlobalValue = (f64 = f);
    if k == .Ks {
        value.f32 = f.cast();
    };
    (k, value)
}

fn cls(self: Wast.Value.Tag) Qbe.Cls = @match(self) {
    fn i32() => .Kw;
    fn i64() => .Kl;
    fn f32() => .Ks;
    fn f64() => .Kd;
    @default => @panic("TODO: %", self);
};

fn eq(a: *SafeValue, b: *SafeValue) bool = {
    @if(a._0 != b._0) return(false);
    @match(a._0) {
        fn Kw() => a._1.i32 == b._1.i32;
        fn Kl() => a._1.i64 == b._1.i64;
        fn Ks() => a._1.f32 == b._1.f32;
        fn Kd() => a._1.f64 == b._1.f64;
        @default => false;
    }
}

fn display(self: *SafeValue, out: *List(u8)) void = {
    @match(self._0) {
        fn Kw() => @fmt(out, "%", self._1.i32);
        fn Kl() => @fmt(out, "%", self._1.i64);
        fn Ks() => @fmt(out, "%", fmt_hex(self._1.f32));
        fn Kd() => @fmt(out, "%", fmt_hex(self._1.f64));
        @default => ();
    };
    @fmt(out, "_%", self._0);
}

Qbe :: import("@/backend/ir.fr");
Rt :: import("@/examples/import_wasm/runtime.fr");
#use("@/lib/encoding/json.fr");
#use("@/lib/encoding/json_reflect.fr");
::DeriveJson(Wast);
::DeriveJson(Wast.Command);
::DeriveJson(Wast.Command.Tag);
::DeriveJson(Wast.Action);
::DeriveJson(Wast.Action.Tag);
::DeriveJson(Wast.Value);
::DeriveJson(Wast.Value.Tag);
