//! This parses the format used by https://github.com/munificent/craftinginterpreters/tree/master/test
//! and runs those tests on my @/examples/lox interpreter. 
//! Currently checks exact output for programs that are not supposed to error but otherwise just expects 
//! runtime vs compile error to be correct (my error messages don't match). 
// note: since i don't check exact error messages it will look like i pass tests that are supposed to error just because they use features i don't support yet
// as a fun bonus, the lox repo has a lox interpreter written in c 
// that i can compile with my c compiler (examples/import_c) and run on the same tests. 

#use("@/examples/testing.fr");
main :: fn() void = {
    args := cli_args();
    
    root := Foreign'craftinginterpreters();
    
    go := false;
    total, pass := (0, 0);
    for args { s |
        continue :: local_return;
        s := s.str();
        if !go {
            if s == "--" {
                go = true;
            };
            if s == "-pass" {
                do_skips[] = true;
            };
            if s == "-hush" {
                HUSH[] = true;
            }
            if s == "-clox" {
                path := compile_c_lox(root);
                CLOX[] = (Some = path);
            };
            continue();
        };
        @assert(!do_skips[], "only skip failing tests when running all");
        mark := mark_temporary_storage();
        yes, no := run_test_at_path("", @tfmt("%/test/%", root, s));
        reset_temporary_storage(mark);
        total += yes + no;
        pass += yes;
    };
    if total == 0 {
        yes, no := run_test_at_path("", @tfmt("%/test", root));
        total += yes + no;
        pass += yes;
    };
    
    @println("\npassed %/% tests.", pass, total);
    if pass != total {
        panic("tests failed");
    }
    Syscall'exit(if(pass == total, => 0, => 1));
}

do_skips :: @static(bool) false;
HUSH :: @static(bool) false;
CLOX :: @static(?Str) (.None);

skip_ :: @const_slice(
    "string/multiline.lox",   // TODO: my test runner is dumb about multiline prints
    "number/literals.lox",  // i don't print -0
    "operator/multiply.lox",  // i don't print decimals
    "regression", 
    "variable/duplicate_local.lox", 
    "variable/local_from_method.lox", 
    "variable/use_local_in_initializer.lox", 
    "closure", 
    "function/local_recursion.lox",
    "function/nested_call_with_arguments.lox",
    "function/print.lox",
    "call/object.lox",
    "return/in_method.lox", 
    "return/at_top_level.lox",  // currently i allow this since it makes the test in lox_main easier
    "while/closure_in_body.lox", "while/return_closure.lox", 
    "for/return_closure.lox", "for/closure_in_body.lox", 
    "for/fun_in_body.lox",   // todo: why can't `fun` be `for` body? 
    "while/fun_in_body.lox", // ^
    "if/fun_in_then.lox", // ^
    "if/fun_in_else.lox", // ^
    "variable/duplicate_parameter.lox",
    "variable/collide_with_parameter.lox",
    "assignment/to_this.lox", "operator/not_class.lox", "operator/equals_class.lox", "operator/equals_method.lox", 
    "constructor", "field", "class", "inheritance", "method", "super", "this",
    "benchmark", "limit/stack_overflow.lox", "limit/too_many_upvalues.lox",
    
    // these are for chapters before the vm
    "expressions", "scanning",
);

::if(Ty(i64, i64));
fn run_test_at_path(prefix: Str, s: Str) Ty(i64, i64) = {
    if do_skips[] && skip_.contains(fn(check) => s.ends_with(@tfmt("/%", check[]))) {
        return(0, 0);
    };
    if s.ends_with(".lox") {
        src := temp().read_to_string_or_crash(s);
        ::FmtPad(Str);
        @if(!HUSH[]) @print("%", f_pad(s.rest(prefix.len), 40, .After));
        ok := run_test(src, s);
        @if(!HUSH[]) @println("[%]", @if(ok, "ok", "fail"));
        (int(ok), int(!ok))
    } else {
        children := collect_directory_ordered(s, temp(), temp()) 
            || @panic("failed to collect test files from %", s);
        @if(!HUSH[]) @println("=== % ===", s.rest(prefix.len));
        a, b := (0, 0);
        for children { e |
            if e.name.ends_with(".lox") || e.is(.Directory) {
                path := @tfmt("%/%", s, e.name);
                c, d := run_test_at_path(s, path);
                a += c; b += d;
            }
        };
        @if(!HUSH[]) @println("===");
        (a, b)
    }
}

#use(Lox)
fn run_test(src: List(u8), lox_filename: Str) bool = {
    want := expected_output(src.items());
    
    found: List(Str) = list(temp());
    result := InterpretResult.CompileError;
    errors := u8.list(temp());
    if CLOX[] { path |
        cargs := make_args_for_exec(path, @slice(lox_filename), temp());
        out := u8.list(temp());
        it := sys_capture_exec(cargs).unwrap();
        status := it&.poll_until_exit(out&, errors&, "");
        // TODO: where am i getting non-8bit numbers. this has been happening forever. fix it in poll() instead. 
        result = @switch(status.shift_right_logical(8)) {
            @case(0) => .Ok;
            @case(70) => .RuntimeError;
            @case(65) => .CompileError;
            @default => @panic("bad status %\n%", status.shift_right_logical(8), errors.items());
        };
        lines := out.items().split("\n", temp()).items();
        lines.len -= 1;
        found&.push_all(lines);
    } else {
        src&.push_all("\nreturn nil;"); // todo: remove
        vm: Vm = init_vm();
        result = vm&.interpret(src.items(), true) { value | 
            found&.push(@tfmt("%", value));
        };
        errors = vm.errors.items().clone(temp());
        vm&.drop();  // test a forced full collection
    };
    
    pass := @match(want) {
        fn Ok(want) => {
            print(errors.items());
            if(result != .Ok || errors.len != 0, => return(false));
            if want.len != found.len {
                @println("Expected % outputs but found %", want.len, found.len);
                return(false);
            };
            
            range(0, want.len) { i |
                if want[i] != found[i] {
                    @println("[%] Expected '%' but found '%'", i, want[i], found[i]);
                    return(false);
                };
            };
            
            
            true
        }
        fn RuntimeError() => result == .RuntimeError;
        fn CompileError() => result == .CompileError;
    };
    if pass {
        s := want&.tag();
        s := s.name_str();
        @print("%", s.slice(0, 1));
    }

    if !want&.is(.Ok) && !pass {
        print(errors.items());
        print("(expected an error)");
    };
    
    pass
}

// TODO: do any of the tests require some prints and then an error later? rn i only return one or the other. 
TestResult :: @tagged(Ok: List(Str), CompileError, RuntimeError);
fn expected_output(src: Str) TestResult = {
    want: List(Str) = list(temp());
    cursor := 0;
    tag := "// expect: ";
    runtime_tag := "expect runtime error: ";
    comptime_tag := "[line ";
    other_comptime_tag := "// Error at ";
    while => cursor < src.len - tag.len {
        if cursor < src.len - runtime_tag.len {
            if src.subslice(cursor, runtime_tag.len) == runtime_tag {
                return(.RuntimeError)
            };
        };
        if src.subslice(cursor, comptime_tag.len) == comptime_tag {
            return(.CompileError)
        };
        if src.subslice(cursor, other_comptime_tag.len) == other_comptime_tag {
            return(.CompileError)
        };
        if src.subslice(cursor, tag.len) == tag {
            cursor += tag.len;
            start := cursor;
            while => cursor < src.len && src[cursor] != "\n".ascii() {
                cursor += 1;
            };
            want&.push(src.slice(start, cursor));
            cursor -= 1;
        };
        cursor += 1;
    };
    (Ok = want)
}

// TODO: far too verbose. can't just cc.fr all the files because need to discardstaticscope
compile_c_lox :: fn(root: Str) Str = {
    files := collect_with_extension(@tfmt("%/c", root), ".c").unwrap();
    
    // TODO: use it through import_module
    Qbe :: import("@/backend/ir.fr");
    C :: import("@/examples/import_c/lib.fr");
    
    c := @ref zeroed(C.Compile.Ctx);
    m := @ref zeroed(Qbe.Module);
    Qbe'backend'init_module(m, (
        arch = query_current_arch(),
        os = query_current_os(),
        type = .Exe,
        wrap_entry_for_linux_libc = true,
        exe_debug_symbol_table = true,
    ));
    ctx := init_codegen_worker(m, true);
    C'init_ctx(c, m, ctx);
    c.include_paths&.push(@tfmt("%/c", root));
    
    for files { it |
        // :discard_static_scope
        c.macros&.clear();
        C'Preprocess'init_macros(c);
        c.scope.vars&.clear();
    
        it := @tfmt("%/c/%", root, it);
        src := read_entire_file_or_crash(temp(), it);
        result := C'catch_call(c, void) {
            tok := c.tokenize_string(it, src);
            tok  = c.C'Preprocess'preprocess(tok);
            c.C'Compile'parse(tok);
        };
        @if_let(result) fn Err(msg) => {
            @panic("failed to compile %\n%", "", msg);
        };
    };
    
    path := "target/clox.out";
    ctx.join_codegen_thread();
    chunks := {m.target.finish_module}(m);
    write_chunks_or_crash(path, chunks);
    c.arena_storage&.deinit();
    drop(m);
    path
}

#use("@/lib/collections/map.fr");
#use("@/lib/sys/fs.fr");

Lox :: import("@/examples/lox/lox_main.fr").Lox;
