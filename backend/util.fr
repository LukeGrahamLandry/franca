// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>

// note: for now the c code still calls its own version of many of these so you can't change the layout of BSet/QList!

fn BIT(n: i64) u64 #inline = 1.shift_left(n);
fn SLOT(i: i64) Qbe.Ref #inline = ref(.RSlot, i.bit_and(0x1fffffff));
fn TMP(i: i64)  Qbe.Ref #inline = ref(.RTmp, i);
fn CALL(i: i64) Qbe.Ref #inline = ref(.RCall, i);

fn TMP(i: i32) Qbe.Ref #inline = TMP(i.intcast());
fn SLOT(i: i32) Qbe.Ref #inline = SLOT(i.intcast());

fn isreg(r: Qbe.Ref) bool #inline = 
    rtype(r) == .RTmp && r.val() < Qbe.Tmp0;

// tmp[t].phi has which id was the .to of a phi with t as an arg. 
// this looks up a chain of phis to see where t is going to end up. 
// if its not used as a phi arg, that's just itself. 
fn phi_dest(t: i64, tmp: QList(Qbe.Tmp)) i64 = {
    t1 := tmp[t].phi.zext();
    if(t1 == 0, => return(t)); // t was not a phi arg
    t1 = phi_dest(t1, tmp);
    tmp[t].phi = t1.intcast();  // cache long chains
    t1
}

// note: typecheck still calls the c version of this
fn clsmerge(pk: *Qbe.Cls, k: Qbe.Cls) bool = {
    k1 := pk[];
    if k1 == .Kx {
        pk[] = k;
        return(false);
    };
    xx := (k1 == .Kw && k == .Kl); // TODO: compiler bug. fix overloading when you inline this. 
    if xx || (k1 == .Kl && k == .Kw) {
        pk[] = .Kw;
        return(false);
    };
    k1 != k
}

fn copy_instructions_from_scratch(f: *Qbe.Fn, b: *Qbe.Blk) void = {
    b.nins = f.len_scratch().trunc();
	idup(b.ins&, f.scratch_next(), b.nins.zext());
	f.globals.curi[] = f.scratch_start(); // TODO: make sure this is right. qbe didn't do it where i'd expect in simpl
}

fn scratch_start(f: *Qbe.Fn) *Qbe.Ins #inline =
    f.globals.insb.index_unchecked(Qbe.MaxInstructions);

fn scratch_next(f: *Qbe.Fn) *Qbe.Ins #inline =
    f.globals.curi[];

fn reset_scratch(f: *Qbe.Fn) void #inline = {
    f.globals.curi[] = f.scratch_start(); 
}

fn len_scratch(f: *Qbe.Fn) i64 #inline = 
    f.scratch_next().ptr_diff(f.scratch_start()); 


// TODO: we rely on globals.curi pointing to the last inst we emitted (in isel) :LookAtLastInst
fn emit(f: *Qbe.Fn, op: Qbe.O, k: Qbe.Cls, to: Qbe.Ref, arg0: Qbe.Ref, arg1: Qbe.Ref) *Qbe.Ins = {
    i := f.globals.curi;
    if i[].identical(f.globals.insb.as_ptr()) {
        die("emit, too many instructions".sym().c_str());
    };
    i[] = i[].offset(-1);
    i[][] = make_ins(op, k, to, arg0, arg1);
    i[]
}

fn emit(f: *Qbe.Fn, i: Qbe.Ins) *Qbe.Ins #inline = 
    f.emit(i&.op(), i&.cls(), i.to, i.arg&[0], i.arg&[1]);

// :TodoPort
fn newtmp(f: *Qbe.Fn, $debug_hint: Str, k: Qbe.Cls) Qbe.Ref #inline = {
    newtmp(debug_hint.sym().c_str(), k, f)
}

fn newtmp($debug_hint: Str, k: Qbe.Cls, f: *Qbe.Fn) Qbe.Ref #inline = {
    newtmp(debug_hint.sym().c_str(), k, f)
}

// :TodoPort
fn newcon(f: *Qbe.Fn, c0: *Qbe.Con) Qbe.Ref #inline =
    newcon(c0, f);


// :TodoPort
fn getcon(f: *Qbe.Fn, val: i64) Qbe.Ref #inline = {
    getcon(val, f)
}

////////////////
/// Bit Sets ///
////////////////

fn bsinit(_0: *Qbe.BSet, _1: i64) void #import("qbe");
fn bszero(_0: *Qbe.BSet) void #import("qbe");
fn bscount(_0: *Qbe.BSet) u32 #import("qbe");
fn bsclr(_0: *Qbe.BSet, _1: i64) void #import("qbe");
fn bscopy(_0: *Qbe.BSet, _1: *Qbe.BSet) void #import("qbe");
fn bsunion(_0: *Qbe.BSet, _1: *Qbe.BSet) void #import("qbe");
fn bsinter(_0: *Qbe.BSet, _1: *Qbe.BSet) void #import("qbe");
fn bsdiff(_0: *Qbe.BSet, _1: *Qbe.BSet) void #import("qbe");
fn bsequal(_0: *Qbe.BSet, _1: *Qbe.BSet) bool #import("qbe");
fn bsiter(_0: *Qbe.BSet, _1: *i32) bool #import("qbe");

// TODO: make elt unsigned to the division is free
fn bshas(bs: *Qbe.BSet, elt: i64) bool #inline = {
    @debug_assert(elt < bs.nt.zext() * Qbe.NBit, "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    mask := BIT(elt.mod(Qbe.NBit));
    slot[].bit_and(mask) != 0
}

fn bsset(bs: *Qbe.BSet, elt: i64) void #inline = {
    @debug_assert(elt < bsmax(bs), "bs oob");
    slot := bs.t.offset(elt / Qbe.NBit);
    slot[] = slot[].bit_or(BIT(elt.mod(Qbe.NBit)));
}

fn bsmax(bs: *Qbe.BSet) i64 #inline =
    bs.nt.zext() * Qbe.NBit;

// :TodoPort
fn init_bitset(size: i64) Qbe.BSet #inline = {
    // this puts it in the pool thing that freeall deals with. i can just stick an arena allocator somewhere i guess and clear it at the end of the function. 
    // is it worth resetting temp() between passes or should i just do it at the end and not deal with it? 
    s := Qbe.BSet.zeroed();
    bsinit(s&, size); 
    s
}

/////////////
/// Lists ///
/////////////

fn vnew(len: i64, element_size: i64, pool: Qbe.Pool) rawptr #import("qbe");
fn vfree(_0: rawptr) void #import("qbe");
fn vgrow(_0: rawptr, _1: i64) void #import("qbe");

fn header();
fn grow();
fn new_copy();

// TODO: move to util
fn QList($T: Type) Type = {
    Self :: @struct(first: *T);
    ::ptr_utils(T);
    
    fn new(len: i64, pool: Qbe.Pool) Self = {
        (first = T.ptr_from_raw(vnew(len, T.size_of(), pool)))
    }
    
    fn new_copy(items: []T, pool: Qbe.Pool) Self = {
        self: Self = new(items.len, pool);
        self.slice(0, items.len).copy_from(items);
        self
    }
    
    // ensure capacity is >= len
    fn grow(s: *Self, len: i64) void = {
        v := Self.raw_from_ptr(s);
        vgrow(v, len);
    }
    
    fn free(s: Self) void = {
        v := T.raw_from_ptr(s.first);
        vfree(v);
    }
    
    // TODO: bounds checking but its hard as long as i have to keep qbe's memory layout because the fields aren't together. 
    //       and anyway it would be sad to add alignment padding just for bounds checks. 
    
    fn index(s: Self, i: i64) *T = 
        s.first.offset(i);
    
    fn index(s: *Self, i: i64) *T = 
        s.first.offset(i);
    
    fn slice(self: Self, start: i64, end: i64) []T = {
        (ptr = self.first.offset(start), len = end - start)
    }
    
    fn header(s: Self) *QbeVec = {
        v := ptr_cast_unchecked(T, Vec, self.first);
        v.offset(-1)
    }
    
    Self
}

// Used with [vnew, vfree, vgrow]
// This is a header that goes before the allocated memory for the array. 
// When a field is an QList it points to the first entry of one of these and you offset backwards to get the header. 
QbeVec :: @struct(
    mag: u64,
    pool: Qbe.Pool,
    esz: i64,
    cap: u64,
    // I don't have unsized types. lets hope thats not a big deal
    // union { long long ll; long double ld; void *ptr; } align[];
);

/////////////////
/// Iterators ///
/////////////////

fn tmps(f: *Qbe.Fn) []Qbe.Tmp #inline = 
    f.tmp.slice(0, f.ntmp.zext());

fn uses(t: *Qbe.Tmp) []Qbe.Use #inline = 
    t.use.slice(0, t.nuse.zext());
    
fn for_blocks(f: *Qbe.Fn, $body: @Fn(b: *Qbe.Blk) void) void = {
    b := f.start;
    while => !b.is_null() {
        body(b);
        b = b.link;
    };
}

fn for_dom(b: *Qbe.Blk, $body: @Fn(b: *Qbe.Blk) void) void = {
    b := b.dom;
    while => !b.is_null() {
        body(b);
        b = b.dlink;
    };
}

fn for_pred(b: *Qbe.Blk, $body: @Fn(p: *Qbe.Blk) void) void = {
    range(0, b.npred.zext()) { p | 
        body(b.pred.offset(p)[]);
    };
}

::ptr_utils(*Qbe.Blk);
fn for_blocks_rpo_rev(f: *Qbe.Fn, $body: @Fn(b: *Qbe.Blk) void) void = {
    i: i64 = f.nblk.zext() - 1;
    while => i >= 0 {
        b := f.rpo.offset(i);
        body(b[]);
        i -= 1;
    };
}

fn for_blocks_rpo_forward(f: *Qbe.Fn, $body: @Fn(b: *Qbe.Blk) void) void = {
    i := 0;
    while => i < f.nblk.zext() {
        b := f.rpo.offset(i);
        body(b[]);
        i += 1;
    };
}

// Not the same as just `for_rev(b.ins.slice(0, b.nins)`
// because the body is allowed to consume multiple instructions by offsetting the pointer. 
// This is needed because the ir uses a vairable length encoding (for blit, call, args).
fn for_insts_rev(b: *Qbe.Blk, $body: @Fn(i: **Qbe.Ins) void) void = {
    i := b.ins.offset(b.nins.zext());
    while => !i.identical(b.ins) {
        i = i.offset(-1);
        body(i&);
        // TODO: @debug_assert() `i` is still in range
    };
}

fn for_insts_forward(b: *Qbe.Blk, $body: @Fn(i: *Qbe.Ins) void) void = {
    i := b.ins;
    while => !i.identical(b.ins.offset(b.nins.zext())) {
        body(i);
        i = i.offset(1);
    };
}

// :TodoPort bsiter. 
fn for(bs: *Qbe.BSet, $body: @Fn(i: i64) void) void = {
    for(bs, 0, fn(i) => body(i))
}

fn for(bs: *Qbe.BSet, start: i64, $body: @Fn(i: i64) void) void = {
    i: i32 = start.intcast();
    while => bsiter(bs, i&) {
        body(i.zext());
        i += 1;
    };
}

::ptr_utils(Qbe.Phi);
fn for_phi(b: *Qbe.Blk, $body: @Fn(p: *Qbe.Phi) void) void = {
    p := b.phi;
    while => !p.is_null() {
        body(p);
        p = p.link;
    };
}

fn for_jump_targets(b: *Qbe.Blk, $body: @Fn(s: *Qbe.Blk) void) void = 
    for_jump_targets_mut(b, fn(b) => body(b[]));

fn for_jump_targets_mut(b: *Qbe.Blk, $body: @Fn(s: **Qbe.Blk) void) void = {
    // TODO: this pastes the code twice which isn't really what you want probably. 
    if !b.s1.is_null() {
        body(b.s1&);
    };
    // :SketchyIterTargets i use this some places that qbe doesn't have the !identical check (sometimes they do have it) so might need to split into two functions. 
    if !b.s2.is_null() && !b.s1.identical(b.s2) {
        body(b.s2&);
    };
}
