// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>
// This is from a patch on the qbe mailing list by Roland Paterson-Jones: https://lists.sr.ht/~mpu/qbe/patches/55968

MAX_IFC_NINS :: 2;
MAX_IFC_NPHIS :: 2;

/* TODO - maybe check for "expensive" instructions? */
fn insok4ifc(f: *Qbe.Fn, b: *Qbe.Blk) bool = {
    n := 0;
    for_insts_forward b { i |
        n += int(!@is(i.op(), .nop, .dbgloc));
        pinned :: import("@/backend/opt/gcm.fr").pinned;
        @if(i.op() != .dbgloc && pinned(i)) return(false);
        @if(n > MAX_IFC_NINS) return(false);
    };
    true
}

fn phisok4ifc(b: *Qbe.Blk) bool = {
    n := 0;
    for_phi b { p |
        n += 1;
        @if(!p.cls.is_int()) return(false);  // TODO: sel for floats.
        @if(n > MAX_IFC_NPHIS) return(false);
    };
    true
}

/* heuristic for performing if-conversion */
fn good4ifc(f: *Qbe.Fn, src: *Qbe.Blk, then: *Qbe.Blk, else: *Qbe.Blk, join: *Qbe.Blk) bool = {
    if(!phisok4ifc(join), => return(false));
    @debug_assert(!then.identical(else));
    if(!then.identical(src) && !insok4ifc(f, then), => return(false));
    if(!else.identical(src) && !insok4ifc(f, else), => return(false));
    true
}

fn ifcblk(f: *Qbe.Fn, src: *Qbe.Blk, then: *Qbe.Blk, else: *Qbe.Blk, join: *Qbe.Blk, scratch: *RawList(Qbe.Ins)) void = {
    vins := scratch;
    vins.clear();
    @debug_assert(src.id <= then.id && src.id <= else.id, "rpo");
    @debug_assert(then.id <= join.id && else.id <= join.id, "rpo");
    
    /* merge if/then/else blks */
    addbins(src, vins);
    merge :: fn(s) => if !s.identical(src) {
        addbins(s, vins);
    };
    merge(then); merge(else);

    /* if-convert the phis to sel1*/
    for_phi join { p |
        continue :: local_return;
        @if(p.to == Qbe.Null) continue();
        
        // TODO: allow multiple sel1 to share a single sel0
        vins.push(make_ins(.sel0, .Kw, Qbe.Null, src.jmp.arg, Qbe.Null), temp());
        
        @debug_assert(p.narg == join.npred);
        argt := p.arg[index_in_phi(then, p)];
        argf := p.arg[index_in_phi(else, p)];
        @debug_assert(p.cls.is_int() && p.narg == 2);
        vins.push(make_ins(.sel1, p.cls, p.to, argt, argf), temp());
    }

    /* fix up the CFG */
    kill :: fn(s) => if !s.identical(src) {
        f.rpo[s.id] = Qbe.Blk.ptr_from_int(0);
    };
    kill(then); kill(else);
    
    idup(src, vins.items());
    src.jmp = (type = .jmp, arg = Qbe.Null);
    src.s1 = join;
    src.s2 = Qbe.Blk.ptr_from_int(0);
    join.npred = 1;
    join.pred[0] = src;
    join.phi = Qbe.Phi.ptr_from_int(0);
}

/* If-convert small if-then[-else] using sel[ect]. */
/* needs rpo pred use; breaks cfg use */
fn ifconvert(f: *Qbe.Fn) void = {
    /* create more trivial if/then/else graphlets */
    blkmerge(f);
    fillcfg(f);

    changed := false;
    scratch: RawList(Qbe.Ins) = empty();
    for f.rpo() { src |
        @if(!src.is_null()) /* not already eliminated */
        if ifgraph(src) { then, else, join |
            if good4ifc(f, src, then, else, join) {
                when_debug(f, .IfOpt) { out |
                    @fmt(out, "\n#    if-converting @% -> @%, @% -> @%", src.name, then.name, else.name, join.name);
                };
                ifcblk(f, src, then, else, join, scratch&);
                changed = true;
            }
        };
    }

    killblks(f);

    @if(changed)
    when_debug_printfn(f, .IfOpt, "\n## After if-conversion:\n");
}

/* (otherwise) isolated if-then[-else] graphlet */
ifgraph :: fn(src: *Qbe.Blk) ?Ty(*Qbe.Blk, *Qbe.Blk, *Qbe.Blk) = {
    lonesucc :: fn(b: *Qbe.Blk, s: *Qbe.Blk) bool = {
        @debug_assert(!s.is_null());
        !s.identical(b)
        && s.npred == 1
        && s.pred[0].identical(b)
        && s.phi.is_null()
    };
    
    lonejmpsucc :: fn(b: *Qbe.Blk, s: *Qbe.Blk) bool = 
        s.jmp.type == .jmp && lonesucc(b, s);

    @if(src.jmp.type != .jnz) return(.None);
    @debug_assert(!src.s1.is_null() && !src.s2.is_null());
    @debug_assert(!src.s1.identical(src.s2));  /* dubious */
    then := src.s1;
    else := src.s2;
    join := src.s1.s1;
    if src.s1.identical(src.s2.s1) {
        /* empty then */
        then = src;
        join = src.s1;
    };
    if src.s1.s1.identical(src.s2) {
        /* empty else */
        else = src;
    };
    
    f :: fn(b) => if !(b.identical(src) ||
        (b.s1.identical(join) && lonejmpsucc(src, b))) {
            return(.None);
        };
    f(then); f(else);
    
    /* there are cases where npred == 2 is not strictly needed - ifconvert for example */
    if join.npred == 2 {
        return(Some = (then, else, join));
    };
    .None
}

Qbe :: import("@/backend/ir.fr");
