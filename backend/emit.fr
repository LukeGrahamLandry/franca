SegmentCursor :: @struct(
    mmapped: []u8,
    next: *u8,
    start_of_writable_code: *u8,
);

SegmentType :: @enum(i64) (
    Code,
    MutableData,
    ConstantData,
    Stubs,
);

SymbolBucket :: @struct(
    n: u32,
    data: QList(SymbolInfo),
);
    
SymbolInfo :: @struct(
    name: CStr,
    inline: *Qbe.Fn, // nullable
    fixups: RsVec(Fixup),
    jit_lookup_offset: i64, // or -1 if not referenced yet 
    segment: SegmentType, // only valid when kind == Local
    offset: i64,
    kind: SymbolKind,
);

::enum_basic(SymbolKind);

SymbolKind :: @enum(i64) (
    // We haven't compiled this yet so we've emitted references as lookups into a table in the data section. 
    // 
    // It might also be a dynamic import. 
    // - For jit, references still go through the table because that means we didn't have to make the code memory writeable again if it already started executing. 
    // - For aot, you may want to go through the fixups again and translate them to use a GOT section. 
    //   That way you don't make the loader waste time patching two tables. 
    //
    // For llvm we still track this and emit forward declarations for anything that's still Pending at the end. 
    //
    Pending,
    // We've already compiled this and we know its close to the code and addressable by a static offset. 
    Local,
    // This is an import and we've already patched it in the jitted code. 
    DynamicPatched,
);

FixupType :: @tagged(
    InReg: @struct(r: i64, increment: i64),
    Call,
);

Fixup :: @struct(
    patch_at: *u8,
    type: FixupType,
);

// TODO: i dont trust calling this multiple times on the same module... thats important to fix. 
fn make_exec(self: *QbeModule) void = {
    self.bump_exec_segment(.Code);
    self.bump_exec_segment(.Stubs);
}

fn bump_exec_segment(self: *QbeModule, segment: SegmentType) void = {
    prot := bit_or(@as(i64) MapProt.Exec, @as(i64) MapProt.Read);
    segment := self.segments&.index(segment);
    end := segment.next&;
    len := segment.start_of_writable_code.ptr_diff(end[]);
    if(len == 0, => return());
    res := mprotect(u8.raw_from_ptr(segment.start_of_writable_code), len, prot); 
    assert(res.value.eq(0), "mprotect failed");
    clear_instruction_cache(u8.raw_from_ptr(segment.start_of_writable_code), u8.raw_from_ptr(end[]));
        
    PAGE_SIZE :: 16384; // TODO: ask the os for this. we're wasting hella memory on linux. 
    page_start := u8.int_from_ptr(end[]) / PAGE_SIZE * PAGE_SIZE;
    end[] = u8.ptr_from_int(page_start + PAGE_SIZE);
    segment.start_of_writable_code = end[];
}

fn get_addr(self: *QbeModule, name: Str) ?rawptr = {
    name := name.maybe_borrow_cstr(temp());
    self.get_addr(name)
}

fn get_addr(self: *QbeModule, name: CStr) ?rawptr = {
    id := self.intern(name);
    symbol := self.get_symbol_info(id);
    if symbol.kind == .Local {
        segment := self.segments&[symbol.segment];
        addr := segment.mmapped.ptr.offset(symbol.offset);
        return(Some = u8.raw_from_ptr(addr));
    };
    .None
}

// TODO: be able to specify mutable or constant
fn new_emit_data(self: *QbeModule, dat: *Qbe.Dat) void = {
    ::enum(@type dat.type);
    
    if self.debug["P".char()] {
        print_dat(dat, self.debug_out);
    };
    
    if self.want_llvm {
        self.emit_llvm(dat);
        return()
    };
    if self.want_text_asm {
        fn emitdat(_0: *Qbe.Dat, _1: *FILE) void #import("qbe"); // :TodoPort
        emitdat(dat, global_module[].outf);
    } else {
        self.emit_data_to_segment(dat);
    };
}

// Used when doing our own bytes. Not needed for emitting text asm/llvm. 
fn emit_data_to_segment(self: *QbeModule, dat: *Qbe.Dat) void = {
    segment := self.segments&[.MutableData]&;
    next := segment.next&;
    @match(dat.type) {
        fn DStart() => {
            segment.align_to(8);
            id := self.intern(dat.name);
            self.do_jit_fixups(id, .MutableData, segment.mmapped.ptr.ptr_diff(next[]));
        }
        fn DEnd() => {
            @assert(ptr_diff(segment.mmapped.ptr, next[]) < segment.mmapped.len, "too much data");  
        };
        fn DZ() => {
            range(0, dat.u.num) { _ |
                next[][] = 0;
                next[] = next[].offset(1);
            };
        }
        fn DB() => {
            @debug_assert(!dat.isref, "can't have a byte sized pointer");
            if dat.isstr {
                // TODO: this is wrong. I have to remove quotes and handle escapes. 
                s := dat.u.str.str();
                (@as([]u8) (ptr = next[], len = s.len)).copy_from(s);
                next[].offset(s.len)[] = 0;
                next[] = next[].offset(s.len + 1);
            } else {
                next[][] = dat.u.num.trunc();
                next[] = next[].offset(1);
            };
        }
        fn DL() => {
            @assert_eq(u8.int_from_ptr(next[]).mod(8), 0, "sorry can't do unaligned constants yet");
            ptr := ptr_cast_unchecked(u8, i64, next[]);
            if dat.isref {
                @assert(dat.u.ref.off == 0, "sorry can't do offset refs yet");
                name := dat.u.ref.name;
                value := or self.get_addr(name) {
                    panic("TODO: data relocations (data containing pointer to data/func declared later)")
                };
                ptr[] = int_from_rawptr(value); // TODO: we have to record that we did this somewhere for aot.
            } else {
                ptr[] = dat.u.num;
            };
            next[] = next[].offset(8);
        }
        fn DW() =>  {
            @debug_assert(!dat.isref, "can't have a w sized pointer");
            @assert_eq(u8.int_from_ptr(next[]).mod(4), 0, "sorry can't do unaligned constants yet");
            ptr_cast_unchecked(u8, u32, next[])[] = dat.u.num.trunc();
            next[] = next[].offset(4);
        }
        fn DH() =>  {
            @debug_assert(!dat.isref, "can't have a h sized pointer");
            @assert_eq(u8.int_from_ptr(next[]).mod(2), 0, "sorry can't do unaligned constants yet");
            ptr_cast_unchecked(u8, u16, next[])[] = dat.u.num.trunc();
            next[] = next[].offset(2);
        }
    }
}

fn add_code_bytes(self: *QbeModule, name: CStr, bytes: []u8) void = {
    name_id := self.intern(name);
    symbol := self.get_symbol_info(name_id);
    code := self.segments&[.Code]&;
    code.align_to(4);  // todo: only for arm
    start_offset := ptr_diff(code.mmapped.ptr, code.next);
    self.do_jit_fixups(name_id, .Code, start_offset);
    dest := slice(code.next, bytes.len);
    dest.copy_from(bytes);
    code.next = code.next.offset(bytes.len);
    
    if self.want_text_asm {
        // TODO: the align4 is only required for arm
        @fmt_write(self.outf, ".text\n.balign 4\n.globl _%\n_%:\n", name, name);
        if bytes.len.mod(4) == 0 && u8.int_from_ptr(bytes.ptr).mod(4) == 0 { 
            // will always be true for arm.
            // doing it as bytes would still work, lets just make it a bit easier for the assembler because why not. 
            words: []u32 = (ptr = ptr_cast_unchecked(u8, u32, bytes.ptr), len = bytes.len / 4);
            for words { inst |
                v := @as(i64) inst.zext();
                @fmt_write(self.outf, "   .word %\n", v);
            };
        } else {
            for bytes { inst |
                v := @as(i64) inst.zext();
                @fmt_write(self.outf, "   .byte %\n", v);
            };
        }
    };
}

fn align_to(s: *SegmentCursor, align: i64) void = {
    extra := u8.int_from_ptr(s.next).mod(align);
    if extra != 0 {
        s.next = s.next.offset(align - extra); 
    };
}

fn put_jit_addr(self: *QbeModule, name: CStr, addr: rawptr) void = {
    symbol := self.get_symbol_info(self.intern(name));
    @assert(symbol.kind == .Pending, "Redeclared symbol %", name);
    symbol.kind = .DynamicPatched;
    self.do_fixups(u8.ptr_from_raw(addr), symbol.fixups.items());
}

// :SLOW insanely inefficient way of doing this. especially when someone tries to add multiple libs. 
// TODO: store a list of the pending ones so don't have to iterate them all. 
fn fill_pending_dynamic_imports(self: *QbeModule, lib: DlHandle) void = {
    for_symbols self { symbol | 
        if symbol.kind == .Pending {
            found := lib.dlsym(symbol.name);
            if !found.is_null() {
                symbol.kind = .DynamicPatched;
                self.do_fixups(u8.ptr_from_raw(found), symbol.fixups.items());
            } else {
                // TODO: remove this and report at the end.
                @eprintln("jit missing symbol %", symbol.name); // wrong once they add multiple dylibs
            };
        };
    };
}

// note: don't push symbols in the body!
fn for_symbols(m: *QbeModule, $body: @Fn(s: *SymbolInfo) void) void = {
    each m.symbols& { bucket | 
        bucket := bucket.data.slice(0, bucket.n.zext());
        each bucket { symbol | 
            body(symbol);
        };
    };
}

fn fill_from_libc(self: *QbeModule) void = {
    if find_os_libc_dylib() { libc_path | 
        libc := dlopen(libc_path, .Lazy);
        if !libc.lib.is_null() { 
            self.fill_pending_dynamic_imports(libc);
        };
    };
}
