//!
//! Llvm treats integers and pointers as distinct types so we insert casts as needed.
//! This is kinda silly because the frontend knew the information, we forced it to throw it away, and now we're reconstructing it.
//! But like, pointers *are* integers, computer can't tell the difference, its a pain to track something that doesn't matter on the other backends. 
//!
//! Similarly llvm comparisons/jumps use i1 so we insert extensions/trunctations,
//! but that offends me less than the pointers thing. 
//! note: jnz isn't a truncation because it looks at the whole number not just the bottom bit).
//!
//! TODO: The main pain is `add` is only for integers but we use it for offseting pointers.
//!       Maybe it would be better to use GEP but we don't have type information. 
//!       I think you're allowed to just offset from an i8 but I can't get it to work on the old llvm backend.
//!

CastCtx :: @struct(
    f: *Qbe.Fn,
    tmps: QList(LlvmTmp),
);

LlvmTmp :: @struct(
    type: LlvmExtraType,
    cast: Qbe.Ref, // TODO: do i ever need it as both ptr and bool?
);

LlvmCast :: @enum(i64) (
    None,
    IntToPtr,
    PtrToInt,
    ExtendI8,
    CmpZero,
);
::if(LlvmCast);

LlvmExtraType :: @enum(u8) (
    None,
    Pointer,
    Bool,
);

fn insert_redundant_casts(f: *Qbe.Fn) void = {
    c: CastCtx = (
        f = f, 
        tmps = new(f.ntmp.zext() * 2, .PFn),
    );
    each f.tmps() { t |
        t.visit = 0;
    };
    f.reset_scratch();
    
    for_blocks f { b |
        for_insts_forward b { i |
            out, _ := i.op().llvm_types();
            if i.to != QbeNull {
                c.tmps[i.to.val()].type = out;
            };
        };
    };
    
    for_blocks f { b |
        if b.jmp.type == .Jjnz {
            c&.fix_arg(b.jmp.arg&, .Bool);
        };  
        for_insts_rev b { i |
            out, args := i[].op().llvm_types();
            x := f.emit(i[][]);
            range(0, 2) { a |
                c&.fix_arg(x.arg&.index(a), args&[a]);
            };
        };
        f.copy_instructions_from_scratch(b);
    };
    if f.globals.debug["I".char()] {
        write(f.globals.debug_out, "\n> After instruction selection:\n");
        printfn(f, f.globals.debug_out);
    };
}

fn emit_cast(c: *CastCtx, dest: Qbe.Ref, src: Qbe.Ref, dest_ty: LlvmExtraType, src_ty: LlvmExtraType) void = {
    c.tmps&.grow(c.f.ntmp.zext());
    cast := cast_type(dest_ty, src_ty).raw();
    c.f.emit(.llcast, .Kl, dest, src, INT(cast));
    if rtype(dest) == .RTmp {
        c.tmps[dest.val()].type = dest_ty;
        c.tmps[dest.val()].cast = src;
    };
    if rtype(src) == .RTmp {
        c.tmps[src.val()].type = src_ty;
        c.tmps[src.val()].cast = dest;
    };
}

::enum_basic(Qbe.UseType);
::enum_basic(LlvmExtraType);
::if(LlvmExtraType);
fn find_best_type(c: *CastCtx, r: Qbe.Ref, original: ?LlvmExtraType) LlvmExtraType = {
    t := c.f.get_temporary(r);
    if t.visit == 1 {
        return(c.tmps[r.val()].type);
    };
    t.visit = 1;  // avoid recursing on phis.
    int_uses  := 0;
    bool_uses := 0;
    pointer_uses := 0;
    tally :: fn(ty: LlvmExtraType) => {
        slot := @match(ty) {
            fn None() => int_uses&;
            fn Bool() => bool_uses&;
            fn Pointer() => pointer_uses&;
        };
        slot[] += 1;
    };
    if(original, tally);
    each t.uses() { use | 
        type := @match(use.type) {
            fn UXXX() => unreachable();
            fn UIns() => {
                i := use.u.ins;
                @debug_assert(i.arg&[0] == r || i.arg&[1] == r, "invalid usage info");
                _, args := i.op().llvm_types();
                if(i.arg&[0] == r, => args&[0], => args&[1])
            }
            fn UPhi() => {
                // TODO: really you want to count all the other things incoming to the phi?
                p := use.u.phi;
                c.find_best_type(p.to, .None)
            }
            fn UJmp() => {
                b := c.f.rpo.offset(use.bid.zext())[];
                if b.jmp.type == .Jjnz {
                    LlvmExtraType.Bool
                } else {
                    .None
                }
            }
        };
        tally(type);
    };
    
    best := LlvmExtraType.None;
    if pointer_uses > int_uses && pointer_uses > bool_uses {
        best = .Pointer;
    };
    if bool_uses > int_uses && bool_uses > pointer_uses {
        best = .Bool;
    };
    if c.f.globals.debug["I".char()] && (bool_uses != 0 || pointer_uses != 0) {
        ::FmtPad(i64);
        @fmt_write(c.f.globals.debug_out, "(%% I:%, P:%, B:%)\n", "%", f_pad(t.name(), 10, .After), f_pad(int_uses, 3, .Before), f_pad(pointer_uses, 3, .Before), f_pad(bool_uses, 3, .Before));
    };
    best
}

fn fix_arg(c: *CastCtx, arg: *Qbe.Ref, want: LlvmExtraType) void = {
    if(rtype(arg[]) != .RTmp, => return());
    id := arg[].val();
    t := c.tmps[id]&;
    if t.type != want {
        if t.cast == QbeNull {
            r := c.f.newtmp("isel", .Kl);
            c.emit_cast(r, arg[], want, t.type);
        };
        arg[] = t.cast;
    };
}

fn cast_type(dest: LlvmExtraType, src: LlvmExtraType) LlvmCast = {
    @match(dest) {
        fn None() => if(src == .Bool, => .ExtendI8, => .PtrToInt);
        fn Pointer() => .IntToPtr;
        fn Bool() => .CmpZero;
    }
}

// (to, arg)
fn llvm_types(o: Qbe.O) Ty(LlvmExtraType, Array(LlvmExtraType, 2)) = {
    yield :: fn(to: LlvmExtraType, a0: LlvmExtraType, a1: LlvmExtraType) => return(to, init(@slice(a0, a1)));
    if(o == .call || o.is_load() || o == .vastart || o == .vaarg, => yield(.None, .Pointer, .None));
    if(o.is_store(), => yield(.None, .None, .Pointer)); // TODO: could store ptr if thats what you have tho
    if(o == .blit0, => yield(.None, .Pointer, .Pointer));
    if(o.between(.alloc4, .alloc16), => yield(.Pointer, .None, .None));
    if(o.between(.ceqw, .cuod), => yield(.Bool, .None, .None));
    yield(.None, .None, .None)
}

::enum_basic(LlvmCast);
::enum_basic(LlvmExtraType);
