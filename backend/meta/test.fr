#!/usr/bin/env franca
//! You want the test runner external to the program being tested so you don't have to think about crashes. 
//! TODO: Maybe I should make it a goal to make this sort of script like thing less painful. 
// TODO: have an option to use import_c for the drivers instead of clang 
// TODO: have an option to run jitted instead of creating a binary
// TODO: don't just shit executables everywhere with fixed names. want to be able to run things in parallel. 

Args :: @struct {
    // TODO: i want to allow the annotation on the end even when there's a default value
    bin: Str  #help("use precompiled backend executable") = "./backend/meta/qbe_frontend.fr"; 
    v:   bool #help("show output on failure") = false;
    x64: bool #help("target x64 instead of your native arch (useful for Rosetta 2)") = false;
    arm: bool #help("target arm64 instead of your native arch") = false;
    h:   bool #help("show this help text") = false;
    cc:  bool #help("use my c compiler (for test harnesses) instead of a system wide one") = false;
    l:   bool #help("FIXME") = false;
    w:   bool #help("target wasm32 and run with examples/import_wasm") = false;
    WIPskipfailing: bool = false;
    paths: []Str #rest = empty();
    d: Str #help("log intermediate representation") = "";
}

// TODO: mkdir -p target/out chmod +x target/out/q.exe
fn main() void = {
    #use("@/lib/args.fr");
    tests_folder := "backend/test";   // TODO: cli args for this too
    args := parse_args(Args);
    HELP :: collect_help(Args, "[test.fr] [options] ['all' or list of .ssa files]");
    
    to_run := Str.list(temp());
    wasm_runner: ?Str = .None;
    
    for args.paths { arg |
        continue :: local_return;
        
        if arg == "franca" || arg.ends_with(".fr") {
            continue();
        };
        if arg == "all" {
            walk_directory(@fmt_cstr("%", tests_folder)) { e |
                if e.name.ends_with(".ssa") && !e.name.starts_with("_") {
                    to_run&.push(@tfmt("%/%", tests_folder, e.name));
                };
            };
            continue();
        };
        if arg.ends_with(".ssa") {
            to_run&.push(@tfmt("%/%", tests_folder, arg));
            continue();
        };
        
        println(HELP);
        @panic("unknown argument %\n", arg);
    };
    
    arch: Arch = @if_else {
        @if(args.x64) => .x86_64;
        @if(args.arm) => .aarch64;
        @else => query_current_arch();
    }
    if args.h {
        print(HELP);
        exit(0);
    };
    if args.w {
        wasm_runner = (Some = "./w.out");
        arch = .wasm32;
        args.cc = true;  // assume this until i can output linkable wasm
        @assert(!args.x64 && !args.arm, "conflicting arch");
    };
    
    @assert(!args.WIPskipfailing || arch == .wasm32);
    @assert(!args.x64 || !args.arm, "conflicting arch");
   
    if to_run.is_empty() {
        eprintln(HELP);
        panic("nothing to run. pass filepaths or 'all'");
    };
    passed := 0;
    failed := 0;
    @eprintln("Testing '%'", args.bin);
    if args.bin.ends_with(".fr") {
        eprintln("note: this is slow because it recompiles the backend from scratch for each test.");
    };
    for to_run { file |
        skip := false
        || (arch != .aarch64 && file.ends_with("-arm.ssa"))
        || (arch != .x86_64 && file.ends_with("-amd.ssa"))
        || (args.WIPskipfailing && !expect_pass_on_wasm.contains(fn(it) => file.ends_with(@tfmt("%.ssa", it[]))))  // allocations georg
        ;
        if !skip {
            pass := run_one(args.bin, file, args.v, arch, args.d, args.l, wasm_runner, args.cc);
            (@if(pass, passed&, failed&))[] += 1;
        } else {
            @println("%[skip]", f_pad(file, 40, .After));
        };
    };
    if failed == 0 {
        @println("\nAll is fine! (passed % tests)", passed);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
        if !args.v {
            println("(run with -v to see output)");
        };
    };
    exit((failed != 0).int());
}

fn run_one(qbe_path: Str, file_path: Str, verbose: bool, arch: Arch, flags: Str, use_llvm: bool, wasm_runner: ?Str, iamthecompilernow: bool) bool #inline = {
    ::FmtPad(Str);
    mark := mark_temporary_storage();
    src := temp().read_to_string_or_crash(file_path).items(); // :panic
    driver_path := "target/out/driver.c";
    obj_path_mine := "target/out/q.o";
    obj_path_driver := "target/out/d.o";
    exe_path := "target/out/q.exe";
    ll_path := "target/out/q.ll";
    c := timestamp();
    @print("%", f_pad(file_path, 40, .After));
    
    driver := extract_section(src, "driver");
    if iamthecompilernow {
        driver = .None;
    }
    expected := extract_section(src, "output");
    
    my_path := if(driver.is_some(), => obj_path_mine, => exe_path);
    args := Str.list(temp());
    if driver.is_some() {
        args&.push("-c");
        if wasm_runner.is_some() {
            println("todo: c+wasm");
            return false;
        }
    };
    if use_llvm {
        args&.push("-l");
    };
    args&.push("-t");
    if wasm_runner.is_some() {
        // TODO: import_wasm shouldn't care about the file extension
        exe_path = "target/out/q.wasm";
        my_path = exe_path;
        args&.push("wasm32");
    } else {
        args&.push(qbe_target_name(arch, query_current_os()));
    };
    args&.push("-o");
    args&.push(@if(use_llvm, ll_path, my_path));
    if flags != "" {
        args&.push("-d");
        args&.push(flags);
    };
    if iamthecompilernow {
        args&.push("-cc");
    }
    args&.push(file_path);
    a := timestamp();
    run(qbe_path, "gen ir");
    b := timestamp();
    
    clang_triple := target_triple(arch, query_current_os());
    
    if use_llvm {
        if wasm_runner.is_some() {
            println("todo: llvm+wasm");
            return false;
        }
        args&.clear();
        if driver.is_some() {
            args&.push("-c");
        };
        args&.push_all(@slice("-target", clang_triple, "-x", "ir", ll_path, "-o", my_path));
        run("clang", "llvm");
    };

    run :: fn(exe: Str, what: Str) => {
        if verbose {
            @print("\n% ", exe);
            for args { a |
                @print("% ", a);
            };
            println("");
        };
        
        ok, out, err := exec_and_catch(exe, args.items(), temp());
        if !ok {
            @println("[fail %]", what);
            if verbose {
                println(err.items());
                println(out.items());
            };
            return(false);
        };
    };
    
    if driver { driver_src | 
        write_entire_file(driver_path, driver_src);
        args&.clear();
        args&.push_all(@slice("-target", clang_triple, "-c", "-o", obj_path_driver, driver_path));
        run("clang", "driver");
    };
    
    if driver.is_some() {
        args&.clear();
        if driver { _ |
            args&.push(obj_path_driver);
        };
        args&.push_all(@slice(obj_path_mine, "-o", exe_path, "-target", clang_triple));
        run("clang", "link");
    }; // else we have our own codesign implementation so we're done
    args&.clear();
    if wasm_runner { wasm_runner |
        args&.push(exe_path);
        exe_path = wasm_runner;
    };
    args&.push_all(@slice("a", "b", "c"));
    ok, out, err := exec_and_catch(exe_path, args.items(), temp());
    if !ok {
        @println("[fail run]");
        if verbose {
            println(err.items());
            println(out.items());
        };
        // HACK because macos has a panic attack if it aborts 
        // (like it does when you dyld[XXXXX]: Symbol not found: XXXXX)
        // and then you rewrite the file and try to run the new program. 
        if wasm_runner.is_none() {
            args&.clear();
            args&.push(exe_path);
            run("rm", "");  // ðŸ¤¡
        };
        return(false);
    };
    
    if expected { expected | 
        if expected != out.items() {
            @println("[fail output]");
            if verbose {
                println(err.items());
                println(out.items());
            };
            return(false);
        };
    }; 
    d := timestamp();
    @println("[ok] %ms, %ms", b - a, d - c);
    
    reset_temporary_storage(mark);
    true
}

fn extract_section(src: Str, name: Str) ?Str = {
    out: List(u8) = list(temp());
    want := @tfmt("# >>> %", name);
    while => src.len != 0 {
        while => src[0] != "#".ascii() {
            src = src.skip_line();
            if(src.len == 0, => return(.None));
        };
        if src.starts_with(want) {
            src = src.skip_line();
            while => !src.starts_with("# <<<") {
                chunk := src;
                // TODO: push a chunk to out
                src = src.skip_line();
                chunk = chunk.slice(0, chunk.len - src.len);
                @assert(chunk.starts_with("# "), "bad format for section: %\nline: |%|\n", name, chunk);
                if chunk.ends_with("#\n") {
                    out&.push_all(chunk.slice(2, chunk.len - 2));
                    out&.push_all("\n");
                } else {
                    out&.push_all(chunk.slice(2, chunk.len));
                };
            };
            return(Some = out.items());
        };
        src = src.skip_line();
    };
    .None
}

fn skip_line(s: Str) Str = {
    loop {
        if(s.len <= 0, => return(s));
        if s[0] == "\n".ascii() {
            return(s.slice_pop_first());
        };
        s = s.slice_pop_first();
    }
}

#use("@/lib/sys/subprocess.fr");

expect_pass_on_wasm :: @const_slice(
    "load4", "mandel", "load3", "subtyping", "puts10", "cprime", "call2",
    "call3", "mem4", "abi9", "div", "mem3", "mem2", "f_whilebreak", "queen", "encoding",
    "fold1", "cmp1", "fold2", "euclc", "env", "rega1", "spill1", "philv", 
    "ldhoist", "fixarg", "cup", "abi10", "isel3", "isel2", "strcmp",
    "fpcnv", "collatz", "double", "align", "prime", "max", "eucl", "loop", "sum", 
    "fixup3", "isel1", "ldbits", "hello", "fixup1", "vararg1", "switch", "abi6",
);
