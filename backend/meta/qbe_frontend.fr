#!/usr/bin/env franca
//! This is just for running Qbe's test files. 
//! As a convinence you can pass -r to run directly (if the qbe ir has a main() function and doesn't require a driver c program).
//! For Franca's normal interaction with the backend we just generate the ir in memory. 

Qbe :: import("@/backend/lib.fr");

INCLUDE_MY_C_COMPILER :: true;

Args :: @struct {
    t: TargetId #help("target environment") = .native;
    o: Str #help("output file path") = "-";
    d: Str #help("log intermediate representation") = "";
    r: bool #help("jit and run main() without outputting an exe. can call functions from libc.") = false;
    c: bool #help("output a relocatable object file") = false;
    h: bool #help("show this help text") = false;
    cc: bool #help("use my import_c to compile '>>> driver' comments") = false;
    frc: bool #help("output .frc binary ir") = false;
    frc_inlinable: bool #help("output .frc binary ir (before regalloc)") = false;
    @"t?": bool #help("TODO: query the native target") = false;
    paths: []Str #rest = empty();
    nostart := false;
    HACK_convert_illegal_ret_to_hlt := false;
    wasm_threads := false;
}

main :: fn() void = { 
    import("@/lib/crash_report.fr")'hook_backtrace();
    
    #use("@/lib/args.fr");
    HELP :: collect_help(Args, "qbe_frontend [OPTIONS] {file.ssa, -}");
    full_args := cli_args();
  
    fn eq(a: *CStr, b: *CStr) bool = a[] == b[].str();
    end := full_args.len;
    if full_args.index_of(@as(CStr) "--") { i |
        end = i;
    };
    cli_args: List(CStr) = full_args.rest(min(full_args.len, end+1)).clone(temp());
    
    args: Args = ();
    parse_args(Args, args&, full_args.slice(1, end));
    
    ::enum(TargetId);
    arch, os := args.t.splat_env();
    if args.h {
        print(HELP);
        return();
    }
    if args.@"t?" {
        return(); // TODO: qbe prints the name of default target
    }
    
    outpath := args.o;
    inpath := "-";
    debug := args.d != "";
    is_args := false;
    for args.paths { a |
        if !a.ends_with(".fr") {// TODO: ugh don't care about the file extension 
            if a.starts_with("-") && a != "-" {
                @panic("Unknown option %", a);
            };
            inpath = a;
        }
    };
    args.frc = args.frc || args.frc_inlinable;
    goal: Qbe.OutputPurpose = @if_else {
        @if(args.r) => .JitOnly;
        @if(args.c) => .Relocatable;
        @if(args.frc_inlinable) => .CachedEarly;
        @if(args.frc) => .Cached;
        @else => .Exe;
    };
    @assert(!args.cc || INCLUDE_MY_C_COMPILER, "didn't INCLUDE_MY_C_COMPILER can't -cc");
    @assert_le(int(args.c) + int(args.r) + int(args.frc), 1, "conflicting output type");
    m := Qbe.Module.zeroed(); m := m&;
    Qbe'backend'init_module(m, (
        type = goal, os = os, arch = arch, 
        exe_debug_symbol_table = true, 
        wrap_entry_for_linux_libc = !args.nostart,
        HACK_convert_illegal_ret_to_hlt = args.HACK_convert_illegal_ret_to_hlt,
        wasm_shared_memory = args.wasm_threads,
    ));
    set_debug_types(m, args.d, true);
    
    src := temp().read_to_string_or_crash(inpath);
    src&.push_all("\n"); // HACK
    src := src.items();
    
    magic8 := ptr_cast_unchecked(u8, u64, src.ptr)[];
    if magic8 == Qbe.Incremental.MAGIC {
        H :: *Qbe.Incremental.Header;
        ::Result(H, Str);
        header: H = or check(src) { e |
            @panic("invalid frc file: %", e)
        };
        t := Qbe'Incremental'pack_target(m.goal.arch, m.goal.os);
        @assert_eq(header.arch_os.bit_and(t), t, "% was compiled for different target", inpath);
        Qbe'backend'load_all(header, m);
    } else {
        parse :: import("@/backend/meta/parse.fr").parse_top_level;
        res := parse(m, src, Qbe'backend'compile_dat, Qbe.backend.compile_fn, args.cc);
        if res&.is_err() {
            panic(res.Err);
        };
        
        if args.cc && res.Ok.len > 0 {
            #use("@/examples/import_c/lib.fr");
            #use("@/examples/import_c/ffi.fr");
            c := Compile.Ctx.zeroed();
            ctx := init_codegen_worker(m, false);
            import_c'init_c(c&, m, ctx);
            // TODO: this way of doing it means you lose location information which sucks
            result := import_c'compile_c(c&, ">>>driver", res.Ok&.items());
            result.or(fn(e) => panic(e));
            c.arena_storage&.deinit();
            Qbe'backend'worker_join(ctx);
            res.Ok&.drop();
        };
        m.Qbe'backend'compile_suspended();
    };
    
    if !args.r {
        chunks := {m.target.finish_module}(m);
        outfile := STD_OUT;
        if outpath != "-" {
            outfile = open_trunc(as_cstr outpath)
                    || @panic("failed to open output '%'", outpath)
        };
        for chunks { chunk | 
            write(outfile&, chunk); 
        };
        @if(outpath != "-") { Syscall'close(outfile); };
    };
    if args.r {
        Crash :: import("@/lib/crash_report.fr");
    
        @if(is_linking_libc()) m.Qbe'fill_from_libc();
        m.make_exec();
        f := m.get_addr(m.goal.entry_point) 
            || @panic("couldn't find %", m.goal.entry_point);
        f := assume_types_fn(Arg = Ty(i64, *CStr, *CStr), Ret = i64, ptr = f);
        cli_args&.insert(0, "thisisjittedcodegoodluckwiththat.exe");
        cli_args&.push(zeroed(CStr));
        envp := tls(.environment_variables)[];
        status := f(cli_args.len - 1, cli_args.maybe_uninit.ptr, envp);
        @if(status != 0) @panic("Returned status %", status);
    };
    drop(m);
}

TargetId :: @enum(i64) (native, arm64_apple, amd64_apple, amd64_sysv, arm64, wasm32, rv64);
fn splat_env(t: TargetId) Ty(Arch, Os) = @match(t) {
    fn arm64_apple() => (.aarch64, .macos);
    fn amd64_apple() => (.x86_64, .macos);
    fn amd64_sysv()  => (.x86_64, .linux);
    fn arm64()       => (.aarch64, .linux);
    fn wasm32()      => (.wasm32, .wasip1);
    fn native()      => (query_current_arch(), query_current_os());
    fn rv64()        => (.rv64, .linux);
};

// TODO: use #where
fn parse_from_args(args: []CStr, i: *i64) TargetId = {
    n: Str = parse_from_args(args, i);
    t := TargetId.from_name(n);
    t || @panic("invalid target '%'", n)
}

#use("@/lib/sys/fs.fr");
