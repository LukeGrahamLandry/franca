#!/usr/bin/env franca
//! This is just for running Qbe's test files. 
//! As a convinence you can pass -r to jit and run directly.
//! Some of the tests include c functions for testing abi. 
//! When passing -r or -cc, they will be compiled by import_c instead of an external c compiler.
//! For Franca's normal interaction with the backend we just generate the ir in memory. 
//! You can also use this with other frontends that output qbe ir text 
//! (but I output executables directly instead of assembly text so not a drop in replacement)

Qbe :: import("@/backend/lib.fr");

Args :: @struct {
    t: TargetId #help("target environment") = .native;
    o: Str #help("output file path") = "-";
    d: Str #help("log intermediate representation") = "";
    r: bool #help("jit and run main() without outputting an exe. can call functions from libc.") = false;
    c: bool #help("output a relocatable object file") = false;
    h: bool #help("show this help text") = false;
    cc: bool #help("use my import_c to compile '>>> driver' comments") = false;
    frc: bool #help("output .frc binary ir") = false;
    frc_inlinable: bool #help("output .frc binary ir (before regalloc)") = false;
    @"t?": bool #help("TODO: query the native target") = false;
    paths: []Str #rest = empty();
    nostart := false;
    HACK_convert_illegal_ret_to_hlt := false;
    wasm_threads := false;
}

main :: fn() void = { 
    import("@/lib/crash_report.fr")'hook_backtrace();
    
    #use("@/lib/args.fr");
    HELP :: collect_help(Args, "qbe_frontend [OPTIONS] {file.ssa, -}");
    full_args := cli_args();
  
    fn eq(a: *CStr, b: *CStr) bool = a[] == b[].str();
    end := full_args.len;
    if full_args.index_of(@as(CStr) "--") { i |
        end = i;
    };
    cli_args: List(CStr) = full_args.rest(min(full_args.len, end+1)).clone(temp());
    
    args: Args = ();
    parse_args(Args, args&, full_args.slice(1, end));
    
    arch, os := args.t.splat_env();
    if args.h {
        print(HELP);
        return();
    }
    if args.@"t?" {
        return(); // TODO: qbe prints the name of default target
    }
    
    outpath := args.o;
    inpath := "-";
    debug := args.d != "";
    is_args := false;
    for args.paths { a |
        if !a.ends_with(".fr") {// TODO: ugh don't care about the file extension 
            if a.starts_with("-") && a != "-" {
                @panic("Unknown option %", a);
            };
            inpath = a;
        }
    };
    args.frc = args.frc || args.frc_inlinable;
    goal: Qbe.OutputPurpose = @if_else {
        @if(args.r) => .JitOnly;
        @if(args.c) => .Relocatable;
        @if(args.frc_inlinable) => .CachedEarly;
        @if(args.frc) => .Cached;
        @else => .Exe;
    };
    @assert_le(int(args.c) + int(args.r) + int(args.frc), 1, "conflicting output type");
    m := Qbe.Module.zeroed(); m := m&;
    Qbe'backend'init_module(m, (
        type = goal, os = os, arch = arch, 
        exe_debug_symbol_table = true, 
        wrap_entry_for_linux_libc = !args.nostart,
        HACK_convert_illegal_ret_to_hlt = args.HACK_convert_illegal_ret_to_hlt,
        wasm_shared_memory = args.wasm_threads,
    ));
    set_debug_types(m, args.d, true);
    
    src := temp().read_to_string_or_crash(inpath);
    src := src.items();
    
    magic8 := ptr_cast_unchecked(u8, u64, src.ptr)[];
    if magic8 == Qbe.Incremental.MAGIC {
        H :: *Qbe.Incremental.Header;
        ::Result(H, Str);
        header: H = or check(src) { e |
            @panic("invalid frc file: %", e)
        };
        t := Qbe'Incremental'pack_target(m.goal.arch, m.goal.os);
        @assert_eq(header.arch_os.bit_and(t), t, "% was compiled for different target", inpath);
        Qbe'backend'load_all(header, m);
    } else {
        parse :: import("@/backend/meta/parse.fr").parse_top_level;
        res := parse(m, src, Qbe'backend'compile_dat, Qbe.backend.compile_fn);
        if res&.is_err() {
            panic(res.Err);
        };
        
    if args.cc {
        sections := extract_sections(src);
        if sections&.get("driver") { src |
            #use("@/examples/import_c/lib.fr");
            #use("@/examples/import_c/ffi.fr");
            c := Compile.Ctx.zeroed();
            ctx := init_codegen_worker(m, false);
            import_c'init_c(c&, m, ctx);
            // TODO: this way of doing it means you lose location information which sucks
            result := import_c'compile_c(c&, ">>>driver", src);
            result.or(fn(e) => panic(e));
            c.arena_storage&.deinit();
            Qbe'backend'worker_join(ctx);
        };
    };
        m.Qbe'backend'compile_suspended();
    };
    
    if !args.r {
        chunks := {m.target.finish_module}(m);
        outfile := STD_OUT;
        if outpath != "-" {
            outfile = open_trunc(as_cstr outpath)
                    || @panic("failed to open output '%'", outpath)
        };
        for chunks { chunk | 
            write(outfile&, chunk); 
        };
        @if(outpath != "-") { Syscall'close(outfile); };
    };
    if args.r {
        Crash :: import("@/lib/crash_report.fr");
    
        @if(is_linking_libc()) m.Qbe'fill_from_libc();
        m.make_exec();
        f := m.get_addr(m.goal.entry_point) 
            || @panic("couldn't find %", m.goal.entry_point);
        f := assume_types_fn(Arg = Ty(i64, *CStr, *CStr), Ret = i64, ptr = f);
        cli_args&.insert(0, "thisisjittedcodegoodluckwiththat.exe");
        cli_args&.push(zeroed(CStr));
        envp := tls(.environment_variables)[];
        status := f(cli_args.len - 1, cli_args.maybe_uninit.ptr, envp);
        @if(status != 0) @panic("Returned status %", status);
    };
    drop(m);
}

TargetId :: @enum(i64) (native, arm64_apple, amd64_apple, amd64_sysv, arm64, wasm32, rv64);
fn splat_env(t: TargetId) Ty(Arch, Os) = @match(t) {
    fn arm64_apple() => (.aarch64, .macos);
    fn amd64_apple() => (.x86_64, .macos);
    fn amd64_sysv()  => (.x86_64, .linux);
    fn arm64()       => (.aarch64, .linux);
    fn wasm32()      => (.wasm32, .linux);
    fn native()      => (query_current_arch(), query_current_os());
    fn rv64()        => (.rv64, .linux);
};

// TODO: use #where
fn parse_from_args(args: []CStr, i: *i64) TargetId = {
    n: Str = parse_from_args(args, i);
    t := TargetId.from_name(n);
    t || @panic("invalid target '%'", n)
}

extract_sections :: fn(src: Str) HashMap(Str, Str) = {
    results: HashMap(Str, Str) = init(temp());
    start_section := "# >>> ";
    while => src.len != 0 {
        while => src[0] != "#".ascii() {
            src = src.skip_line();
            if(src.len == 0, => return(results));
        };
        if src.starts_with(start_section) {
            name := {
                i := start_section.len;
                while => !src[i].is_ascii_whitespace() {
                    i += 1;
                };
                src.slice(start_section.len, i)
            };
            src = src.skip_line();
            out, new_src, nested := consume_section(src, name);
            prev := results&.insert(name, out);
            if prev { prev |  // allow split sections. see tests/abi8.ssa for example. 
                results&.insert(name, @tfmt("%%", prev, out));
            };
            if !nested {
                src = new_src;
            };
        };
        src = src.skip_line();
    };
    results
}

consume_section :: fn(src: Str, name: Str) Ty(Str, Str, bool) = {
    start_of_this_section := src.ptr;
    out: List(u8) = list(temp());
    strip_hashes := src.starts_with("#");
    depth := 1;
    nested := false;
    while => depth > 0 {
        chunk := src;
        src = src.skip_line();
        if strip_hashes {
            chunk = chunk.slice(0, chunk.len - src.len);
            @assert(chunk.starts_with("# "), "bad format for section: %\nline: |%|\nmust start with <hash><space>", name, chunk);
            if chunk.ends_with("#\n") {
                out&.push_all(chunk.slice(2, chunk.len - 2));
                out&.push_all("\n");
            } else {
                out&.push_all(chunk.slice(2, chunk.len));
            };
        };
        
        if src.starts_with("# >>>") {
            depth += 1;
            nested = true;
        };
        depth -= src.starts_with("# <<<").int();
    };
    out := if strip_hashes {
        out.items()
    } else {
        between(start_of_this_section, src.ptr)
    };
    
    (out, src, nested)
}

fn skip_line(s: Str) Str = {
    loop {
        if(s.len <= 0, => return(s));
        if s[0] == "\n".ascii() {
            return(s.slice_pop_first());
        };
        s = s.slice_pop_first();
    }
}

#use("@/lib/sys/fs.fr");
#use("@/lib/collections/map.fr");
