// this feels like a massive pain and i must be making it more complicated than it needs to be...
// but consider that the Zig has ~18000 lines of dealing with mach-o files: 
//  - https://github.com/ziglang/zig/tree/master/src/link/MachO
//  - https://github.com/ziglang/zig/blob/master/src/link/MachO.zig
// not at all a fair comparison, they do far more stuff, but the point remains. 

// life is better if you're always 8 byte aligned. 


WipSegment :: @struct(
    name: Str,
    prot: u32,
    virtual_size := 0,
    file_size := 0,
    sections: []WipSection = empty(),
);

WipSection :: @struct(
    name: Str,
    flag: u32,
    offset_in_segment: i64,
    size: i64,
    reserved2: u32 = 0,
);

fn output_macho(m: *QbeModule) List([]u8) = {  
    global_module.fill_from_libc(); // TODO: don't waste time doing this just to bump reloc state. 
    for_enum SegmentType { s | 
        //m.align_to(s, 8);  // forgeting this manifested as getting fucked on __LINKEDIT (when reading not writing because you're writting into a new allocation)
        // but do we need to do this? it makes it look more like clang does. 
        m.align_to(s, macos_page_size);
    };
    m.fixups_locked = true; // we're going to stomp the data section with relocation info so you can run it jitted anymore after this. 
    chunks := list([]u8, 10, temp());
    chunks&.push(empty()); // this used to be for commands but now thats part of .Code which is stupid. :commandsispartofcodenow
    // TODO: waste. dead zone Code[stubs_cursor..SIZE_OF_STUBS]
    chunks&.push(live_segment_part(m, .Code));  // :MySegmentsStartAt1 :CodeIsFirst
    chunks&.push(live_segment_part(m, .ConstantData));  // TODO: waste. dead zone ConstantData[got_cursor..MAX_GOT_SIZE]
    chunks&.push(live_segment_part(m, .MutableData));
    
    //add_data_file_offset := list(*u32, 10, temp());
    // :leak
    //commands := u8.list(COMMANDS_SIZE_GUESS, page_allocator); // temp()); :SLOW want to use temp but life is confusing if not aligned. need to support passing greater alignment than the type requires. 
    commands: List(u8) = (maybe_uninit = (ptr = m.segment_address(.Code, 0), len = COMMANDS_SIZE_GUESS), len = 0, gpa = page_allocator); // :cantreallocatebutgivegooderrormessage
    command_count := 0;
    segment_file_offsets := temp().alloc_zeroed(i64, m.segments.data&.len());
    
    macho_header := commands&.reserve_type(MachoHeader);
    macho_header[] = (
        cpu_type = 0x0100000C, // arm 64bit
        cpu_subtype = 0x00000000,
        file_type = 0x00000002, // Demand paged executable file. (idk, thats what rust uses ¯\_(ツ)_/¯ )
        commands_count = 0, 
        commands_size = 0, 
        flags = 0b00000000001000000000000010000101, // ¯\_(ツ)_/¯  what rust uses except I don't HAS_TLV_DESCRIPTORS
    );
    
    ::enum_basic(LoadCommand);
    // I guess this is to make sure you segfault on low addresses. 
    // But it can't guarentee my base address is zero right? so what's the point? clearly im missing something. 
    // TODO: probably don't do this if we're making a linkable .o file. 
    zero_page_size :: 0x100000000;
    
    segments := WipSegment.list(6, temp());
    segments&.push(prot = 5, name = "__TEXT");
    segments&.push(prot = 3, name = "__DATA_CONST");
    segments&.push(prot = 3, name = "__DATA");
    enumerate segments& { i, s |
        s.virtual_size = m.segments&[@as(SegmentType) i].mmapped.len;
        s.file_size = chunks[i + 1].len;
    };
    segments&.insert(0, (prot = 0, name = "__PAGEZERO", virtual_size = zero_page_size)); // ???? some insane compiler bug... -- Oct 24
    
    code_flag := ATTR_PURE_INSTRUCTIONS.bit_or(ATTR_SOME_INSTRUCTIONS);
    segments[1].sections = @slice(@as(WipSection) (name = "__text", flag = code_flag, offset_in_segment = COMMANDS_SIZE_GUESS + SIZE_OF_STUBS, size = chunks[1].len - SIZE_OF_STUBS));
    // 12 is the size of each stub (adrp, ldr, br)
    segments[1].sections = @slice(@as(WipSection) (name = "__stubs", size = SIZE_OF_STUBS, reserved2 = 12, flag = code_flag.bit_or(S_SYMBOL_STUBS), offset_in_segment = COMMANDS_SIZE_GUESS));
    // TODO: do i need reserved1 set to something? maybe thats an offset into LC_SYMTAB? or maybe undefined_symbol_count, that seems more consistant in the binraries i checked. 
    segments[2].sections = @slice(@as(WipSection) (name = "__got", size = chunks[2].len, flag = S_NON_LAZY_SYMBOL_POINTERS, offset_in_segment = 0));
    segments[3].sections = @slice(@as(WipSection) (name = "__data", size = chunks[3].len, flag = 0, offset_in_segment = 0));
   
    file_offset := 0;
    base_file_offset := @slice(0, 0, 0, 0); // you always need to use add_data_file_offset with this. --- but not anymore
    virtual_segment_offset := @slice(0, 0, 0, 0);
    virtual_offset := 0;
    {
        enumerate segments& { segment_index, s | 
            // no! you cant skip segments because then the offsets are wrong below when doing chianed fixups. 
            //if segment_index == 0 || s.file_size != 0 {
                start := commands.len;
                h := commands&.reserve_type(LoadCommandHeader);
                h.type = LoadCommand.SegmentLoad.raw();
                command_count += 1;
                cmd := commands&.reserve_type(SegmentLoad);
                cmd[] = SegmentLoad.zeroed();
                // you do need this tho or you crash in dyld`dyld4::fixupPage64(void*, mwl_info_hdr const*, dyld_chained_starts_in_segment const*, unsigned int, bool) 
                if s.name == "__DATA_CONST" {
                    cmd.flag = 16; // TODO: why :HACK
                };
                cmd.max_prot = s.prot;
                cmd.init_prot = s.prot;
                cmd.name = str_to_16_byte_value(s.name);
                cmd.address = virtual_offset.bitcast();
                cmd.address_size = s.virtual_size.bitcast();
                virtual_segment_offset[segment_index] = virtual_offset;
                cmd.file_offset = if(s.file_size != 0, => file_offset.bitcast(), => 0);
                base_file_offset[segment_index] = cmd.file_offset.bitcast();
                if s.file_size != 0 {
                    //add_data_file_offset&.push(ptr_cast_unchecked(u64, u32, cmd.file_offset&)); // :overflow
                };
                cmd.size = s.file_size.bitcast(); 
                /*
                cmd.section_count = s.sections.len.trunc();
                each s.sections { sec | 
                    c  := commands&.reserve_type(SegmentSection);
                    c[] = SegmentSection.zeroed();
                    c.segment_name = cmd.name;
                    c.section_name = str_to_16_byte_value(sec.name);
                    c.address      = cmd.address + sec.offset_in_segment.bitcast();
                    c.file_offset  = cmd.file_offset.trunc() + sec.offset_in_segment.trunc(); // :overflow
                    //add_data_file_offset&.push(c.file_offset&);
                    c.alignment    = 3; // TODO
                    c.flag         = sec.flag;
                    c.size         = sec.size.bitcast();
                    c._reserved2   = sec.reserved2;
                };
                */
                h.size = trunc(commands.len - start);
            //};
            virtual_offset += s.virtual_size;
            file_offset += s.file_size;
        };
    };
    
    start := commands.len;
    linkedit_load_header := commands&.reserve_type(LoadCommandHeader);
    linkedit_load_header.type = LoadCommand.SegmentLoad.raw();
    command_count += 1;
    link_edit_load_command := commands&.reserve_type(SegmentLoad);
    linkedit_load_header.size = trunc(commands.len - start);
    
    
    {
        CHAINED_SIZE_GUESS :: 16000;
        chained := u8.list(CHAINED_SIZE_GUESS, temp());
        chain_header := chained&.reserve_type(ChainedFixupsHeader);
        
        fixups, symbols := collect_aot_fixups(m);
        @debug_assert_ge(fixups.len, m.got_cursor / 8, "at least each __got entry needs a fixup");
        sort :: quicksort(FixP, fn(a, b) => ptr_diff(a._1.patch_at, b._1.patch_at) <= 0); // TODO: flipped?
        sort(fixups);
        // at this point, `fixups` is in the order of the patch targets in virtual memory which is the order we need to emit the fixup chains. 
        import_count := 0;
        for symbols { s |
            if s.kind != .Local {
                s.got_lookup_offset = import_count;
                import_count += 1;
            };
        };
        // imports are fixed size. so we can reserve that early
        imports_len_b := import_count * 4;
        imports_offset := chained.len; // TODO: is this right?
        chained&.reserve(imports_len_b);
        chained.len += imports_len_b;
        symbols_offset := chained.len; // TODO: is this right?
        imports_bytes := chained.items().slice(chained.len - imports_len_b, chained.len);
        imports_bytes: []u32 = (ptr = ptr_cast_unchecked(u8, u32, imports_bytes.ptr), len = import_count);
        for symbols { s |
            if s.kind != .Local {
                n: u32 = trunc(chained.len - symbols_offset);
                imports_bytes[s.got_lookup_offset] = encode_import(lib_ordinal = 1, weak = false, name_offset = n); // TODO: don't assume libc
                mangled := items(@format("_%", s.name) temp()); // :slow don't do an extra copy
                append_padded_cstr(chained&, mangled, 1);
            };
        };
        zero_pad_to_align(chained&, 4);
        
        //
        // Now we have to do the fixup chain page starts. 
        // This is how we tell it where it has to do relocations. 
        //
        starts_offset := chained.len;
        // TODO: uncomment the real number when ready
        seg_count :: 2 + enum_count(SegmentType);  // __zeropage, <the rest>, __linkedit
        chained&.reserve_type(u32)[] = seg_count.trunc();
        // indexed by segment index
        offset_to_csis: []u32 = (ptr = ptr_cast_unchecked(u8, u32, chained.maybe_uninit.ptr.offset(chained.len)), len = seg_count); // from chained[starts_offset]
        unprocessed_sentinal :: MAX_u32;
        range(0, seg_count) { i |
            o := chained&.reserve_type(u32);
            o[] = unprocessed_sentinal;
        };
        
        chained&.zero_pad_to_align(8);
        start_of_csis := chained.len;
        csis_off := chained.len - starts_offset;
        csis := chained&.reserve_type(ChainedStartsInSegment);  // one of these per segment.  
        chained.len -= 2; // take it back now yall
        csis[] = ChainedStartsInSegment.zeroed();
        // TODO: what if there's a page in the middle with no relocations? 
        fix := fixups.index(0);
        @assert_eq(fixups.len, 1, "tODO: more fixups");
        seg, off_in_segment := compiler_address_to_segment_offset(m, fix._1.patch_at);
        segment_index := seg.raw() + 1;  // :MySegmentsStartAt1
        page_index, offset_in_page := off_in_segment.div_mod(macos_page_size);
        if offset_to_csis[segment_index] == unprocessed_sentinal {
            @assert_eq(page_index, 0, "TODO: how do we skip pages without fixups?");
            offset_to_csis[segment_index] = csis_off.trunc();
            chained&.reserve_type(u16)[] = offset_in_page.trunc();
        } else {
            panic("TODO: multiple fixups");
        };
        csis.segment_offset = base_file_offset[segment_index].bitcast(); // this is the offset into the file to the first page in this segment. 
        //add_data_file_offset&.push(ptr_cast_unchecked(u64, u32, csis.segment_offset&)); // :overflow
        encoded := encode_chained(
            next = 0,  // TODO
            reserved = 0,
            payload = @if(fix._0.kind != .Local, {
                @debug_assert(fix._0.got_lookup_offset >= 0 && fix._0.got_lookup_offset < import_count, "bad ordinal");
                (Bind = (addend = 0, ordinal = fix._0.got_lookup_offset.trunc()))
            }, {
                dest_segment := fix._0.segment.raw() + 1; // :MySegmentsStartAt1
                target := virtual_segment_offset[dest_segment] - zero_page_size + fix._0.offset;
                @assert_lt(target, 1.shift_left(36), "rebase > 36 bits");
                (Rebase = (high8 = 0, target = target))
            })
        );
        ptr_cast_unchecked(u8, i64, fix._1.patch_at)[] = encoded;
        csis.page_size = macos_page_size;
        csis.pointer_format = 6; // who knows man, i just work here. TODO
        
        csis.size = trunc(chained.len - start_of_csis);
        csis.max_valid_pointer = 0; // TODO: what does this mean?
        // TODO: handle multiple
        csis.page_count = 1;
        
        i := 0;
        each offset_to_csis { it |
            @debug_assert(u32.int_from_ptr(it) == u8.int_from_ptr(chained.maybe_uninit.ptr) + starts_offset + 4 + i * 4, "miscounted offset_to_csis");
            i += 1;
            if it[] == unprocessed_sentinal { 
                it[] = 0;  // zero means no fixups
            };
        };
        
        @debug_assert(offset_to_csis[0] == 0 && offset_to_csis[offset_to_csis.len - 1] == 0, "__PAGEZERO and __LINKEDIT shouldn't have fixups.");
        
        chained&.zero_pad_to_align(8);
        @assert_le(chained.len, CHAINED_SIZE_GUESS, "resized and now the header pointer is junk");
        chain_header[] = (
            imports_count = import_count.trunc(), 
            imports_format = 1, 
            symbols_format = 0, 
            version = 0, 
            starts_offset = starts_offset.trunc(), 
            imports_offset = imports_offset.trunc(), 
            symbols_offset = symbols_offset.trunc(),
        );
        chained_size := chained.len;
        /*
        //
        // now there's still more stuff that goes in __linkedit 
        //
        
        // for now we're only recording the symbols we're trying to dynamic import. 
        {
            start := commands.len;
            h := commands&.reserve_type(LoadCommandHeader);
            h.type = LoadCommand.LinkEditSymbolInfo.raw();
            command_count += 1;
            cmd := commands&.reserve_type(LinkEditSymbolInfo);
            cmd[] = LinkEditSymbolInfo.zeroed();
            cmd.undefined_symbol_index = 0;
            cmd.undefined_symbol_count = symbols.len.trunc();
            h.size = trunc(commands.len - start);
            
            // TODO: are you supposed to put those in (indirect_symbol_offset, indirect_symbol_count) too?
            
            start := commands.len;
            h := commands&.reserve_type(LoadCommandHeader);
            h.type = LoadCommand.LinkEditSymbolTable.raw();
            command_count += 1;
            cmd := commands&.reserve_type(LinkEditSymbolTable);
            cmd[] = LinkEditSymbolTable.zeroed();
            cmd.symbol_count = symbols.len.trunc();
            //add_data_file_offset&.push(cmd.strings_offset&);
            //add_data_file_offset&.push(cmd.symbols_offset&);
            // the data for those goes in __LINKEDIT
            // TODO: using file_offset way down here feels a bit fragile. 
            cmd.symbols_offset = trunc(file_offset + chained.len);
            size_of_symbols := symbols.len * size_of(SymbolEntry);
            cmd.strings_offset = cmd.symbols_offset + trunc(size_of_symbols);
            h.size = trunc(commands.len - start);
            
            symbols_bytes: []SymbolEntry = (ptr = ptr_cast_unchecked(u8, SymbolEntry, chained.maybe_uninit.ptr.offset(chained.len)), len = symbols.len);
            chained.len += size_of_symbols; @debug_assert(chained.len <= chained.maybe_uninit.len);
            strings_start := chained.len;
            symbols_bytes.set_zeroed();
            enumerate symbols { i, s |
                entry := symbols_bytes.index(i);
                entry.symbol_type = 1;
                entry.data_info = 256; // ordinal 1. we assume libc. TODO
                entry.name_offset = trunc(chained.len - strings_start);
                append_padded_cstr(chained&, s.name.str(), 1);
            };
            cmd.strings_size = trunc(chained.len - strings_start);
            
        };
        */
        
        @assert_le(chained.len, CHAINED_SIZE_GUESS, "resized and now the header pointer is junk"); 
        
        // this must include the part before symbol table or llvm-objcopy complains bout them overlapping
        start := commands.len;
        h := commands&.reserve_type(LoadCommandHeader);
        h.type = LoadCommand.ChainedFixups.raw();
        command_count += 1;
        cmd := commands&.reserve_type(LinkEditBlob);
        //add_data_file_offset&.push(cmd.offset&);
        // TODO: using file_offset way down here feels a bit fragile. 
        cmd[] = (offset = file_offset.trunc(), size = chained_size.trunc());  // :CodeIsFirst its fine to change this, you just have to do the math here. 
        h.size = trunc(commands.len - start);
        
        chunks&.push(chained.items()); // TODO: is it the rules that this be the last thing in the file? 
        
        // TODO: do i really need to have it load __LINKEDIT? its not used except by other commands that reference it. 
        // TODO: can i just reserve_type here or do they all have to be at the beginning?
        //       theres no reason it would matter by lief.parse doesn't like it: "Can't find the segment associated with the LC_DYLD_CHAINED_FIXUPS payload"
        cmd := link_edit_load_command;
        cmd[] = SegmentLoad.zeroed();
        cmd.name = str_to_16_byte_value("__LINKEDIT");
        cmd.address_size = chained.len.bitcast();
        cmd.size = chained.len.bitcast();
        cmd.max_prot = 1;
        cmd.init_prot = 1;
        cmd.file_offset = file_offset.bitcast();
        //add_data_file_offset&.push(ptr_cast_unchecked(u64, u32, cmd.file_offset&)); // :overflow
        cmd.address = virtual_offset.bitcast();
    };
    
    {  // LC_LOAD_DYLINKER
        start := commands.len;
        h := commands&.reserve_type(LoadCommandHeader);
        h.type = LoadCommand.LoadDynamicLinker.raw();
        command_count += 1;
        commands&.reserve_type(u32)[] = 12;
        append_padded_cstr(commands&, "/usr/lib/dyld", 8);
        h.size = trunc(commands.len - start);
    };
    {
        start := commands.len;
        h := commands&.reserve_type(LoadCommandHeader);
        h.type = LoadCommand.MainEntryPoint.raw();
        command_count += 1;
        cmd := commands&.reserve_type(MainEntryPoint);
        symbol := m.get_symbol_info(m.intern("main".sym().c_str()));
        assert(symbol.kind == .Local, "no main function?");
        // offset is from the start of interesting virtual memory? 
        cmd[] = (entry_offset = symbol.offset.bitcast(), stack_size = 0);  // :CodeIsFirst its fine to change this, you just have to do the math here. 
        h.size = trunc(commands.len - start);
        @debug_assert_ge(symbol.offset, COMMANDS_SIZE_GUESS + SIZE_OF_STUBS);
        
        // TODO: this can't be right now. but if i really have to make __TEXT start at file offset 0, you'll need this. 
        //add_data_file_offset&.push(ptr_cast_unchecked(u64, u32, cmd.entry_offset&)); // :overflow
    };
    // TODO: don't assume you want libc. but on macos you always do. 
    {  // LC_LOAD_DYLIB
        start := commands.len;
        h := commands&.reserve_type(LoadCommandHeader);
        h.type = LoadCommand.LinkLibrary.raw();
        command_count += 1;
        cmd := commands&.reserve_type(LinkLibrary);
        // TODO: where does one get these numbers? this is just what clang does. 
        cmd[] = (
            time_date_stamp = 2,
            current_version = 86467587,
            compatible_version = 65536,
        );
        append_padded_cstr(commands&, "/usr/lib/libSystem.B.dylib", 8);
        h.size = trunc(commands.len - start);
    };
    
    macho_header.commands_size = (commands.len - MachoHeader.size_of()).trunc();
    //zero_pad_to_align(commands&, 8);
    commands&.zero_pad_to_align(macos_page_size);
    // :cantreallocatebutgivegooderrormessage
    // now we want exact match because we put it on the front of the text section for some reason who knows idk man. 
    @assert_eq(commands.len, COMMANDS_SIZE_GUESS, "we guessed wrong so the array resized and all the pointers are junk");
    macho_header.commands_count = command_count.trunc();
    //for add_data_file_offset& { offset | 
    //    offset[] += commands.len.trunc();
    //};
    //chunks[0] = commands.items(); :commandsispartofcodenow
    
    chunks
}

fn compiler_address_to_segment_offset(m: *QbeModule, address: *u8) Ty(SegmentType, i64) = {
    low  := MAX_i64;
    high := 0;
    for_enum SegmentType { type | 
        seg := m.segments&[type]&;
        dist_from_start := ptr_diff(seg.mmapped.ptr, address);
        if dist_from_start >= 0 && dist_from_start < seg.mmapped.len {
            @assert(ptr_diff(seg.next, address) < 0, "address was inside segment %'s allocation but after next[]", type);
            return(type, dist_from_start);
        };
        // TODO: waste of code. they're always ordered. 
        high = high.max(u8.int_from_ptr(seg.mmapped.ptr) + seg.mmapped.len);
        low = low.min(u8.int_from_ptr(seg.mmapped.ptr));
    };
    @panic("% was not found in module.segments (low = %, high = %)", u8.int_from_ptr(address), low, high)
}

// TODO: collect_aot_fixups compiles if you typo to *Symbol, :FUCKED
FixP :: Ty(*SymbolInfo, *Fixup);
fn collect_aot_fixups(m: *QbeModule) Ty([]FixP, []*SymbolInfo) = {
    // :SLOW keep a list because most will probably be local with no relocations. 
    fixups := list(FixP, temp());
    symbols := list(*SymbolInfo, temp());
    
    symbol_count := 0;
    for_symbols m { s | 
        first := true;
        each s.fixups& { f | 
            if f.type&.is(.DataAbsolute) {
                fixups&.push(@as(FixP) (s, f));
                if first {
                    first = false;
                    symbols&.push(s);
                }
            };
        };
    };
    
    (fixups.items(), symbols.items())
}

fn live_segment_part(m: *QbeModule, s: SegmentType) []u8 = {
    s := m.segments&[s]&;
    s.mmapped.slice(0, ptr_diff(s.mmapped.ptr, s.next))
}

fn append_padded_cstr(bytes: *List(u8), s: Str, align: i64) i64 = {
    start := bytes.len;
    bytes.push_all(s);
    bytes.push(0);
    bytes.zero_pad_to_align(align);
    bytes.len - start
}

// TODO: do we want to put these helpers in a different file so other people can use them less painfully? 

fn reserve_type(bytes: *List(u8), $T: Type) *T #generic = {
    bytes.reserve(T.size_of());
    ptr := bytes.maybe_uninit.ptr.offset(bytes.len);
    @debug_assert(u8.int_from_ptr(ptr).mod(T.align_of()) == 0, "unaligned reserve");
    ptr := ptr_cast_unchecked(u8, T, ptr);
    bytes.len += T.size_of();
    ptr
}

fn zero_pad_to_align(bytes: *List(u8), align: i64) void = {
    ptr := bytes.maybe_uninit.ptr.offset(bytes.len);
    extra := u8.int_from_ptr(ptr).mod(align);
    if extra != 0 {
        extra := align - extra;
        bytes.reserve(extra);
        range(0, extra) { _ |
            bytes.push(0);
        };
    };
    @debug_assert_eq(bytes.len.mod(align), 0, "alignment confusion. allocation aligned differently from our length.");
}

fn str_to_16_byte_value(s: Str) u128 = {
    assert(s.len.le(16), "A segment name cannot be larger than 16 text characters in bytes");
    low: u64 = 0;
    high: u64 = 0;
    enumerate s { i, c |
        c: u64 = c[].zext();
        if i < 8 {
            low = low.bit_or(c.shift_left(i * 8));
        } else {
            high = high.bit_or(c.shift_left((i - 8) * 8));
        };
    };
    (low = low, high = high)
}
