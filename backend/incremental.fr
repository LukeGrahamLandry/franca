/// This defines the .frc file format used by the franca compiler. 
/// See @/docs/caching.md

MAGIC :: 0x0002_41434E415246;  // FRANCA__
Header :: @struct {
    meta: Meta #use;
    dep: Storage(Dep);
    sym: Storage(Sym);
    blk: Storage(Blk);
    ins: Storage(Qbe.Ins);
    con: Storage(Qbe.Con);
    mem: Storage(Qbe.Addr);
    rel: Storage(Dat2.Reloc);
    str: Storage(u8);
    lib: Storage(Lib);
};

Meta :: @struct {
    magic_v: u64 = MAGIC;
    filelen: u32 = 0;  // patched by to_bytes()
    arch_os: u32;
    // Qbe.no_symbol if this file cannot be executed
    entry_sym: u32;
    entry_dep: u32;
};

// Hashes of all the input files that contributed to this module. 
Dep :: @struct {
    filename: Ref(u8);
    file_len: u32;
    hashcode: Sha256.Digest;
};

Sym :: @struct {
    segment: Seg; 
    align_log2: u8;
    name: Ref(u8);  // TODO: having names is kinda dumb
    // TODO: this should parse when inlined but then need to :UpdateBoot :Compiler
    P :: @union(fnc: Fnc, dat: Dat, imp: Imp);  
    payload: P #use;  // active variant depends on segment
};

Seg :: @enum(u8) (
    Invalid,  // used while writing when the symbol has been referenced but not declared yet
    Code,  // payload: Fnc;
    ConstantData, MutableData, ZeroInitData,  // payload: Dat;
    Import,  // payload: Imp;
    MachineCode,  // payload: Dat; but goes in Segment.Code
);

// Currently i only save right before emitting machine code, 
// so no need for phi/typ/switch. Those can be added later when i want to do 
// inlining across modules or saving right after "parse". 
Fnc :: @struct {
    reg: u64;
    // When the instructions have Blk/Con indices, they're relative to these arrays, 
    // so they don't need to be remapped when saving. 
    blk: Ref(Blk);
    con: Ref(Qbe.Con);
    mem: Ref(Qbe.Addr);
    slot: u32;
    flags: u32;
};

Flags :: @bit_fields(
    leaf   := 1,
    vararg := 1,
    salign := 4,
    dynalloc := 1,
    _ := 25,
);

Blk :: @struct {
    ins: Ref(Qbe.Ins);
    s1: u32;
    s2: u32;
    jmp: Qbe.BlkJmp;
};

Dat :: @struct {
    bytes: Ref(u8);  // off=Qbe.no_symbol when it's all zeroes
    rel: Ref(Dat2.Reloc);
};

Imp :: @struct {
    lib: Ref(Lib);
};

Lib :: @struct {
    name: Ref(u8);
};

Storage :: fn($T: Type) Type = {
    // SAFETY: the serialized data is immediately after the header in memory
    // check() ensures that storage.count is within filelen. 
    fn get(self: *Header, i: Ref(T)) []T = {
        f :: find_storage_field(T);
        storage := Header.get_field_ptr(self, f);
        first := T.ptr_from_raw(Header.raw_from_ptr(self).offset(storage.off.zext()));
        @debug_assert_le(i.off + i.count, storage.count, "%", ::f[].name.str());
        (ptr = first.offset(i.off.zext()), len = i.count.zext())
    }
    
    fn get(self: *Header, i: u32) *T = {
        i: Ref(T) = (off = i, count = 1);
        self.get(i).index(0)
    }

    @struct(
        off: u32 /* bytes from start of header to first element */, 
        count: u32, 
        StorageElement :: T,
    )
};

Ref :: fn($T: Type) Type = {
    Self :: @struct(off: u32, count: u32, RefElement :: T);
    
    Self
};

fn check(data: []u8) *Header = {
    @assert_ge(data.len, size_of(Header));
    self := ptr_cast_unchecked(u8, Header, data.ptr);
    @assert_eq(self.magic_v, MAGIC);
    @assert_le(self.filelen.zext(), data.len);
    
    for storage_fields { off, size |
        S :: @struct(off: u32, count: u32);
        storage := S.ptr_from_raw(Header.raw_from_ptr(self).offset(off.zext()));
        @assert_le(storage.off, self.filelen);
        @assert_le(storage.off + storage.count * size, self.filelen);
    };
    self
}

storage_fields :: {
    out := Ty(u32, u32).list(ast_alloc());
    for Header.get_fields() { f |
        if get_constant(Type, Type.scope_of(f.ty), @symbol StorageElement) { T |
            push(out&, (f.byte_offset.trunc(), T.size_of().trunc()));
        }
    };
    out.items()
};

// TODO: bucketarray. comptime generate this from the Header. 
Writer :: @struct {
    dep: List(Dep);
    sym: List(Sym);
    blk: List(Blk);
    ins: List(Qbe.Ins);
    con: List(Qbe.Con);
    mem: List(Qbe.Addr);
    rel: List(Dat2.Reloc);
    str: List(u8);
    lib: List(Lib);
    symbols: HashMap(u32, i64);
};

fn init(a: Alloc) Writer = (
    symbols = init(a),
    // TODO: generate this
    dep = list(a),
    sym = list(a),
    blk = list(a),
    ins = list(a),
    con = list(a),
    mem = list(a),
    rel = list(a),
    str = list(a),
    lib = list(a),
);

fn push(self: *Writer, it: []u8) Ref(u8) = {
    r: Ref(u8) = (off = self.str.len.trunc(), count = it.len.trunc());
    self.str&.push_all(it);
    r
}

fn map_sym(self: *Writer, m: *QbeModule, id: u32) i64 = {
    self.symbols&.get(id) || {
        i := self.sym.len;
        self.sym&.push(zeroed Sym);
        self.sym[i].name = self.push(m.str(id));
        self.symbols&.insert(id, i);
        i
    }
}

fn push(self: *Writer, f: *Qbe.Fn) void = {
    id := self.map_sym(f.globals, f.lnk.id);
    
    self.sym[id].segment = .Code;
    
    // unfortunatly this includes constants that are no longer used. 
    // so a function will all uses inlined will still have an Invalid Sym because of this map_sym
    self.sym[id].fnc.con = (off = self.con.len.trunc(), count = trunc(f.ncon.zext() - fixed_const_count));
    each f.con.slice(fixed_const_count, f.ncon.zext()) { c |
        self.con&.push(
            sym = @if(c.sym == Qbe.no_symbol, Qbe.no_symbol, trunc self.map_sym(f.globals, c.sym)), 
            bits = c.bits,
        );
    };
    
    self.sym[id].fnc.blk = (off = self.blk.len.trunc(), count = f.nblk.bitcast());
    {
        i: i32 = 0;
        for_blocks f { b |
            b.id = i;
            i += 1;
        };
    };
    for_blocks f { b |
        self.blk&.push(
            ins = (off = self.ins.len.trunc(), count = b.nins),
            s1 = @if(b.s1.is_null(), Qbe.no_symbol, bitcast b.s1.id),
            s2 = @if(b.s2.is_null(), Qbe.no_symbol, bitcast b.s2.id),
            jmp = b.jmp,
        );
        self.ins&.push_all(b.ins.slice(0, zext b.nins));
    };
    
    self.sym[id].fnc.mem = (off = self.mem.len.trunc(), count = f.nmem.bitcast());
    self.mem&.push_all(f.mem.slice(0, zext f.nmem));
    
    self.sym[id].fnc.reg = f.reg;
    self.sym[id].fnc.slot = f.slot.bitcast();
    
    flags: Flags = construct(
        leaf = int(f.leaf),
        vararg = int(f.vararg),
        salign = f.salign.intcast(),
        dynalloc = int(f.dynalloc),
        _ = 0,
    );
    self.sym[id].fnc.flags = flags.repr;
}

fn push(self: *Writer, m: *QbeModule, d: *Dat2) void = {
    id := self.map_sym(m, d.id);
    
    self.sym[id].segment = @as(Seg) @as(u8) trunc((@as(i64) d.seg) + 1);
    @match(d.template) {
        fn Bytes(it) => {
            self.sym[id].dat.bytes = self.push(it);
        };
        fn Zeroes(it) => {
            self.sym[id].dat.bytes.count = it.trunc();
            self.sym[id].dat.bytes.off = Qbe.no_symbol;
        }
    };

    self.sym[id].dat.rel = (off = self.rel.len.trunc(), count = d.relocations.len.trunc());
    each d.relocations { it |
        self.rel&.push(
            off = it.off,
            id = self.map_sym(m, it.id).trunc(),
            addend = it.addend,
        );
    };
    
    self.sym[id].align_log2 = d.align.trailing_zeros().trunc();
}

fn push_asm(self: *Writer, m: *QbeModule, code: []u8, id: u32) void = {
    id := self.map_sym(m, id);
    self.sym[id].segment = .MachineCode;
    self.sym[id].dat.bytes = (off = self.str.len.trunc(), count = code.len.trunc());
    self.str&.push_all(code);
}

// TODO: this shouldn't suck this bad
find_storage_field :: fn(T: Type) *Field = {
    each Header.get_fields() { f | 
        ::AutoEq(?Type);
        ::RefEq(?Type);
        if get_type_info_ref(f.ty).is(.Struct) {
            c := get_constant(Type, Type.scope_of(f.ty), @symbol StorageElement);
            if c == (Some = T) {
                return(f);
            }
        }
    };
    unreachable()
};

fn to_bytes(self: *Writer, meta: Meta) [][]u8 = {
    bytes := list([]u8, temp());
    
    n := size_of(Header);
    header := temp().box(Header);
    ::[]Header;
    bytes&.push(header.slice(1).interpret_as_bytes());
    header.meta = meta;
    
    X :: fn(storage, data) => {
        b := data.items().interpret_as_bytes();
        bytes&.push(b);
        storage[] = (off = n.trunc(), count = data.len.trunc());
        n += b.len;
    };
    
    // TODO: generate this
    X(header.dep&, self.dep&);
    X(header.sym&, self.sym&);
    X(header.blk&, self.blk&);
    X(header.ins&, self.ins&);
    X(header.con&, self.con&);
    X(header.mem&, self.mem&);
    X(header.rel&, self.rel&);
    X(header.str&, self.str&);
    X(header.lib&, self.lib&);
    header.filelen = n.trunc();
    
    // Maybe limitting to 4GB is too small and I should make all the offsets be u64 instead. 
    // Could probably produce a reasonable program that hit that by embedding a lot of data 
    // (like 3d meshes maybe) but I already can't do arbitrary sizes because I don't resize 
    // segments and the constants in ../lib.fr are already kinda low.  -- May 26, 2025
    @assert_lt(n, 0xFFFFFFFF, "overflow");
    
    bytes.items()
}

fn finish_imports(writer: *Writer, m: *QbeModule) void = {
    writer := m.save.unwrap();
        
    // :SLOW
    _, symbols := collect_aot_fixups(m);
    for symbols { s |
        if s.kind != .Local {
            if s.library == 0 {
                ::?u32;
                s.library = m.find_library("libc") || {
                    @panic("import % from unknown library", s.name)
                };
            };
            
            id := writer.map_sym(m, m.intern(s.name));
            writer.sym[id].segment = .Import;
            writer.sym[id].imp.lib.off = s.library - 1;
        };
    };
}

finish_module :: fn(m: *QbeModule) [][]u8 = {
    writer := m.save.unwrap();
    finish_imports(writer, m);
    meta: Incremental.Meta = (
        arch_os = Incremental'pack_target(m.goal.arch, m.goal.os),
        entry_sym = writer.map_sym(m, m.intern("main")).trunc(), // :HardcodeMain
        // TODO: would be nice if you could set this without needing to paste this function
        entry_dep = Qbe.no_symbol,
    );
    writer.to_bytes(meta)
};

// note: this doesn't call default_init
fn load(header: *Header, f: *Qbe.Fn, it: Ref(Sym), syms: []u32) void = {
    m := f.globals;
    sym := header.get(it).index(0);
    f.lnk.id = syms[it.off.zext()];
    fnc := sym.fnc&;
    
    f.con = new(fnc.con.count.zext() + fixed_const_count);
    f.ncon = 0;
    push_fixed_consts(f);
    f.ncon = fixed_const_count.trunc() + fnc.con.count.bitcast();
    enumerate header.get(fnc.con) { i, src |
        dest := f.con[i + fixed_const_count]&;
        dest[] = src[];
        if src.sym != Qbe.no_symbol {
            dest.sym = syms[src.sym.zext()];
        }
    };
    
    blks := temp().alloc_zeroed(Qbe.Blk, fnc.blk.count.zext());
    enumerate header.get(fnc.blk) { i, b |
        blks[i].id = i.trunc();
        blks[i].nins = b.ins.count;
        // TODO: it's sad that this can't just use the slice because of QList
        blks[i].ins = new_copy(header.get(b.ins));
        blks[i].jmp = b.jmp;
        if b.s1 != Qbe.no_symbol {
            blks[i].s1 = blks.index(b.s1.zext());
        }
        if b.s2 != Qbe.no_symbol {
            blks[i].s2 = blks.index(b.s2.zext());
        }
        if i != blks.len - 1 {
            blks[i].link = blks.index(i + 1);
        }
    };
    f.start = blks.index(0);
    f.nblk = fnc.blk.count.bitcast();
    
    // TODO: these are pretty chunky. it would be nice to deduplicate them. 
    //       need to be careful, there might be something in amd64/emit.fr that assumes they don't alias?
    f.nmem = fnc.mem.count.bitcast();
    f.mem = new_copy(header.get(fnc.mem));
    
    f.reg = fnc.reg;
    f.slot = fnc.slot.bitcast();
    flags: Flags = (repr = fnc.flags);
    f.leaf = flags.get(.leaf) != 0 ;
    f.vararg = flags.get(.vararg) != 0;
    f.salign = flags.get(.salign).intcast();
    f.dynalloc = flags.get(.dynalloc) != 0;
}

fn load(header: *Header, m: *QbeModule, i: Ref(Sym), syms: []u32) Dat2 = {
    it := header.get(i).index(0);
    relocs := temp().alloc(Dat2.Reloc, it.dat.rel.count.zext());
    relocs.copy_from(header.get(it.dat.rel));
    each relocs { it |
        if it.id != Qbe.no_symbol {
            it.id = syms[it.id.zext()];
        }
    };
    
    (
        template = @if(it.dat.bytes.off == Qbe.no_symbol, 
            (Zeroes = it.dat.bytes.count.zext()),
            (Bytes = header.get(it.dat.bytes)),
        ),
        relocations = relocs,
        align = 1.shift_left(@as(i64) it.align_log2.zext()),
        seg = @as(SegmentType) @as(i64) zext(@as(u8) it.segment) - 1,
        id = syms[i.off.zext()],
        export = false, // TODO
    )
}

pack_current_target :: fn() u32 = {
    arch, os := (query_current_arch(), query_current_os());
    pack_target(arch, os)
};

pack_target :: fn(arch: Arch, os: Os) u32 = 
    bit_or(@as(i64) os, shift_left(@as(i64) arch, 8)).trunc();

fn preintern_syms(header: *Header, m: *QbeModule) []u32 = {
    count: i64 = header.sym.count.zext();
    syms := m.forever&.borrow().alloc(u32, count);
    range(0, count) { i |
        it: *Sym = header.get(i.trunc());
        syms[i] = m.intern(header.get(it.name));
    };
    syms
}

fn compile_all_symbols(header: *Header, m: *QbeModule) void = {
    // TODO: maybe entry_sym should be export=true
    f := @uninitialized Qbe.Fn;
    default_init(f&, m);
    
    syms := preintern_syms(header, m);
    
    range(0, syms.len) { i |
        it: *Sym = header.get(i.trunc());
        
        mark := mark_temporary_storage();
        ::enum(@type it.segment);
        @match(it.segment) {
            fn Code() => {
                i: Ref(Incremental.Sym) = (off = i.trunc(), count = 1);
                load(header, f&, i, syms);
                zone := @if(ENABLE_ENABLE_TRACY, zone_begin(.Backend), ());
                emit_fn(f&);
                @if(ENABLE_ENABLE_TRACY) zone_end(zone);
            }
            fn MachineCode() => {
                m.add_code_bytes(syms[i], header.get(it.dat.bytes));
            }
            fn Import() => {
                lib := header.get(it.imp.lib);
                lib := header.get(lib[0].name);
                m.set_library(syms[i], lib);
            }
            fn Invalid() => ();
            @default => {
                i: Ref(Incremental.Sym) = (off = i.trunc(), count = 1);
                dat := load(header, m, i, syms);
                m.emit_data(dat);
            };
        };
        reset_temporary_storage(mark);
    };
    
    // TODO: it would kinda feel better to keep track of the imports
    //       instead of making the caller loop over all the symbols again 
    //       (probably by calling fill_from_libc), but that gets messed up by m.symbol_memmove, 
    //       which i guess doesn't get set_library called on it (should be fixed anyway). 
    //       + need to do a more complicated thing to allow non-libc libraries anyway. 
}

ENABLE_ENABLE_TRACY :: get_environment_variable("FRANCA_TRACY").is_some();
Sha256 :: import("@/backend/macho/sha256.fr");
