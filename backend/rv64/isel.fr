// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>

rv64_isel :: fn(f: *Qbe.Fn) void = 
    native_isel(f, fixarg, seljmp, sel_inst);

sel_inst :: fn(i: **Qbe.Ins, b: *Qbe.Blk, f: *Qbe.Fn) void = {
    if i[].op() == .cas1 {
        // :paste from arm/isel
        cas0, cas1 := find_cas(i[], b);
        cas1 := f.emit(cas1);
        k := cas1.cls();
        fixarg(cas0.arg&.index(0), .Kl, cas0, f);
        fixargs(k, cas1, f);
        cas1.arg&[0] = f.new_mem(cas1.arg&[0], cas1.arg&[1], 0, 0);
        cas1.arg&[1] = cas0.arg&[0];
        cas0.set_nop();
    } else {
        sel(i[], f);
    }
}

fixarg :: fn(r: *Qbe.Ref, k: Qbe.Cls, i: *Qbe.Ins, f: *Qbe.Fn) void = {
    r0, r1 := (r[], r[]);
    o := @if(!i.is_null(), i.op(), .copy);  // i=null means it's a phi which will be converted to copy in rega 
    @match(rtype(r0)) {
    fn RCon() => {
        break :: local_return;
        c := f.get_constant(r0);
        if c.type() == .CAddr && memarg(r, o, i) {
            if o == .call { // TODO: local call can access symbol directly: || !f.could_be_import(c) {
                break();
            }
        };
        if c.type() == .CBits && o == .copy && !is_float(k) {
            break();
        }
        // the I immediates are 12 bits, sign extended
        if !is_float(k)
        && c.type() == .CBits && immarg(r, o, i)
        && -2048 <= c.bits() && c.bits() < 2048 {
            break();
        }
        r1 = f.newtmp("isel", k);
        if is_float(k) {
            // TODO: see arm64/isel comment about this
            r_int := f.newtmp("isel", .Kl);
            f.emit(.cast, k, r1, r_int, QbeNull);
            f.emit(.copy, .Kl, r_int, r0, QbeNull);
        } else {
            f.emit(.copy, k, r1, r0, Qbe.Null);
        }
    }
    fn RTmp() => {
        break :: local_return;
        if isreg(r0) {
            break();
        };
        s := f.get_temporary(r0)[].slot;
        if (s != -1) {
            /* aggregate passed by value on
             * stack, or fast local address,
             * replace with slot if we can */
            if memarg(r, o, i) {
                // TODO: why? emit has to do it as multiple instructions anyway. 
                //       replace this with generally using the small immediates of ldr/str like arm isel does. 
                //       ie. check range here. oh the problem might be that you have to address past the spill slots 
                //       because locals are are the other end of the stack frame from fp. so you need range check in emit anyway. 
                r1 = SLOT(s);
                break();
            }
            r1 = f.newtmp("isel", k);  // :IselRSlotGetsNewTmp
            f.emit(.addr, k, r1, SLOT(s), Qbe.Null);
            break();
        }
        t := f.get_temporary(r0);
        if k == .Kw && t.cls == .Kl {
            /* TODO: this sign extension isn't needed
             * for 32-bit arithmetic instructions */
            r1 = f.newtmp("isel", k);
            f.emit(.extsw, .Kl, r1, r0, Qbe.Null);
        } else {
            // TODO: this isn't always true. like =l extub Kw -> =l and Kw, 255
            // @debug_assert_eq(k, t.cls, "wrong cls in $%: %(%)", f.name(), i.op(), r);
        }
    }
    @default => ();
    };
    r[] = r1;
}

negate :: fn(pr: *Qbe.Ref, f: *Qbe.Fn) void = {
    r := f.newtmp("isel", .Kw);
    f.emit(.xor, .Kw, pr[], r, f.getcon(1));
    pr[] = r;
}

selcmp :: fn(i: Qbe.Ins, k: Qbe.Cls, op: Qbe.Cmp, f: *Qbe.Fn) void = {
    @match(op) {
        fn Cieq() => return cmp_int_zero(i, k, true, f);
        fn Cine() => return cmp_int_zero(i, k, false, f);
        fn Cfuo() => return cmp_float_order(i, k, true, f);
        fn Cfo()  => return cmp_float_order(i, k, false, f);
        // for floats, only (eq, lt, le) are real
        fn Cfne() => i&.set_op(@if(is_wide(k), .ceqd, .ceqs));
        fn Cfgt() => i&.set_op(@if(is_wide(k), .cltd, .clts));
        fn Cfge() => i&.set_op(@if(is_wide(k), .cled, .cles));
        @default => ();
    };

    sign := @is(op, .Cisge, .Cisgt, .Cisle, .Cislt);
    swap := @is(op, .Cisgt, .Cisle, .Ciugt, .Ciule, .Cfgt, .Cfge);
    neg  := @is(op, .Cisge, .Cisle, .Ciuge, .Ciule, .Cfne);
    
    if op.raw() < Qbe.CmpICount {
        i&.set_op(@if(sign, .csltl, .cultl));
    }
    if swap {
        r := i.arg&[0];
        i.arg&[0] = i.arg&[1];
        i.arg&[1] = r;
    }
    if neg {
        negate(i.to&, f);
    }
    icmp := f.emit(i);
    fixargs(k, icmp, f)
}

// (a=a) = false iff a is NaN
cmp_float_order :: fn(i: Qbe.Ins, k: Qbe.Cls, uo: bool, f: *Qbe.Fn) void = {
    if uo {
        negate(i.to&, f);
    }
    r0 := f.newtmp("isel", i&.cls());
    r1 := f.newtmp("isel", i&.cls());
    f.emit(.and, i&.cls(), i.to, r0, r1);
    o: Qbe.O = @if(is_wide(k), .ceqd, .ceqs);
    icmp := f.emit(o, i&.cls(), r0, i.arg&[0], i.arg&[0]);
    fixargs(k, icmp, f);
    icmp := f.emit(o, i&.cls(), r1, i.arg&[1], i.arg&[1]);
    fixargs(k, icmp, f);
}

// (a xor b) = 0 iff a=b
cmp_int_zero :: fn(i: Qbe.Ins, k: Qbe.Cls, equals: bool, f: *Qbe.Fn) void = {
    r := f.newtmp("isel", k);
    // SNEZ/SEQZ are pseudoinstructions. 
    if equals {  // (a == 0) = (a < 1)
        f.emit(.cultl, i&.cls(), i.to, r, f.getcon(1));
    } else {     // (a != 0) = (0 < a)
        f.emit(.cultl, i&.cls(), i.to, Qbe.Null, r);
    };
    icmp := f.emit(.xor, k, r, i.arg&[0], i.arg&[1]);
    fixargs(k, icmp, f);
}

fixargs :: fn(k: Qbe.Cls, icmp: *Qbe.Ins, f: *Qbe.Fn) void = {
    fixarg(icmp.arg&[0]&, k, icmp, f);
    fixarg(icmp.arg&[1]&, k, icmp, f);
}

sel :: fn(i: *Qbe.Ins, f: *Qbe.Fn) void = {
    // TODO: try_kill_inst
    k := i.cls();
    @match(i.op()) {
        fn dbgloc() => {
            f.emit(i);
            return();
        }
        fn nop() => return();
        // (it's tempting to just leave it as sel1+sel0 but then it gets messed up if fixarg or rega puts something else between them). 
        // TODO: if one of the inputs is ConZero this generates dumb code
        fn sel1() => {
            isel0 := i.offset(-1);
            @debug_assert_eq(isel0.op(), .sel0);
            cond := isel0.arg&[0];
            isel0.set_nop();
    
            // (r = c?a:b;) -> (t0 = c?a:0; t1 = !c?b:0; t = t0|t1;)
            t0, t1 := (f.newtmp("isel", k), f.newtmp("isel", k));
            f.emit(.or, k, i.to, t0, t1);
            i1 := f.emit(.seline, k, t0, i.arg&[1], cond);  // czero.nez
            fixarg(i1.arg&[0]&, k, i1, f);
            i0 := f.emit(.selieq, k, t1, i.arg&[0], cond);  // czero.eqz
            fixarg(i0.arg&[0]&, k, i0, f);
            
            // cond is the same in both
            fixarg(i0.arg&[1]&, .Kw, i0, f);
            i1.arg&[1] = i0.arg&[1];
            chuse(i0.arg&[1], 1, f);
            
            return();
        };
        fn extub() => {
            i.set_op(.and);
            i.arg&[1] = f.getcon(255);
        };
        fn neg() => if k.is_int() {
            i[] = make_ins(.sub, k, i.to, Qbe.Null, i.arg&[0]);
        };
        fn byteswap() => if k == .Kw {
            // rev8 is always on the whole register
            r := f.newtmp("isel", .Kl);
            f.emit(.sar, .Kl, i.to, r, f.getcon(32));
            i0 := f.emit(.byteswap, .Kl, r, i.arg&[0], Qbe.Null);
            fixarg(i0.arg&[0]&, .Kw, i0, f);
            return();
        }
        fn sub() => if k.is_int() {
            if f.get_int(i.arg&[1]) { imm |
                // might fit in the immediate and save an instruction
                i.set_op(.add);
                i.arg&[1] = f.getcon(-imm);
            };
        }
        @default => ();
    };
    
    if is_alloc(i.op()) {
        i0 := f.globals.curi.offset(-1);  // :LookAtLastInst
        salloc(i.to, i.arg&[0], f);
        fixarg(i0.arg&[0]&, .Kl, i0, f);
        return();
    }
    
    ck, cc := (Qbe.Cls.Kw, @as(i32) -1);
    if (iscmp(i.op(), ck&, cc&)) {
        selcmp(i[], ck, @as(Qbe.Cmp) cc, f);
        return();
    }
    
    i0 := f.emit(i);
    fixarg(i0.arg&[0]&, argcls(i, 0), i0, f);
    fixarg(i0.arg&[1]&, argcls(i, 1), i0, f);
}

seljmp :: fn(b: *Qbe.Blk, f: *Qbe.Fn) void = {
    /* TODO: replace cmp+jnz with beq/bne/blt[u]/bge[u] */
    if b.jmp.type == .jnz {
        fixarg(b.jmp.arg&, .Kw, Qbe.Ins.ptr_from_int(0), f);
    }
}

memarg :: fn(r: *Qbe.Ref, op: Qbe.O, i: *Qbe.Ins) bool = {
    @if(is_load(op) || op == .call) return(r.identical(i.arg&[0]&));
    @if(is_store(op)) return(r.identical(i.arg&[1]&));
    // cas also references memory but it doesn't get an immediate.
    false
}

immarg :: fn(r: *Qbe.Ref, o: Qbe.O, i: *Qbe.Ins) bool = {
    OpTab'get(o, .rv_imm) && r.identical(i.arg&[1]&)
}


#use("@/backend/lib.fr");
#use("@/backend/abi.fr");
