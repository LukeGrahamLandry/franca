fill_target_rv64 :: fn(t: *Qbe.Target) void = {
    ::enum(RvReg);
    t.gpr0 = RvReg.T0.raw().zext();
    t.ngpr = zext(RvReg.RA.raw() - RvReg.T0.raw() + 1 -1/*T6*/);
    t.fpr0 = RvReg.FT0.raw().zext();
    t.nfpr = zext(RvReg.FS11.raw() - RvReg.FT0.raw() + 1 -1/*FT11*/);
    // ._XXN: one int and one float are reserved for emit()
    RGLOB :: @const_slice(RvReg.FP, .SP, .GP, .TP, .RA, ._T6, ._FT11);
    t.rglob = @run RGLOB.interpret_as_bytes().bytes_to_bit_mask();
    t.caller_saved = @run Abi'rv64_rsave.interpret_as_bytes().bytes_to_bit_mask();
    t.nrsave = (
        zext(RvReg.A7.raw() - RvReg.T0.raw() + 1 -1/*T6*/),
        zext(RvReg.FA7.raw() - RvReg.FT0.raw() + 1 -1/*FT11*/),
    );    

    t.retregs = Abi.rv64_retregs;
    t.argregs = Abi.rv64_argregs;
    t.memargs = fn(o: Qbe.O) i32 = 0;    
    t.abi1 = Abi.rv64_abi;    
    
    t.isel = Isel.rv64_isel;
    
    t.emit_fn = Emit.rv64_emitfn;  // todo: compiler faults if `rv64_emitfn` is an undefined variable
    
    @run @assert_le(RvReg.enum_count(), Qbe.Tmp0);
    @run @assert_eq(size_of(RvReg), size_of(u8));
    
    Abi  :: import("@/backend/rv64/abi.fr");
    Isel :: import("@/backend/rv64/isel.fr");
    Emit :: import("@/backend/rv64/emit.fr");
};

RvReg :: @enum(u8) (
    Rxxx,
    /* caller-save */
    T0, T1, T2, T3, T4, T5, _T6,
    A0, A1, A2, A3, A4, A5, A6, A7,

    /* callee-save */
    S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11,

    /* globally live */
    FP, SP, GP, TP, RA,

    /* FP caller-save */
    FT0, FT1, FT2, FT3, FT4, FT5, FT6, FT7, FT8, FT9, FT10, _FT11,
    FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7,

    /* FP callee-save */
    FS0, FS1, FS2, FS3, FS4, FS5, FS6, FS7, FS8, FS9, FS10, FS11,
);


fn TMP(r: RvReg) Qbe.Ref = TMP(@as(i64) r.raw().zext());

#use("@/backend/lib.fr");
