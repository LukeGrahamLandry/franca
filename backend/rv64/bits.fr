
R :: @bit_fields(funct7 := 8, rs2 := 4, rs1 := 5, funct3 := 3, rd := 5, opcode := 7);  // SB splits imm between funct7 and rd
I :: @bit_fields(imm := 12,             rs1 := 5, funct3 := 3, rd := 5, opcode := 7);
U :: @bit_fields(imm := 20,                                    rd := 5, opcode := 7);  // J

Opcode :: @enum(
    lui   = 0b0110111, // load upper immidiate
    auipc = 0b0010111, // add upper immidiate to pc; same as arm's adrp
    // "and link" means write next pc to a register, so dest=zero register for just normal jump
    jal   = 0b1101111, // jump and link
    jalr  = 0b1100111, // jump to register and link
    // they don't have a flags register. compare 2 registers and jump based on the result is one instruction. 
    bcmp  = 0b1100011, // branch if cmp
);

Bcmp :: @enum(i64) (
    beq  = 0b000,
    bne  = 0b001,
    blt  = 0b100,
    bge  = 0b101,
    bltu = 0b110,
    bgeu = 0b111,
);

ecall  :: 0b000000000000_0000000000000_1110011;
ebreak :: 0b000000000001_0000000000000_1110011;

fn jalr(target: RvReg, off: u32, link: RvReg) u32 = {
    todo()
}

// when jal has 20 bit offset; the bits are not in order :(
// distance multiplied by 2 bytes
// x1 normal link register

// (ordered by encoding, named by usage in calling convention)
RvReg :: @enum(u8) (
    // integers
    Zero, 
    RA, SP, GP,  TP, T0, T1, T2, FP, S1,
    A0, A1, A2,  A3, A4, A5, A6, A7, 
    S2, S3, S4,  S5, S6, S7, S8, S9, S10, S11,
    T3, T4, T5, _T6,
    
    // floats
    FT0, FT1, FT2, FT3, FT4, FT5, FT6, FT7,
    FS0, FS1,
    FA0, FA1, FA2, FA3, FA4, FA5, FA6, FA7,
    FS2, FS3, FS4, FS5, FS6, FS7, FS8, FS9, FS10, FS11,
    FT8, FT9, FT10, _FT11,
);
