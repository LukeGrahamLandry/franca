Elf :: import("@/backend/elf/bits.fr");

// results are in temp()
fn output_elf(m: *QbeModule) [][]u8 = {
    debug_log_byte_size(m);
    patch_pending_symbols(m);
    
    MYSTERY_SPICE :: 0x10000;
    
    code := m.segments&[.Code]&;
    code_size := code.len() - COMMANDS_SIZE_GUESS - SIZE_OF_STUBS;
    for_enum SegmentType { s | 
        m.align_to(s, 4096);
    };
    m.fixups_locked = true; // we're going to stomp the data section with relocation info so you can run it jitted anymore after this. 
    chunks := list([]u8, 10, temp());
    commands: List(u8) = (maybe_uninit = (ptr = m.segment_address(.Code, 0), len = COMMANDS_SIZE_GUESS), len = 0, gpa = page_allocator);
    
    e_header := commands&.reserve_type(Elf.Header);
    e_header[] = (
        type = @match(m.goal.type) {
            fn Exe() => .Executable;
            fn Relocatable() => .Relocatable;
            fn Dynamic() => .Dynamic;
            @default => unreachable();
        },
        machine = @if(m.goal.arch == .aarch64, .arm64, .amd64),
        entry = main_entry_point_vaddr(m) + MYSTERY_SPICE,
        program_header_off = size_of(Elf.Header),
        section_header_off = 0, 
        flags = 0, // todo
        ehsize = 0, //64, // TODO?
        program_header_num = 0, // patched
        section_header_num = 0,
        section_header_names_index = 0, 
    );
    
    start_program_headers := commands.len;
    
    program_header :: fn() => {
        h := commands&.reserve_type(Elf.ProgramHeader);
        e_header.program_header_num += 1;
        h
    };
    
    p_header := program_header();
    
    
    dynamic_header: ?Ty(*Elf.ProgramHeader, *Elf.ProgramHeader, *Elf.ProgramHeader) = .None;
    
    virtual_offset := MYSTERY_SPICE; 
    file_offset    := 0;
    make_segment :: fn(seg: SegmentType, prot: u32) => {
        segment := m.segments&[seg]&;
        chunks&.push(live_segment_part(m, seg)); // :waste :commandsispartofcodenow
    
        program_header()[] = (
            type = .Load,
            prot = prot,
            offset = file_offset,
            vaddr = virtual_offset, 
            paddr = virtual_offset,
            file_size = segment.len(),
            mem_size = segment.len(),
            align = 4096,
        );
        
        virtual_offset += segment.mmapped.len;
        file_offset += segment.len();
        header
    };
    
    // TODO: we're asking it to map the elf info like you need to for mach-o but probably shouldn't do that here. 
    
    make_segment(.Code, RX); RX :: 5;// :waste :commandsispartofcodenow
    make_segment(.ConstantData, RW); R :: 4; // :waste  // TODO: how the fuck do i do relocations in a non-writable segment?
    make_segment(.MutableData, RW); RW :: 6;
    
    if m.imports.len > 0 {
        dynamic_header = (Some = (program_header(), program_header(), Elf.ProgramHeader.ptr_from_int(0)));
    };
    
    if dynamic_header& { it |
        it._2 = program_header();  // TODO: can this get moved up? or does it have to be after all load commands? 
    };
    
    payload := u8.list(CHAINED_SIZE_GUESS, temp());
    
    program_header()[] = (
        type = .Stack,
        prot = RW,
        offset = 0,
        vaddr = 0, 
        paddr = 0,
        file_size = 0,
        mem_size = 16777216,
        align = 0,
    );
    
    dynamics := Elf.Dyn.list(10, temp());
    
    final_p_header_count := e_header.program_header_num;
    program_headers_size := commands.len - start_program_headers;
    p_header[] = (
        type = .Phdr,
        prot = 4,
        offset = size_of(Elf.Header),
        vaddr = size_of(Elf.Header) + MYSTERY_SPICE, 
        paddr = size_of(Elf.Header) + MYSTERY_SPICE,
        file_size = program_headers_size,
        mem_size = program_headers_size,
        align = 8,
    );
    
    // TODO: it seems you still need one empty one even tho they don't do anything? wtf?
    section_names := Str.list(10, temp());
    e_header.section_header_off = commands.len;
    section_header :: fn(name: Str) => {
        section_names&.push(name);
        h := commands&.reserve_type(Elf.SectionHeader);
        e_header.section_header_num += 1;
        h
    };
    section_header("")[] = Elf.SectionHeader.zeroed();
    
    if dynamic_header { it |
        interp_header, load_payload_header, dynamic_header := it;
        {
            loader_path := "/lib64/ld-linux-x86-64.so.2\0";
            size := loader_path.len;
            addr := virtual_offset + payload.len;
            interp_header[] = (
                type = .Interp,
                prot = R,
                offset = file_offset + payload.len,
                vaddr = addr, 
                paddr = addr,
                file_size = size,
                mem_size = size,
                align = 1,
            );
            payload&.push_all(loader_path);
            payload&.zero_pad_to_align(8);
        };
        
        // SectionHeader.link: Relocations -> DynSymbolTable -> StringTable
        // This is conceptually the same, it's just that the section headers don't do anything (?)
        
        string_table_start := payload.len;
        imported_symbol_name_offsets := u32.list(m.imports.len, temp());
        payload&.push(0);  // null
        
        libc_name_offset := payload.len - string_table_start;
        libc_name := "/lib/x86_64-linux-gnu/libc.so.6"; // "libc.so.6";  ??
        //libc_name := "libc.so.6";
        payload&.push_all(libc_name);
        payload&.push(0);
        // TODO: not always. make people tell us what libs they need. 
        libdl_name_offset := payload.len - string_table_start;
        libdl_name := "libdl.so.2";
        payload&.push_all(libdl_name);
        payload&.push(0);
        libpthread_name_offset := payload.len - string_table_start;
        libpthread_name := "libpthread.so.0";
        payload&.push_all(libpthread_name);
        payload&.push(0);
      
        dynamics&.push(tag = .Needed, val = libc_name_offset);
        dynamics&.push(tag = .Needed, val = libdl_name_offset);
        dynamics&.push(tag = .Needed, val = libpthread_name_offset);
        dynamics&.push(tag = .Flags, val = 8);  // DF_BIND_NOW // TODO: does this do anything?
        dynamics&.push(tag = .Flags_1, val = 1);  // ?     // TODO: does this do anything?
        dynamics&.push(tag = .Debug, val = 0);  // ?     // TODO: does this do anything?
        
        //dynamics&.push(tag = .BindNow, val = 0);  // TODO: does this do anything? 
        
        for m.imports& { id |
            imported_symbol_name_offsets&.push(trunc(payload.len - string_table_start));
            name := m.str(id);
            payload&.push_all(name);
            payload&.push(0);
        };
        
        // ugh
        string_table_index := e_header.section_header_num;
        section_header(".dynstr")[] = (
            name = 0,
            type = .StringTable, 
            flags = 1.shift_left(@as(i64) Elf.SectionFlag.Strings),
            addr = 0,
            offset = file_offset + string_table_start, 
            size = payload.len - string_table_start,
            addr_align = 1,
        );
        
        dynamics&.push(tag = .StrTab, val = virtual_offset + string_table_start);
        dynamics&.push(tag = .StrSz, val = payload.len - string_table_start);
        payload&.zero_pad_to_align(8);
        symbol_table_start := payload.len;
        payload&.reserve_type(Elf.Symbol)[] = Elf.Symbol.zeroed();  // null
        enumerate m.imports& { i, id |
            STT_FUNC :: 2;
            payload&.reserve_type(Elf.Symbol)[] = (
                name = imported_symbol_name_offsets[i],
                info = 1.shift_left(4).bit_or(2).trunc(), // GLOBAL FUNC
            );
        };
        
        // ugh
        symbol_table_index := e_header.section_header_num;
        section_header(".dynsym")[] = (
            name = 0, // TODO
            type = .DynSymbolTable, 
            flags = 2, // TODO: what does this mean? 
            addr = 0,  // TODO: clang has some virtual place here
            offset = file_offset + symbol_table_start, 
            size = payload.len - symbol_table_start,
            addr_align = 8,
            ent_size = size_of(Elf.Symbol),
            link = string_table_index.zext(),
            info = 1,  // TODO: ??
        );
        
        dynamics&.push(tag = .SymTab, val = virtual_offset + symbol_table_start);
        dynamics&.push(tag = .SymEnt, val = size_of(Elf.Symbol));
        
        relocation_table_start := payload.len;
        //payload&.reserve_type(Elf.RelA)[] = Elf.RelA.zeroed();  // null
        enumerate m.imports& { i, id |
            symbol := m.get_symbol_info(id[]);
            each symbol.fixups { fix |
                @if_let(fix.type&) fn DataAbsolute(it) => {
                    ptr_cast_unchecked(u8, i64, fix.patch_at)[] = 0;
                    payload&.reserve_type(Elf.RelA)[] = (
                        sym = trunc(i + 1),
                        offset = ptr_diff(m.segments&[.Code].mmapped.ptr, fix.patch_at) + MYSTERY_SPICE, // TODO: or is it offset in a specific segment?
                        addend = it.increment,
                        type = 6, // 8 R_AMD64_RELATIVE // R_AMD64_64 1 // R_AMD64_GLOB_DAT 6  // R_AMD64_JUMP_SLOT 7,  // TODO: what does this mean?
                    );
                };
            };
        };
        
        // ugh
        section_header(".rela.dyn")[] = (
            name = 0,
            type = .RelocAddend, 
            flags = 2, // TODO: what does this mean? 
            addr = 0,  // TODO: clang has some virtual place here
            offset = file_offset + relocation_table_start, 
            size = payload.len - relocation_table_start,
            addr_align = 8,
            ent_size = size_of(Elf.RelA),
            link = symbol_table_index.zext(),
        );
        // TODO: local relocations 
        dynamics&.push(tag = .RelA, val = virtual_offset + relocation_table_start);
        dynamics&.push(tag = .RelASz, val = payload.len - relocation_table_start);
        dynamics&.push(tag = .RelAEnt, val = size_of(Elf.RelA));
        
        dynamics&.push(tag = .Null, val = 0);
        
        dynamics := dynamics.items().interpret_as_bytes();
        addr := virtual_offset + payload.len;
        
        // ugh
        section_header(".dynamic")[] = (
            name = 0,
            type = .Dynamic, 
            flags = 2,
            addr = addr, 
            offset = file_offset + payload.len, 
            size = dynamics.len,
            ent_size = size_of(Elf.Dyn),
            addr_align = 8,
        );
        
        code := m.segments&[.Code]&;
        section_header(".plt")[] = (
            name = 0, // TODO
            type = .ProgramBits, 
            flags = 1.shift_left(@as(i64) Elf.SectionFlag.Exec),
            addr = MYSTERY_SPICE + COMMANDS_SIZE_GUESS, 
            offset = COMMANDS_SIZE_GUESS, 
            size = m.stubs&.len(),
            addr_align = 1,
        );
        section_header(".text")[] = (
            name = 0, // TODO
            type = .ProgramBits, 
            flags = 1.shift_left(@as(i64) Elf.SectionFlag.Exec),
            addr = MYSTERY_SPICE + COMMANDS_SIZE_GUESS + SIZE_OF_STUBS,  
            offset = COMMANDS_SIZE_GUESS + SIZE_OF_STUBS, 
            size = code_size,
            addr_align = 1,
        );
        
        dynamic_header[] = (
            type = .Dynamic,
            prot = RW,
            offset = file_offset + payload.len,
            vaddr = addr, 
            paddr = addr,
            file_size = dynamics.len,
            mem_size = dynamics.len,
            align = 8,
        );
        payload&.push_all(dynamics);
        size := payload.len();
        load_payload_header[] = (
            type = .Load,
            prot = RW,
            offset = file_offset,
            vaddr = virtual_offset, 
            paddr = virtual_offset,
            file_size = size,
            mem_size = size,
            align = 4096,
        );
        
        // TODO: I think it really doesn't need the names so maybe i can take this out. 
        {
            e_header.section_header_names_index = e_header.section_header_num;
            header := section_header(".shstrtab");
            
            offsets := u32.list(temp());
            string_table_start := payload.len;
            for section_names { n |
                offsets&.push(trunc(payload.len - string_table_start));
                payload&.push_all(n);
                payload&.push(0);
            };
            header[] = (
                name = 0,
                type = .StringTable, 
                flags = 0,
                addr = 0,
                offset = file_offset + string_table_start, 
                size = payload.len - string_table_start,
                addr_align = 1,
            );
            
            ptr := ptr_cast_unchecked(u8, Elf.SectionHeader, commands.maybe_uninit.ptr.offset(e_header.section_header_off));
            s_headers: []Elf.SectionHeader = (ptr = ptr, len = e_header.section_header_num.zext());
            enumerate s_headers { i, h |
                h.name = offsets[i];
            };
        };
        
        file_offset += size;
        virtual_offset += size;
    };
    
    @debug_assert_eq(final_p_header_count, e_header.program_header_num, "added headers too late");
    end := commands.len;
    @assert_le(end, COMMANDS_SIZE_GUESS, "we guessed wrong so the array resized and all the pointers are junk");
    commands.len = COMMANDS_SIZE_GUESS;
    commands.items().rest(end).set_zeroed();
    @assert_le(payload.len, CHAINED_SIZE_GUESS, "resized and now the pointers are junk");  // TODO: don't think i need this here, just mach-o did
    if payload.len != 0 {
        chunks&.push(payload.items());
    };
    
    chunks.items()
}
