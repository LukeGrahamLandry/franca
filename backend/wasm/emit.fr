// Wasm is a bit annoying because it's designed to be compact and fast to load, not to be output in one pass. 

EmitWasmA :: @struct(
    m: *QbeModule,
    f: *Qbe.Fn,
    locals: []i32,
);

fn emit_func_wasm32(f: *Qbe.Fn) void = {
    e: EmitWasmA = (
        f = f,
        m = f.globals,
        locals = temp().alloc(i32, f.ntmp.zext()),
    );
    pack_locals(e&);
    // TODO: reserve space for the length of code
}

fn pack_locals(e: *EmitWasmA) void = {
    memset(i32.raw_from_ptr(e.locals.ptr), 0xFF, e.locals.len);
    total_locals: i32 = 0;
    for_pars e.f { i |
        e.locals[i.to.val()] = total_locals;
        // TODO: use cls to say function signeture. 
        total_locals += 1;
        i.set_nop();
    };
    // TODO: this probably isn't worth the time. 
    // Declaration of locals uses run-length-encoding so group by type to shrink the module. 
    for (@const_slice(Qbe.Cls.Kw, .Kl, .Ks, .Kd)) { k |
        prev_locals := total_locals;
        range(Qbe.Tmp0, e.f.ntmp.zext()) { i |
            t := e.f.tmp.index(i);
            if e.locals[i] == -1 && t.nuse > 0 && t.cls == k {
                e.locals[i] = total_locals;
                total_locals += 1;
            };
        };
        n := total_locals - prev_locals;
        // TODO: declare locals of this type
    };
}

fn output_wasm_module(f: *QbeModule) [][]u8 = {
    version_magic := @const_slice(0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00);
    empty()
}

//
// After the magic + version, the thing is a list of sections. 
// Each section is [id byte, size u32, data]
// Note that many sections are a vec of something which is encoded as [count u32, data], 
// so you sometimes have two lengths, one in bytes and then one in elements. 
// Also, when the spec says sizes like u32, that doesn't mean encode using that many bytes, 
// you still use the leb128 stuff. The type is just a range restriction. 
//

// TODO: we're not going to do it this way at all i think, 
//       want to just spam out functions in one chunk like other backends 
// TODO: use bucket arrays for less copying? 
fn dump(self: *Wasm.Module, out: *List(u8)) void = {
    :: enum(Wasm.Section);
    @debug_assert(self.imports.len == 0, "TODO: dump wasm imports");
    @debug_assert(self.data.len == 0, "TODO: dump wasm data");
    @debug_assert(self.memories.len == 0, "TODO: dump wasm");
    @debug_assert(self.tables.len == 0, "TODO: dump wasm");
    @debug_assert(self.globals.len == 0, "TODO: dump wasm");
    @debug_assert(self.elements.len == 0, "TODO: dump wasm");
    out.push_all(@slice(0x00, 0x61, 0x73, 0x6D));  // magic
    out.push_all(@slice(0x01, 0x00, 0x00, 0x00));  // version
    buf: List(u8) = list(temp());
    buf := buf&;
    inner_buf: List(u8) = list(temp());
    inner_buf := inner_buf&;
    
    Section :: Wasm.Section;
    out.push(Section.Type.raw());
    buf.leb128_unsigned(self.types.len); 
    for self.types { it | 
        buf.push(0x60);
        buf.leb128_unsigned(it.arg.len);
        for it.arg { ty |
            buf.push(ty.repr);
        };
        buf.leb128_unsigned(it.ret.len);
        for it.ret { ty |
            buf.push(ty.repr);
        };
    };
    out.leb128_unsigned(buf.len);
    out.push_all(buf.items());
    buf.clear();
    
    out.push(Section.Function.raw());
    buf.leb128_unsigned(self.functions.len); 
    for self.functions { it | 
        buf.leb128_unsigned(it.id.zext());
    };
    out.leb128_unsigned(buf.len);
    out.push_all(buf.items());
    buf.clear();
    
    out.push(Section.Export.raw());
    buf.leb128_unsigned(self.exports.len); 
    each self.exports { it | 
        buf.leb128_unsigned(it.name.len);
        buf.push_all(it.name.items());
        ::tagged(@type it.desc);
        tag: u8 = it.desc&.tag().ordinal().trunc();
        buf.push(tag);
        @match(it.desc) {  // TODO: this is kinda sad
            fn Function(idx) => buf.leb128_unsigned(idx.id.zext());
            fn Table(idx)    => buf.leb128_unsigned(idx.id.zext());
            fn Memory(idx)   => buf.leb128_unsigned(idx.id.zext());
            fn Global(idx)   => buf.leb128_unsigned(idx.id.zext());
        };
    };
    out.leb128_unsigned(buf.len);
    out.push_all(buf.items());
    buf.clear();
    
    out.push(Section.Code.raw());
    buf.leb128_unsigned(self.code.len); 
    each self.code { it | 
        inner_buf.leb128_unsigned(it.locals.len);
        each it.locals { local | 
            inner_buf.leb128_unsigned(local.count);
            inner_buf.push(local.ty.repr);
        };
        
        // Expressions aren't length prefixed, they have a terminator. 
        inner_buf.push_all(it.insts.items());
        ::?*u8;
        end := it.insts.items().last().unwrap()[];
        @assert_eq(end, Wasm.Inst.End.raw()); // TODO: move @debug_assert_eq to lib
        
        buf.leb128_unsigned(inner_buf.len);
        buf.push_all(inner_buf.items());
        inner_buf.clear();
    };
    out.leb128_unsigned(buf.len);
    out.push_all(buf.items());
    buf.clear();
}
