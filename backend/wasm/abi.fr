//! https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md
//! - non-scalar aggragates are always passed by pointer 
//! - aggragate return pointer is prepended to arguments
//! - varargs pointer is appended to arguments

fn wasm_abi(f: *Qbe.Fn) void = {
    // params come in as locals, not on the stack, which seems odd, 
    // but to be fair, the first thing i would do here is save them in locals anyway so i can't complain. 
    for_pars f { i |
        @debug_assert(i.op() != .pare, "TODO: env par wasm");
        if i.op() == .parc {
            // TODO: check if they said its a type but really there's only one scalar so the ir expects a pointer but we got a value. 
            i.set_op(.par);
            i.arg&[0] = QbeNull;
        };
    };
    
    if f.retty != -1 {
        // TODO: check if they said its a type but really there's only one scalar 
        f.retr = f.newtmp("abi", .Kl); 
    };
    
    for_blocks f { b |
        changed := false; 
        f.reset_scratch();
        
        f.ret_cls = .Ke;
        if is_ret(b.jmp.type) && b.jmp.arg != QbeNull {
            @debug_assert(b.jmp.type != .ret0, "J.ret0 had arg");
            // TODO: check if they said its a type but really there's only one scalar 
            is_scalar := b.jmp.type != .retc;
            changed = true;
            if is_scalar {
                k := @as(Qbe.Cls) @as(i32) b.jmp.type.raw() - Qbe.J.retw.raw();
                f.ret_cls = k;
                f.emit(.push, k, QbeNull, b.jmp.arg, QbeNull);
            } else {
                @debug_assert(f.retr != QbeNull, "missing indirect return pointer");
                m := f.globals;
                @if(use_threads) pthread_mutex_lock(m.types_mutex&).unwrap();
                size := m.types[][f.retty.zext()].size; 
                @if(use_threads) pthread_mutex_unlock(m.types_mutex&).unwrap();
                f.emit(.blit1, .Kw, QbeNull, INT(size), QbeNull);
                f.emit(.blit0, .Kw, QbeNull, b.jmp.arg, f.retr);  // src, dest
            };
            b.jmp.type = .ret0;
            b.jmp.arg = QbeNull;
        };
        
        pending_indirect_return := QbeNull;
        check_pending_indirect_return :: fn() => if pending_indirect_return != QbeNull {
            @debug_assert(changed);
            f.emit(.push, .Kl, QbeNull, pending_indirect_return, QbeNull);
            pending_indirect_return = QbeNull;
        };
    
        for_insts_rev b { i | 
            continue :: local_return;
            i := i[];
            
            @debug_assert(!@is(i.op(), .vaarg, .vastart), "TODO: wasm c-varargs");
            if i.op() == .call {
                f.move_end_of_block_to_scratch(b, i, changed&);
                
                // TODO: check if they said its a type but really there's only one scalar and it should be converted to a load. 
                is_scalar := i.arg&[1] == QbeNull;
                if is_scalar {
                    if i.to != QbeNull {
                        f.emit(.pop, i.cls(), i.to, QbeNull, QbeNull);
                    };
                } else {
                    // TODO: convert this into an alloc or RSlot or something
                    eprintln(":todo this wont work");
                    pending_indirect_return = i.to;
                };
                i.to = QbeNull;
                f.emit(i[]);
                continue();
            };
            
            // TODO: we need to know argument types for indirect_call but don't want to rely on consecutive pushes holding cls
            
            if is_arg(i.op()) {
                // TODO: check if they said its a type but really there's only one scalar and it should be converted to a load. 
                i.set_op(.push);
            } else {
                check_pending_indirect_return();
            };
            
            if changed {
                i = f.emit(i[]);
            };
        };
        
        check_pending_indirect_return();
        
        if f.retr != QbeNull && f.start.identical(b) {
            // prepend aggragate return pointer
            f.move_end_of_block_to_scratch(b, b.ins.first, changed&);
            f.emit(.pop, .Kl, f.retr, QbeNull, QbeNull);
        };
        
        if changed {
            f.copy_instructions_from_scratch(b); 
        };
    };
    
    when_debug(f, .Abi) { out | 
        write(out, "\n> After ABI lowering:\n");
        printfn(f, out);
    }
}
