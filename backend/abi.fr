// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>
//! Some helpers used by the abi for multiple targets. 

/* eliminate sub-word abi op
 * variants for targets that
 * treat char/short/... as
 * words with arbitrary high
 * bits
 */
fn elimsb(f: *Qbe.Fn) void = {
    for_blocks f { b |
        for_insts_forward b { i |
            if(is_argbh(i.op()), => i.set_op(.arg));
            if(is_parbh(i.op()), => i.set_op(.par));
        };
        if is_retbh(b.jmp.type) {
            b.jmp.type = .retw;
        }
    }
}

fn split(f: *Qbe.Fn, b: *Qbe.Blk) *Qbe.Blk = {
    f.nblk += 1;
    bn := newblk();
    f.copy_instructions_from_scratch(bn);
    b.visit += 1;
    bn.visit = b.visit;
    l: List(u8) = (maybe_uninit = bn.name&.items(), len = 0, gpa = panicking_allocator); // :UnacceptablePanic
    @fmt(l&, "%.%", b.name(), @as(i64) b.visit.zext());
    bn.loop = b.loop;
    bn.link = b.link;
    b.link = bn;
    bn
}

fn chpred(b: *Qbe.Blk, bp: *Qbe.Blk, bp1: *Qbe.Blk) void = {
    for_phi b { p |
        a := 0;
        while => !p.blk[a].identical(bp) {
            @debug_assert(a + 1 < p.narg.zext(), "didn't find phi for block");
            a += 1;
        };
        p.blk[a] = bp1;
    }
}

fn realloc_for_params(f: *Qbe.Fn, i: *Qbe.Ins) void = {
    // TODO: avoid useless reallocation if we have no params? 
    b := f.start;
    n: i64 = b.nins.zext() - ptr_diff(b.ins, i) + f.len_scratch();
    i0 := temp().alloc(Qbe.Ins, n).as_ptr();
    ip := i0;
    ip = icpy(ip, f.globals.curi[], f.len_scratch());
    ip = icpy(ip, i, ptr_diff(i, b.ins.offset(b.nins.zext())));  
    b.nins = n.trunc();
    b.ins = i0;
}

fn find_past_last_param(f: *Qbe.Fn) *Qbe.Ins = {
    for_insts_forward f.start { i | 
        if !is_par(i.op()) {
            return(i);
        }
    };
    f.start.ins.offset(f.start.nins.zext())
}

fn find_first_arg(b: *Qbe.Blk, call: *Qbe.Ins) *Qbe.Ins = {
    i := call;
    while => Qbe.Ins.int_from_ptr(i) > Qbe.Ins.int_from_ptr(b.ins) {
        if !is_arg(i.offset(-1).op()) {
            return(i);
        };
        i = i.offset(-1);
    };
    i
}
