// Adapted from Qbe. MIT License. Â© 2015-2024 Quentin Carbonneaux <quentin@c9x.me>
//! Some helpers used by the abi for multiple targets. 

/* eliminate sub-word abi op
 * variants for targets that
 * treat char/short/... as
 * words with arbitrary high
 * bits
 */
fn elimsb(f: *Qbe.Fn) void = {
    for_blocks f { b |
        for_insts_forward b { i |
            if(is_argbh(i.op()), => i.set_op(.arg));
            if(is_parbh(i.op()), => i.set_op(.par));
        };
        if is_retbh(b.jmp.type) {
            b.jmp.type = .retw;
        }
    }
}

// TODO: my move_end_of_block_to_scratch here is not super well tested because i don't use b/h in from_bc 
/* abi0 for arm64-apple and wasm32; introduces
 * necessary sign extensions in calls
 * and returns
 */
fn apple_extsb(f: *Qbe.Fn) void = {
    for_blocks f { b |
        changed := false; 
        f.reset_scratch();
        j := b.jmp.type;
        if is_retbh(j) {
            changed = true;
            r := f.newtmp("abi", .Kw);
            o := @as(Qbe.O) @as(i32) Qbe.O.extsb.raw() + (j.raw() - Qbe.J.retsb.raw());
            f.emit(o, .Kw, r, b.jmp.arg, QbeNull);
            b.jmp.arg = r;
            b.jmp.type = .retw;
        };
        for_insts_rev b { i | 
            if changed {
                f.emit(i[][]);
            };
            if i[].op() == .call {
                i1 := i[];
                i0 := b.find_first_arg(i[]); 
                i[] = i1;
                while => Qbe.Ins.int_from_ptr(i[]) > Qbe.Ins.int_from_ptr(i0) {
                    i[] = i[].offset(-1);
                    if is_argbh(i[].op()) {
                        f.move_end_of_block_to_scratch(b, i[], changed&);
                        prev := f.emit(i[][]);
                        i.to = f.newtmp("abi", .Kl);
                        prev.arg&[0] = i.to;
                    } else {
                        if changed {
                            f.emit(i[][]);
                        };
                    }
                };
                i[] = i1;
                while => Qbe.Ins.int_from_ptr(i[]) > Qbe.Ins.int_from_ptr(i0) {
                    i[] = i[].offset(-1);
                    if is_argbh(i[].op()) {
                        f.move_end_of_block_to_scratch(b, i[], changed&);
                        o := rebase(i[].op(), .extsb, .argsb);
                        f.emit(o, .Kw, i.to, i.arg&[0], QbeNull);
                    }
                };
            };
        };
        if changed {
            f.copy_instructions_from_scratch(b); 
        };
    };

    if f.globals.debug["A".char()] {
        out := f.globals.debug_out;
        write(out, "\n> After Apple pre-ABI:\n");
        printfn(f, out);
    }
}

fn split(f: *Qbe.Fn, b: *Qbe.Blk) *Qbe.Blk = {
    f.nblk += 1;
    bn := newblk();
    f.copy_instructions_from_scratch(bn);
    b.visit += 1;
    bn.visit = b.visit;
    @if(TRACK_IR_NAMES) {
        l := fixed_list(bn.name&.items()); // :UnacceptablePanic
        @fmt(l&, "%.%", b.name(), @as(i64) b.visit.zext());
    };
    bn.loop = b.loop;
    bn.link = b.link;
    b.link = bn;
    bn
}

fn chpred(b: *Qbe.Blk, bp: *Qbe.Blk, bp1: *Qbe.Blk) void = {
    for_phi b { p |
        a := index_in_phi(bp, p);
        p.blk[a] = bp1;
    }
}

fn realloc_for_params(f: *Qbe.Fn, i: *Qbe.Ins) void = {
    b := f.start;
    param_count := ptr_diff(b.ins.first, i);
    if f.len_scratch() == 0 && param_count == 0 {
        // avoid useless reallocation if we have no params  (and no big ret pointer)
        return();
    };
    n: i64 = b.nins.zext() - param_count + f.len_scratch();
    i0: QList(Qbe.Ins) = new(n);
    ip := i0.first;
    ip = icpy(ip, f.globals.curi[], f.len_scratch());
    ip = icpy(ip, i, ptr_diff(i, b.ins.index(b.nins.zext())));  
    b.nins = n.trunc();
    b.ins = i0;
}

fn find_past_last_param(f: *Qbe.Fn) *Qbe.Ins = {
    for_insts_forward f.start { i | 
        if !is_par(i.op()) {
            return(i);
        }
    };
    f.start.ins.first.offset(f.start.nins.zext())
}

fn find_first_arg(b: *Qbe.Blk, call: *Qbe.Ins) *Qbe.Ins = {
    i := call;
    while => Qbe.Ins.int_from_ptr(i) > Qbe.Ins.int_from_ptr(b.ins.first) {
        if !is_arg(i.offset(-1).op()) {
            return(i);
        };
        i = i.offset(-1);
    };
    i
}

// You're allowed multiple sequential isel1 using the same condition. 
// Scan backwards to find the condition instruction. 
fn find_sel0(b: *Qbe.Blk, isel0: *Qbe.Ins) *Qbe.Ins = {
    @debug_assert_eq(isel0.op(), .sel1);
    while => in_memory_after(isel0, b.ins.first) && isel0.op() == .sel1 {
        isel0 = isel0.offset(-1);
    };
    @debug_assert_eq(isel0.op(), .sel0);
    isel0
}

fn find_last_sel1(b: *Qbe.Blk, isel1: *Qbe.Ins) *Qbe.Ins = {
    @debug_assert_eq(isel1.op(), .sel0);
    dowhile {
        isel1 = isel1.offset(1);
        in_memory_after(b.ins.index(b.nins.zext()), isel1) && isel1.op() == .sel1
    };
    isel1 = isel1.offset(-1);
    @debug_assert_eq(isel1.op(), .sel1);
    isel1
}

// used by arm64/amd64 isel       TODO: worth a new file? 
// Any alloc with constant size gets assigned a fixed slot that we know as a constant offset into the stack frame. 
// Then the instruction for the alloc is removed. 
// So any remaining alloc instructions after this must be a dynamic alloca.  
// Note: We only do this for allocs in the start block. 
//       I guess if you conditionally do a large but constant size alloc, you don't want to always use the stack space. 
fn assign_alloc_slots(f: *Qbe.Fn) void = {
    approx := 0;
    for_insts_forward f.start { i |
        if is_alloc(i.op()) {
            if f.get_int(i.arg&[0]) { size |
                align := 16; 
                size = size.add(align - 1).bit_and(-align);
                approx += size;
            };
        }
    };
    f.escaping_slots = init_bitset(approx);
    
    allocs := @slice(Qbe.O.alloc4, Qbe.O.alloc8, Qbe.O.alloc16); // TODO: for_enum_range (these are sequentual)
    
    /* specific to NAlign == 3 */ /* or change align=4 and size /= 4 below */
    align := 4;
    for allocs { alloc_type |
        break :: local_return; // TODO: make break less of a pain in this language
        for_insts_forward f.start { i |
            if i.op() == alloc_type {
                if f.get_int(i.arg&[0]) { size |
                    if size < 0 || size >= MAX_i32 - 15 {
                        @panic("invalid alloc size %", size);
                    };
                    size = size.add(align - 1).bit_and(-align);
                    t := f.get_temporary(i.to);
                    t.slot = f.slot;
                    f.slot += size.intcast();
                    f.salign = 2 + alloc_type.raw() - Qbe.O.alloc4.raw();
                
                    // TODO: unfortunate that all my tests still work if you don't do this
                    //       i think it will matter more if i get store elimination working?  -- Jan 15
                    if escapes(i.to, f) { 
                        range(0, size) { i |
                            bsset(f.escaping_slots&, t.slot.intcast() + i);
                        };
                    };
                
                    i.set_nop();
                } else {
                    panic("TODO: none of my tests get here (alloca a dynamically sized stack slot)");
                    align *= 2; // :break
                    break(); 
                };
            }
        };
        align *= 2; // :break
        
        // on arm: ~23KB -- Nov 6
        //         It's actually fine if they're unaligned, you just can't use the immediate in ldr/str,
        //         so doing it this way lets fuse_addressing catch a few more cases at the cost of wasting 4 bytes of stack half the time. 
        if align == 8 && f.slot.intcast().mod(align) != 0 {
            f.slot += 4;
            f.salign = 3;
        };
    };
    @debug_assert(approx >= f.slot.zext(), "failed at guessing stack size");
};

fn chuse(r: Qbe.Ref, du: i64, f: *Qbe.Fn) void #inline = {
    if rtype(r) == .RTmp {
        nuse := f.get_temporary(r)[].nuse&;
        nuse[] = trunc(nuse[].zext() + du);
    }
}

fn try_kill_inst(f: *Qbe.Fn, i: *Qbe.Ins) bool #inline = {
    if rtype(i.to) == .RTmp
    && !isreg(i.to) && !isreg(i.arg&[0]) && !isreg(i.arg&[1])
    && f.get_temporary(i.to)[].nuse == 0 {
        chuse(i.arg&[0], -1, f);
        chuse(i.arg&[1], -1, f);
        return(true);
    };
    false
}
