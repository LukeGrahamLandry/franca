SgColor :: @struct(
    r: f32,
    g: f32,
    b: f32,
    a: f32,
);
SgBackend :: @enum(i32) (
    GLCORE,
    GLES3,
    D3D11,
    METAL_IOS,
    METAL_MACOS,
    METAL_SIMULATOR,
    WGPU,
    DUMMY,
);
SgPixelFormat :: @enum(i32) (
    DEFAULT,
    NONE,
    R8,
    R8SN,
    R8UI,
    R8SI,
    R16,
    R16SN,
    R16UI,
    R16SI,
    R16F,
    RG8,
    RG8SN,
    RG8UI,
    RG8SI,
    R32UI,
    R32SI,
    R32F,
    RG16,
    RG16SN,
    RG16UI,
    RG16SI,
    RG16F,
    RGBA8,
    SRGB8A8,
    RGBA8SN,
    RGBA8UI,
    RGBA8SI,
    BGRA8,
    RGB10A2,
    RG11B10F,
    RGB9E5,
    RG32UI,
    RG32SI,
    RG32F,
    RGBA16,
    RGBA16SN,
    RGBA16UI,
    RGBA16SI,
    RGBA16F,
    RGBA32UI,
    RGBA32SI,
    RGBA32F,
    DEPTH,
    DEPTH_STENCIL,
    BC1_RGBA,
    BC2_RGBA,
    BC3_RGBA,
    BC3_SRGBA,
    BC4_R,
    BC4_RSN,
    BC5_RG,
    BC5_RGSN,
    BC6H_RGBF,
    BC6H_RGBUF,
    BC7_RGBA,
    BC7_SRGBA,
    PVRTC_RGB_2BPP,
    PVRTC_RGB_4BPP,
    PVRTC_RGBA_2BPP,
    PVRTC_RGBA_4BPP,
    ETC2_RGB8,
    ETC2_SRGB8,
    ETC2_RGB8A1,
    ETC2_RGBA8,
    ETC2_SRGB8A8,
    EAC_R11,
    EAC_R11SN,
    EAC_RG11,
    EAC_RG11SN,
    ASTC_4x4_RGBA,
    ASTC_4x4_SRGBA,
    NUM,
);

PixFmtInfo :: @enum(u32) (sample, filter, render, blend, msaa, depth);
_sg_pixelformat_info_t :: EnumMap(PixFmtInfo, bool);

SgPixelformatInfo :: @struct(
    flags: _sg_pixelformat_info_t #use,
    compressed: bool,
    bytes_per_pixel: i32,
);
SgFeatures :: @struct(
    origin_top_left: bool,
    image_clamp_to_border: bool,
    mrt_independent_blend_state: bool,
    mrt_independent_write_mask: bool,
    compute: bool,
    msaa_image_bindings: bool,
);
SgLimits :: @struct(
    max_image_size_2d: i32,
    max_image_size_cube: i32,
    max_image_size_3d: i32,
    max_image_size_array: i32,
    max_image_array_layers: i32,
    max_vertex_attrs: i32,
    gl_max_vertex_uniform_components: i32 = 0,
    gl_max_combined_texture_image_units: i32 = 0,
);
SgResourceState :: @enum(i32) (
    INITIAL,
    ALLOC,
    VALID,
    FAILED,
    INVALID,
);
SgUsage :: @enum(i32) (
    DEFAULT,
    IMMUTABLE,
    DYNAMIC,
    STREAM,
    NUM,
);
SgBufferType :: @enum(i32) (
    DEFAULT,
    VERTEXBUFFER,
    INDEXBUFFER,
    STORAGEBUFFER,
    NUM,
);
SgIndexType :: @enum(i32) (
    DEFAULT,
    NONE,
    UINT16,
    UINT32,
    NUM,
);
SgImageType :: @enum(i32) (
    DEFAULT,
    _2D,
    CUBE,
    _3D,
    ARRAY,
    NUM,
);
SgImageSampleType :: @enum(i32) (
    DEFAULT,
    FLOAT,
    DEPTH,
    SINT,
    UINT,
    UNFILTERABLE_FLOAT,
    NUM,
);
SgSamplerType :: @enum(i32) (
    DEFAULT,
    FILTERING,
    NONFILTERING,
    COMPARISON,
    NUM,
);
SgCubeFace :: @enum(i32) (
    POS_X,
    NEG_X,
    POS_Y,
    NEG_Y,
    POS_Z,
    NEG_Z,
    NUM,
);
SgPrimitiveType :: @enum(i32) (
    DEFAULT,
    POINTS,
    LINES,
    LINE_STRIP,
    TRIANGLES,
    TRIANGLE_STRIP,
    NUM,
);
SgFilter :: @enum(i32) (
    DEFAULT,
    NEAREST,
    LINEAR,
    NUM,
);
SgWrap :: @enum(i32) (
    DEFAULT,
    REPEAT,
    CLAMP_TO_EDGE,
    CLAMP_TO_BORDER,
    MIRRORED_REPEAT,
    NUM,
);
SgBorderColor :: @enum(i32) (
    DEFAULT,
    TRANSPARENT_BLACK,
    OPAQUE_BLACK,
    OPAQUE_WHITE,
    NUM,
);


SgVertexFormat :: @enum(i32) (
    INVALID,
    FLOAT,
    FLOAT2,
    FLOAT3,
    FLOAT4,
    INT,
    INT2,
    INT3,
    INT4,
    UINT,
    UINT2,
    UINT3,
    UINT4,
    BYTE4,
    BYTE4N,
    UBYTE4,
    UBYTE4N,
    SHORT2,
    SHORT2N,
    USHORT2,
    USHORT2N,
    SHORT4,
    SHORT4N,
    USHORT4,
    USHORT4N,
    UINT10_N2,
    HALF2,
    HALF4,
    NUM,
);
SgVertexStep :: @enum(i32) (
    DEFAULT,
    PER_VERTEX,
    PER_INSTANCE,
    NUM,
);
SgUniformType :: @enum(i32) (
    INVALID,
    FLOAT,
    FLOAT2,
    FLOAT3,
    FLOAT4,
    INT,
    INT2,
    INT3,
    INT4,
    MAT4,
    NUM,
);
SgUniformLayout :: @enum(i32) (
    DEFAULT,
    NATIVE,
    STD140,
    NUM,
);
SgCullMode :: @enum(i32) (
    DEFAULT,
    NONE,
    FRONT,
    BACK,
    NUM,
);
SgFaceWinding :: @enum(i32) (
    DEFAULT,
    CCW,
    CW,
    NUM,
);
SgCompareFunc :: @enum(i32) (
    DEFAULT,
    NEVER,
    LESS,
    EQUAL,
    LESS_EQUAL,
    GREATER,
    NOT_EQUAL,
    GREATER_EQUAL,
    ALWAYS,
    NUM,
);
SgStencilOp :: @enum(i32) (
    DEFAULT,
    KEEP,
    ZERO,
    REPLACE,
    INCR_CLAMP,
    DECR_CLAMP,
    INVERT,
    INCR_WRAP,
    DECR_WRAP,
    NUM,
);
SgBlendFactor :: @enum(i32) (
    DEFAULT,
    ZERO,
    ONE,
    SRC_COLOR,
    ONE_MINUS_SRC_COLOR,
    SRC_ALPHA,
    ONE_MINUS_SRC_ALPHA,
    DST_COLOR,
    ONE_MINUS_DST_COLOR,
    DST_ALPHA,
    ONE_MINUS_DST_ALPHA,
    SRC_ALPHA_SATURATED,
    BLEND_COLOR,
    ONE_MINUS_BLEND_COLOR,
    BLEND_ALPHA,
    ONE_MINUS_BLEND_ALPHA,
    NUM,
);
SgBlendOp :: @enum(i32) (
    DEFAULT,
    ADD,
    SUBTRACT,
    REVERSE_SUBTRACT,
    MIN,
    MAX,
    NUM,
);
SgColorMask :: @enum(i32) (
    DEFAULT = 0,
    NONE = 16,
    R = 1,
    G = 2,
    RG = 3,
    B = 4,
    RB = 5,
    GB = 6,
    RGB = 7,
    A = 8,
    RA = 9,
    GA = 10,
    RGA = 11,
    BA = 12,
    RBA = 13,
    GBA = 14,
    RGBA = 15,
);
SgLoadAction :: @enum(i32) (
    DEFAULT,
    CLEAR,
    LOAD,
    DONTCARE,
);
SgStoreAction :: @enum(i32) (
    DEFAULT,
    STORE,
    DONTCARE,
);

AttachmentAction :: fn($Clear) => @struct(
    load_action: SgLoadAction,
    store_action: SgStoreAction,
    clear_value: Clear,
);
SgColorAttachmentAction :: AttachmentAction(SgColor);
SgDepthAttachmentAction :: AttachmentAction(f32);
SgStencilAttachmentAction :: AttachmentAction(u8);
SgPassAction :: @struct(
    colors: Array(SgColorAttachmentAction, 4),
    depth: SgDepthAttachmentAction,
    stencil: SgStencilAttachmentAction,
);
SgMetalSwapchain :: @struct(
    current_drawable: rawptr,
    depth_stencil_texture: rawptr,
    msaa_color_texture: rawptr,
);
SgD3d11Swapchain :: @struct(
    render_view: rawptr,
    resolve_view: rawptr,
    depth_stencil_view: rawptr,
);
SgWgpuSwapchain :: @struct(
    render_view: rawptr,
    resolve_view: rawptr,
    depth_stencil_view: rawptr,
);
SgGlSwapchain :: @struct(
    framebuffer: u32,
);
SgSwapchain :: @struct(
    width: i32,
    height: i32,
    sample_count: i32,
    color_format: SgPixelFormat,
    depth_format: SgPixelFormat,
    metal: SgMetalSwapchain,
    d3d11: SgD3d11Swapchain,
    wgpu: SgWgpuSwapchain,
    gl: SgGlSwapchain,
);
SgPass :: @struct(
    _start_canary: u32,
    action: SgPassAction,
    attachments: Sg.Attachments,
    swapchain: SgSwapchain,
    label: CStr,
    compute: bool,
    _end_canary: u32,
);
SgBindings :: @struct(
    _start_canary: u32,
    vertex_buffers: Array(Sg.Buffer, 8),
    vertex_buffer_offsets: Array(i32, 8),
    index_buffer: Sg.Buffer,
    index_buffer_offset: i32,
    images: Array(Sg.Image, 16),
    samplers: Array(Sg.Sampler, 16),
    storage_buffers: Array(Sg.Buffer, 8),
    _end_canary: u32,
);
SgBufferDesc :: @struct(
    size := 0,  // will default to data.len if provided
    type := SgBufferType.VERTEXBUFFER,
    usage := SgUsage.IMMUTABLE,
    data: []u8 = empty(),
    label: CStr = "",
    gl_buffers := zeroed Array(u32, 2),
    mtl_buffers := zeroed Array(rawptr, 2),
    d3d11_buffer := zeroed rawptr,
    wgpu_buffer := zeroed rawptr,
);
// TODO: why is this not just a flat byte array?
//       there's this whole replaceRegion dance where we calculate where to put each part. 
//       maybe different backends want you to layout your CUBE differently? idk
SgImageData :: @struct(
    subimage: Array(Array([]u8, 16), 6),
);
SgImageDesc :: @struct(
    _start_canary: u32,
    type: SgImageType,
    render_target: bool,
    width: i32,
    height: i32,
    num_slices: i32,
    num_mipmaps: i32,
    usage: SgUsage,
    pixel_format: SgPixelFormat,
    sample_count: i32,
    data: SgImageData,
    label: CStr,
    gl_textures: Array(u32, 2),
    gl_texture_target: u32,
    mtl_textures: Array(rawptr, 2),
    d3d11_texture: rawptr,
    d3d11_shader_resource_view: rawptr,
    wgpu_texture: rawptr,
    wgpu_texture_view: rawptr,
    _end_canary: u32,
);

FLT_MAX: f32 : bitcast(0b01111111011111111111111111111111);

SamplerCommon :: @struct(
    min_filter := SgFilter.NEAREST,
    mag_filter := SgFilter.NEAREST,
    mipmap_filter := SgFilter.NEAREST,
    wrap_u := SgWrap.REPEAT,
    wrap_v := SgWrap.REPEAT,
    wrap_w := SgWrap.REPEAT,
    min_lod: f32 = FLT_MAX,
    max_lod: f32 = 0,
    border_color := SgBorderColor.OPAQUE_BLACK,
    compare := SgCompareFunc.NEVER,
    max_anisotropy: u32 = 1,
);

SgSamplerDesc :: @struct {
    common: SamplerCommon #use = ();
    label: CStr = "";
    gl_sampler: u32 = 0;
    mtl_sampler := zeroed rawptr;
    d3d11_sampler := zeroed rawptr;
    wgpu_sampler := zeroed rawptr;
};
SgShaderStage :: @enum(i32) (
    NONE,
    VERTEX,
    FRAGMENT,
    COMPUTE,
);
// TODO: @tagged(Source: Str, Bytecode: []u8);
SgShaderFunction :: @struct(
    source: CStr,
    bytecode: []u8,
    entry: CStr,
    d3d11_target: CStr,
);
SgShaderVertexAttr :: @struct(
    base_type: Sg.ShaderAttrBaseType = .Undefined,
    glsl_name: CStr,
    hlsl_sem_name: CStr,
    hlsl_sem_index: u8,
);
SgGlslShaderUniform :: @struct(
    type: SgUniformType,
    array_count: u16,
    glsl_name: CStr,
);
SgShaderUniformBlock :: @struct(
    stage: SgShaderStage,
    size: u32,
    hlsl_register_b_n: u8,
    msl_buffer_n: u8,
    wgsl_group0_binding_n: u8,
    layout: SgUniformLayout,
    glsl_uniforms: Array(SgGlslShaderUniform, 16),
);
SgShaderImage :: @struct(
    stage: SgShaderStage,
    image_type: SgImageType,
    sample_type: SgImageSampleType,
    multisampled: bool,
    hlsl_register_t_n: u8,
    msl_texture_n: u8,
    wgsl_group1_binding_n: u8,
);
SgShaderSampler :: @struct(
    stage: SgShaderStage,
    sampler_type: SgSamplerType,
    hlsl_register_s_n: u8,
    msl_sampler_n: u8,
    wgsl_group1_binding_n: u8,
);
SgShaderStorageBuffer :: @struct(
    stage: SgShaderStage,
    readonly: bool,
    hlsl_register_t_n: u8,
    msl_buffer_n: u8,
    wgsl_group1_binding_n: u8,
    glsl_binding_n: u8,
);
SgShaderImageSamplerPair :: @struct(
    stage: SgShaderStage,
    image_slot: u8,
    sampler_slot: u8,
    glsl_name: CStr,
);
SgShaderDesc :: @struct(
    _start_canary: u32,
    vertex_func: SgShaderFunction,
    fragment_func: SgShaderFunction,
    compute_func: SgShaderFunction,
    attrs: Array(SgShaderVertexAttr, 16),
    uniform_blocks: Array(SgShaderUniformBlock, 8),
    storage_buffers: Array(SgShaderStorageBuffer, 8),
    images: Array(SgShaderImage, 16),
    samplers: Array(SgShaderSampler, 16),
    image_sampler_pairs: Array(SgShaderImageSamplerPair, 16),
    mtl_threads_per_threadgroup: SgMtlShaderThreadsPerThreadGroup,
    label: CStr,
    _end_canary: u32,
);
SgMtlShaderThreadsPerThreadGroup :: @struct {
    x: i32; y: i32; z: i32;
};
SgVertexBufferLayoutState :: @struct(
    stride: i32,
    step_func := SgVertexStep.PER_VERTEX,
    step_rate: i32 = 1,
);
SgVertexAttrState :: @struct(
    buffer_index: i32 = 0,
    offset: i32 = 0,
    format := SgVertexFormat.INVALID,
);
SgVertexLayoutState :: @struct(
    buffers: Array(SgVertexBufferLayoutState, 8),
    attrs: Array(SgVertexAttrState, 16),
);
SgStencilFaceState :: @struct(
    compare := SgCompareFunc.ALWAYS,
    fail_op := SgStencilOp.KEEP,
    depth_fail_op := SgStencilOp.KEEP,
    pass_op := SgStencilOp.KEEP,
);

SgStencilState :: @struct(
    enabled: bool = false,
    front: SgStencilFaceState = (),
    back: SgStencilFaceState = (),
    read_mask: u8 = 0,
    write_mask: u8 = 0,
    ref: u8 = 0,
);
SgDepthState :: @struct(
    pixel_format := SgPixelFormat.DEFAULT,
    compare := SgCompareFunc.DEFAULT,
    write_enabled: bool = false,
    bias: f32 = 0,
    bias_slope_scale: f32 = 0,
    bias_clamp: f32 = 0,
);
SgBlendState :: @struct(
    enabled: bool,
    src_factor_rgb := SgBlendFactor.DEFAULT,
    dst_factor_rgb := SgBlendFactor.DEFAULT,
    op_rgb := SgBlendOp.DEFAULT,
    src_factor_alpha := SgBlendFactor.DEFAULT,
    dst_factor_alpha := SgBlendFactor.DEFAULT,
    op_alpha := SgBlendOp.DEFAULT,
);
SgColorTargetState :: @struct(
    pixel_format: SgPixelFormat,
    write_mask := SgColorMask.DEFAULT,
    blend: SgBlendState,
);

SgPipelineShared :: @struct(
    compute := false,
    shader := zeroed Sg.Shader,
    layout := zeroed SgVertexLayoutState,
    depth: SgDepthState = (),
    stencil: SgStencilState = (),
    color_count: i32 = 0,  // defaults to 1 if not depth only
    colors := zeroed Array(SgColorTargetState, 4),
    primitive_type := SgPrimitiveType.TRIANGLES,
    index_type := SgIndexType.NONE,
    cull_mode := SgCullMode.NONE,
    face_winding := SgFaceWinding.CW,
    sample_count: i32 = 0,  // set from environment.defaults
    blend_color := zeroed SgColor,
    alpha_to_coverage_enabled := false,
);

SgPipelineDesc :: @struct {
    common: SgPipelineShared #use = ();
    label: CStr = "";
};
SgAttachmentDesc :: @struct(
    image: Sg.Image,
    mip_level: i32,
    slice: i32,
);
SgAttachmentsDesc :: @struct(
    _start_canary: u32,
    colors: Array(SgAttachmentDesc, 4),
    resolves: Array(SgAttachmentDesc, 4),
    depth_stencil: SgAttachmentDesc,
    label: CStr,
    _end_canary: u32,
);
SgTraceHooks :: @struct(
    user_data: rawptr,
    reset_state_cache: @FnPtr(rawptr) void,
    make_buffer: @FnPtr(*SgBufferDesc, SgBuffer, rawptr) void,
    make_image: @FnPtr(*SgImageDesc, SgImage, rawptr) void,
    make_sampler: @FnPtr(*SgSamplerDesc, SgSampler, rawptr) void,
    make_shader: @FnPtr(*SgShaderDesc, SgShader, rawptr) void,
    make_pipeline: @FnPtr(*SgPipelineDesc, SgPipeline, rawptr) void,
    make_attachments: @FnPtr(*SgAttachmentsDesc, SgAttachments, rawptr) void,
    destroy_buffer: @FnPtr(SgBuffer, rawptr) void,
    destroy_image: @FnPtr(SgImage, rawptr) void,
    destroy_sampler: @FnPtr(SgSampler, rawptr) void,
    destroy_shader: @FnPtr(SgShader, rawptr) void,
    destroy_pipeline: @FnPtr(SgPipeline, rawptr) void,
    destroy_attachments: @FnPtr(SgAttachments, rawptr) void,
    update_buffer: @FnPtr(SgBuffer, *SgRange, rawptr) void,
    update_image: @FnPtr(SgImage, *SgImageData, rawptr) void,
    append_buffer: @FnPtr(SgBuffer, *SgRange, i32, rawptr) void,
    begin_pass: @FnPtr(*SgPass, rawptr) void,
    apply_viewport: @FnPtr(i32, i32, i32, i32, bool, rawptr) void,
    apply_scissor_rect: @FnPtr(i32, i32, i32, i32, bool, rawptr) void,
    apply_pipeline: @FnPtr(SgPipeline, rawptr) void,
    apply_bindings: @FnPtr(*SgBindings, rawptr) void,
    apply_uniforms: @FnPtr(i32, *SgRange, rawptr) void,
    draw: @FnPtr(i32, i32, i32, rawptr) void,
    end_pass: @FnPtr(rawptr) void,
    commit: @FnPtr(rawptr) void,
    alloc_buffer: @FnPtr(SgBuffer, rawptr) void,
    alloc_image: @FnPtr(SgImage, rawptr) void,
    alloc_sampler: @FnPtr(SgSampler, rawptr) void,
    alloc_shader: @FnPtr(SgShader, rawptr) void,
    alloc_pipeline: @FnPtr(SgPipeline, rawptr) void,
    alloc_attachments: @FnPtr(SgAttachments, rawptr) void,
    dealloc_buffer: @FnPtr(SgBuffer, rawptr) void,
    dealloc_image: @FnPtr(SgImage, rawptr) void,
    dealloc_sampler: @FnPtr(SgSampler, rawptr) void,
    dealloc_shader: @FnPtr(SgShader, rawptr) void,
    dealloc_pipeline: @FnPtr(SgPipeline, rawptr) void,
    dealloc_attachments: @FnPtr(SgAttachments, rawptr) void,
    init_buffer: @FnPtr(SgBuffer, *SgBufferDesc, rawptr) void,
    init_image: @FnPtr(SgImage, *SgImageDesc, rawptr) void,
    init_sampler: @FnPtr(SgSampler, *SgSamplerDesc, rawptr) void,
    init_shader: @FnPtr(SgShader, *SgShaderDesc, rawptr) void,
    init_pipeline: @FnPtr(SgPipeline, *SgPipelineDesc, rawptr) void,
    init_attachments: @FnPtr(SgAttachments, *SgAttachmentsDesc, rawptr) void,
    uninit_buffer: @FnPtr(SgBuffer, rawptr) void,
    uninit_image: @FnPtr(SgImage, rawptr) void,
    uninit_sampler: @FnPtr(SgSampler, rawptr) void,
    uninit_shader: @FnPtr(SgShader, rawptr) void,
    uninit_pipeline: @FnPtr(SgPipeline, rawptr) void,
    uninit_attachments: @FnPtr(SgAttachments, rawptr) void,
    fail_buffer: @FnPtr(SgBuffer, rawptr) void,
    fail_image: @FnPtr(SgImage, rawptr) void,
    fail_sampler: @FnPtr(SgSampler, rawptr) void,
    fail_shader: @FnPtr(SgShader, rawptr) void,
    fail_pipeline: @FnPtr(SgPipeline, rawptr) void,
    fail_attachments: @FnPtr(SgAttachments, rawptr) void,
    push_debug_group: @FnPtr(CStr, rawptr) void,
    pop_debug_group: @FnPtr(rawptr) void,
);
SgSlotInfo :: @struct(
    state: SgResourceState,
    res_id: u32,
);
SgBufferInfo :: @struct(
    slot: SgSlotInfo,
    update_frame_index: u32,
    append_frame_index: u32,
    append_pos: i32,
    append_overflow: bool,
    num_slots: i32,
    active_slot: i32,
);
SgImageInfo :: @struct(
    slot: SgSlotInfo,
    upd_frame_index: u32,
    num_slots: i32,
    active_slot: i32,
);
SgSamplerInfo :: @struct(
    slot: SgSlotInfo,
);
SgShaderInfo :: @struct(
    slot: SgSlotInfo,
);
SgPipelineInfo :: @struct(
    slot: SgSlotInfo,
);
SgAttachmentsInfo :: @struct(
    slot: SgSlotInfo,
);
SgFrameStatsGl :: @struct(
    num_bind_buffer: u32,
    num_active_texture: u32,
    num_bind_texture: u32,
    num_bind_sampler: u32,
    num_use_program: u32,
    num_render_state: u32,
    num_vertex_attrib_pointer: u32,
    num_vertex_attrib_divisor: u32,
    num_enable_vertex_attrib_array: u32,
    num_disable_vertex_attrib_array: u32,
    num_uniform: u32,
);
SgFrameStatsD3d11Pass :: @struct(
    num_om_set_render_targets: u32,
    num_clear_render_target_view: u32,
    num_clear_depth_stencil_view: u32,
    num_resolve_subresource: u32,
);
SgFrameStatsD3d11Pipeline :: @struct(
    num_rs_set_state: u32,
    num_om_set_depth_stencil_state: u32,
    num_om_set_blend_state: u32,
    num_ia_set_primitive_topology: u32,
    num_ia_set_input_layout: u32,
    num_vs_set_shader: u32,
    num_vs_set_constant_buffers: u32,
    num_ps_set_shader: u32,
    num_ps_set_constant_buffers: u32,
);
SgFrameStatsD3d11Bindings :: @struct(
    num_ia_set_vertex_buffers: u32,
    num_ia_set_index_buffer: u32,
    num_vs_set_shader_resources: u32,
    num_ps_set_shader_resources: u32,
    num_vs_set_samplers: u32,
    num_ps_set_samplers: u32,
);
SgFrameStatsD3d11Uniforms :: @struct(
    num_update_subresource: u32,
);
SgFrameStatsD3d11Draw :: @struct(
    num_draw_indexed_instanced: u32,
    num_draw_indexed: u32,
    num_draw_instanced: u32,
    num_draw: u32,
);
SgFrameStatsD3d11 :: @struct(
    pass: SgFrameStatsD3d11Pass,
    pipeline: SgFrameStatsD3d11Pipeline,
    bindings: SgFrameStatsD3d11Bindings,
    uniforms: SgFrameStatsD3d11Uniforms,
    draw: SgFrameStatsD3d11Draw,
    num_map: u32,
    num_unmap: u32,
);
SgFrameStatsMetalIdpool :: @struct(
    num_added: u32,
    num_released: u32,
    num_garbage_collected: u32,
);
SgFrameStatsMetalPipeline :: @struct(
    num_set_blend_color: u32,
    num_set_cull_mode: u32,
    num_set_front_facing_winding: u32,
    num_set_stencil_reference_value: u32,
    num_set_depth_bias: u32,
    num_set_render_pipeline_state: u32,
    num_set_depth_stencil_state: u32,
);
SgFrameStatsMetalBindings :: @struct(
    num_set_vertex_buffer: u32,
    num_set_vertex_texture: u32,
    num_set_vertex_sampler_state: u32,
    num_set_fragment_buffer: u32,
    num_set_fragment_texture: u32,
    num_set_fragment_sampler_state: u32,
);
SgFrameStatsMetalUniforms :: @struct(
    num_set_vertex_buffer_offset: u32,
    num_set_fragment_buffer_offset: u32,
);
SgFrameStatsMetal :: @struct(
    idpool: SgFrameStatsMetalIdpool,
    pipeline: SgFrameStatsMetalPipeline,
    bindings: SgFrameStatsMetalBindings,
    uniforms: SgFrameStatsMetalUniforms,
);
SgFrameStatsWgpuUniforms :: @struct(
    num_set_bindgroup: u32,
    size_write_buffer: u32,
);
SgFrameStatsWgpuBindings :: @struct(
    num_set_vertex_buffer: u32,
    num_skip_redundant_vertex_buffer: u32,
    num_set_index_buffer: u32,
    num_skip_redundant_index_buffer: u32,
    num_create_bindgroup: u32,
    num_discard_bindgroup: u32,
    num_set_bindgroup: u32,
    num_skip_redundant_bindgroup: u32,
    num_bindgroup_cache_hits: u32,
    num_bindgroup_cache_misses: u32,
    num_bindgroup_cache_collisions: u32,
    num_bindgroup_cache_invalidates: u32,
    num_bindgroup_cache_hash_vs_key_mismatch: u32,
);
SgFrameStatsWgpu :: @struct(
    uniforms: SgFrameStatsWgpuUniforms,
    bindings: SgFrameStatsWgpuBindings,
);
SgFrameStats :: @struct(
    frame_index: u32,
    num_passes: u32,
    num_apply_viewport: u32,
    num_apply_scissor_rect: u32,
    num_apply_pipeline: u32,
    num_apply_bindings: u32,
    num_apply_uniforms: u32,
    num_draw: u32,
    num_update_buffer: u32,
    num_append_buffer: u32,
    num_update_image: u32,
    size_apply_uniforms: u32,
    size_update_buffer: u32,
    size_append_buffer: u32,
    size_update_image: u32,
    gl: SgFrameStatsGl,
    d3d11: SgFrameStatsD3d11,
    metal: SgFrameStatsMetal,
    wgpu: SgFrameStatsWgpu,
);
SgLogItem :: @enum(i32) (
    OK,
    MALLOC_FAILED,
    GL_TEXTURE_FORMAT_NOT_SUPPORTED,
    GL_3D_TEXTURES_NOT_SUPPORTED,
    GL_ARRAY_TEXTURES_NOT_SUPPORTED,
    GL_SHADER_COMPILATION_FAILED,
    GL_SHADER_LINKING_FAILED,
    GL_VERTEX_ATTRIBUTE_NOT_FOUND_IN_SHADER,
    GL_IMAGE_SAMPLER_NAME_NOT_FOUND_IN_SHADER,
    GL_FRAMEBUFFER_STATUS_UNDEFINED,
    GL_FRAMEBUFFER_STATUS_INCOMPLETE_ATTACHMENT,
    GL_FRAMEBUFFER_STATUS_INCOMPLETE_MISSING_ATTACHMENT,
    GL_FRAMEBUFFER_STATUS_UNSUPPORTED,
    GL_FRAMEBUFFER_STATUS_INCOMPLETE_MULTISAMPLE,
    GL_FRAMEBUFFER_STATUS_UNKNOWN,
    D3D11_CREATE_BUFFER_FAILED,
    D3D11_CREATE_BUFFER_SRV_FAILED,
    D3D11_CREATE_DEPTH_TEXTURE_UNSUPPORTED_PIXEL_FORMAT,
    D3D11_CREATE_DEPTH_TEXTURE_FAILED,
    D3D11_CREATE_2D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT,
    D3D11_CREATE_2D_TEXTURE_FAILED,
    D3D11_CREATE_2D_SRV_FAILED,
    D3D11_CREATE_3D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT,
    D3D11_CREATE_3D_TEXTURE_FAILED,
    D3D11_CREATE_3D_SRV_FAILED,
    D3D11_CREATE_MSAA_TEXTURE_FAILED,
    D3D11_CREATE_SAMPLER_STATE_FAILED,
    D3D11_LOAD_D3DCOMPILER_47_DLL_FAILED,
    D3D11_SHADER_COMPILATION_FAILED,
    D3D11_SHADER_COMPILATION_OUTPUT,
    D3D11_CREATE_CONSTANT_BUFFER_FAILED,
    D3D11_CREATE_INPUT_LAYOUT_FAILED,
    D3D11_CREATE_RASTERIZER_STATE_FAILED,
    D3D11_CREATE_DEPTH_STENCIL_STATE_FAILED,
    D3D11_CREATE_BLEND_STATE_FAILED,
    D3D11_CREATE_RTV_FAILED,
    D3D11_CREATE_DSV_FAILED,
    D3D11_MAP_FOR_UPDATE_BUFFER_FAILED,
    D3D11_MAP_FOR_APPEND_BUFFER_FAILED,
    D3D11_MAP_FOR_UPDATE_IMAGE_FAILED,
    METAL_CREATE_BUFFER_FAILED,
    METAL_TEXTURE_FORMAT_NOT_SUPPORTED,
    METAL_CREATE_TEXTURE_FAILED,
    METAL_CREATE_SAMPLER_FAILED,
    METAL_SHADER_COMPILATION_FAILED,
    METAL_SHADER_CREATION_FAILED,
    METAL_SHADER_COMPILATION_OUTPUT,
    METAL_SHADER_ENTRY_NOT_FOUND,
    METAL_CREATE_RPS_FAILED,
    METAL_CREATE_RPS_OUTPUT,
    METAL_CREATE_DSS_FAILED,
    WGPU_BINDGROUPS_POOL_EXHAUSTED,
    WGPU_BINDGROUPSCACHE_SIZE_GREATER_ONE,
    WGPU_BINDGROUPSCACHE_SIZE_POW2,
    WGPU_CREATEBINDGROUP_FAILED,
    WGPU_CREATE_BUFFER_FAILED,
    WGPU_CREATE_TEXTURE_FAILED,
    WGPU_CREATE_TEXTURE_VIEW_FAILED,
    WGPU_CREATE_SAMPLER_FAILED,
    WGPU_CREATE_SHADER_MODULE_FAILED,
    WGPU_SHADER_CREATE_BINDGROUP_LAYOUT_FAILED,
    WGPU_CREATE_PIPELINE_LAYOUT_FAILED,
    WGPU_CREATE_RENDER_PIPELINE_FAILED,
    WGPU_ATTACHMENTS_CREATE_TEXTURE_VIEW_FAILED,
    DRAW_REQUIRED_BINDINGS_OR_UNIFORMS_MISSING,
    IDENTICAL_COMMIT_LISTENER,
    COMMIT_LISTENER_ARRAY_FULL,
    TRACE_HOOKS_NOT_ENABLED,
    DEALLOC_BUFFER_INVALID_STATE,
    DEALLOC_IMAGE_INVALID_STATE,
    DEALLOC_SAMPLER_INVALID_STATE,
    DEALLOC_SHADER_INVALID_STATE,
    DEALLOC_PIPELINE_INVALID_STATE,
    DEALLOC_ATTACHMENTS_INVALID_STATE,
    INIT_BUFFER_INVALID_STATE,
    INIT_IMAGE_INVALID_STATE,
    INIT_SAMPLER_INVALID_STATE,
    INIT_SHADER_INVALID_STATE,
    INIT_PIPELINE_INVALID_STATE,
    INIT_ATTACHMENTS_INVALID_STATE,
    UNINIT_BUFFER_INVALID_STATE,
    UNINIT_IMAGE_INVALID_STATE,
    UNINIT_SAMPLER_INVALID_STATE,
    UNINIT_SHADER_INVALID_STATE,
    UNINIT_PIPELINE_INVALID_STATE,
    UNINIT_ATTACHMENTS_INVALID_STATE,
    FAIL_BUFFER_INVALID_STATE,
    FAIL_IMAGE_INVALID_STATE,
    FAIL_SAMPLER_INVALID_STATE,
    FAIL_SHADER_INVALID_STATE,
    FAIL_PIPELINE_INVALID_STATE,
    FAIL_ATTACHMENTS_INVALID_STATE,
    BUFFER_POOL_EXHAUSTED,
    IMAGE_POOL_EXHAUSTED,
    SAMPLER_POOL_EXHAUSTED,
    SHADER_POOL_EXHAUSTED,
    PIPELINE_POOL_EXHAUSTED,
    PASS_POOL_EXHAUSTED,
    BEGINPASS_ATTACHMENT_INVALID,
    DRAW_WITHOUT_BINDINGS,
    VALIDATE_BUFFERDESC_CANARY,
    VALIDATE_BUFFERDESC_SIZE,
    VALIDATE_BUFFERDESC_DATA,
    VALIDATE_BUFFERDESC_DATA_SIZE,
    VALIDATE_BUFFERDESC_NO_DATA,
    VALIDATE_BUFFERDESC_STORAGEBUFFER_SUPPORTED,
    VALIDATE_BUFFERDESC_STORAGEBUFFER_SIZE_MULTIPLE_4,
    VALIDATE_IMAGEDATA_NODATA,
    VALIDATE_IMAGEDATA_DATA_SIZE,
    VALIDATE_IMAGEDESC_CANARY,
    VALIDATE_IMAGEDESC_WIDTH,
    VALIDATE_IMAGEDESC_HEIGHT,
    VALIDATE_IMAGEDESC_RT_PIXELFORMAT,
    VALIDATE_IMAGEDESC_NONRT_PIXELFORMAT,
    VALIDATE_IMAGEDESC_MSAA_BUT_NO_RT,
    VALIDATE_IMAGEDESC_NO_MSAA_RT_SUPPORT,
    VALIDATE_IMAGEDESC_MSAA_NUM_MIPMAPS,
    VALIDATE_IMAGEDESC_MSAA_3D_IMAGE,
    VALIDATE_IMAGEDESC_MSAA_CUBE_IMAGE,
    VALIDATE_IMAGEDESC_DEPTH_3D_IMAGE,
    VALIDATE_IMAGEDESC_RT_IMMUTABLE,
    VALIDATE_IMAGEDESC_RT_NO_DATA,
    VALIDATE_IMAGEDESC_INJECTED_NO_DATA,
    VALIDATE_IMAGEDESC_DYNAMIC_NO_DATA,
    VALIDATE_IMAGEDESC_COMPRESSED_IMMUTABLE,
    VALIDATE_SAMPLERDESC_CANARY,
    VALIDATE_SAMPLERDESC_ANISTROPIC_REQUIRES_LINEAR_FILTERING,
    VALIDATE_SHADERDESC_CANARY,
    VALIDATE_SHADERDESC_SOURCE,
    VALIDATE_SHADERDESC_BYTECODE,
    VALIDATE_SHADERDESC_SOURCE_OR_BYTECODE,
    VALIDATE_SHADERDESC_NO_BYTECODE_SIZE,
    VALIDATE_SHADERDESC_NO_CONT_UB_MEMBERS,
    VALIDATE_SHADERDESC_UB_SIZE_IS_ZERO,
    VALIDATE_SHADERDESC_UB_METAL_BUFFER_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_UB_METAL_BUFFER_SLOT_COLLISION,
    VALIDATE_SHADERDESC_UB_HLSL_REGISTER_B_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_UB_HLSL_REGISTER_B_COLLISION,
    VALIDATE_SHADERDESC_UB_WGSL_GROUP0_BINDING_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_UB_WGSL_GROUP0_BINDING_COLLISION,
    VALIDATE_SHADERDESC_NO_UB_MEMBERS,
    VALIDATE_SHADERDESC_UB_UNIFORM_GLSL_NAME,
    VALIDATE_SHADERDESC_UB_SIZE_MISMATCH,
    VALIDATE_SHADERDESC_UB_ARRAY_COUNT,
    VALIDATE_SHADERDESC_UB_STD140_ARRAY_TYPE,
    VALIDATE_SHADERDESC_STORAGEBUFFER_METAL_BUFFER_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_STORAGEBUFFER_METAL_BUFFER_SLOT_COLLISION,
    VALIDATE_SHADERDESC_STORAGEBUFFER_HLSL_REGISTER_T_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_STORAGEBUFFER_HLSL_REGISTER_T_COLLISION,
    VALIDATE_SHADERDESC_STORAGEBUFFER_GLSL_BINDING_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_STORAGEBUFFER_GLSL_BINDING_COLLISION,
    VALIDATE_SHADERDESC_STORAGEBUFFER_WGSL_GROUP1_BINDING_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_STORAGEBUFFER_WGSL_GROUP1_BINDING_COLLISION,
    VALIDATE_SHADERDESC_STORAGEBUFFER_READONLY,
    VALIDATE_SHADERDESC_IMAGE_METAL_TEXTURE_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_IMAGE_METAL_TEXTURE_SLOT_COLLISION,
    VALIDATE_SHADERDESC_IMAGE_HLSL_REGISTER_T_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_IMAGE_HLSL_REGISTER_T_COLLISION,
    VALIDATE_SHADERDESC_IMAGE_WGSL_GROUP1_BINDING_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_IMAGE_WGSL_GROUP1_BINDING_COLLISION,
    VALIDATE_SHADERDESC_SAMPLER_METAL_SAMPLER_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_SAMPLER_METAL_SAMPLER_SLOT_COLLISION,
    VALIDATE_SHADERDESC_SAMPLER_HLSL_REGISTER_S_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_SAMPLER_HLSL_REGISTER_S_COLLISION,
    VALIDATE_SHADERDESC_SAMPLER_WGSL_GROUP1_BINDING_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_SAMPLER_WGSL_GROUP1_BINDING_COLLISION,
    VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_IMAGE_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_SAMPLER_SLOT_OUT_OF_RANGE,
    VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_IMAGE_STAGE_MISMATCH,
    VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_SAMPLER_STAGE_MISMATCH,
    VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_GLSL_NAME,
    VALIDATE_SHADERDESC_NONFILTERING_SAMPLER_REQUIRED,
    VALIDATE_SHADERDESC_COMPARISON_SAMPLER_REQUIRED,
    VALIDATE_SHADERDESC_IMAGE_NOT_REFERENCED_BY_IMAGE_SAMPLER_PAIRS,
    VALIDATE_SHADERDESC_SAMPLER_NOT_REFERENCED_BY_IMAGE_SAMPLER_PAIRS,
    VALIDATE_SHADERDESC_ATTR_STRING_TOO_LONG,
    VALIDATE_PIPELINEDESC_CANARY,
    VALIDATE_PIPELINEDESC_SHADER,
    VALIDATE_PIPELINEDESC_NO_CONT_ATTRS,
    VALIDATE_PIPELINEDESC_LAYOUT_STRIDE4,
    VALIDATE_PIPELINEDESC_ATTR_SEMANTICS,
    VALIDATE_ATTACHMENTSDESC_CANARY,
    VALIDATE_ATTACHMENTSDESC_NO_ATTACHMENTS,
    VALIDATE_ATTACHMENTSDESC_NO_CONT_COLOR_ATTS,
    VALIDATE_ATTACHMENTSDESC_IMAGE,
    VALIDATE_ATTACHMENTSDESC_MIPLEVEL,
    VALIDATE_ATTACHMENTSDESC_FACE,
    VALIDATE_ATTACHMENTSDESC_LAYER,
    VALIDATE_ATTACHMENTSDESC_SLICE,
    VALIDATE_ATTACHMENTSDESC_IMAGE_NO_RT,
    VALIDATE_ATTACHMENTSDESC_COLOR_INV_PIXELFORMAT,
    VALIDATE_ATTACHMENTSDESC_DEPTH_INV_PIXELFORMAT,
    VALIDATE_ATTACHMENTSDESC_IMAGE_SIZES,
    VALIDATE_ATTACHMENTSDESC_IMAGE_SAMPLE_COUNTS,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_COLOR_IMAGE_MSAA,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_SAMPLE_COUNT,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_MIPLEVEL,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_FACE,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_LAYER,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_SLICE,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_NO_RT,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_SIZES,
    VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_FORMAT,
    VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE,
    VALIDATE_ATTACHMENTSDESC_DEPTH_MIPLEVEL,
    VALIDATE_ATTACHMENTSDESC_DEPTH_FACE,
    VALIDATE_ATTACHMENTSDESC_DEPTH_LAYER,
    VALIDATE_ATTACHMENTSDESC_DEPTH_SLICE,
    VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_NO_RT,
    VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_SIZES,
    VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_SAMPLE_COUNT,
    VALIDATE_BEGINPASS_CANARY,
    VALIDATE_BEGINPASS_ATTACHMENTS_EXISTS,
    VALIDATE_BEGINPASS_ATTACHMENTS_VALID,
    VALIDATE_BEGINPASS_COLOR_ATTACHMENT_IMAGE,
    VALIDATE_BEGINPASS_RESOLVE_ATTACHMENT_IMAGE,
    VALIDATE_BEGINPASS_DEPTHSTENCIL_ATTACHMENT_IMAGE,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_WIDTH,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_WIDTH_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_HEIGHT,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_HEIGHT_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_SAMPLECOUNT,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_SAMPLECOUNT_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_COLORFORMAT,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_COLORFORMAT_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_DEPTHFORMAT_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_CURRENTDRAWABLE,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_CURRENTDRAWABLE_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_DEPTHSTENCILTEXTURE,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_DEPTHSTENCILTEXTURE_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_MSAACOLORTEXTURE,
    VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_MSAACOLORTEXTURE_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RENDERVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RENDERVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RESOLVEVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RESOLVEVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_DEPTHSTENCILVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_DEPTHSTENCILVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RENDERVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RENDERVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RESOLVEVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RESOLVEVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_DEPTHSTENCILVIEW,
    VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_DEPTHSTENCILVIEW_NOTSET,
    VALIDATE_BEGINPASS_SWAPCHAIN_GL_EXPECT_FRAMEBUFFER_NOTSET,
    VALIDATE_APIP_PIPELINE_VALID_ID,
    VALIDATE_APIP_PIPELINE_EXISTS,
    VALIDATE_APIP_PIPELINE_VALID,
    VALIDATE_APIP_SHADER_EXISTS,
    VALIDATE_APIP_SHADER_VALID,
    VALIDATE_APIP_CURPASS_ATTACHMENTS_EXISTS,
    VALIDATE_APIP_CURPASS_ATTACHMENTS_VALID,
    VALIDATE_APIP_ATT_COUNT,
    VALIDATE_APIP_COLOR_FORMAT,
    VALIDATE_APIP_DEPTH_FORMAT,
    VALIDATE_APIP_SAMPLE_COUNT,
    VALIDATE_ABND_PIPELINE,
    VALIDATE_ABND_PIPELINE_EXISTS,
    VALIDATE_ABND_PIPELINE_VALID,
    VALIDATE_ABND_EXPECTED_VB,
    VALIDATE_ABND_VB_EXISTS,
    VALIDATE_ABND_VB_TYPE,
    VALIDATE_ABND_VB_OVERFLOW,
    VALIDATE_ABND_NO_IB,
    VALIDATE_ABND_IB,
    VALIDATE_ABND_IB_EXISTS,
    VALIDATE_ABND_IB_TYPE,
    VALIDATE_ABND_IB_OVERFLOW,
    VALIDATE_ABND_EXPECTED_IMAGE_BINDING,
    VALIDATE_ABND_IMG_EXISTS,
    VALIDATE_ABND_IMAGE_TYPE_MISMATCH,
    VALIDATE_ABND_EXPECTED_MULTISAMPLED_IMAGE,
    VALIDATE_ABND_IMAGE_MSAA,
    VALIDATE_ABND_EXPECTED_FILTERABLE_IMAGE,
    VALIDATE_ABND_EXPECTED_DEPTH_IMAGE,
    VALIDATE_ABND_EXPECTED_SAMPLER_BINDING,
    VALIDATE_ABND_UNEXPECTED_SAMPLER_COMPARE_NEVER,
    VALIDATE_ABND_EXPECTED_SAMPLER_COMPARE_NEVER,
    VALIDATE_ABND_EXPECTED_NONFILTERING_SAMPLER,
    VALIDATE_ABND_SMP_EXISTS,
    VALIDATE_ABND_EXPECTED_STORAGEBUFFER_BINDING,
    VALIDATE_ABND_STORAGEBUFFER_EXISTS,
    VALIDATE_ABND_STORAGEBUFFER_BINDING_BUFFERTYPE,
    VALIDATE_AUB_NO_PIPELINE,
    VALIDATE_AUB_NO_UB_AT_SLOT,
    VALIDATE_AUB_SIZE,
    VALIDATE_UPDATEBUF_USAGE,
    VALIDATE_UPDATEBUF_SIZE,
    VALIDATE_UPDATEBUF_ONCE,
    VALIDATE_UPDATEBUF_APPEND,
    VALIDATE_APPENDBUF_USAGE,
    VALIDATE_APPENDBUF_SIZE,
    VALIDATE_APPENDBUF_UPDATE,
    VALIDATE_UPDIMG_USAGE,
    VALIDATE_UPDIMG_ONCE,
    VALIDATION_FAILED,
);
/*
    NOTE: on WebGPU, the default color pixel format MUST be provided,
    cannot be a default compile-time constant.
*/
// TODO: this confuses me. color_format default depends on backend, so i guess we're telling 
//       it what the defaults are, not asking for them to be a certain thing? 
//       but these are what's used for "creating render target images", doesn't that mean 
//       you can never use the defaults because it will be randomly different depending on the platform? 
//       i feel like my mental model for whats going on is wrong. 
SgEnvironmentDefaults :: @struct(
    color_format: SgPixelFormat, 
    depth_format := SgPixelFormat.DEPTH_STENCIL,
    sample_count: i32 = 1,
);
SgMetalEnvironment :: @struct(
    device: rawptr,
);
SgD3d11Environment :: @struct(
    device: rawptr,
    device_context: rawptr,
);
SgWgpuEnvironment :: @struct(
    device: rawptr,
);
// you can use app.fr/glue_environment() to get one of these 
// or open a window yourself and gives us the context pointers. 
SgEnvironment :: @struct(
    defaults: SgEnvironmentDefaults = (),
    metal := zeroed SgMetalEnvironment,
    d3d11 := zeroed SgD3d11Environment,
    wgpu := zeroed SgWgpuEnvironment,
);
SgCommitListener :: @struct(
    func: @FnPtr(rawptr) void,
    user_data: rawptr,
);
SgAllocator :: @struct(
    alloc_fn: @FnPtr(usize, rawptr) rawptr,
    free_fn: @FnPtr(rawptr, rawptr) void,
    user_data: rawptr,
);
SgLogger :: @struct(
    func: @FnPtr(CStr, u32, u32, CStr, u32, CStr, rawptr) void,
    user_data: rawptr,
);

SgDesc :: @struct(
    _start_canary: u32 = 0,
    buffer_pool_size: i32 = 128,
    image_pool_size: i32 = 128,
    sampler_pool_size: i32 = 64,
    shader_pool_size: i32 = 32,
    pipeline_pool_size: i32 = 64,
    attachments_pool_size: i32 = 16,
    uniform_buffer_size: i32 = 4 * 1024 * 1024,
    max_dispatch_calls_per_pass: i32 = 1024,
    max_commit_listeners: i32 = 1024,
    disable_validation: bool = false,
    d3d11_shader_debugging := false,
    mtl_force_managed_storage_mode := false,
    mtl_use_command_buffer_with_retained_references := false,
    wgpu_disable_bindgroups_cache := false,
    wgpu_bindgroups_cache_size: i32 = 1024,
    allocator: Alloc,
    //logger: SgLogger,  // TODO :GfxLogging
    environment: SgEnvironment,
    _end_canary: u32 = 0,
);

SgD3d11BufferInfo :: @struct(
    buf: rawptr,
);
SgD3d11ImageInfo :: @struct(
    tex2d: rawptr,
    tex3d: rawptr,
    res: rawptr,
    srv: rawptr,
);
SgD3d11SamplerInfo :: @struct(
    smp: rawptr,
);
SgD3d11ShaderInfo :: @struct(
    cbufs: Array(rawptr, 8),
    vs: rawptr,
    fs: rawptr,
);
SgD3d11PipelineInfo :: @struct(
    il: rawptr,
    rs: rawptr,
    dss: rawptr,
    bs: rawptr,
);
SgD3d11AttachmentsInfo :: @struct(
    color_rtv: Array(rawptr, 4),
    resolve_rtv: Array(rawptr, 4),
    dsv: rawptr,
);
SgMtlBufferInfo :: @struct(
    buf: Array(rawptr, 2),
    active_slot: i32,
);
SgMtlImageInfo :: @struct(
    tex: Array(rawptr, 2),
    active_slot: i32,
);
SgMtlSamplerInfo :: @struct(
    smp: rawptr,
);
SgMtlShaderInfo :: @struct(
    vertex_lib: rawptr,
    fragment_lib: rawptr,
    vertex_func: rawptr,
    fragment_func: rawptr,
);
SgMtlPipelineInfo :: @struct(
    rps: rawptr,
    dss: rawptr,
);
SgWgpuBufferInfo :: @struct(
    buf: rawptr,
);
SgWgpuImageInfo :: @struct(
    tex: rawptr,
    view: rawptr,
);
SgWgpuSamplerInfo :: @struct(
    smp: rawptr,
);
SgWgpuShaderInfo :: @struct(
    vs_mod: rawptr,
    fs_mod: rawptr,
    bgl: rawptr,
);
SgWgpuPipelineInfo :: @struct(
    pip: rawptr,
);
SgWgpuAttachmentsInfo :: @struct(
    color_view: Array(rawptr, 4),
    resolve_view: Array(rawptr, 4),
    ds_view: rawptr,
);
SgGlBufferInfo :: @struct(
    buf: Array(u32, 2),
    active_slot: i32,
);
SgGlImageInfo :: @struct(
    tex: Array(u32, 2),
    tex_target: u32,
    msaa_render_buffer: u32,
    active_slot: i32,
);
SgGlSamplerInfo :: @struct(
    smp: u32,
);
SgGlShaderInfo :: @struct(
    prog: u32,
);
SgGlAttachmentsInfo :: @struct(
    framebuffer: u32,
    msaa_resolve_framebuffer: Array(u32, 4),
);

SshapeRange :: @struct(
    ptr: rawptr,
    size: usize,
);
SshapeMat4 :: @struct(
    m: Array(Array(f32, 4), 4),
);
SshapeVertex :: @struct(
    x: f32,
    y: f32,
    z: f32,
    normal: u32,
    u: u16,
    v: u16,
    color: u32,
);
SshapeElementRange :: @struct(
    base_element: i32,
    num_elements: i32,
);
SshapeSizesItem :: @struct(
    num: u32,
    size: u32,
);
SshapeSizes :: @struct(
    vertices: SshapeSizesItem,
    indices: SshapeSizesItem,
);
SshapeBufferItem :: @struct(
    buffer: SshapeRange,
    data_size: usize,
    shape_offset: usize,
);
SshapeBuffer :: @struct(
    valid: bool,
    vertices: SshapeBufferItem,
    indices: SshapeBufferItem,
);
SshapePlane :: @struct(
    width: f32,
    depth: f32,
    tiles: u16,
    color: u32,
    random_colors: bool,
    merge: bool,
    transform: SshapeMat4,
);
SshapeBox :: @struct(
    width: f32,
    height: f32,
    depth: f32,
    tiles: u16,
    color: u32,
    random_colors: bool,
    merge: bool,
    transform: SshapeMat4,
);
SshapeSphere :: @struct(
    radius: f32,
    slices: u16,
    stacks: u16,
    color: u32,
    random_colors: bool,
    merge: bool,
    transform: SshapeMat4,
);
SshapeCylinder :: @struct(
    radius: f32,
    height: f32,
    slices: u16,
    stacks: u16,
    color: u32,
    random_colors: bool,
    merge: bool,
    transform: SshapeMat4,
);
SshapeTorus :: @struct(
    radius: f32,
    ring_radius: f32,
    sides: u16,
    rings: u16,
    color: u32,
    random_colors: bool,
    merge: bool,
    transform: SshapeMat4,
);
SimguiLogItem :: @enum(i32) (
    OK,
    MALLOC_FAILED,
);
SimguiAllocator :: @struct(
    alloc_fn: @FnPtr(usize, rawptr) rawptr,
    free_fn: @FnPtr(rawptr, rawptr) void,
    user_data: rawptr,
);
SimguiLogger :: @struct(
    func: @FnPtr(CStr, u32, u32, CStr, u32, CStr, rawptr) void,
    user_data: rawptr,
);
SimguiDesc :: @struct(
    max_vertices: i32,
    color_format: SgPixelFormat,
    depth_format: SgPixelFormat,
    sample_count: i32,
    ini_filename: CStr,
    no_default_font: bool,
    disable_paste_override: bool,
    disable_set_mouse_cursor: bool,
    disable_windows_resize_from_edges: bool,
    write_alpha_channel: bool,
    allocator: SimguiAllocator,
    logger: SimguiLogger,
);
SimguiFrameDesc :: @struct(
    width: i32,
    height: i32,
    delta_time: f64,
    dpi_scale: f32,
);
SimguiFontTexDesc :: @struct(
    min_filter: SgFilter,
    mag_filter: SgFilter,
);

SG_INVALID_ID : u32 : 0;
