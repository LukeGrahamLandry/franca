//! Renders a 1-bit ascii art mandelbrot set. 
//! If you like fractals, check out: https://github.com/LukeGrahamLandry/FractalViewer

Pos :: @struct(x: f64, y: f64);

fun init(x: f64, y: f64) Pos = (x = x, y = y); // TODO: can't inline this, it doesn't keep the return type hint. -- May 14
#inline fn add(var a: Pos, var b: Pos) Pos = (x = add(a.x, b.x), y = add(a.y, b.y));
#inline fn sub(var a: Pos, var b: Pos) Pos = (x = sub(a.x, b.x), y = sub(a.y, b.y));
#inline fn div(var a: Pos, var b: Pos) Pos = (x = div(a.x, b.x), y = div(a.y, b.y));
#inline fn mul(var a: Pos, var b: Pos) Pos = (x = mul(a.x, b.x), y = mul(a.y, b.y));

fn mandelbrot(c: Pos, var z: Pos, steps: i64) i64 = {
    var i = 0;
    var zSq = z.mul(z);
    while(=> and(i.lt(steps), zSq.x.add(zSq.y).lt(4.0))) {|
        z.y = z.x.mul(2.0).mul(z.y);
        z.x = zSq.x.sub(zSq.y);
        z += c;
        zSq = z.mul(z);
        i += 1;
    };
    i
}

fn main() Unit = {
    let start = timestamp();
    let max_steps = 45;
    let width = 70;
    let height = 35;
    let x_speed = 0.03;
    let y_speed = 0.06;
    x_start := 0.0.sub(1.5);
    y_start := 0.0.sub(1.0);
    // @InsertConfig
    
    var out: List$u8 = list(width.mul(height));
    var pos: Pos = init(x = x_start, y = y_start);
    range(0, height) {(_: i64)|
        range(0, width) {(_: i64)|
            let steps = mandelbrot(pos, init(x = 0.0, y = 0.0), max_steps);
            if(steps.eq(max_steps)) {|
                out&.push("@".ascii());
            }{|
                out&.push(" ".ascii());
            };
            pos.x = pos.x.add(x_speed);
        };
        
        out&.push_all("|\n");
        pos.x = x_start;
        pos.y = pos.y.add(y_speed); // TODO: fix += with new place expressions. 
    };
    print(out&.items());
    
    let end = timestamp();
    @println("Finished running main() in % milliseconds.", end.sub(start)); 
}

// TODO: add 'fn int_to_float' so i can return answer in seconds like other lang versions
fn timestamp() i64 = {
    const NS_TO_MS = 1000.mul(1000);
    const CLOCK_REALTIME = 0;
    var time_spec: TimeSpec = (seconds = 0, nanoseconds = 0);
    clock_gettime(CLOCK_REALTIME, time_spec&);
    time_spec.seconds.mul(1000).add(time_spec.nanoseconds.div(NS_TO_MS))
}
