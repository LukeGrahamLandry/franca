//! === WARNING === This is not a sandbox! === WARNING ===

#include_std("backend/lib.fr");
#include_std("examples/import_wasm/parse.fr");

// TODO: this could be hella faster: 
//       - there's a wasteful prepass that splits up bits of the module into a big data structure. 
//       - the parser+wasm->ir could be on a different thread from the ir->asm 
//         (i have the machinery to do this already because the Franca compiler works that way)
//         + you could compile multiple functions in parallel (but that would need more work).
//       - the number of bounds checks the parser does per byte is a bit sad. 
//       - the way i deal with adjusting indexes for imports is silly. 
//       - could inline more if we pre-sorted based on callgraph,
//         but maybe the expectation with wasm is that the first compiler did that already?

// TODO: validation
// TODO: tables, vector ops, call_indirect, br_table, br_if, drop, select, memory grow/init/size/copy/fill, data drop,
//       T.eqz, clz, ctz, popcnt, rot, abs, ceil, floor, trunc, nearest, sqrt, min, max, copysign, trunc_sat, some other conversions
//       multiple return values, ref.*
// TODO: nicer api for filling in exports from a franca struct
// TODO: provide standard c api so could run other people's tests? https://github.com/WebAssembly/wasm-c-api/blob/main/include/wasm.h
// TODO: use fill_backend_vtable to toggle between recompiling 
//       and using the host's backend when running as a driver 
//       (see import_c for an example). 

fn main() void = {
    args := cli_args();
    for args { arg | 
        arg := arg.str();
        if arg.ends_with(".wasm") {
            @eprint("Loading '%'", arg);
            bytes := temp().read_to_string_or_crash(arg).items(); // :panic
            @eprintln(" (% bytes).", bytes.len);
            module := QbeModule.zeroed();
            init_default_module(module&, (type = .JitOnly, os = query_current_os(), arch = query_current_arch()), false);
            a := libc_allocator;
            wasm: LoadWasm = (
                m = module&,
                w = empty(a),
                stack = list(a),
                locals = empty(),
                blocks = list(temp()),
            );
            p: ParseWasm = (w = wasm.w&, src = bytes);
            or parse_wasm(p&) { e |
                @panic("% (at byte index %)", e, p.cursor);
            };
            wasm&.load_module();
            
            buf := page_allocator.alloc(u8, wasm.w.memories[0].min.zext() * wasm_page_size);
            wasm_context_pointer := u8.int_from_ptr(buf.ptr);
            
            if p.w.data.len > 0 {
                @assert_eq(p.w.data.len, 1, "TODO: multiple datas");
                data := wasm.w.data[0]&;
                expr := data.active_offset_expr;
                @assert_ne(expr.len, 0, "TODO: passive data");
                off, k := const_eval_wasm_expr(expr.items());
                @debug_assert_eq(k, .Kw, "offset expression");
                buf.subslice(off, data.bytes.len).copy_from(data.bytes.items());
            };
            
            module&.emit_suspended_inlinables();
            module&.put_jit_addr(module&.intern("write$host"), @as(rawptr) fn(ctx: *u8, ptr: u32, len: u32) void = {
                s: []u8 = (ptr = ctx.offset(ptr.zext()), len = len.zext());
                println(s);
            });
            module&.put_jit_addr(module&.intern("putchar$env"), @as(rawptr) fn(ctx: *u8, c: u8) void = {
                s: []u8 = (ptr = c&, len = 1);
                print(s);
            });
            module&.put_jit_addr(module&.intern("puts$env"), @as(rawptr) fn(ctx: *u8, p: u32) void = {
                s: CStr = (ptr = ctx.offset(p.zext()));
                @print("%", s);
            });
            module&.put_jit_addr(module&.intern("labs$env"), @as(rawptr) fn(ctx: *u8, i: i64) i64 = i.abs());
            module&.make_exec();
            
            //n := "module_f1";
            //f := or module&.get_addr(n) {
            //    @panic("couldn't find %()", n)
            //};
            //f := assume_types_fn(Arg = Ty(i64, i32, i32), Ret = i32, ptr = f);
            //pointer := 12;
            //buf[pointer] = 2;
            //result := f(wasm_context_pointer, 5, pointer.intcast());
            //@println("5 - 2 = %", result);
            
            @assert(p.w.exports.len == 1, "TODO: support multiple exports");
            main := p.w.exports[0].id;
            n := wasm.functions[main.zext()];
            f, _ := or module&.get_addr(n) {
                @panic("couldn't find %: %", n, wasm.m.str(n));
            };
            @println("Calling %", wasm.m.str(n));
            f := assume_types_fn(Arg = i64, Ret = void, ptr = f);
            f(wasm_context_pointer);
        };
    };
}

fn const_eval_wasm_expr(expr: []u8) Ty(i64, Qbe.Cls) = {
    o := @as(Wasm.Inst) expr[0];
    @assert(@is(o, .I32_Const, .I64_Const), "TODO: complex expr");
    v, _, ok := read_leb128_signed(expr.rest(1));
    @debug_assert(ok, "bad constant expression");
    (v, @match(o) {
        fn I32_Const() => .Kw;
        fn I64_Const() => .Kl;
        fn F32_Const() => .Ks;
        fn F64_Const() => .Kd;
        @default => @panic("unhandled op in const_eval_wasm_expr");
    })
} 

LoadWasm :: @struct(
    m: *QbeModule,
    w: WasmModule,
    stack: List(Qbe.Ref),
    locals: []Qbe.Ref,  // TODO: we can't store a 128 bit vector in a temporary 
    f := zeroed(*Qbe.Fn),
    src := "",
    cursor := 0,
    module_name := "module",
    global_store := QbeNull,
    data_symbol: []u32 = empty(),
    blk := zeroed(*Qbe.Blk),
    blocks: List(BlockEntry),
    return_types: []Wasm.ValType = empty(),
    link := zeroed(**Qbe.Blk),
    global_names: []u32 = empty(),
    global_cls: []Qbe.Cls = empty(),
    tables: []u32 = empty(),
    functions: []u32 = empty(),
);

fn create_init_func(self: *LoadWasm) void = {
    //f := Qbe.Fn.zeroed();
    //self.f = f&;
    //self.f.default_init(self.m);
    //f.lnk.id = self.m.intern("init");
    //self.f.start = newblk();
    //self.stack&.clear();
    //self.datas = libc_allocator.alloc(u32, self.w.data.len);
    //enumerate self.w.data { i, it |
    //    name := @tfmt("%_f%", self.module_name, local_func_i);    // :WasmNameMangling
    //    self.data_symbol[i] = 
    //};
    //self.f.copy_instructions_from_scratch_reversed_which_means_forwards(self.f.start);
    //self.f.start.jmp.type = .ret0;
    //self.f.nblk = 1;
    //printfn(self.f, self.f.globals.debug_out);
}

preleb :: import("@/backend/wasm/isel.fr").wasm_type_preleb;

fn load_module(self: *LoadWasm) void = {
    self.create_globals();
    self.create_init_func();
    
    enumerate self.w.code& { local_func_i, code | 
        global_func_i := local_func_i + self.w.imported_function_count;
        mark := mark_temporary_storage();
        f := Qbe.Fn.zeroed();
        self.f = f&;
        self.f.default_init(self.m);
        
        f.lnk.id = self.functions[global_func_i];
        
        local_func_type_index := self.w.functions[local_func_i];
        
        local_func_type := self.w.types[local_func_type_index.id.zext()]&;
        self.stack&.clear();
        self.locals = temp().alloc(Qbe.Ref, code.total_local_count + local_func_type.arg.len);
        self.blocks = list(temp());
        self.global_store = self.f.newtmp("wasm_globals", .Kl);
        self.f.emit(.par, .Kl, self.global_store, QbeNull, QbeNull);
        
        // parameters come in as locals not on the stack
        range(0, local_func_type.arg.len) { i |
            k := local_func_type.arg[i].cls();
            self.locals[i] = self.f.newtmp(@tfmt("L%", i), k);
            self.f.emit(.par, k, self.locals[i], QbeNull, QbeNull);
        };
        
        {
            i := local_func_type.arg.len;
            for code.locals& { local |
                k := local.type.cls();
                range(0, local.count) { _ |
                    self.locals[i] = self.f.newtmp(@tfmt("L%", i), k);
                    i += 1;
                };
            };
        };
        
        self.src = code.insts.items();
        self.cursor = 0;
        
        self.link = self.f.start&;
        blk := self.link_new_block();
        end := self.link_new_block();  // TODO: unused
        self.blocks&.push(continue = blk, current = blk, break = end, loop = false);
        self.push_block(preleb(.EmptyBlock).intcast(), false);
        
        self.return_types = local_func_type.ret.items();
        self.emit_the_code();
        //self.end_block();
        //self.emit_return(self.return_types);
        
        self.f.lnk.export = true; // TODO
        
        printfn(self.f, self.f.globals.debug_out);
        //each self.f.globals.debug { d | 
            //d[] = true;
        //};
        run_qbe_passes(self.f);
        reset_temporary_storage(mark);
    };
}

fn create_globals(self: *LoadWasm) void = {
    self.functions = libc_allocator.alloc(u32, self.w.functions.len + self.w.imported_function_count); // :Leak
    f_i := 0;
    each self.w.imports& { import |
        @if_let(import.desc&) fn Function(id) => {
            self.functions[f_i] = self.m.intern(@tfmt("%$%", import.name.items(), import.module.items()));
            f_i += 1;
        };
    };
    @debug_assert_eq(f_i, self.w.imported_function_count);
    range(0, self.w.functions.len) { i |
        self.functions[f_i] = self.m.intern(@tfmt("%_F%", self.module_name, f_i));
        f_i += 1;
    };
    
    // actually, if it's an export it's nicer to use the real names. TODO: same thing for globals
    each self.w.exports& { it |
        ::enum(@type it.type);
        if it.type == .Func {
            self.functions[it.id.zext()] = self.m.intern(@tfmt("%$%", it.name.items(), self.module_name));
        };
    };
    
    self.global_names = libc_allocator.alloc(u32, self.w.globals.len); // :Leak
    self.global_cls = libc_allocator.alloc(Qbe.Cls, self.w.globals.len); // :Leak
    enumerate self.w.globals& { local_global_i, global | 
        // TODO: offset the index by number of imported globals
        id := self.m.intern(@tfmt("%_G%", self.module_name, local_global_i));
        self.global_names[local_global_i] = id;
        create_var(self.m, id) { dat |
            dat.type = @if(global.type == .I32 || global.type == .F32, .DW, .DL);
            value, k := const_eval_wasm_expr(global.init_expr.items());
            dat.u.num = value; 
            self.m.new_emit_data(dat&);
            self.global_cls[local_global_i] = k;
        };
    };
    
    self.tables = libc_allocator.alloc(u32, self.w.tables.len); // :Leak
    enumerate self.w.tables { table_i, table | 
        table_pointer := self.m.intern(@tfmt("%_T%", self.module_name, table_i));
        table_initial := self.m.intern(@tfmt("init__%_T%", self.module_name, table_i));
        
        self.tables[table_i] = table_pointer;
        @assert(table.type == .FuncRef, "TODO: non-func tables");
        
        // Reserve some memory for the starting values in the table. 
        found := false;
        create_var(self.m, table_initial) { dat |
            each self.w.elements { elem | 
                if elem.table.id.zext() == table_i {
                    @assert(!found, "TODO: init multiple parts of a table");
                    found = true;
                    off, k := const_eval_wasm_expr(elem.active_offset_expr.items());
                    @assert_eq(off, 0, "TODO: init table offset non-zero");
                    @assert_ge(elem.funcs.len, table.limits.min.zext(), "TODO: init table < table.min");
                    dat.type = .DL;
                    dat.is_ref = true;
                    for elem.funcs { f_id | 
                        dat.u.ref = (id = self.functions[f_id.id.zext()], off = 0);
                        self.m.new_emit_data(dat&);
                    };
                    dat.is_ref = false;
                };
            };
        };
        @assert(found, "TODO: uninit table");
        
        // Reserve a symbol to hold the address of the table
        create_var(self.m, table_pointer) { dat |
            dat.type = .DL;
            dat.is_ref = true;
            dat.u.ref = (id = table_initial, off = 0);
            self.m.new_emit_data(dat&);
            dat.is_ref = false;
        };
    };
}   

fn create_var(m: *QbeModule, id: u32, $init: @Fn(dat: *Qbe.Dat) void) void = {
    lnk: Qbe.Lnk = (id = id);
    dat := Qbe.Dat.zeroed();
    dat.lnk = lnk&;
    dat.type = .DStart;
    m.new_emit_data(dat&);
    init(dat);
    dat.type = .DEnd;
    m.new_emit_data(dat&);
}

BlockEntry :: @struct(continue: *Qbe.Blk, break: *Qbe.Blk, current: *Qbe.Blk, loop: bool);

fn emit_the_code(self: *LoadWasm) void = {
    IfNode :: @struct(src: *Qbe.Blk, block_type: i64, stack: []Qbe.Ref);
    if_stack := list(IfNode, temp());
    while => self.cursor < self.src.len {
        continue :: local_return;
        
        b := self.src[self.cursor];
        self.cursor += 1;
        inst := @as(Wasm.Inst) b;
        ::enum(Wasm.Inst);
        
        if self.get_blk()[].jmp.type != .Jxxx && !@is(inst, .End, .Unreachable, .Nop) {
            printfn(self.f, self.f.globals.debug_out);
            @panic("more instructions @% which has already been terminated. (TODO: this happens when there is unreachable code after a BR instruction but that is likely not what you wanted anyway)", self.get_blk()[].id);
        };
        
        // Single byte unary/binary instructions are found in the table. 
        encoding := lookup_wasm_encoding(b);
        
        ::enum(@type encoding.kind);
        if encoding.kind != .other {
            a0, a1, r := (QbeNull, QbeNull, QbeNull);
            @match(encoding.kind) {
                fn other() => unreachable();
                fn unary() => {
                    if encoding.op == .truncl {
                        encoding.op = .copy;
                    };
                    r = self.f.newtmp("wasm", encoding.cls);
                    a := self.stack[self.stack.len - 1]&;
                    a0 = a[];
                    a[] = r;
                };
                fn binary() => {
                    r = self.f.newtmp("wasm", encoding.cls);
                    a1 = self.stack[self.stack.len - 1];
                    b := self.stack[self.stack.len - 2]&;
                    self.stack.len -= 1;
                    a0 = b[];
                    b[] = r;
                };
                fn load() => {
                    align := self.read_u();
                    offset := self.read_u();
                    addr := self.stack&.pop().unwrap();
                    addr := self.compute_address(addr, offset.bitcast());
                    
                    result := self.f.newtmp("load", encoding.cls);
                    self.stack&.push(result);
                    a0 = addr; a1 = QbeNull; r = result; 
                };
                fn store() => {
                    align := self.read_u();
                    offset := self.read_u();
                    value := self.stack&.pop().unwrap();
                    addr := self.stack&.pop().unwrap();
                    addr := self.compute_address(addr, offset.bitcast());
                    a0 = value; a1 = addr; r = QbeNull; 
                };
            };
            
            self.f.emit(encoding.op, encoding.cls, r, a0, a1);
            continue();
        }; // Otherwise it's a more complicated instruction. 
        
        @match(inst) {
            fn I32_Const() => self.stack&.push(self.f.getcon(self.read_s()));
            fn I64_Const() => self.stack&.push(self.f.getcon(self.read_s()));
            fn F64_Const() => {
                v := f64.cast_front_unaligned(self.src.rest(self.cursor));
                value: i64 = v.bitcast();
                self.cursor += 8;
                self.stack&.push(self.f.getcon(value));
            }
            fn F32_Const() => {
                v := f32.cast_front_unaligned(self.src.rest(self.cursor));
                value: i64 = (@as(u32) v.bitcast()).zext();
                self.cursor += 4;
                self.stack&.push(self.f.getcon(value));
            }
            fn LocalGet() => self.local_inst(1);
            fn LocalSet() => self.local_inst(-1);
            fn LocalTee() => self.local_inst(0);
            fn CallIndirect() => {
                type_index       := self.read_u();
                table_index      := self.read_u();
                index_in_table_W := self.stack&.pop().expect("call index on stack");
                table_var        := self.tables[table_index.bitcast()];
                table_var        := self.f.symcon(table_var);
                callee           := self.f.newtmp("Icallee", .Kl);
                index_in_table_L := self.f.newtmp("Iindex", .Kl);
                table_slot       := self.f.newtmp("Islot", .Kl);
                table_offset     := self.f.newtmp("Ioff", .Kl);
                table_base       := self.f.newtmp("Ibase", .Kl);
                
                self.f.emit(.load, .Kl, table_base, table_var, QbeNull);
                self.f.emit(.extuw, .Kl, index_in_table_L, index_in_table_W, QbeNull);
                self.f.emit(.mul, .Kl, table_offset, index_in_table_L, self.f.getcon(8));
                self.f.emit(.add, .Kl, table_slot, table_base, table_offset);
                self.f.emit(.load, .Kl, callee, table_slot, QbeNull);
                
                self.emit_call_from_stack(callee, (id = type_index.trunc()));
            }
            fn Call() => {
                callee := self.read_index(Wasm.FuncIdx);
                import := self.w&.find_import_index(0, callee.id.zext());
                ::if(Wasm.TypeIdx);
                type_index := if import.is_some() {
                    import := self.w.imports&.index(import.Some);
                    import.desc.Function
                } else {
                    self.w.functions[callee.id.zext() - self.w.imported_function_count]
                };
                callee := self.remap_global_func(callee.id.zext());
                self.emit_call_from_stack(callee, type_index);
            }
            fn Return() => self.emit_return(self.return_types);
            fn GlobalSet() => {
                i: i64 = self.read_u().bitcast();
                g := self.f.symcon(self.global_names[i]);
                val := self.stack&.pop().expect("enough stack");
                k := self.global_cls[i];
                o := store_ops[k.raw().zext()];
                self.f.emit(o, .Kw, QbeNull, val, g); 
            }
            fn GlobalGet() => {
                i: i64 = self.read_u().bitcast();
                g := self.f.symcon(self.global_names[i]);
                k := self.global_cls[i];
                val := self.f.newtmp("global_get", k);
                self.stack&.push(val);
                self.f.emit(.load, k, val, g, QbeNull);
            }
            fn VectorPrefix() => panic("Vector instructions are not supported (0xFD prefix)");
            fn Nop() => ();
            fn Unreachable() => if self.get_blk()[].jmp.type == .Jxxx {
                self.get_blk()[].jmp.type = .hlt;
            };
            fn Loop() => {
                block_type := self.read_s();  // TODO: use this for something. 
                self.push_block(block_type, true);
                self.phi_to_stack(self.get_blk());
            }
            fn Block() => {
                block_type := self.read_s();  // TODO: use this for something. 
                self.push_block(block_type, false);
                self.phi_to_stack(self.get_blk());
            }
            fn End() => self.end_block();
            fn If() => {
                block_type := self.read_s();  // TODO: use this for something. 
                old := self.get_blk();
                old.jmp = (type = .jnz, arg = self.stack&.pop().expect("arg on stack for If"));
                // :NoIfInputsYet , stack = self.stack.items().clone(temp()).items());
                if_stack&.push(src = old, block_type = block_type, stack = empty()); 
                self.push_block(block_type, false);
                self.phi_to_stack(self.get_blk());
                old.s1 = self.get_blk();
            }
            fn Else() => {
                self.end_block();
                if_node := if_stack&.pop().expect("Else only inside If");
                // :NoIfInputsYet self.stack = assume_owned(if_node.stack, temp());
                self.push_block(if_node.block_type, false);
                self.phi_to_stack(self.get_blk());
                if_node.src.s2 = self.get_blk();
            }
            fn Br() => {
                depth: i64 = self.read_u().bitcast();
                target := self.blocks.len - depth - 1; 
                @debug_assert_lt(target, self.blocks.len, "Br index too high");
                self.get_blk()[].jmp.type = .jmp;
                it := self.blocks[target];
                self.get_blk()[].s1 = @if(it.loop, it.continue, it.break);
                self.stack_to_phi(self.get_blk(), self.get_blk()[].s1);
            }
            fn BrIf() => {
                depth: i64 = self.read_u().bitcast();
                target := self.blocks.len - depth - 1; 
                
                it         := self.blocks[target];
                dest       := @if(it.loop, it.continue, it.break);
                block_type := dest.visit.intcast();
                if_block := self.get_blk();
                if_block.jmp = (type = .jnz, arg = self.stack&.pop().expect("arg on stack for If"));
                stack := self.stack.items().clone(temp());
                self.stack_to_phi(if_block, dest);
                if_block.s1 = dest;
                
                new := self.link_new_block();
                new.visit = preleb(.EmptyBlock);
                block_entry := self.blocks[self.blocks.len - 1]&;
                self.f.copy_instructions_from_scratch_reversed_which_means_forwards(block_entry.current);
                block_entry.current = new;
                if_block.s2 = new;
                self.stack = stack;
            }
            fn Drop() => {
                self.stack&.pop().unwrap();
            }
            @default => {
                @panic("unhandled unstruction %", self.src[self.cursor - 1]);
            };
        };
    };
}

fn stack_to_phi(self: *LoadWasm, src: *Qbe.Blk, dest: *Qbe.Blk) void = {
    arg_types, _ := self.decode_block_type(dest.visit.intcast());
    if(arg_types.len == 0, => return());
    if dest.phi.is_null() {
        init_empty_phis(self.f, dest.phi&, arg_types);
    };
    for_phi dest { p |
        p.push(src, self.stack&.pop() || @panic("missing value for phi % -> % %", src.id, dest.id, { printfn(self.f, self.f.globals.debug_out); ""}));
    };
}

fn phi_to_stack(self: *LoadWasm, b: *Qbe.Blk) void = {
    arg_types, _ := self.decode_block_type(b.visit.intcast());
    if(arg_types.len == 0, => return());
    if b.phi.is_null() {
        init_empty_phis(self.f, b.phi&, arg_types);
    };
    for_phi_rev_TODOSLOW b { p |
        self.stack&.push(p.to);
    };
}

fn init_empty_phis(f: *Qbe.Fn, link: **Qbe.Phi, arg_types: []Wasm.ValType) void = {
    for_rev arg_types { ty |
        link[] = temp().box_zeroed(Qbe.Phi);
        link.cls = ty.cls();
        link.to = f.newtmp("join", link.cls);
        link.arg = new(1);
        link.blk = new(1);
        
        link = link.link&;
    };
}

fn decode_block_type(self: *LoadWasm, block_type: i64) Ty([]Wasm.ValType, []Wasm.ValType) = {
    if block_type >= 0 {
        ty := self.w.types[block_type]&;
        return(ty.arg.items(), ty.ret.items());
    };
    if block_type == preleb(.EmptyBlock).intcast() {
        return(empty(), empty());
    };
    
    // :SLOW
    values :: get_cases(Wasm.ValType);
    each values { it |
        if block_type == preleb(it[]).intcast() {
            return(empty(), (ptr = it, len = 1));
        };
    };
    
    @panic("invalid block type %", block_type)
}

fn get_blk(self: *LoadWasm) *Qbe.Blk =
    self.blocks[self.blocks.len - 1].current;

fn push_block(self: *LoadWasm, block_type: i64, loop: bool) void = {
    arg, ret := self.decode_block_type(block_type);
    ::enum(Wasm.ValType);  ::DerefEq(Wasm.ValType);
    
    old := self.blocks[self.blocks.len - 1]&;
    new := self.link_new_block();
    new.visit = block_type.intcast();
    self.stack_to_phi(old.current, new);
    self.f.copy_instructions_from_scratch_reversed_which_means_forwards(old.current);
    continuation := self.link_new_block();
    continuation.visit = preleb(.EmptyBlock);
    self.blocks&.push(continue = new, break = continuation, current = new, loop = loop);
    if old.current.jmp.type == .Jxxx {
        old.current.jmp.type = .jmp;
        old.current.s1 = self.get_blk();
    };
    old.current = continuation;
}

fn end_block(self: *LoadWasm) void = {
    it := self.blocks&.pop().expect("well nested End instructions");
    self.f.copy_instructions_from_scratch_reversed_which_means_forwards(it.current);
    if it.current.jmp.type == .Jxxx {
        it.current.jmp.type = .jmp;
        it.current.s1 = it.break;
    };
    it.current = zeroed(*Qbe.Blk);
    self.blocks[self.blocks.len - 1].current = it.break;
}

fn link_new_block(self: *LoadWasm) *Qbe.Blk = {
    b := newblk();
    b.id = self.f.nblk;
    self.f.nblk += 1;
    self.link[] = b; 
    self.link = b.link&;
    b
}

fn compute_address(self: *LoadWasm, addr: Qbe.Ref, offset: i64) Qbe.Ref = {
    f := self.f;
    r0 := f.newtmp("a", .Kl);
    r1 := f.newtmp("a", .Kl);
    r2 := f.newtmp("a", .Kl);
    f.emit(.extuw, .Kl, r0, addr, QbeNull);
    f.emit(.add, .Kl, r1, self.global_store, r0);
    f.emit(.add, .Kl, r2, r1, f.getcon(offset));
    r2
}

fn local_inst(self: *LoadWasm, delta: i64) void = {
    i    := self.read_u();
    var  := self.locals[i.bitcast()];
    t    := self.f.get_temporary(var);
    dest := if(delta == 1, => self.f.newtmp(@tfmt("getL%", i), t.cls), => var);
    src  := if(delta == 1, => var, => self.stack[self.stack.len - 1]);
    self.stack&.reserve(abs(delta));
    self.stack.len += delta;
    if delta == 1 {
        @debug_assert(self.stack.len > 0, "tried to access empty stack in local_inst");
        self.stack[self.stack.len - 1] = dest;
    };
    self.f.emit(.copy, t.cls, dest, src, QbeNull);
}

fn emit_return(self: *LoadWasm, return_types: []Wasm.ValType) void = {
    @debug_assert(self.get_blk()[].jmp.type == .Jxxx, "tried to return from terminated block");
    @switch(return_types.len) {
        @case(0) => {
            self.get_blk()[].jmp.type = .ret0;
        };
        @case(1) => {
            r := @as(Qbe.J) @as(i32) Qbe.J.retw.raw() + return_types[0].cls().raw();
            self.get_blk()[].jmp = (type = r, arg = self.stack[self.stack.len - 1]);
            self.stack.len -= 1;
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn emit_call_from_stack(self: *LoadWasm, callee: Qbe.Ref, type: Wasm.TypeIdx) void = {
    type := self.w.types[type.id.zext()]&;
    @assert_le(type.arg.len, self.stack.len, "not enough stack for call");
    
    self.f.emit(.arg, .Kl, QbeNull, self.global_store, QbeNull);
    range(0, type.arg.len) { i |
        ref := self.stack[self.stack.len - type.arg.len + i];
        k := type.arg[i].cls();
        self.f.emit(.arg, k, QbeNull, ref, QbeNull);
    };
    self.stack.len -= type.arg.len;
    @switch(type.ret.len) {
        @case(0) => {
            self.f.emit(.call, .Kw, QbeNull, callee, QbeNull);
        };
        @case(1) => {
            k := type.ret[0].cls();
            ref := self.f.newtmp("ret", k);
            self.f.emit(.call, k, ref, callee, QbeNull);
            self.stack&.push(ref);
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn remap_global_func(self: *LoadWasm, id: i64) Qbe.Ref = 
    self.f.symcon(self.functions[id]);

// TODO: this is stupid. store them in seperate arrays. surely you never need to refer to them by an untyped import index. 
fn find_import_index(self: *WasmModule, kind: i64, id: i64) ?i64 = {
    i := 0;
    each self.imports& { check | 
        ::tagged(@type check.desc);
        if check.desc&.tag().raw() == kind {
            if i == id {
                return(Some = i);
            };
            i += 1;
        };
    };
    .None
}

// (dest_offset, src_offset_in_data, size_to_copy)  // TODO: make sure those arguments are right
fn emit_memory_init(self: *WasmModule, data_id: i64) void = {
    todo()
}
