#include_std("backend/lib.fr");
#include_std("examples/import_wasm/parse.fr");
use_threads :: false;

// TODO: this could be hella faster: 
//       - there's a wasteful prepass that splits up bits of the module into a big data structure. 
//       - the parser+wasm->ir could be on a different thread from the ir->asm 
//         (i have the machinery to do this already because the Franca compiler works that way)
//         + you could compile multiple functions in parallel (but that would need more work).
//       - the number of bounds checks the parser does per byte is a bit sad. 
//       - the way i deal with adjusting indexes for imports is silly. 
//       - could inline more if we pre-sorted based on callgraph,
//         but maybe the expectation with wasm is that the first compiler did that already?

fn main() void = {
    args := cli_args();
    for args { arg | 
        arg := arg.str();
        if arg.ends_with(".wasm") {
            @eprint("Loading '%'", arg);
            bytes := temp().read_to_string(arg).items(); // :panic
            @eprintln(" (% bytes).", bytes.len);
            xx := query_current_arch();
            module := QbeModule.zeroed();
            init_default_module(module&, (type = .JitOnly, os = query_current_os(), arch = xx.unwrap()), false);
            a := libc_allocator;
            wasm: LoadWasm = (
                m = module&,
                w = empty(a),
                stack = list(a),
                locals = empty(),
                referenced_globals = init(temp()),
                blocks = list(temp()),
            );
            p: ParseWasm = (w = wasm.w&, src = bytes);
            or parse_wasm(p&) { e |
                @panic("% (at byte index %)", e, p.cursor);
            };
            wasm&.load_module();
            
            buf := page_allocator.alloc(u8, wasm.w.memories[0].min.zext() * wasm_page_size);
            wasm_context_pointer := u8.int_from_ptr(buf.ptr);
            
            {
                @assert_eq(p.w.data.len, 1, "TODO: multiple datas");
                data := wasm.w.data[0]&;
                expr := data.active_offset_expr;
                @assert_ne(expr.len, 0, "TODO: passive data");
                off, k := const_eval_wasm_expr(expr.items());
                @debug_assert_eq(k, .Kw, "offset expression");
                buf.subslice(off, data.bytes.len).copy_from(data.bytes.items());
            };
            
            module&.emit_suspended_inlinables();
            module&.put_jit_addr(module&.intern("write$host"), @as(rawptr) fn(ctx: *u8, ptr: u32, len: u32) void = {
                s: []u8 = (ptr = ctx.offset(ptr.zext()), len = len.zext());
                println(s);
            });
            module&.make_exec();
            
            n := "module_f1";
            f := or module&.get_addr(n) {
                @panic("couldn't find %()", n)
            };
            f := assume_types_fn(Arg = Ty(i64, i32, i32), Ret = i32, ptr = f);
            result := f(wasm_context_pointer, 5, 2);
            @println("5 - 2 = %", result);
            
            n := "module_f2";
            f := or module&.get_addr(n) {
                @panic("couldn't find %()", n)
            };
            f := assume_types_fn(Arg = i64, Ret = void, ptr = f);
            f(wasm_context_pointer);
        };
    };
}

fn const_eval_wasm_expr(expr: []u8) Ty(i64, Qbe.Cls) = {
    @assert_eq(expr[0], @as(u8) Wasm.Inst.I32_Const, "TODO: complex expr");
    v, _, ok := read_leb128_unsigned(expr.rest(1));
    @debug_assert(ok, "bad constant expression");
    (v.bitcast(), .Kw)
} 

LoadWasm :: @struct(
    m: *QbeModule,
    w: WasmModule,
    stack: List(Qbe.Ref),
    locals: []Qbe.Ref,  // TODO: we can't store a 128 bit vector in a temporary 
    f := zeroed(*Qbe.Fn),
    src := "",
    cursor := 0,
    referenced_globals: HashMap(i64, Qbe.Ref), 
    module_name := "module",
    global_store := QbeNull,
    data_symbol: []u32 = empty(),
    blk := zeroed(*Qbe.Blk),
    blocks: List(*Qbe.Blk),
    return_types: []Wasm.ValType = empty(),
    link := zeroed(**Qbe.Blk),
    global_names: []u32 = empty(),
);

fn create_init_func(self: *LoadWasm) void = {
    //f := Qbe.Fn.zeroed();
    //self.f = f&;
    //self.f.default_init(self.m);
    //f.lnk.id = self.m.intern("init");
    //self.f.start = newblk();
    //self.stack&.clear();
    //self.datas = libc_allocator.alloc(u32, self.w.data.len);
    //enumerate self.w.data { i, it |
    //    name := @tfmt("%_f%", self.module_name, local_func_i);    // :WasmNameMangling
    //    self.data_symbol[i] = 
    //};
    //self.f.copy_instructions_from_scratch_reversed_which_means_forwards(self.f.start);
    //self.f.start.jmp.type = .ret0;
    //self.f.nblk = 1;
    //printfn(self.f, self.f.globals.debug_out);
}

fn load_module(self: *LoadWasm) void = {
    self.create_globals();
    self.create_init_func();
    
    enumerate self.w.code& { local_func_i, code | 
        global_func_i := local_func_i + self.w.imported_function_count;
        mark := mark_temporary_storage();
        f := Qbe.Fn.zeroed();
        self.f = f&;
        self.f.default_init(self.m);
        
        name := @tfmt("%_f%", self.module_name, global_func_i);    // :WasmNameMangling
        self.f.name&.items().slice(0, name.len).copy_from(name);  // :UnacceptablePanic
        f.lnk.id = self.m.intern(name);
        
        local_func_type_index := self.w.functions[local_func_i];
        
        local_func_type := self.w.types[local_func_type_index.id.zext()]&;
        self.stack&.clear();
        self.locals = temp().alloc(Qbe.Ref, code.total_local_count + local_func_type.arg.len);
        self.referenced_globals = init(temp());
        self.blocks = list(temp());
        self.global_store = self.f.newtmp("wasm_globals", .Kl);
        self.f.emit(.par, .Kl, self.global_store, QbeNull, QbeNull);
        
        // parameters come in as locals not on the stack
        range(0, local_func_type.arg.len) { i |
            k := local_func_type.arg[i].cls();
            self.locals[i] = self.f.newtmp("param", k);
            self.f.emit(.par, k, self.locals[i], QbeNull, QbeNull);
        };
        
        {
            i := local_func_type.arg.len;
            for code.locals& { local |
                k := local.type.cls();
                range(0, local.count) { _ |
                    self.locals[i] = self.f.newtmp("local", k);
                    i += 1;
                };
            };
        };
        
        self.src = code.insts.items();
        self.cursor = 0;
        
        self.link = self.f.start&;
        self.blk = self.link_new_block();
        self.blocks&.push(self.blk);
        self.push_block();
        
        self.return_types = local_func_type.ret.items();
        self.emit_the_code();
        self.emit_return(self.return_types);
        
        self.f.lnk.export = true; // TODO
        
        //printfn(self.f, self.f.globals.debug_out);
        each self.f.globals.debug { d | 
            d[] = true;
        };
        if typecheck_failed(self.f) { err | 
            printfn(self.f, self.f.globals.debug_out);
            @panic("IR failed typecheck: %", err);
        };
        run_qbe_passes(self.f);
        reset_temporary_storage(mark);
    };
}

fn create_globals(self: *LoadWasm) void = {
    self.global_names = libc_allocator.alloc(u32, self.w.globals.len); // :Leak
    enumerate self.w.globals& { local_global_i, global | 
        // TODO: offset the index by number of imported globals
        id := self.m.intern(@tfmt("%_G%", self.module_name, local_global_i));
        self.global_names[local_global_i] = id;
        lnk: Qbe.Lnk = (id = id);
        dat := Qbe.Dat.zeroed();
        dat.lnk = lnk&;
        dat.type = .DStart;
        self.m.emit_data_to_segment(dat&);
        dat.type = @if(global.type == .I32 || global.type == .F32, .DW, .DL);
        self.m.emit_data_to_segment(dat&);
        dat.type = .DEnd;
        self.m.emit_data_to_segment(dat&);
    };
}   

fn push_block(self: *LoadWasm) *Qbe.Blk = {
    old := self.blocks&.pop().expect("a block on the stack");
    self.f.copy_instructions_from_scratch_reversed_which_means_forwards(old);
    self.blk = self.link_new_block();
    continuation := self.link_new_block();
    self.blocks&.push(continuation);
    self.blocks&.push(self.blk);
    if old.jmp.type == .Jxxx {
        old.jmp.type = .jmp;
        old.s1 = self.blk;
    };
    old
}

fn link_new_block(self: *LoadWasm) *Qbe.Blk = {
    b := newblk();
    @if(TRACK_IR_NAMES) {
        l := fixed_list(b.name&.items()); // :UnacceptablePanic
        @fmt(l&, "%", self.f.nblk);
    };
    self.f.nblk += 1;
    self.link[] = b; 
    self.link = b.link&;
    b
}

fn seal_current_block(self: *LoadWasm) *Qbe.Blk = {
    old := self.blocks&.pop().expect("a block on the stack");
    self.f.copy_instructions_from_scratch_reversed_which_means_forwards(old);
    self.f.nblk += 1;
    self.blk = newblk();
    old.link = self.blk;
    self.blocks&.push(self.blk);
    old
}

fn emit_the_code(self: *LoadWasm) void = {
    while => self.cursor < self.src.len {
        continue :: local_return;
        //@println("inst %", self.src[self.cursor]);
        
        inst := self.src[self.cursor];
        self.cursor += 1;
        
        // Single byte unary/binary instructions are found in the table. 
        encoding := lookup_wasm_encoding(inst);
        a0, a1, r := (QbeNull, QbeNull, QbeNull);
        ::enum(@type encoding.kind);
        @match(encoding.kind) {
            fn other() => ();
            fn unary() => {
                r = self.f.newtmp("wasm", encoding.cls);
                a := self.stack[self.stack.len - 1]&;
                a0 = a[];
                a[] = r;
            };
            fn binary() => {
                r = self.f.newtmp("wasm", encoding.cls);
                a0 = self.stack[self.stack.len - 1];
                b := self.stack[self.stack.len - 2]&;
                self.stack.len -= 1;
                a1 = b[];
                b[] = r;
            };
            fn load() => {
                align := self.read_u();
                offset := self.read_u();
                panic("TODO: wasm load"); 
                self.stack&.pop().unwrap();
                self.stack&.push(QbeNull);
                continue(); // TODO
            };
            fn store() => {
                align := self.read_u();
                offset := self.read_u();
                value := self.stack&.pop().unwrap();
                addr := self.stack&.pop().unwrap();
                addr := self.compute_address(addr, offset.bitcast());
                self.f.emit(encoding.op, encoding.cls, QbeNull, value, addr);
                continue(); // TODO
            };
        };
        
        if encoding.kind != .other {
            @debug_assert(r != QbeNull || a0 != QbeNull);
            self.f.emit(encoding.op, encoding.cls, r, a0, a1);
            continue();
        };
        
        // Otherwise it's a more complicated instruction. 
        inst := @as(Wasm.Inst) inst;
        ::enum(Wasm.Inst);
        @switch(inst) {
            @case(.I32_Const) => {
                value := self.read_u();
                self.stack&.push(self.f.getcon(value.bitcast()));
            };
            @case(.I64_Const) => {
                value := self.read_u();
                self.stack&.push(self.f.getcon(value.bitcast()));
            };
            @case(.LocalGet) => self.local_inst(1);
            @case(.LocalSet) => self.local_inst(-1);
            @case(.LocalTee) => self.local_inst(0);
            @case(.Call) => {
                callee := self.read_index(FuncIdx);
                @println("% func", callee.id);
                import := self.w&.find_import_index(0, callee.id.zext());
                ::if(TypeIdx);
                type_index := if import.is_some() {
                    import := self.w.imports&.index(import.Some);
                    import.desc.Function
                } else {
                    self.w.functions[callee.id.zext() - self.w.imported_function_count]
                };
                callee := self.remap_global(0, callee.id.zext());
                self.emit_call_from_stack(callee, type_index);
                println("call!");
            };
            @case(.Return) => {
                self.emit_return(self.return_types);
            };
            @case(.End) => {
                current := self.blocks&.pop().expect("well nested End instructions");
                continuation := self.blocks[self.blocks.len - 1];
                self.f.copy_instructions_from_scratch_reversed_which_means_forwards(current);
                if current.jmp.type == .Jxxx {
                    current.jmp.type = .jmp;
                    current.s1 = continuation;
                };
                self.blk = continuation;
            };
            @case(.GlobalSet) => {
                i: i64 = self.read_u().bitcast();
                g := self.f.symcon(self.global_names[i]);
                val := self.stack&.pop().expect("enough stack");
                self.f.emit(.storew, .Kw, QbeNull, val, g); // TODO: other types!
            };
            @case(.GlobalGet) => {
                i: i64 = self.read_u().bitcast();
                g := self.f.symcon(self.global_names[i]);
                k := Qbe.Cls.Kw; // TODO: other types
                val := self.f.newtmp("global_get", k);
                self.stack&.push(val);
                self.f.emit(.load, k, val, g, QbeNull);
            };
            @case(.VectorPrefix) => panic("Vector instructions are not supported (0xFD prefix)");
            @case(.Nop) => ();
            @case(.Unreachable) => {
                self.blk.jmp.type = .hlt;
                // TODO: stop doing anything else in this block
            };
            @case(.Loop) => {
                block_type := self.read_s();  // TODO: use this for something. 
                self.push_block();
            };
            @default => {
                @panic("unhandled unstruction %", self.src[self.cursor - 1]);
            };
        };
    };
}


fn compute_address(self: *LoadWasm, addr: Qbe.Ref, offset: i64) Qbe.Ref = {
    f := self.f;
    r0 := f.newtmp("a", .Kl);
    r1 := f.newtmp("a", .Kl);
    r2 := f.newtmp("a", .Kl);
    f.emit(.extuw, .Kl, r0, addr, QbeNull);
    f.emit(.add, .Kl, r1, self.global_store, r0);
    f.emit(.add, .Kl, r2, r1, f.getcon(offset));
    r2
}

fn local_inst(self: *LoadWasm, delta: i64) void = {
    i    := self.read_u();
    var  := self.locals[i.bitcast()];
    t    := self.f.get_temporary(var);
    dest := if(delta == 1, => self.f.newtmp("get", t.cls), => var);
    src  := if(delta == 1, => var, => self.stack[self.stack.len - 1]);
    self.stack&.reserve(abs(delta));
    self.stack.len += delta;
    if delta == 1 {
        @debug_assert(self.stack.len > 0, "tried to access empty stack in local_inst");
        self.stack[self.stack.len - 1] = dest;
    };
    self.f.emit(.copy, t.cls, dest, src, QbeNull);
}

fn emit_return(self: *LoadWasm, return_types: []Wasm.ValType) void = {
    @debug_assert(self.blk.jmp.type == .Jxxx, "tried to return from terminated block");
    @switch(return_types.len) {
        @case(0) => {
            self.blk.jmp.type = .ret0;
        };
        @case(1) => {
            @assert(return_types[0].cls() == .Kw, "// TODO: correct cls");
            self.blk.jmp = (type = .retw, arg = self.stack[self.stack.len - 1]);
            self.stack.len -= 1;
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn emit_call_from_stack(self: *LoadWasm, callee: Qbe.Ref, type: TypeIdx) void = {
    @println("% type", type.id);
    type := self.w.types[type.id.zext()]&;
    @assert_le(type.arg.len, self.stack.len, "not enough stack for call");
    
    self.f.emit(.arg, .Kl, QbeNull, self.global_store, QbeNull);
    range(0, type.arg.len) { i |
        ref := self.stack[self.stack.len - type.arg.len + i];
        k := type.arg[i].cls();
        self.f.emit(.arg, k, QbeNull, ref, QbeNull);
    };
    self.stack.len -= type.arg.len;
    @switch(type.ret.len) {
        @case(0) => {
            self.f.emit(.call, .Kw, QbeNull, callee, QbeNull);
        };
        @case(1) => {
            ref := self.f.newtmp("ret", type.ret[0].cls());
            self.f.emit(.call, .Kw, ref, callee, QbeNull);
            self.stack&.push(ref);
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn remap_global(self: *LoadWasm, kind: i64, id: i64) Qbe.Ref = {
    @debug_assert(kind < 4, "remap_global");
    key := kind.shift_left(32).bit_or(id);
    if self.referenced_globals&.get(key) { local | 
        return(local);
    };
    ref: Qbe.Ref = @switch(key) {
        @case(0) => { // func 
            import := self.w&.find_import_index(kind, id);
            name := if import.is_some() {
                // TODO: no this doesn't make any since, the binding of names should happen separately. 
                import := self.w.imports&.index(import.Some);
                @tfmt("%$%", import.name.items(), import.module.items())
            } else {
                // :WasmNameMangling
                @tfmt("%_f%", self.module_name, id)
            };
            id := self.m.intern(name);
            self.f.unique_named_con(id, 0)
        };
        @default => panic("TODO: remap global to local ref");
    };
    self.referenced_globals&.insert(key, ref);
    ref
}

// TODO: this is stupid. store them in seperate arrays. surely you never need to refer to them by an untyped import index. 
fn find_import_index(self: *WasmModule, kind: i64, id: i64) ?i64 = {
    i := 0;
    each self.imports& { check | 
        ::tagged(@type check.desc);
        if check.desc&.tag().raw() == kind {
            if i == id {
                return(Some = i);
            };
            i += 1;
        };
    };
    .None
}

// (dest_offset, src_offset_in_data, size_to_copy)  // TODO: make sure those arguments are right
fn emit_memory_init(self: *WasmModule, data_id: i64) void = {
    todo()
}
