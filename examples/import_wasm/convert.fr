#include_std("backend/lib.fr");
#include_std("examples/import_wasm/parse.fr");

// TODO: this could be hella faster: 
//       - there's a wasteful prepass that splits up bits of the module into a big data structure. 
//       - the parser+wasm->ir could be on a different thread from the ir->asm + you could compile multiple functions in parallel,
//         but that requires more careful use of temp() which will be easier once i implement thread locals in Franca. 
//       - the number of bounds checks the parser does per byte is a bit sad. 
//       - the way i deal with adjusting indexes for imports is silly. 
//       - could inline more if we pre-sorted based on callgraph,
//         but maybe the expectation with wasm is that the first compiler did that already?

fn main() void = {
    panic("TODO: need to set f.lnk.id to intern(name)");
    args := cli_args();
    for args { arg | 
        arg := arg.str();
        if arg.ends_with(".wasm") {
            @eprint("Loading '%'", arg);
            bytes := temp().read_to_string(arg).items(); // :panic
            @eprintln(" (% bytes).", bytes.len);
            xx := query_current_arch();
            module := init_default_module(type = .JitOnly, os = query_current_os(), arch = xx.unwrap());
            a := libc_allocator;
            wasm: LoadWasm = (
                m = module&,
                w = empty(a),
                stack = list(a),
                locals = empty(),
                referenced_globals = init(temp()),
            );
            p: ParseWasm = (w = wasm.w&, src = bytes);
            or parse_wasm(p&) { e |
                @panic("% (at byte index %)", e, p.cursor);
            };
            wasm&.load_module();
            
            module&.emit_suspended_inlinables();
            module&.make_exec();
            f := or module&.get_addr("module_f2") {
                panic("couldn't find module_f2()")
            };
            f := assume_types_fn(Arg = Ty(i64, i32, i32), Ret = i32, ptr = f);
            wasm_context_pointer := 0;
            result := f(wasm_context_pointer, 1, 2);
            @println("1 + 2 = %", result);
        };
    };
}

LoadWasm :: @struct(
    m: *QbeModule,
    w: Wasm.Module,
    stack: List(Qbe.Ref),
    locals: []Qbe.Ref,  // TODO: we can't store a 128 bit vector in a temporary 
    f := zeroed(*Qbe.Fn),
    src := "",
    cursor := 0,
    referenced_globals: HashMap(i64, Qbe.Ref), 
    module_name := "module",
    global_store := QbeNull,
    data_symbol: []u32 = empty(),
    blk := zeroed(*Qbe.Blk),
);

fn create_init_func(self: *LoadWasm) void = {
    //f := Qbe.Fn.zeroed();
    //self.f = f&;
    //self.f.default_init(self.m);
    //self.f.start = newblk();
    //self.stack&.clear();
    //self.datas = libc_allocator.alloc(u32, self.w.data.len);
    //enumerate self.w.data { i, it |
    //    name := @tfmt("%_f%", self.module_name, local_func_i);    // :WasmNameMangling
    //    self.data_symbol[i] = 
    //};
    //self.f.copy_instructions_from_scratch_reversed_which_means_forwards(self.f.start);
    //self.f.start.jmp.type = .ret0;
    //self.f.nblk = 1;
    //printfn(self.f, self.f.globals.debug_out);
}

fn load_module(self: *LoadWasm) void = {
    self.create_init_func();

    enumerate self.w.code& { local_func_i, code | 
        local_func_i += self.w.imported_function_count;
        mark := mark_temporary_storage();
        f := Qbe.Fn.zeroed();
        self.f = f&;
        self.f.default_init(self.m);
        
        name := @tfmt("%_f%", self.module_name, local_func_i);    // :WasmNameMangling
        self.f.name&.items().slice(0, name.len).copy_from(name);  // :UnacceptablePanic
        
        local_func_type := self.w.types[local_func_i]&;
        self.stack&.clear();
        self.locals = temp().alloc(Qbe.Ref, code.total_local_count + local_func_type.arg.len);
        self.referenced_globals = init(temp());
        self.global_store = self.f.newtmp("wasm_globals", .Kl);
        self.f.emit(.par, .Kl, self.global_store, QbeNull, QbeNull);
        
        // parameters come in as locals not on the stack
        range(0, local_func_type.arg.len) { i |
            k := local_func_type.arg[i].cls();
            self.locals[i] = self.f.newtmp("param", k);
            self.f.emit(.par, k, self.locals[i], QbeNull, QbeNull);
        };
        
        {
            @println("% locals", code.total_local_count);
            i := local_func_type.arg.len;
            for code.locals& { local |
                k := local.ty.cls();
                range(0, local.count) { _ |
                    self.locals[i] = self.f.newtmp("local", k);
                    i += 1;
                };
            };
        };
        
        self.src = code.insts.items();
        self.cursor = 0;
        while => self.cursor < self.src.len {
            continue :: local_return;
            @println("inst %", self.src[self.cursor]);
            
            inst := self.src[self.cursor];
            self.cursor += 1;
            
            // Single byte unary/binary instructions are found in the table. 
            encoding := lookup_wasm_encoding(inst);
            a0, a1, r := (QbeNull, QbeNull, QbeNull);
            @match(encoding.kind) {
                fn other() => ();
                fn unary() => {
                    r = self.f.newtmp("wasm", k);
                    a := self.stack[self.stack.len - 1]&;
                    a0 = a[];
                    a[] = r;
                };
                fn binary() => {
                    r = self.f.newtmp("wasm", k);
                    a0 = self.stack[self.stack.len - 1];
                    b := self.stack[self.stack.len - 2]&;
                    self.stack.len -= 1;
                    a1 = b[];
                    b[] = r;
                };
                fn load() => {
                    align := self.read_u();
                    offset := self.read_u();
                    println("TODO: wasm load"); kind = 0;
                    self.stack&.pop().unwrap();
                    self.stack&.push(QbeNull);
                    continue(); // TODO
                };
                fn store() => {
                    align := self.read_u();
                    offset := self.read_u();
                    println("TODO: wasm store"); 
                    self.stack&.pop().unwrap();
                    self.stack&.pop().unwrap();
                    continue(); // TODO
                };
            };
            
            if encoding.kind != .other {
                @debug_assert(r != QbeNull || a0 != QbeNull);
                self.f.emit(o, k, r, a0, a1);
                continue();
            };
            
            // Otherwise it's a more complicated instruction. 
            self.emit_instruction(@as(Wasm.Inst) inst)
        };
        self.f.lnk.export = true; // TODO
        self.f.start = newblk();
        self.blk = self.f.start;
        self.f.copy_instructions_from_scratch_reversed_which_means_forwards(self.f.start);
        self.emit_return(local_func_type.ret.items());
        self.f.nblk = 1;
        printfn(self.f, self.f.globals.debug_out);
        each self.f.globals.debug { d | 
            d[] = true;
        };
        run_qbe_passes(self.f);
        reset_temporary_storage(mark);
    };
}

// Simple instructions are handled by the table before calling this. 
fn emit_instruction(self: *LoadWasm, inst: Wasm.Inst) void = {
    ::enum(Wasm.Inst);
    @switch(inst) {
        @case(.I32_Const) => {
            value := self.read_u();
            self.stack&.push(self.f.getcon(value.bitcast()));
        };
        @case(.I64_Const) => {
            value := self.read_u();
            self.stack&.push(self.f.getcon(value.bitcast()));
        };
        @case(.LocalGet) => self.local_inst(1);
        @case(.LocalSet) => self.local_inst(-1);
        @case(.LocalTee) => self.local_inst(0);
        @case(.Call) => {
            callee := self.read_index(FuncIdx);
            @println("% func", callee.id);
            import := self.w&.find_import_index(0, callee.id.zext());
            ::if(TypeIdx);
            type_index := if import.is_some() {
                import := self.w.imports&.index(import.Some);
                import.desc.Function
            } else {
                self.w.functions[callee.id.zext() - self.w.imported_function_count]
            };
            callee := self.remap_global(0, callee.id.zext());
            self.emit_call_from_stack(callee, type_index);
            println("call!");
        };
        @case(.Return) => {
            println("return!");
        };
        @case(.End) => {
            println("end!");
        };
        @case(.GlobalSet) => {
            println("TODO: global.set");
            i := self.read_u();
            val := self.stack&.pop();
        };
        @case(.GlobalGet) => {
            println("TODO: global.get");
            i := self.read_u();
            val := QbeNull;
            self.stack&.push(val);
        };
        @case(.VectorPrefix) => panic("Vector instructions are not supported (0xFD prefix)");
        @default => {
            @panic("unhandled unstruction %", self.src[self.cursor - 1]);
        };
    }
}

fn local_inst(self: *LoadWasm, delta: i64) void = {
    i    := self.read_u();
    var  := self.locals[i.bitcast()];
    t    := self.f.get_temporary(var);
    dest := if(delta == 1, => self.f.newtmp("get", t.cls), => var);
    src  := if(delta == 1, => var, => self.stack[self.stack.len - 1]);
    self.stack.len += delta;
    if delta == 1 {
        self.stack[self.stack.len - 1] = dest;
    };
    self.f.emit(.copy, t.cls, dest, src, QbeNull);
}

fn emit_return(self: *LoadWasm, return_types: []Wasm.ValType) void = {
    @debug_assert(self.blk.jmp.type == .Jxxx, "tried to return from terminated block");
    @switch(return_types.len) {
        @case(0) => {
            self.blk.jmp.type = .ret0;
        };
        @case(1) => {
            @assert(return_types[0].cls() == .Kw, "// TODO: correct cls");
            self.blk.jmp = (type = .retw, arg = self.stack[self.stack.len - 1]);
            self.stack.len -= 1;
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn emit_call_from_stack(self: *LoadWasm, callee: Qbe.Ref, type: TypeIdx) void = {
    @println("% type", type.id);
    type := self.w.types[type.id.zext()]&;
    @assert_le(type.arg.len, self.stack.len, "not enough stack for call");
    
    self.f.emit(.arg, .Kl, QbeNull, self.global_store, QbeNull);
    range(0, type.arg.len) { i |
        ref := self.stack[self.stack.len - type.arg.len + i];
        k := type.arg[i].cls();
        self.f.emit(.arg, k, QbeNull, ref, QbeNull);
    };
    self.stack.len -= type.arg.len;
    @switch(type.ret.len) {
        @case(0) => {
            self.f.emit(.call, .Kw, QbeNull, callee, QbeNull);
        };
        @case(1) => {
            ref := self.f.newtmp("ret", type.ret[0].cls());
            self.f.emit(.call, .Kw, ref, callee, QbeNull);
            self.stack&.push(ref);
        };
        @default => panic("TODO: handle multiple returns");
    };
}

fn remap_global(self: *LoadWasm, kind: i64, id: i64) Qbe.Ref = {
    @debug_assert(kind < 4, "remap_global");
    key := kind.shift_left(32).bit_or(id);
    if self.referenced_globals&.get(key) { local | 
        return(local);
    };
    ref: Qbe.Ref = @switch(key) {
        @case(0) => { // func 
            import := self.w&.find_import_index(kind, id);
            name := if import.is_some() {
                // TODO: no this doesn't make any since, the binding of names should happen separately. 
                import := self.w.imports&.index(import.Some);
                @tfmt("%_f%", import.module.items(), import.name.items())
            } else {
                // :WasmNameMangling
                @tfmt("%_f%", self.module_name, id)
            };
            id := self.m.intern(name);
            self.f.unique_named_con(id, 0)
        };
        @default => panic("TODO: remap global to local ref");
    };
    self.referenced_globals&.insert(key, ref);
    ref
}

// TODO: this is stupid. store them in seperate arrays. surely you never need to refer to them by an untyped import index. 
fn find_import_index(self: *Wasm.Module, kind: i64, id: i64) ?i64 = {
    i := 0;
    each self.imports& { check | 
        ::tagged(@type check.desc);
        if check.desc&.tag().raw() == kind {
            if i == id {
                return(Some = i);
            };
            i += 1;
        };
    };
    .None
}

// (dest_offset, src_offset_in_data, size_to_copy)  // TODO: make sure those arguments are right
fn emit_memory_init(self: *Wasm.Module, data_id: i64) void = {
    todo()
}
