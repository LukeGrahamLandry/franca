
puts :: fn(c: *u8) i32 = {
    s: CStr = (ptr = c);
    s := s.str();
    // TODO: this is bad idea... thread safety
    s.index_unchecked(s.len)[] = 10;
    result := Syscall'write((fd = 1), s.ptr, s.len + 1);
    s.index_unchecked(s.len)[] = 0;
    result || return(-1);
    0
}

putchar :: fn(c: u8) i32 = {
    Syscall'write((fd = 1), c&, 1) || return(-1);
    0
}

strlen :: fn(p: *u8) i64 = 
    len(str(@as(CStr) (ptr = p)));

labs :: fn(a: i64) i64 = a.abs();

strcmp :: fn(a: *u8, b: *u8) i32 = {
    while => a[] == b[] && a[] != 0 {
        a = a.offset(1);
        b = b.offset(1);
    };
    a[].zext() - b[].zext()
}

memcmp :: fn(a: *u8, b: *u8, n: i64) i32 = {
    i := 0;
    a := a.slice(n); b := b.slice(n);
    while => a[i] == b[i] {
        i += 1;
        @if(i == n) return(@as(i32)0);
    };
    a[i].zext() - b[i].zext()
}

memcpy :: fn(d: *u8, s: *u8, n: i64) *u8 = {
    d.slice(n).copy_from(s.slice(n));
    d
}
