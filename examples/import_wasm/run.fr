#use("@/examples/import_wasm/convert.fr");
#use("@/examples/import_wasm/parse.fr");
#use("@/backend/lib.fr");  // TODO: garbage that this needs to be in the root scope
Crash :: import("@/lib/crash_report.fr");

// TODO: -o to output a binary
// TODO: use fill_backend_vtable to toggle between recompiling 
//       and using the host's backend when running as a driver 
//       (see import_c for an example). 

main :: fn() void = {
    Crash'hook_backtrace();
    args := cli_args();
    logging := "";
    i := 0;
    wasm_file := "";
    if true {
        break :: local_return;
        while => i < args.len {
            arg := args[i].str(); i += 1;
            if arg == "-d" {
                @assert_lt(i, args.len, "expected arg after -d");
                logging = args[i].str(); i += 1;
            }
            if arg.ends_with(".wasm") {
                @assert_eq(wasm_file, "", "can only specify one wasm file to run");
                wasm_file = arg;
            }
            if arg == "--" {
                break();
            }
        }
    }
    args := args.rest(i - 1);  // meh, for now: argv[0] == "--"
    
    E :: {  
        E :: Exports;
        s := Type.scope_of(E.env);
        fr := current_compiler_context();
        inline_for weak_imports { $name |
            // TODO: this should work without the rebind
            XX :: name[];
            crash := fn() void = @panic("wasm guest called a weak function: %", XX);
            if get_constant(s, ::name[].sym()).is_none() {
                (fr.vtable.add_to_scope)(fr.data, s, ::name[].sym(), FuncId, FuncId.raw_from_ptr(crash&));
            };
        };
        E
    };
    
    #use("@/lib/sys/fs.fr");
    bytes := temp().read_to_string_or_crash(wasm_file).items(); // :panic
    exec_wasm_file(E, bytes, logging, args);
}

fn exec_wasm_file($Exports: Type, bytes: []u8, logging: Str, args: []CStr) void = {
    module := QbeModule.zeroed(); m := module&;
    init_default_module(m, (type = .JitOnly, os = query_current_os(), arch = query_current_arch(), link_libc = false));
    
    arena: ArenaAlloc = init(page_allocator, 1.shift_left(12));
    a := arena&.borrow();
    m.set_debug_types(logging, true);
    
    w: WasmModule = empty(a);
    p: ParseWasm = (w = w&, src = bytes);
    or parse_wasm(p&) { e |
        @panic("% (at byte index %)", e, p.cursor);
    };
    
    // TODO: need 33 bits becase memarg has offset 
    //       (but nobody uses it that way because you'd need to know statically which half you're on)
    // TODO: can't do this if i want to run in wasm (meta-circularly). so at least need an option to be normal. 
    //       this also doesn't work if i want to support memory64. 
    // relies on page allocator giving zeroes
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(32)); // wasm.w.memories[0].min.zext() * wasm_page_size);
    wasm_context_pointer := buf.ptr;
    heap_base[] = trunc(buf.len - 1);

    // write the cli arguments into memory the module can access. 
    // i'm making each entry in argv 8 bytes because then my programs 
    // that use Kl for pointers don't need to change, but it means 
    // you probably won't have success using this with anyone else's wasm modules. 
    argc, argv := {
        arg_offsets := i64.list(temp());
        for args { s | 
            s := s.str();
            heap_base[] -= align_to(s.len.trunc() + 1, 16);
            buf.subslice(heap_base[].zext(), s.len).copy_from(s);
            buf[heap_base[].zext() + s.len] = 0;
            arg_offsets&.push(heap_base[].zext());
        };
        arg_offsets&.push(0);
        src := arg_offsets.items().interpret_as_bytes();
        heap_base[] -= align_to(src.len, 16).trunc();
        buf.subslice(heap_base[].zext(), src.len).copy_from(src);
        (arg_offsets.len - 1, heap_base[])
    };
    heap_base[] = align_back(heap_base[], 65536);
    
    self: LoadWasm = init(m, w&, a);
    self&.load_module();
    // TODO: save the typeinfo and at least do arity checking
    exports := comptime_exports(Exports);
    fill_imports(self&, exports&);
    self&.instantiate(wasm_context_pointer);
    main_module[] = self&;
    
    trace := Crash'push_resolver(QbeModule, m, find_ip_in_module);
    
    // TODO: there's a segment where it tells you the entry point
    exports := self&.collect_exports(temp());
    
    {  // TODO
        enumerate self.w.exports& { i, it |
            @if_let(it.type) fn Table() => {
                addr, _ := m.get_addr(exports[i]).unwrap();
                // TODO: this shouldn't need the '::'
                the_table[] = bit_cast_unchecked(rawptr, ::*[]rawptr, addr);
            };
        };
    };
    
    // :NamespaceChar
    main := exports.index_of(fn(it) => m.str(it[]) == "main^module")
        || @panic("expected export called 'main'");
    n := exports[main];
    f, _ := or m.get_addr(n) {
        @panic("couldn't find %: %", n.id, m.str(n));
    };
    //@println(">>> Calling %", wasm.m.str(n));
    f := assume_types_fn(Arg = Ty(*u8, u32, u32, u32, u32), Ret = i64, ptr = f);
    result := f(wasm_context_pointer, argc.trunc(), argv, 0, 0);
    if result != 0 {
        @eprintln(">>> returned %", result);
    };
    
    pop_resolver(trace);
    drop(m);
    page_allocator.dealloc(u8, buf);
    arena&.deinit();
}

// note: this is on the opposite end of how i did it in wasm_test.html
heap_base :: @static(u32) 0;  // TODO: BAD!
main_module :: @static(*LoadWasm);
the_table :: @static(*[]rawptr);

// TODO
// Generate a wrapper to promote offsets in linear memory to native pointers. 
// This avoids writing a lot of verbose code like `ctx.offset(ptr.zext())`. 
// (fn(a: *T, b: i32, c: *U) *R) -> (fn(ctx: *u8, a_off: u32, b: i32, c_off: u32) u32)
PromotePointers :: fn(fid: FuncId) FuncId #fold = {
    callee := get_function_ast(fid, true, false, true, false);
    todo();
    intern_func(wrapper&)
}

weak_imports :: @const_slice(
   "__libc_start_main", "__error", "__errno_location", "__clear_cache", 
   "pthread_jit_write_protect_np", "remove", "poll", "fork", "close", 
   "wait4", "pipe", "nanosleep", "execvp", "read", "mkstemp", "dup2",
   "readdir$INODE64", "dlsym", "fstatat", "fstatat$INODE64", "renameat", 
   "readlink", "_NSGetExecutablePath", "mkdirat", "pthread_attr_setstack", 
   "opendir$INODE64", "closedir", "readdir", "lseek", "pthread_create",
   "pthread_join", "opendir", "dlopen", "sigaction",
   "pthread_attr_init", 
   "strtod", "localtime", "time",
   "snprintf", 
);

WellKnown :: import("@/examples/import_wasm/well_known.fr");

// TODO: make it easy to ship these as a binary form of the ir so you can inline accross host calls. 
Exports :: @struct {
    env :: @struct {
        putchar :: fn(_: *u8, c: u8) i32 = 
            WellKnown'putchar(c);
        getchar :: fn(_: *u8) u8 = {
            getchar_UNBUFFERED().zext().trunc()
        }
        puts :: fn(ctx: *u8, p: u32) i32 = 
            WellKnown'puts(ctx.offset(p.zext()));
        strlen :: fn(ctx: *u8, p: u32) i64 = 
            WellKnown'strlen(ctx.offset(p.zext()));
        labs :: fn(ctx: *u8, i: i64) i64 = WellKnown'labs(i);
        calloc :: fn(ctx: *u8, m: u32, n: u32) u32 = {  // HACK
            heap_base[] -= align_to(m*n, 16);
            heap_base[]
        }
        // clocking in for my shift at the garbage pasta factory FIXME PLEASE
        vprintf :: fn(ctx: *u8, fmt: u32, valist: u32) u32 = {
            args := valist.zext();
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            print(out.items());
            out.len.trunc()
        }
        printf :: fn(ctx: *u8, fmt: u32, args: i64) u32 = {
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            print(out.items());
            out.len.trunc()
        }
        sprintf :: fn(ctx: *u8, dest: u32, fmt: u32, args: i64) u32 = {
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            dest := ctx.offset(dest.zext());
            dest.slice(out.len).copy_from(out.items());
            out.len.trunc()
        }
        vsprintf :: fn(ctx: *u8, dest: u32, fmt: u32, valist: u32) u32 = {
            args := valist.zext();
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            dest := ctx.offset(dest.zext());
            dest.slice(out.len).copy_from(out.items());
            out.len.trunc()
        }
        abort :: fn(ctx: *u8) void = {
            panic("wasm called abort");
        }
        exit :: fn(ctx: *u8, status: u32) void = {
            if status != 0 {
                // i want a stack trace.
                @panic("wasm guest called exit(%)", status);
            }
            Syscall'exit(status.zext());
        }
        strcmp :: fn(ctx: *u8, a: u32, b: u32) i32 = 
            WellKnown'strcmp(ctx.offset(a.zext()), ctx.offset(b.zext()));
        
        memcmp :: fn(ctx: *u8, a: u32, b: u32, n: u32) i32 = 
            WellKnown'memcmp(ctx.offset(a.zext()), ctx.offset(b.zext()), n.zext());
        
        memcpy :: fn(ctx: *u8, a: u32, b: u32, n: u32) u32 = {
            WellKnown'memcpy(ctx.offset(a.zext()), ctx.offset(b.zext()), n.zext());
            a
        }

        strncmp :: fn(ctx: *u8, a: u32, b: u32, n: u32) i32 = {
            a := ctx.offset(a.zext());
            b := ctx.offset(b.zext());
            strncmp :: fn(a: *u8, b: *u8, n: i64) i32 #libc;
            strncmp(a, b, n.zext())
        }
        mmap :: fn(ctx: *u8, addr: u32, len: u32, prot: u32, flags: u32, fd: u32, offset: u32) i64 = {
            heap_base[] = align_back(heap_base[], 65536);
            calloc(ctx, 1, len.align_to(65536)).zext()
        }
        munmap :: fn(ctx: *u8, addr: u32, len: u32) i64 = 0;
          free :: fn(ctx: *u8, p: u32) i64 = 0;
        malloc :: fn(ctx: *u8, len: u32) i64 = calloc(ctx, 1, len).zext();
         write :: fn(ctx: *u8, fd: i32, addr: u32, len: u32) i64 = {
            if fd != 1 && fd != 2 {
                return(-1);
            };
            r := Syscall'write((fd = fd), ctx.offset(addr.zext()), len.zext());
            r.value
        };
        mprotect :: fn(ctx: *u8, a: u32, b: u32, c: u32) u32 = 0;
        fsync :: fn(ctx: *u8, p: u32) i64 = 0;
        clock_gettime :: fn(ctx: *u8, clock_id: u32, p: i64) u32 = {
            time_spec := bit_cast_unchecked(*u8, *Array(i64, 2), ctx.offset(p));
            ms := timestamp();
            time_spec[0] = ms / 1000;
            time_spec[1] = (ms - time_spec[0]*1000) * 1000000;
            0
        }
        jit_instantiate_module :: fn(ctx: *u8, address: i64, length: i64, first_export: i64, table_index: u32) void = {
            @debug_assert_eq(table_index, 0);
            module_bytes := ctx.offset(address).slice(length);
            
            // TODO: should probably just allow userdata
            
            a := general_allocator(); // TODO
            m := a.box_uninit(Qbe.Module);
            init_default_module(m, (type = .JitOnly, os = query_current_os(), arch = query_current_arch(), link_libc = false));
            m.debug = main_module.m.debug;
            w: WasmModule = empty(a);
            p: ParseWasm = (w = w&, src = module_bytes);
            or parse_wasm(p&) { e |
                @panic("% (at byte index %)", e, p.cursor);
            };
            
            new: LoadWasm = init(m, w&, a);
            new.module_name = "other";  // TODO
            new&.load_module();
            new&.fill_imports("main", main_module[]);
            new&.instantiate(ctx);

            exports := new&.collect_exports(temp());
            
            table := the_table[][];
            j := first_export;
            enumerate new.w.exports& { i, it |
                @if_let(it.type) fn Func() => {
                    addr, _ := m.get_addr(exports[i]) 
                        || @panic("missing addr for export % id=% %", i, it.id, it.name.items());
                    table[j] = addr;
                    j += 1;
                };
            };
            
            // TODO: make the api nice so it's not more painful than the js version
        }
        
        fetch_file :: fn(ctx: *u8, ptr: i64, length: i64, p_filelen: i64) i64 = {
            path := ctx.offset(ptr).slice(length);
            // TODO: do it without the extra copy. 
            src := read_entire_file(temp(), path) || return(0);
            p := malloc(ctx, src.len.trunc());
            (@as([]u8) (ptr = ctx.offset(p), len = src.len)).copy_from(src);
            filelen := bit_cast_unchecked(*u8, *i64, ctx.offset(p_filelen));
            filelen[] = src.len;
            p
        }
        
        yield_file :: fn(ctx: *u8, ptr: i64, length: i64) void = {
            bytes := ctx.offset(ptr).slice(length);
            write_entire_file_or_crash("a.out", bytes);
        }
        
        null :: fn(ctx: *u8) void = {
            @panic("wasm guest called a null function pointer");
        }
    }
}

// ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ 
// blehhhhh todo
fn printf_impl();
fn printf_impl(out: *List(u8), ctx: *u8, fmt_s: u32, args: *i64) void = {
    printf_impl(out, ctx.offset(fmt_s.zext()), fn($T) => {
        args[] = align_to(args[], ::align_of(T));
        value := ptr_cast_unchecked(u8, T, ctx.offset(args[]))[];
        args[] += ::size_of(T);
        value
    }, fn(p) => ctx.offset(p));
}

fn printf_impl(out: *List(u8), fmt_s: CStr, va: *CVariadicArgumentList) void = {
    printf_impl(out, fmt_s.ptr, fn($T) => va.next(T), fn(p) => u8.ptr_from_int(p));
}

fn printf_impl(
    out: *List(u8), 
    fmt_s: *u8, 
    $get_arg: FuncId #duplicated /* @Fn($T: Type) T */, 
    $m: @Fn(p: i64) *u8 #duplicated,
) void #generic = {
    i := 0;
    c :: fn(i) => fmt_s.offset(i)[];
    snprintf :: fn(buf: *u8, len: i64, fmt: CStr, _: CVariadic) i64 #weak #libc;
    
    putchar :: Exports.env.putchar;
    while => c(i) != 0 {
        if c(i) != "%".ascii() {
            out.push(c(i));
            i += 1;
        } else {
            i += 1;
            @switch(c(i)) {
                @case("l".ascii()) => {
                    if c(i + 1) == "l".ascii() && c(i + 2) == "d".ascii() {
                        i += 3;
                        @fmt(out, "%", get_arg(i64));
                    } else {
                        if c(i + 1) == "d".ascii() {
                            i += 2;
                            @fmt(out, "%", get_arg(i64));
                        };
                    };
                }
                @case("d".ascii()) => {
                    i += 1;
                    @fmt(out, "%", get_arg(i32));
                }
                @case("g".ascii()) => {
                    i += 1;
                    x := get_arg(f64);
                    //@print("%", x);  // TODO: just fix my float printing to not suck
                    out.reserve(64);
                    n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%g", @va x);
                    @debug_assert(n < 64);
                    out.len += n;
                }
                @case("f".ascii()) => {  // TODO: this is a copy-paste
                    i += 1;
                    x := get_arg(f64); 
                    //@print("%", x);  // TODO: just fix my float printing to not suck
                    out.reserve(64);
                    n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%f", @va x);
                    @debug_assert(n < 64);
                    out.len += n;
                }
                @case("c".ascii()) => {
                    i += 1;
                    push(out, get_arg(u32).trunc());
                }
                @case("s".ascii()) => {
                    i += 1;
                    p := get_arg(i64);  // TODO: this should be u32 but then the ir needs to know what's a pointer 
                    
                    // when this was in the Exports struct
                    // this isn't what you want anyway but its still a compiler bug
                    //puts(ctx, p);  // TODO: You can't have a void pointer 4582761636 as a constant :FUCKED
                    
                    s: CStr = (ptr = m(p));
                    @fmt(out, "%", s);
                }
                // TODO: fix this!! i just dont care rn. 
                @case("0".ascii()) => {
                    @assert_eq(fmt_s.offset(i).slice(3), "08x", "HACK to make load2.ssa work");
                    i += 3;
                    x := get_arg(u32);
                    range_rev(0, 4) { i |
                        push_hex_byte(out, x.shift_right_logical(8*i).trunc(), false);
                    };
                }
                // TODO: fix this!! i just dont care rn. 
                // ops.ssa uses #010x, usualconv.c uses #04x
                @case("#".ascii()) => {
                    @assert_eq(fmt_s.offset(i).slice(2), "#0", "HACK to make ops.ssa work");
                    i += 2;
                    j := i;
                    while => c(i).is_ascii_digit() {
                        i += 1;
                    };
                    count := parse_int(fmt_s.offset(j).slice(i-j));
                    @assert_eq(fmt_s.offset(i).slice(1), "x", "HACK");
                    i += 1;
                    @assert(count.mod(2) == 0, "HACK");
                    
                    x := get_arg(u32);
                    @fmt(out, "0x");
                    range_rev(0, count.min(8)/2) { i |
                        push_hex_byte(out, x.shift_right_logical(8*i).trunc(), false);
                    };
                }
                // TODO: fix this!! i just dont care rn. 
                @case(".".ascii()) => {
                    // HACK to make abi8.ssa work
                    if fmt_s.offset(i).slice(4) == ".17s" {
                        i += 4;
                        p := get_arg(i64);  // TODO: this should be u32 but then the ir needs to know what's a pointer 
                        @fmt(out, "%", m(p).slice(17));
                    } else {
                        // HACK to make function.c work
                        if fmt_s.offset(i).slice(3) == ".1f" {
                            i += 3;
                            x := get_arg(f64); 
                            //@print("%", x);  // TODO: just fix my float printing to not suck
                            out.reserve(64);
                            n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%.1f", @va x);
                            @debug_assert(n < 64);
                            out.len += n;
                        } else {
                            @panic("TODO: proper printf");
                        }
                    }
                }
                @case("%".ascii()) => {
                    push(out, c(i));  // :SLOW
                    i += 1;
                }
                @default => ();
            };
        };
    };
}
#use("@/lib/variadic.fr");