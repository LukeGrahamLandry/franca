#use("@/examples/import_wasm/convert.fr");
#use("@/examples/import_wasm/parse.fr");
#use("@/backend/lib.fr");  // TODO: garbage that this needs to be in the root scope
Crash :: import("@/lib/crash_report.fr");

// TODO: -o to output a binary
// TODO: use fill_backend_vtable to toggle between recompiling 
//       and using the host's backend when running as a driver 
//       (see import_c for an example). 

Wasm :: import("@/examples/import_wasm/runtime.fr");
main :: fn() void = {
    Crash'hook_backtrace();
    args := cli_args();
    logging := "";
    i := 0;
    wasm_file := "";
    if true {
        break :: local_return;
        while => i < args.len {
            arg := args[i].str(); i += 1;
            if arg == "-d" {
                @assert_lt(i, args.len, "expected arg after -d");
                logging = args[i].str(); i += 1;
            }
            if arg.ends_with(".wasm") {
                @assert_eq(wasm_file, "", "can only specify one wasm file to run");
                wasm_file = arg;
            }
            if arg == "--" {
                break();
            }
        }
    }
    args := args.rest(i - 1);  // meh, for now: argv[0] == "--"
    
    #use("@/lib/sys/fs.fr");
    bytes := temp().read_to_string_or_crash(wasm_file).items(); // :panic
    
    a := general_allocator();
    target: Qbe.QbeTargetEnv = (type = .JitOnly, os = query_current_os(), arch = query_current_arch(), link_libc = false);
    rt: Wasm.Engine = init(a, target, logging);
    mod := rt&.compile(bytes);
    exec_wasm_file(AugmentedExports, rt&, mod, args, standard_log);
}

standard_log: Log : (ctx = zeroed(rawptr), f = fn(_, err, msg) = if err {
    eprint(msg);
} else {
    print(msg);
});

AugmentedExports :: {  
        insert :: fn(scope, name, value) => 
            (fr.vtable.add_to_scope)(fr.data, scope, name, @type value, raw_from_ptr(@type value, value&));
        E :: Exports;
        s := Type.scope_of(E.env);
        fr := current_compiler_context();
        inline_for weak_imports { $name |
            // TODO: this should work without the rebind
            XX :: name[];
            crash := fn() void = @panic("wasm guest called a weak function: %", XX);
            if get_constant(s, ::name[].sym()).is_none() {
                insert(s, ::name[].sym(), crash);
            };
        };
        
        // for now just stub these out so it can still run examples/web/demo.fr as its compiling a non-graphics program. 
        // the way i handle imports for the child jitted program in b.fr means the compiler always 
        // has to import the graphics functions before knowing if it actually needs them. 
        // TODO: eventually i want to link dawn and make this work for real. 
        if file_exists("target/franca/webgpu.g.fr") {
            WGPU := import("@/target/franca/webgpu.g.fr");
            crash :: fn() void = @panic("TODO: import_wasm does not support webgpu");
            // TODO: i don't make a scope for @struct(francaRequestState :: crash); it only works with {} :compilerbug
            webgpu := @struct {
                francaRequestState :: crash;
            };
            w := Type.scope_of(webgpu);
            for WGPU.get_constants() { n |
                if n.str().starts_with("wgpu") {
                    insert(w, n, crash);
                };
            };
            insert(Type.scope_of(E), @symbol webgpu, webgpu);
        } else {
            insert(Type.scope_of(E), @symbol webgpu, @struct { _HACK :: 1; });
        };
        
        @struct {
            env :: wrap_fns_with_load_memory(Globals, Type.scope_of(E.env));
            webgpu :: wrap_fns_with_load_memory(Globals, Type.scope_of(E.webgpu));
        }
};

create_exports :: fn($Exports: Type, globals: *Globals) Rt.ExportsEnv = {
    exports: Rt.ExportsEnv = (_ = init(temp()));
    #use("@/examples/import_wasm/ffi.fr");
    // TODO: save the typeinfo and at least do arity checking
    for comptime_exports(Exports) { m, n, it |
        exports&.insert(m, n, it.Function.callee, globals);
    };
    exports&.insert("main", "memory", (Memory = globals.memory));
    
    // HACK to undo :MultiDylibLibc 
    exports._&.insert("libc***", exports._&.get("env").unwrap());
    
    exports
}

Log :: @struct(f: @FnPtr(self: rawptr, err: bool, msg: []u8) void, ctx: rawptr);

fn exec_wasm_file($Exports: Type, rt: *Rt.Engine, mod: *Wasm.Module, args: []CStr, log: Log) void = {
    a := general_allocator();
    
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(32));  // page allocator always gives zeros
    memory := a.boxed(SaneRawList(u8), (ptr = buf.ptr, cap = buf.len, len = 0));
    globals := a.box_zeroed(Globals);
    globals.thread = .None;
    globals.memory = memory;
    globals.env = get_dynamic_environment();
    globals.heap_base = memory.cap.trunc();
    globals.create_exports = fn(self) = create_exports(Exports, self);
    globals.log = log;
    exports := (globals.create_exports)(globals);
    globals.engine = rt;
    instance := mod.instantiate(exports&);
    
    trace := Crash'push_resolver(Qbe.Module, mod.m.unwrap(), find_ip_in_module);
    
    ::tagged(Wasm.Export);    
    if instance.exports&.get("__indirect_table") { it |
        @assert(it&.is(.Table));
        globals.table = it.Table;
    };
    
    argc, argv := (0, 0);
    // unfortunate that i depend on a specific symbol name
    if instance.exports&.get("__stackbase") { stackbase |
        stackbase := stackbase.Global.i32&;
        // TODO: should use the limits in the wasm binary instead of this HACK
        memory.len = stackbase[].zext().align_to(wasm_page_size);
        argc_, argv_ := write_cli_args(args, memory.maybe_uninit(), stackbase);
        argc = argc_;
        argv = argv_;
    };
    
    wasm_page_size :: 1.shift_left(16);
    globals.instance = instance;
    globals.mod = mod;
    
    // TODO: there's a segment where it tells you the entry point
    func := instance.exports&.get("main")
        || @panic("expected export called 'main'");
    @debug_assert(func&.is(.Function));
    func := func.Function;
    f := assume_types_fn(Arg = Ty(rawptr, u32, u32, u32, u32), Ret = i64, ptr = func.callee);
    
    @match(try(globals.exit_thread&)) {
        fn Try() => {
            result := f(func.context, argc.trunc(), argv.trunc(), 0, 0);
            if result != 0 {
                @eprintln(">>> returned %", result);
            };
        }
        fn Catch() => ();
    };
    
    pop_resolver(trace);
    // TODO
    //drop(m);
    //page_allocator.dealloc(u8, buf);
    //arena&.deinit();
}

fn write_cli_args(args: []CStr, buf: []u8, stackbase: *i32) Ty(i64, i64) = {
    i := stackbase[].zext();
    // write the cli arguments into memory the module can access. 
    // i'm making each entry in argv 8 bytes because then my programs 
    // that use Kl for pointers don't need to change, but it means 
    // you probably won't have success using this with anyone else's wasm modules. 
    arg_offsets := i64.list(temp());
    for args { s | 
        s := s.str();
        i -= align_to(s.len + 1, 16);
        buf.subslice(i, s.len).copy_from(s);
        buf[i + s.len] = 0;
        arg_offsets&.push(i);
    };
    arg_offsets&.push(0);
    src := arg_offsets.items().interpret_as_bytes();
    i -= align_to(src.len, 16);
    buf.subslice(i, src.len).copy_from(src);
    stackbase[] = i.trunc();
    (arg_offsets.len - 1, i)
}

Globals :: @rec @struct {
    memory: *SaneRawList(u8);
    env: rawptr;
    heap_base: u32;  // TODO: use rt'memory_grow instead
    table: *SaneRawList(Rt.Callable);
    instance: *Rt.Instance;
    engine: *Rt.Engine;
    mod: *Rt.Module;
    create_exports: (@FnPtr(globals: *Globals) Rt.ExportsEnv);
    exit_futex: *u32;
    thread: ?*Thread;
    exit_thread: import("@/lib/sys/jump.fr").JumpBuf;
    log: Log;
};

weak_imports :: @const_slice(
   "__libc_start_main", "__error", "__errno_location", "__clear_cache", 
   "pthread_jit_write_protect_np", "unlinkat", "poll", "fork", "close", 
   "wait4", "pipe", "nanosleep", "execvp", "read", "mkstemp", "dup2",
   "readdir$INODE64", "dlsym", "fstatat", "fstatat$INODE64", "renameat", 
   "readlinkat", "_NSGetExecutablePath", "mkdirat", "pthread_attr_setstack", 
   "opendir$INODE64", "closedir", "readdir", "lseek", "pthread_create",
   "pthread_join", "opendir", "dlopen", "sigaction",
   "pthread_attr_init", 
   "strtod", "localtime_r", "time",
   "snprintf", 
   "ppoll", "execve",
   "posix_getdents", "FR_openat",
   "sqrt", "pow", "acos", "cos", "fabs", "floor", "ceil",
   "FR_wasm_jit_event", 
);

WellKnown :: import("@/examples/os/user/libc/string.fr");

// TODO: make it easy to ship these as a binary form of the ir so you can inline accross host calls. 
Exports :: @struct {
    env :: @struct {
        // (same reasoning as the webgpu ones. see comment above.)
        fmodf :: fn() void = panic("TODO: fmodf");
         fmod :: fn() void = panic("TODO: fmod");
         sinf :: fn() void = panic("TODO: sinf");
         cosf :: fn() void = panic("TODO: cosf");
    
        putchar :: fn(_: *u8, c: u8) i32 = 
            import("@/examples/os/user/libc/stdio.fr")'putchar(c);
        getchar :: fn(_: *u8) u8 = {
            getchar_UNBUFFERED().zext().trunc()
        }
        puts :: fn(ctx: *u8, p: u32) i32 = 
            import("@/examples/os/user/libc/stdio.fr")'puts(@as(CStr) (ptr = ctx.offset(p.zext())));
        strlen :: fn(ctx: *u8, p: u32) i64 = 
            WellKnown'strlen(@as(CStr) (ptr = ctx.offset(p.zext())));
        labs :: fn(ctx: *u8, i: i64) i64 = 
            import("@/examples/os/user/libc/stdlib.fr")'labs(i);
        calloc :: fn(ctx: *Globals, m: u32, n: u32) u32 #ctx = {  // HACK
            ctx.heap_base -= align_to(m*n, 16);
            ctx.heap_base
        }
        // clocking in for my shift at the garbage pasta factory FIXME PLEASE
        vprintf :: fn(ctx: *u8, fmt: u32, valist: u32) u32 = {
            args := valist.zext();
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            print(out.items());
            out.len.trunc()
        }
        printf :: fn(ctx: *u8, fmt: u32, args: i64) u32 = {
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            print(out.items());
            out.len.trunc()
        }
        sprintf :: fn(ctx: *u8, dest: u32, fmt: u32, args: i64) u32 = {
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            dest := ctx.offset(dest.zext());
            dest.slice(out.len).copy_from(out.items());
            out.len.trunc()
        }
        vsprintf :: fn(ctx: *u8, dest: u32, fmt: u32, valist: u32) u32 = {
            args := valist.zext();
            out := u8.list(temp());
            printf_impl(out&, ctx, fmt, args&);
            dest := ctx.offset(dest.zext());
            dest.slice(out.len).copy_from(out.items());
            out.len.trunc()
        }
        abort :: fn(ctx: *u8) void = {
            panic("wasm called abort");
        }
        exit :: fn(ctx: *u8, status: u32) void = {
            if status != 0 {
                // i want a stack trace.
                @panic("wasm guest called exit(%)", status);
            }
            Syscall'exit(status.zext());
        }
        strcmp :: fn(ctx: *u8, a: u32, b: u32) i32 = 
            WellKnown'strcmp(ctx.offset(a.zext()), ctx.offset(b.zext()));
        
        memcmp :: fn(ctx: *u8, a: u32, b: u32, n: u32) i32 = 
            WellKnown'memcmp(ctx.offset(a.zext()), ctx.offset(b.zext()), n.zext());
        
        memcpy :: fn(ctx: *u8, a: u32, b: u32, n: u32) u32 = {
            WellKnown'memcpy(u8.raw_from_ptr(ctx.offset(a.zext())), u8.raw_from_ptr(ctx.offset(b.zext())), n.zext());
            a
        }

        strncmp :: fn(ctx: *u8, a: u32, b: u32, n: u32) i32 = {
            a := ctx.offset(a.zext());
            b := ctx.offset(b.zext());
            strncmp :: fn(a: *u8, b: *u8, n: i64) i32 #libc;
            strncmp(a, b, n.zext())
        }
        mmap :: fn(ctx: *Globals, addr: u32, len: u32, prot: u32, flags: u32, fd: u32, offset: u32) i64 #ctx = {
            ctx.heap_base = align_back(ctx.heap_base, 65536);
            calloc(ctx, 1, len.align_to(65536)).zext()
        }
        munmap :: fn(ctx: *u8, addr: u32, len: u32) i64 = 0;
          free :: fn(ctx: *u8, p: u32) i64 = 0;
        malloc :: fn(ctx: *Globals, len: u32) i64 #ctx = calloc(ctx, 1, len).zext();
         write :: fn(ctx: *Globals, fd: i32, addr: u32, len: u32) i64 #ctx = {
            if fd != 1 && fd != 2 {
                return(-1);
            };
            msg := ctx.memory.items().subslice(addr.zext(), len.zext());
            ctx.engine.lock&.lock();
            (ctx.log.f)(ctx.log.ctx, fd != 1, msg);
            ctx.engine.lock&.unlock();
            len.zext()
        };
        
        FR_debug_write :: fn(ctx: *Globals, addr: u32, len: u32) void #ctx = {
            write(ctx, 1, addr, len);
        }
        js_write :: fn(ctx: *Globals, id: i64, addr: u32, len: u32) i64 #ctx = {
            @if(id == 0xBBBB0000) return(write(ctx, 1, addr, len));
            if id == 0xBBBB0001 {
                yield_file(ctx.memory.ptr, addr.zext(), len.zext());
                return(len.zext());
            }
            write(ctx, 2, addr, len);
            -1
        }
            
        mprotect :: fn(ctx: *u8, a: u32, b: u32, c: u32) u32 = 0;
        fsync :: fn(ctx: *u8, p: u32) i64 = 0;
        clock_gettime :: fn(ctx: *u8, clock_id: u32, p: i64) u32 = {
            time_spec := bit_cast_unchecked(*u8, *Array(i64, 2), ctx.offset(p));
            ms := timestamp();
            time_spec[0] = ms / 1000;
            time_spec[1] = (ms - time_spec[0]*1000) * 1000000;
            0
        }
        
        js_performace_now :: fn(_: *u8) f64 = 
            timestamp_s();

        // TODO
        tcgetattr :: fn() i64 = 0;
        tcsetattr :: fn() i64 = 0;

        jit_instantiate_module :: fn(ctx: *Globals, address: i64, length: i64, first_export: i64, table_index: u32) void #ctx = {
            @debug_assert_eq(table_index, 0);
            module_bytes := ctx.memory.ptr.offset(address).slice(length);
            mod := ctx.engine.compile(module_bytes);
            
            exports: Rt.ExportsEnv = (_ = init(temp()));
            exports._&.insert("main", ctx.instance.exports);
            new := mod.instantiate(exports&);
            
            table := ctx.table[];
            table := table.from_sane();
            j := first_export;
            enumerate new.ordered_exports& { i, it |
                @if_let(it) fn Function(it) => {
                    table[j] = it[];
                    j += 1;
                };
            };
        }
        
        js_worker_spawn :: fn(ctx: *Globals, userdata: i64, stack: i64, exit_futex: i64) void #ctx = {            
            child := general_allocator().boxed(Child, (
                userdata = userdata,
                stack = stack,
                globals = ctx[],
            ));       
            child.globals.thread = .None;
            child.globals.exit_futex = u32.ptr_from_int(u8.int_from_ptr(ctx.memory.ptr) + exit_futex);            
            t := Child.start_thread_data(child, handle_child_thread);
            child.globals.thread = (Some = t);
        }
        js_worker_stop :: fn(ctx: *Globals, status: i64) void #ctx = {
            @if(ctx.thread.is_none() && status != 0) @eprintln(">>> exited with status %", status);
            throw(ctx.exit_thread&);
        }
        
        yield_file :: fn(ctx: *u8, ptr: i64, length: i64) void = {
            bytes := ctx.offset(ptr).slice(length);
            write_entire_file_or_crash("a.out", bytes);
        }
        
        null :: fn(ctx: *u8) void = {
            @panic("wasm guest called a null function pointer");
        }
    }
}

Child :: @struct {
    userdata: i64;
    stack: i64;
    globals: Globals;
};

handle_child_thread :: fn(child: *Child) void = {
    exports := (child.globals.create_exports)(child.globals&);
    instance := child.globals.mod.instantiate(exports&);
    child.globals.instance = instance;
    it := instance.exports&.get("__indirect_table").unwrap();
    @assert(it&.is(.Table));
    child.globals.table = it.Table;
    stackbase := instance.exports&.get("__stackbase").unwrap();
    stackbase.Global.i64 = child.stack;
    
    // TODO: make this suck less
    wasm_init_thread := instance.exports&.get("wasm_init_thread").unwrap();
    f, c := (wasm_init_thread.Function.callee, wasm_init_thread.Function.context);
    f := bit_cast_unchecked(rawptr, @FnPtr(c: rawptr, a: i64, b: i64) i64, f);
    
    @match(try(child.globals.exit_thread&)) {
        fn Try() => {
            known_wasm_jit_event := 0;  // TODO: keep this once i do thread pool
            known_wasm_jit_event := (f)(c, child.userdata, known_wasm_jit_event);
        }
        fn Catch() => ();
    };
    
    child.globals.exit_futex[] = 0;
    _ := Rt'atomic_notify(instance, child.globals.exit_futex, MAX_i32);
    // TODO: recycle old threads? 
    general_allocator().dealloc_one(Child, child);
};

// ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ ðŸ¤¡ 
// blehhhhh todo
fn printf_impl();
fn printf_impl(out: *List(u8), ctx: *u8, fmt_s: u32, args: *i64) void = {
    printf_impl(out, ctx.offset(fmt_s.zext()), fn($T) => {
        args[] = align_to(args[], ::align_of(T));
        value := ptr_cast_unchecked(u8, T, ctx.offset(args[]))[];
        args[] += ::size_of(T);
        value
    }, fn(p) => ctx.offset(p));
}

fn printf_impl(out: *List(u8), fmt_s: CStr, va: *CVariadicArgumentList) void = {
    printf_impl(out, fmt_s.ptr, fn($T) => va.next(T), fn(p) => u8.ptr_from_int(p));
}

fn printf_impl(
    out: *List(u8), 
    fmt_s: *u8, 
    $get_arg: FuncId #duplicated /* @Fn($T: Type) T */, 
    $m: @Fn(p: i64) *u8 #duplicated,
) void #generic = {
    i := 0;
    c :: fn(i) => fmt_s.offset(i)[];
    snprintf :: fn(buf: *u8, len: i64, fmt: CStr, _: CVariadic) i64 #weak #libc;
    
    putchar :: Exports.env.putchar;
    while => c(i) != 0 {
        if c(i) != "%".ascii() {
            out.push(c(i));
            i += 1;
        } else {
            i += 1;
            @switch(c(i)) {
                @case("l".ascii()) => {
                    if c(i + 1) == "l".ascii() && c(i + 2) == "d".ascii() {
                        i += 3;
                        @fmt(out, "%", get_arg(i64));
                    } else {
                        if c(i + 1) == "d".ascii() {
                            i += 2;
                            @fmt(out, "%", get_arg(i64));
                        };
                    };
                }
                @case("d".ascii()) => {
                    i += 1;
                    @fmt(out, "%", get_arg(i32));
                }
                @case("g".ascii()) => {
                    i += 1;
                    x := get_arg(f64);
                    //@print("%", x);  // TODO: just fix my float printing to not suck
                    out.reserve(64);
                    n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%g", @va x);
                    @debug_assert(n < 64);
                    out.len += n;
                }
                @case("f".ascii()) => {  // TODO: this is a copy-paste
                    i += 1;
                    x := get_arg(f64); 
                    //@print("%", x);  // TODO: just fix my float printing to not suck
                    out.reserve(64);
                    n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%f", @va x);
                    @debug_assert(n < 64);
                    out.len += n;
                }
                @case("c".ascii()) => {
                    i += 1;
                    push(out, get_arg(u32).trunc());
                }
                @case("s".ascii()) => {
                    i += 1;
                    p := get_arg(i64);  // TODO: this should be u32 but then the ir needs to know what's a pointer 
                    
                    // when this was in the Exports struct
                    // this isn't what you want anyway but its still a compiler bug
                    //puts(ctx, p);  // TODO: You can't have a void pointer 4582761636 as a constant :FUCKED
                    
                    s: CStr = (ptr = m(p));
                    @fmt(out, "%", s);
                }
                // TODO: fix this!! i just dont care rn. 
                @case("0".ascii()) => {
                    @assert_eq(fmt_s.offset(i).slice(3), "08x", "HACK to make load2.ssa work");
                    i += 3;
                    x := get_arg(u32);
                    range_rev(0, 4) { i |
                        push_hex_byte(out, x.shift_right_logical(8*i).trunc(), false);
                    };
                }
                // TODO: fix this!! i just dont care rn. 
                // ops.ssa uses #010x, usualconv.c uses #04x
                @case("#".ascii()) => {
                    @assert_eq(fmt_s.offset(i).slice(2), "#0", "HACK to make ops.ssa work");
                    i += 2;
                    j := i;
                    while => c(i).is_ascii_digit() {
                        i += 1;
                    };
                    count := parse_int(fmt_s.offset(j).slice(i-j));
                    @assert_eq(fmt_s.offset(i).slice(1), "x", "HACK");
                    i += 1;
                    @assert(count.mod(2) == 0, "HACK");
                    
                    x := get_arg(u32);
                    @fmt(out, "0x");
                    range_rev(0, count.min(8)/2) { i |
                        push_hex_byte(out, x.shift_right_logical(8*i).trunc(), false);
                    };
                }
                // TODO: fix this!! i just dont care rn. 
                @case(".".ascii()) => {
                    // HACK to make abi8.ssa work
                    if fmt_s.offset(i).slice(4) == ".17s" {
                        i += 4;
                        p := get_arg(i64);  // TODO: this should be u32 but then the ir needs to know what's a pointer 
                        @fmt(out, "%", m(p).slice(17));
                    } else {
                        // HACK to make function.c work
                        if fmt_s.offset(i).slice(3) == ".1f" {
                            i += 3;
                            x := get_arg(f64); 
                            //@print("%", x);  // TODO: just fix my float printing to not suck
                            out.reserve(64);
                            n := snprintf(out.maybe_uninit.ptr.offset(out.len), 64, "%.1f", @va x);
                            @debug_assert(n < 64);
                            out.len += n;
                        } else {
                            @panic("TODO: proper printf");
                        }
                    }
                }
                @case("%".ascii()) => {
                    push(out, c(i));  // :SLOW
                    i += 1;
                }
                @default => ();
            };
        };
    };
}

#use("@/lib/variadic.fr");
#use("@/lib/sys/threads.fr");
Qbe :: import("@/backend/ir.fr");
