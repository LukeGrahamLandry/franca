// some wasm instructions don't map directly to native instructions 
// and do heavy weight things that don't need super tight code generation. 

// TODO: do something fancy with this annotation
#wasm(0xFC, 0x0F, .table)
table_grow :: fn(ctx: *u8, table: *[]rawptr, fill: rawptr, delta: i32) i32 = {
    if delta < 0 || table.len + delta.intcast() > MAX_i32 {
        return(-1);
    };
    
    // TODO: don't rely on having a dynamicenv here. 
    //       store an allocator somewhere you can get to from the linear memory base pointer
    // TODO: store capacity and amortize the resizing as well
    new := general_allocator().alloc_uninit(rawptr, table.len + delta.intcast());
    new.slice(0, table.len).copy_from(table[]);
    each new.rest(table.len) { it |
        it[] = fill;
    };
    table[] = new;
    // TODO: free the old table, :LEAK
    //       but only if this isn't the first time resizing because initial is in data segment.  
    
    table.len.intcast() - delta
}

// TODO: actually call these 
//       (my stuff doesn't use multiple threads yet so it's pointless)

#wasm(0xFE, 0x00, .memarg)
atomic_notify :: fn(ctx: *u8, addr: *u32, count: u32) i32 = {
    _ := Futex'wake(addr, count);
    
    // TODO: return the number that waiters that were woken
    0
};

#wasm(0xFE, 0x01, .memarg)
atomic_wait32 :: fn(ctx: *u8, addr: *u32, expect: u32, timeout_ns: i64) Futex.WasmWaitResult = {
    forever := timeout_ns < 0;
    @assert(forever, "TODO(import_wasm): atomic.wait with timeout");
    _ := Futex'wait(addr, expect);
    // TODO: return the correct reason for waking
    .Ok
}

atomic_fence :: fn(ctx: *u8) void #wasm(0xFE, 0x03, 0x00) = fence();

// i always preallocate the whole memory so it doesn't have to resize, 
// but keep track of a smaller "length" value so user code can use memory_grow as the page allocator.
#wasm(0x40, .memory)
memory_grow :: fn(ctx: *u8, memory_size: *i32, delta_pages: i32) i32 = {
    old := i32.cas(memory_size) { old |
        new := old + delta_pages;
        limit: i32 = 65536;  // 4gb
        @if(new > limit) return(-1);
        new
    };
    old
}

#wasm(0xFC, 0x08, .data, .memory)
memory_init :: fn(ctx: *u8, data_start: *u8, _: *i32, dest: u32, src_offset: u32, size: u32) void = {
    src := data_start.offset(src_offset.zext()).slice(size.zext());
    dest := ctx.offset(dest.zext()).slice(size.zext());
    dest.copy_from(src);
}

Futex :: import("@/lib/sys/sync/futex.fr");
