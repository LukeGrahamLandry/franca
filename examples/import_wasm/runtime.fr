// some wasm instructions don't map directly to native instructions 
// and do heavy weight things that don't need super tight code generation. 

// TODO: do something fancy with this annotation
#wasm(0xFC, 0x0F, .table)
table_grow :: fn(ctx: *u8, table: *[]rawptr, delta: i32, fill: rawptr) i32 = {
    if delta < 0 || table.len + delta.intcast() > MAX_i32 {
        return(-1);
    };
    
    // TODO: don't rely on having a dynamicenv here. 
    //       store an allocator somewhere you can get to from the linear memory base pointer
    // TODO: store capacity and amortize the resizing as well
    new := general_allocator().alloc_uninit(rawptr, table.len + delta.intcast());
    new.slice(0, table.len).copy_from(table[]);
    each new.rest(table.len) { it |
        it[] = fill;
    };
    table[] = new;
    // TODO: free the old table, :LEAK
    //       but only if this isn't the first time resizing because initial is in data segment.  
    
    table.len.intcast() - delta
}

// TODO: actually call these 
//       (my stuff doesn't use multiple threads yet so it's pointless)

#wasm(0xFE, 0x02, .memarg)
atomic_notify :: fn(ctx: *u8, addr: *u32, count: u32) i32 = {
    _ := Futex'wake(addr, count);
    
    // TODO: return the number that waiters that were woken
    0
};

#wasm(0xFE, 0x01, .memarg)
atomic_wait :: fn(ctx: *u8, addr: *u32, expect: u32, timeout_ns: i64) WasmWaitResult = {
    forever := timeout_ns < 0;
    @assert(forever, "TODO(import_wasm): atomic.wait with timeout");
    _ := Futex'wait(addr, expect);
    // TODO: return the correct reason for waking
    .Ok
}

atomic_fence :: fn(ctx: *u8) void #wasm(0xFE, 0x03, 0x00) = fence();
