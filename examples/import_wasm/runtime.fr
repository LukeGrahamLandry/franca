// some wasm instructions don't map directly to native instructions 
// and do heavy weight things that don't need super tight code generation. 

// TODO: do something fancy with this annotation
#wasm(0xFC, 0x0F, .table)
table_grow :: fn(ctx: *u8, table: *[]rawptr, delta: i32, fill: rawptr) i32 = {
    @println("table_grow(delta = %, fill = %)", delta, fill);
    if delta < 0 || table.len + delta.intcast() > MAX_i32 {
        return(-1);
    };
    
    // TODO: don't rely on having a dynamicenv here. 
    //       store an allocator somewhere you can get to from the linear memory base pointer
    // TODO: store capacity and amortize the resizing as well
    new := general_allocator().alloc_uninit(rawptr, table.len + delta.intcast());
    new.slice(0, table.len).copy_from(table[]);
    each new.rest(table.len) { it |
        it[] = fill;
    };
    table[] = new;
    // TODO: free the old table, :LEAK
    //       but only if this isn't the first time resizing because initial is in data segment.  
    
    table.len.intcast() - delta
}
