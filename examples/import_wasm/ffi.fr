#use("@/examples/import_wasm/convert.fr");
#use("@/examples/import_wasm/parse.fr");

// import_from :: @struct { module_name :: @struct { function_name : FuncId : fn(); }; };  
fn include(wasm: []u8, fr: CompCtx, export_to: ScopeId, import_from: ScopeId) void = {
    module := QbeModule.zeroed(); m := module&;
    // :HardcodeOs but it doesn't matter because we copy out of the module before doing anything. 
    init_default_module_dyn(m, fr.vtable, (arch = .aarch64, os = .macos, type = .JitOnly));
    
    push_dynamic_context {
        a: ArenaAlloc = init(fr.get_alloc(), 10000);  // TODO: nesting arenas like this is silly
        context(DefaultContext)[].temporary_allocator = a&;
        a := fr.get_alloc();
        // TODO: also it means we're leaking any temp stuff so really need to be able to 
        //       ask for our function stuff to be in a different allocator. 
        //       but also it's annoying that im doing an extra copy out of the module anyway. 
        //       maybe i want to give the compiler a callback to ask for the Fn to be filled out. 
        //       It needs 3 pieces of information: exports, callgraph and bodies, but there's 
        //       no need to supply those at the same time. we want to enable the different frontends 
        //       so run in parallel whenever possible.   :RethinkTheFfiCompileApi
        
        w: WasmModule = empty(temp());
        p: ParseWasm = (w = w&, src = wasm);
        or parse_wasm(p&) { e |
            @panic("% (at byte index %)", e, p.cursor);
        };
        
        self: LoadWasm = init(m, w&, temp());
        self&.load_module();
        initializer := self&.create_init_func();
        
        fns := temp().alloc(FuncId, self.w.code.len);
        i := 0;
        each self.w.imports { it |
            ::tagged(@type it.desc);
            if it.desc&.is(.Function) {
                module, name := (fr.intern_string(it.module.items()), fr.intern_string(it.name.items()));
                // TODO: this is bad this is very very bad! you need to use `fr` :FUCKED
                //       this means this needs to run in the same compilation context (not a precompiled driver). 
                val, ty := get_constant(import_from, module) 
                    || @panic("expected to import module '%'", it.module.items());
                s := scope_from_value(ty, val) 
                    || @panic("expected to import module '%'", it.module.items());
                get_constant(s, name, FuncId, FuncId.raw_from_ptr(fns.index(i))) // :get_or_create_type
                    || @panic("expected to import '%' from module '%'", it.name.items(), it.module.items());
                i += 1;
                // TODO: check that the signeture matches-ish
            };
        };
        n := self.w.imported_function_count;
        @debug_assert_eq(i, n);
        
        // Start by reserving all the ids so we can fill in the call graph
        range(0, self.w.code.len) { i |
            loc := Span.zeroed();  // TODO: translate this too! less interesting since it's a binary format. 
            fn_type :Type= todo();
            name :Symbol= todo();
            func := empty_fn(fn_type, name, loc);
            fns[i+n] = fr.add_function(func);
        };
        
        range(0, self.w.code.len) { i |
            f := temp().box(Qbe.Fn);
            self&.translate_func(i, f);
            
            fid := fns[i+n];
            func := fr.get_function(fid);
            func&.set_flag(.EnsuredCompiled);
            funcs := a.alloc_zeroed(FuncId, f.ncon.zext());
            datas := a.alloc_zeroed(BakedVarId, f.ncon.zext());
            callees := FuncId.list(a);
            enumerate f.con.slice(0, f.ncon.zext()) { i, c |
                if c.type == .CAddr {
                    name := m.str(c.sym.id);
                    // TODO: datas like tables, globals
                    callees[i] = todo();
                };
            };
            func.body = (Ir = (fn_internal = Qbe.Fn.int_from_ptr(f), data = datas, funcs = funcs));
            f_ty := FuncId; // TODO
            fr.add_to_scope(export_to, name, f_ty, fid);
        };
    };
}

#use("@/compiler/ast_external.fr");
