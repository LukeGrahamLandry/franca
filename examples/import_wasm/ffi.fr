#use("@/examples/import_wasm/convert.fr");
#use("@/examples/import_wasm/parse.fr");

// This works well enough for the examples/bf demo but pretty much nothing else. 
// TODO: many problems to fix:
// - don't append "$module" to the names of all the exports
// - convert tables/globals to baked var id
// - export the initializer func
// - wasm doesn't have type info so you need some way to give it bindings 
//   and have it deal with generating code for offseting the pointers from 
//   the base memory so it's not such a massive pain to use. 

// import_from :: @struct { module_name :: @struct { function_name : FuncId : fn(); }; };  
fn include(wasm: []u8, fr: CompCtx, import_from: ScopeId) ScopeId = {
    mark := mark_temporary_storage();
    m := @uninitialized QbeModule; m := m&;
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, fr.vtable, (arch = query_current_arch(), os = query_current_os(), type = .CachedEarly));
    writer := m.save.unwrap();
    // TODO: making everyone remember to do this is kinda lame
    range(0, FTy.COUNT) { _ |
        writer.fty&.push(zeroed FTy);   // skip builtin types so offsets work out
    };
    decls := Fld.list(temp());
    
    w: WasmModule = empty(temp());
    p: ParseWasm = (w = w&, src = wasm);
    or parse_wasm(p&) { e |
        @panic("% (at byte index %)", e, p.cursor);
    };
    
    self: LoadWasm = init(m, w&, temp());
    self&.load_module();
    initializer := self&.create_init_func();
    
    n := self.w.import_count&[.Func];
    i := 0;
    each self.w.imports { it |
        ::tagged(@type it.desc);
        if it.desc&.is(.Function) {            
            module, name := (it.module.items(), it.name.items());
            
            // TODO: this is bad this is very very bad! you need to use `fr` :FUCKED
            //       this means this needs to run in the same compilation context (not a precompiled driver). 
            val, ty := get_constant(import_from, fr.intern_string(module)) 
                || @panic("expected to import module '%'", module);
            s := scope_from_value(ty, val) 
                || @panic("expected to import module '%'", module);
            fid := zeroed FuncId;
            get_constant(s, fr.intern_string(name), FuncId, FuncId.raw_from_ptr(fid&)) // :get_or_create_type
                || @panic("expected to import '%' from module '%'", name, module);

            sign := self.w.types[self.function_types[i].id.zext()]&;
            type := function_type(writer, sign.arg.items(), sign.ret.items());
            mangled := @tfmt("%^%", name, module);  // :NamespaceChar
            id  := m.intern(mangled);
            idx := writer.map_sym(m, id);
            decls&.push(
                name = writer.push(mangled),
                type = type,
                payload = (offset = trunc idx),
            );
            
            m.set_library(id, "W");
            writer.sym[idx].imp.temporary_funcid = bit_cast_unchecked(FuncId, u32, fid);
            
            i += 1;
            
            // TODO: check that the signeture matches-ish
        };
    };
    @debug_assert_eq(i, n);
    
    range(0, self.w.code.len) { i |
        f := temp().box_uninit(Qbe.Fn);
        self&.translate_func(i, f);
        
        sign := self.w.types[self.function_types[n+i].id.zext()]&;
        type := function_type(writer, sign.arg.items(), sign.ret.items());
        
        fr'vtable'run_qbe_passes(Qbe.Fn.raw_from_ptr(f));
        decls&.push(
            name = writer.push(m.str(f.lnk.id)),
            type = type,
            payload = (offset = trunc writer.map_sym(m, f.lnk.id))
        );
    };
    
    meta: Meta = (arch_os = 0x0F0F, root_scope = save_fields(writer, .Scope, decls.items()));
    b := writer.to_bytes(meta, m);
    bytes := concat(b, ast_alloc());
    drop(m);
    result := fr'vtable'import_frc(fr.data, bytes);
    root_scope := result.or(fn(err) => fr.report_error(err));
    reset_temporary_storage(mark);
    
    root_scope
}

// TODO: deduplicate
fn function_type(writer: *Writer, par: []Wasm.ValType, ret: []Wasm.ValType) One(FTy) = {
    arg := writer.fld_to_par(writer.translate_types(par, true));
    ret := writer.fld_to_par(writer.translate_types(ret, false));
    writer.fty&.push(tag = .Func, payload = (func = (arg = arg, ret = ret)));
    (off = trunc(writer.fty.len - 1))
}

fn translate_types(writer: *Writer, w: []Wasm.ValType, prepend_pointer: bool) []Fld = {
    types := Fld.list(w.len + int(prepend_pointer), temp());
    if prepend_pointer {
        types&.push(type = (off = FTy.RAWPTR));
    }
    for w { w | 
        types&.push(type = w.cls().cls_to_fty());
    }
    types.items()
}

// Call this at comptime. 
// Take a struct like { Module :: { Func :: fn(); } } and create a map [func^module -> fnptr]
fn comptime_exports(Exports: Type) RawHashMap(Str, RawHashMap(Str, Rt.Export)) #fold = {
    // TODO: sane error message if you try to have this be the whole HashMap that includes ast_alloc as a rawptr
    //       but it wont have been baked before so you cant bake it now and don't know why but the error makes it sound like its a rawptr value in the map. 
    fr := current_compiler_context();
    a := ast_alloc();
    exports: HashMap(Str, RawHashMap(Str, Rt.Export)) = init(a);
    s := scope_of(Type, Exports);
    for get_constants(s) { module_name |
        s2 := scope_of(Type, get_constant(Type, s, module_name)
             || @panic("?? failed to get constant %", module_name));
        func_names := get_constants(s2);
        for func_names { func_name | 
            // note: get_constant(rawptr, _, _) when the value is an Expr::Closure does not bake it properly
            fid := get_constant(FuncId, s2, func_name)
                || @panic("?? failed to get constant %", func_name.str());
            addr := fr.get_jitted(fid);
            
            it: Rt.Export = (Function = (callee = addr, context = zeroed(rawptr)));
            exports := exports&.get_or_insert(module_name.str(), => init());
            exports.insert(func_name.str(), it, a);
        }
    }
    exports.raw&.zero_unused_slots();
    exports.raw
} 

// `s` is contains functions with first argument *u8 wasm linear memory base. 
// returns scope of functions with first argument *Rt.Header that sets dynenv and then forwards to the one in s. 
fn wrap_fns_with_load_memory(s: ScopeId) Type = {
    E2 := Type.const_eval(@{ @struct {  } });
    fr := current_compiler_context();
    for s.get_constants() { name |
        continue :: local_return;
        val, ty := get_constant(s, name) || continue();
        @if(ty != FuncId) continue();
        fid := FuncId.ptr_from_raw(val)[];
        
        func := get_function_ast(fid, false, false, false, false);
        loc := func.loc;
        if func.arg.bindings[0].ty&.is(.Finished) && func.arg.bindings[0].ty.Finished == void {
            func.arg.bindings[0].ty = (Finished = *u8);
            func.arg.bindings[0].name = (Ident = @symbol __mem);
        };
        
        pars := func.arg.bindings&.items().shallow_copy(ast_alloc());
        pars[0].ty = (Finished = *Rt.Instance);
        wrapper_func: Func = empty_fn(name, loc);
        wrapper_func.resolve_scope = Type.scope_of(E2);  // :WhatScope 
        wrapper_func.arg = (bindings = pars.as_raw_list(), loc = loc);
        wrapper_func.ret = func.ret;
        
        wrapper_fid := fr.intern_func(wrapper_func&);
        wrapper_func := get_function_ast(wrapper_fid, true, true, true, false);
        
        args := FatExpr.list(pars.len, ast_alloc());
        get :: fn(b: *Binding) FatExpr => (expr = (GetVar = b.name.Var), ty = b.ty.Finished, loc = func.loc, done = false);
        each pars { it |
            args&.push(get(it));
        };
    
        new_body := @{
            ctx := @[get(pars.index(0))];
            set_dynamic_context(ctx.env);
            mem := ctx.memory.ptr;
            @[@literal fid](@[{
                args[0] = @{ mem };
                args: FatExpr = @if(args.len == 1, 
                    args[0], 
                    (expr = (Tuple = args.as_raw()), ty = UnknownType, done = false, loc = func.loc),
                );
                args
            }])
        };
        
        wrapper_func.body = (Normal = new_body);
        
        insert :: fn(scope, name, value) => 
            (fr.vtable.add_to_scope)(fr.data, scope, name, @type value, raw_from_ptr(@type value, value&));
        insert(Type.scope_of(E2), name, wrapper_fid);
    };
    E2
}

#use("@/compiler/ast_external.fr");
#use("@/backend/incremental.fr");
#use("@/backend/lib.fr");
