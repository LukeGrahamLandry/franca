#use("@/examples/import_wasm/convert.fr");
#use("@/examples/import_wasm/parse.fr");

// This works well enough for the examples/bf demo but pretty much nothing else. 
// TODO: many problems to fix:
// - convert tables/globals to baked var id
// - wasm doesn't have type info so you need some way to give it bindings 
//   and have it deal with generating code for offseting the pointers from 
//   the base memory so it's not such a massive pain to use. 

// this is an unusual situation where everybody has to be bake-aware. 
// it doesn't just work magically because bake_relocatable_value can't 
// work for the physical jitted code. instead you have to launder it 
// through import_frc so you get the right bytes on both sides. 
// it's less noticible in the import_c example because there you also 
// get type info so don't have to write bindings and the result 
// shows up as normal functions. here there's no side benifit other
// than being able to bake a Rt.Module. 
// TODO: should talk about this in docs/aot_bake.md

// import_from :: @struct { module_name :: @struct { function_name : FuncId : fn(); }; };  
fn include(wasm: []u8, fr: CompCtx, import_from: ScopeId) *Rt.Module = {
    mark := mark_temporary_storage();
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    rt: Rt.Engine = init(ast_alloc(), (arch = query_current_arch(), os = query_current_os(), type = .CachedEarly), "");
    // TODO: allow Engine without cache, don't need to keep the wasm bytes like in hashmap? 
    mod := rt&.compile(wasm);
    m := mod.m.unwrap();
    writer := m.save.unwrap();
    // TODO: making everyone remember to do this is kinda lame
    range(0, FTy.COUNT) { _ |
        writer.fty&.push(zeroed FTy);   // skip builtin types so offsets work out
    };
    decls := Fld.list(temp());
    
    n := mod.w.import_count&[.Func];
    range(0, mod.w.code.len) { i |
        sign := mod.w.types[mod.loader.function_types[n+i].id.zext()]&;
        type := function_type(writer, sign.arg.items(), sign.ret.items());
        
        id := mod.loader.functions[n+i];
        decls&.push(
            name = writer.push(m.str(id)),
            type = type,
            payload = (offset = trunc writer.map_sym(m, id))
        );
    };
    
    meta: Meta = (arch_os = 0x0F0F, root_scope = save_fields(writer, .Scope, decls.items()));
    b := writer.to_bytes(meta, m);
    bytes := concat(b, ast_alloc());
    mod.m = .None;
    drop(m);
    result := fr'vtable'import_frc(fr.data, bytes);
    root_scope := result.or(fn(err) => fr.report_error(err));
    
    fns, _ := import("@/compiler/incremental.fr")'collect_fns_from_scope(fr, root_scope);
    @assert_eq(mod.loader.datas.len, 0, "TODO: import_wasm/ffi data");
    @assert_eq(mod.loader.functions.len - n, fns.len);
    mod.functions = ast_alloc().alloc_zeroed(rawptr, mod.loader.functions.len);
    enumerate fns { i, fid | 
        mod.functions[n + i] = fr.get_jitted(fid[]);
    };

    reset_temporary_storage(mark);
    
    mod
}

// TODO: deduplicate
fn function_type(writer: *Writer, par: []Wasm.ValType, ret: []Wasm.ValType) One(FTy) = {
    arg := writer.fld_to_par(writer.translate_types(par, true));
    ret := writer.fld_to_par(writer.translate_types(ret, false));
    writer.fty&.push(tag = .Func, payload = (func = (arg = arg, ret = ret)));
    (off = trunc(writer.fty.len - 1))
}

fn translate_types(writer: *Writer, w: []Wasm.ValType, prepend_pointer: bool) []Fld = {
    types := Fld.list(w.len + int(prepend_pointer), temp());
    if prepend_pointer {
        types&.push(type = (off = FTy.RAWPTR));
    }
    for w { w | 
        types&.push(type = w.cls().cls_to_fty());
    }
    types.items()
}

// Take a struct like { Module :: { Func :: fn(); } } and create a map [func^module -> fnptr]
fn comptime_exports(Exports: Type) []Ty(Str, Str, Rt.Export) #fold = {
    // TODO: sane error message if you try to have this be the whole HashMap that includes ast_alloc as a rawptr
    //       but it wont have been baked before so you cant bake it now and don't know why but the error makes it sound like its a rawptr value in the map. 
    fr := current_compiler_context();
    a := ast_alloc();
    exports := Ty(Str, Str, Rt.Export).list(a);
    s := scope_of(Type, Exports);
    for get_constants(s) { module_name |
        s2 := scope_of(Type, get_constant(Type, s, module_name)
             || @panic("?? failed to get constant %", module_name));
        func_names := get_constants(s2);
        for func_names { func_name | 
            // note: get_constant(rawptr, _, _) when the value is an Expr::Closure does not bake it properly
            fid := get_constant(FuncId, s2, func_name)
                || @panic("?? failed to get constant %", func_name.str());
            addr := fr.get_jitted(fid);
            
            it: Rt.Export = (Function = (callee = addr, context = zeroed(rawptr)));
            push(exports&, (module_name.str(), func_name.str(), it));
        }
    }
    exports.items()
} 

// `s` is contains functions with first argument *u8 wasm linear memory base. 
// returns scope of functions with first argument *Rt.Header that sets dynenv and then forwards to the one in s. 
fn wrap_fns_with_load_memory(s: ScopeId) Type = {
    E2 := Type.const_eval(@{ @struct {  } });
    fr := current_compiler_context();
    for s.get_constants() { name |
        continue :: local_return;
        val, ty := get_constant(s, name) || continue();
        @if(ty != FuncId) continue();
        fid := FuncId.ptr_from_raw(val)[];
        
        func := get_function_ast(fid, false, false, false, false);
        loc := func.loc;
        if func.arg.bindings[0].ty&.is(.Finished) && func.arg.bindings[0].ty.Finished == void {
            func.arg.bindings[0].ty = (Finished = *u8);
            func.arg.bindings[0].name = (Ident = @symbol __mem);
        };
        
        pars := func.arg.bindings&.items().shallow_copy(ast_alloc());
        pars[0].ty = (Finished = *Rt.Instance);
        wrapper_func: Func = empty_fn(name, loc);
        wrapper_func.resolve_scope = Type.scope_of(E2);  // :WhatScope 
        wrapper_func.arg = (bindings = pars.as_raw_list(), loc = loc);
        wrapper_func.ret = func.ret;
        
        wrapper_fid := fr.intern_func(wrapper_func&);
        wrapper_func := get_function_ast(wrapper_fid, true, true, true, false);
        
        args := FatExpr.list(pars.len, ast_alloc());
        get :: fn(b: *Binding) FatExpr => (expr = (GetVar = b.name.Var), ty = b.ty.Finished, loc = func.loc, done = false);
        each pars { it |
            args&.push(get(it));
        };
    
        new_body := @{
            ctx := @[get(pars.index(0))];
            set_dynamic_context(ctx.env);
            mem := ctx.memory.ptr;
            @[@literal fid](@[{
                args[0] = @{ mem };
                args: FatExpr = @if(args.len == 1, 
                    args[0], 
                    (expr = (Tuple = args.as_raw()), ty = UnknownType, done = false, loc = func.loc),
                );
                args
            }])
        };
        
        wrapper_func.body = (Normal = new_body);
        
        insert :: fn(scope, name, value) => 
            (fr.vtable.add_to_scope)(fr.data, scope, name, @type value, raw_from_ptr(@type value, value&));
        insert(Type.scope_of(E2), name, wrapper_fid);
    };
    E2
}

#use("@/compiler/ast_external.fr");
#use("@/backend/incremental.fr");
#use("@/backend/lib.fr");
Wasm :: import("@/backend/wasm/bits.fr");
