fn main() void = {
    @run test_incremental_compilation();
}

test_incremental_compilation :: fn() void = {
    when :: fn() => {
        file_info := zeroed MacosLibc.Stat;
        stat("examples/hacky_incremental.fr", file_info&)
            || panic("failed to stat the file");
        file_info.mtime
    }
    mtime := when();
    i := 0;
    changed := true;
    T :: @FnPtr() Str;   
    f := zeroed(T);
    loop {
        if changed {
            // Compile Error: Poison expression Unknown. if you try to replace this return type with T
            get :: fn($src: Str) (@FnPtr() Str) = import(src).result;
            src := @tfmt("{ result :: (fn() Str = { get_secret_message() }); /*%*/};", i);
            f   = invoke_specialized(Str, T, get, src);
            changed = false;
            i += 1;
        }
        println(f());
        
        new := when();
        ::AutoEq(TimeSpec);
        if new& != mtime& {
            @println("File changed at %!", new);
            
            src := libc_allocator.read_to_string_or_crash("examples/hacky_incremental.fr").items();
            quine := @tfmt("// % //", "START");
            while => !src.starts_with(quine) {
                src = src.rest(1);
            }
            while => !src.ends_with("// END //") {
                src = src.slice(0, src.len - 1);
            }
            
            mtime = new;
            changed = true;
            c := current_compiler_context();
            c'vtable'replace_body_source(c.data, get_secret_message, src);
        } else {
            usleep(1000 * 1000);
        }
    }
}

get_secret_message :: fn() Str #noinline = {
    // START // 
    "Hello World"
    // END // 
}
