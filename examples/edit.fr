#include_std("graphics/lib.fr");

/*
// TODO: this should work but does not 
Graphics :: import("@/graphics/lib.fr");
#use(Graphics);
// TODO: also this should work
#include_std("bindings/sokol.fr");
Graphics :: import("@/graphics/lib.fr");
Sdtx :: Graphics.Sdtx;
// but then things in the debugtext don't find things in the lib file for some reason. 
*/

State :: @struct(
    pass_action: SgPassAction,
    text: *Sdtx.Common,
    buffers: List(TextBuffer),
    selected_buffer: i64,
    app: Sapp.Common, // :ThisIsOnTheStackWhichWontWorkOnWasm
    sg: Sg.Self,
);

allocator :: libc_allocator;

do_init :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    
    sapp := state.app&;
    state.sg&.setup(
        environment = sapp.glue_environment(),
        allocator = allocator,
    );
    
    state.text.setup(
        allocator = allocator,
        fonts = @slice(Sdtx.font.cpc),
        sg = state.sg&,
    );
    
    b := state.buffers.index(0);
    b.at.w = sapp.width().float() / 2;
    b.at.h = sapp.height().float();
    b := state.buffers.index(1);
    b.at.w = sapp.width().float() / 2;
    b.at.h = sapp.height().float();
    b.at.pos.x = sapp.width().float() / 2;
    
    state.pass_action.colors&[0] = (
        load_action = .CLEAR,
        clear_value = (r = 0.156, g = 0.156, b = 0.156, a = 1),
    );
};

Colour :: @struct(r: i64, g: i64, b: i64, a := 255);
Pos :: @struct(x: f64, y: f64);
Rect :: @struct(pos: Pos, w: f64, h: f64);

do_render :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    mark := mark_temporary_storage();
    
    each state.buffers& { b |
        draw_text(state, b);
    };
    
    sg := state.sg&;
    state.app&.glue_begin_pass(sg, state.pass_action);
    
    sdtx := state.text.default_context&;
    sdtx.draw_layer(0);
    
    sg.end_pass();
    sg.commit();
    reset_temporary_storage(mark);
};

scroll_speed :: -2.0;

do_event :: fn(userdata: rawptr, event: *Sapp.Event) void = {
    state := State.ptr_from_raw(userdata);
   
    if event.type == .MOUSE_DOWN {
        pos: Pos = (x = event.mouse_x.cast(), y = event.mouse_y.cast());
        enumerate state.buffers& { i, b |
            if b.at.contains(pos) {
                state.selected_buffer = i;
            };
        };
    };
    
    if event.type == .KEY_DOWN {
        if event.key_code == .ESCAPE {
            state.app.quit_requested = true;
        };
    };
    
    if event.type == .MOUSE_SCROLL {
        if state.selected_buffer() { b |
            b.render.x += event.scroll_x.cast() * scroll_speed;
            b.render.y += event.scroll_y.cast() * scroll_speed;
        };
    };
};

fn selected_buffer(state: *State) ?*TextBuffer = {
    if(state.selected_buffer >= state.buffers.len, => return(.None));
    (Some = state.buffers.index(state.selected_buffer))
}

fn main() void = {
    state := State.zeroed();
    state.text = allocator.box(@type state.text[]);
    state.buffers = list(allocator);
    
    // :SLOW
    fn load_new_buffer(path: Str, a: Alloc) TextBuffer = {
        buffer := TextBuffer.zeroed();
        buffer.gpa = a;
        input := buffer.gpa.read_to_string_or_crash(path).items(); // :panic :leak
        input := input.split("\n", temp()).items();
        //buffer.lines&.reserve(input.len, buffer.gpa);  // TODO
        for input { l |
            buffer.max_x = max(buffer.max_x, l.len.float());
            buffer.lines&.push((ptr = l.ptr, len = l.len, cap = l.len), buffer.gpa);
        };
        buffer
    };
    state.buffers&.push(load_new_buffer("compiler/v2/sema.fr", allocator));
    state.buffers&.push(load_new_buffer("examples/edit.fr", allocator));
    state.app&.run(
        init_cb = do_init,
        frame_cb = do_render,
        event_cb = do_event,
        user_data = State.raw_from_ptr(state&),
        //window_title = "pleasejustletmeeditthetext", // TODO
        allocator = general_allocator(),
    );
}

fn driver(vtable: *ImportVTable) void = 
    build_for_graphics(vtable, "examples/edit.fr");

#include_std("backend/lib.fr");

TextBuffer :: @struct(
    lines: RawList(RawList(u8)),
    at: Rect,
    gpa: Alloc,
    cursor: Pos,
    render: Pos,
    max_x: f64,
    dead: bool,
);

fn draw_text(state: *State, self: *TextBuffer) void = {
    if(self.dead, => return());
    SCALE :: 16.0; // (80.0 / 1.75);
    w, h := (self.at.w, self.at.h);
    max_line_width := self.max_x - (w / SCALE);
    self.render.x = max(0, min(self.render.x, max_line_width));
    self.render.y = max(0, min(self.render.y, self.lines.len.float()));
    
    sdtx := state.text.default_context&;
    sdtx.color = pack_rgba(235, 219, 178, 255);
    sapp := state.app&;
    sdtx.canvas(sapp.width().float().div(1.75).cast(), sapp.height().float().div(1.75).cast());
    
    // the fractional component of your scroll position is used to offset the text rendering on the screen.
    // and the integral component chooses which range of lines we draw.
    sdtx.pos.y = cast(self.at.pos.y / SCALE- (self.render.y - self.render.y.floor()));
    x := cast(self.at.pos.x / SCALE - (self.render.x - self.render.x.floor()));
    sdtx.pos.x = x;
    line_count := int(h / 13.0);
    start := min(max(0, self.render.y.int()), self.lines.len);
    end   := min(start + line_count, self.lines.len);
    chars_that_fit := int(w / SCALE);
    range(start, end) { i |
        line := self.lines&.index(i);
        col := self.render.x.int();
        if col < line.len {
            count := min(line.len - col, chars_that_fit);
            sdtx.put(line.items().subslice(col, count)); 
        };
        sdtx.pos.y += 1;
        sdtx.pos.x = x;
    };
}

fn contains(r: Rect, p: Pos) bool = 
    p.x > r.pos.x && p.x < r.pos.x + r.w && p.y > r.pos.y && p.y < r.pos.y + r.h;

#use("@/lib/sys/fs.fr");
