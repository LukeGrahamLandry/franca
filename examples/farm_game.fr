#include_std("core.fr"); // TODO: handle adding these here. 

State :: @struct(
    pipe: SglPipeline,
    pass_action: SgPassAction,
);

do_init :: fn(userdata: rawptr) Unit = {
    state := State.ptr_from_raw(userdata);
    
    desc := SgDesc.zeroed();
    desc.environment = sglue_environment();
    desc.logger.func = (@resolve(@type desc.logger.func) slog_func)!fn_ptr;
    sg_setup(desc&);
    
    desc := SglDesc.zeroed();
    desc.logger.func = (@resolve(@type desc.logger.func) slog_func)!fn_ptr;
    sgl_setup(desc&);
    
    desc := SdtxDesc.zeroed();
    desc.logger.func = (@resolve(@type desc.logger.func) slog_func)!fn_ptr;
    desc.fonts&.as_ptr()[] = sdtx_font_kc854();
    sdtx_setup(desc&);
    
    desc := SgPipelineDesc.zeroed();
    state.pipe = sgl_make_pipeline(desc&);
    state.pass_action.colors&[0].load_action = .CLEAR;
    state.pass_action.colors&[0].clear_value.r = 1.0.cast();
    
};

do_render :: fn(userdata: rawptr) Unit = {
    state := State.ptr_from_raw(userdata);
    
    sgl_defaults();
    sgl_viewport(0.intcast(), 0.intcast(), sapp_width(), sapp_height(), true);
    sgl_load_pipeline(state.pipe);
    sgl_begin_quads();
    sdtx_color3f(0.0.cast(), 0.0.cast(), 1.0.cast());
    sdtx_puts("hello world".maybe_borrow_cstr(libc_allocator));
    sgl_end();
    
    desc := SgPass.zeroed();
    desc.action = state.pass_action;
    desc.swapchain = sglue_swapchain();
    desc.swapchain.width = sapp_width();
    desc.swapchain.height = sapp_height();
    sg_begin_pass(desc&);
    
    sgl_draw();
    sdtx_draw();
    
    sg_end_pass();
    sg_commit();
};

// TODO: dependency problem so can't go in the eq overload set :(
fn eqq(a: SappEventType, b: SappEventType) bool = (@as(i32) a).eq(@as(i32) b);
fn eqq(a: SappKeycode, b: SappKeycode) bool = (@as(i32) a).eq(@as(i32) b);

do_event :: fn(event: *SappEvent, userdata: rawptr) Unit = {
    state := State.ptr_from_raw(userdata);
    
    if(event.type.eqq(.KEY_DOWN).and(=> event.key_code.eqq(.Q))) {|
        exit(0);
    };
};

fn main() Unit = {
    println("Hello World");
    state := State.zeroed();
    desc := SappDesc.zeroed();
    //desc.userdata = 
    desc.init_userdata_cb = do_init!fn_ptr;
    desc.frame_userdata_cb = do_render!fn_ptr;
    desc.event_userdata_cb = do_event!fn_ptr;
    desc.user_data = State.raw_from_ptr(state&);
    // TODO: I can't decide if this would be creepy as an auto cast.
    desc.logger.func = (@resolve(@type desc.logger.func) slog_func)!fn_ptr;
    sapp_run(desc&);
}

::print_stacktrace_on_panic();
fn driver(vtable: *ImportVTable) Unit #export = {
    SOKOL_C :: """
        #include "sokol_app.h"
        #include "sokol_gfx.h"
        #include "sokol_glue.h"
        #include "sokol_log.h"
        #include "util/sokol_debugtext.h"
        #include "util/sokol_gl.h"
        #include "util/sokol_shape.h"
    """;
    // TODO: this whole thing where you have to write your program inside out is really annoying. 
    //       I want the user program to be in charge and call into the compiler as a library. 
    UserData :: @struct(
        vtable: *ImportVTable,
        sokol: DlHandle,
    );
    
    resolve_comptime_import :: fn(userdata: rawptr, comp: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = {
        userdata := UserData.ptr_from_raw(userdata);
        // TODO: can't call @println here?? oh it doesnt like when no %s?
        sokol_sym := {userdata.vtable.intern_string}(comp, "sokol");
        fn_name := {userdata.vtable.get_string}(comp, fn_name);
        ret :: @return;
        @println("Asked for a function %", fn_name);
        if(sokol_sym.eq(lib_name)){|
            fn_name := fn_name.maybe_borrow_cstr(libc_allocator);
            f := dlsym(userdata.sokol, fn_name);
            assert(f.is_null().not(), "bad sokol function name");
            ret((Some = f));
        };
        .None
    };

    dylib_path := "target/sokol.dylib";
    dylib_path_c := dylib_path.maybe_borrow_cstr(libc_allocator);
    sokol := dlopen(dylib_path_c, DlFlag.Lazy);
    if(sokol.lib.is_null()){|
        c_file := open_temp_file();
        c_file.fd&.write(SOKOL_C);
        
        // TODO: don't hardcode platform. and -DSOKOL_DLL
        // build it!
        // macos_args must go first to treat source as objective c!
        macos_args := ("-DSOKOL_METAL", "-x", "objective-c", "-framework", "Metal", "-framework", "MetalKit", "-framework", "Cocoa", "-framework", "QuartzCore")!slice;
        common_args := ("-Ivendor/sokol", "-DSOKOL_IMPL", "-DSOKOL_NO_ENTRY", "-dynamiclib", "-O2", "-o", dylib_path, c_file&.s_name())!slice;
        args := macos_args.clone(libc_allocator);
        args&.push_all(common_args);
        ::display_slice(Str);
        @println("building sokol dylib for comptime: %", args.items());
        run_cmd_blocking(CLANG_PATH, args.items());
        sokol = dlopen(dylib_path_c, DlFlag.Lazy);
        assert(sokol.lib.is_null().not(), "failed to open sokol for comptime");
        c_file.remove();
    };
    
    my_vtable: ExportVTable = (
        resolve_comptime_import = (Some = resolve_comptime_import!fn_ptr),
    );
    data: UserData = (vtable = vtable, sokol = sokol);
    
    src := libc_allocator.read_to_string("examples/farm_game.fr");
    sokol_bindings := libc_allocator.read_to_string("vendor/sokol.fr");
    src&.push_all(sokol_bindings.items());
    comp := vtable.new_with_src(src.items(), .Aarch64);
    {vtable.give_vtable}(comp, my_vtable&, UserData.raw_from_ptr(data&));
    
    jit_and_run_main(vtable, comp);
    fn jit_and_run_main(vtable: *ImportVTable, comp: Compiler) Unit = {
        main_sym := {vtable.intern_string}(comp, "main");
        main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
        {vtable.compile_func}(comp, main_f, .Jit).unwrap();
        ptr := {vtable.get_jitted_ptr}(comp, main_f).unwrap();
        {vtable.make_jitted_exec}(comp);
        f := assume_types_fn(Arg = Unit, Ret = Unit, ptr = ptr);
        f();
    }
}
