State :: @struct(
    pipe: SglPipeline,
    pass_action: SgPassAction,
    x: f64,
    y: f64,
    dx: f64,
    dy: f64,
    // TODO: not all fields have default values! :FUCKED
    world: World = (),
);

World :: @struct(
    farm: List(Planted),
    shelves: List(Shelf),
    shops: List(Shop),
    requests: List(CropType),
    player: Player,
    money: i64 = 20,
    timer: i64 = 60,
    farm_area: Rect,
);

Player :: @struct(pos: Pos, inventory: ?Object = .None, dx: f64 = 0.0, dy: f64 = 0.0);
Growth :: @enum(Seed, Ready);
CropType :: @enum(Tomato, Potato, Acorn, Tree);
Crop :: @struct(ty: CropType, age: Growth);
Planted :: @struct(pos: Pos, drought: f64 = 0.0, crop: Crop);
Object :: @tagged(
    crop: Crop,
    Scarecrow,
    Sprinkler,
    Fertalizer,
    CrowBaton,
    Shelf,
    Wall,
);
Shelf :: @struct(
    pos: Pos, 
    holding: ?Object = .None,
    crow_hp: i64 = 0,
    scarecrow: bool = false,
);
Shop :: @struct(
    pos: Pos,
    price: i64 = 0,
    item: ?Object = .None,
);

allocator :: libc_allocator;

fn load_default_world(self: *World) void = {
    self.player =  (pos = (x = 50.0, y = 50.0));
    self.shelves = list(allocator);
    range(0, 5) {i|
        self.shelves&.push((pos = (x = i.float().mul(75.0).add(350.0), y = 200.0)));
    };
    self.shops = list(allocator);
    range(0, 2) {x|
        range(0, 5) {y|
            self.shops&.push((pos = (x = x.float().mul(75.0).add(175.0), y = y.float().mul(75.0).add(300.0))));
        };
    };
    self.farm_area = (pos = (x = 350.0, y = 300.0), w = 500.0, h = 300.0);
}

do_init :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    
    desc := SgDesc.zeroed();
    desc.environment = sglue_environment();
    // TODO: single argument version of @resolve that uses inferred result type. 
    logger :: (@resolve(@type desc.logger.func) slog_func);
    desc.logger.func = logger;
    sg_setup(desc&);
    
    desc := SglDesc.zeroed();
    desc.logger.func = logger;
    sgl_setup(desc&);
    
    desc := SdtxDesc.zeroed();
    desc.logger.func = logger;
    desc.fonts&.as_ptr()[] = sdtx_font_kc854();
    sdtx_setup(desc&);
    
    desc := SgPipelineDesc.zeroed();
    // This makes transperency work
    colour := desc.colors&[0]&;
    // TODO: struct update sytax. colour.blend = (enabled = true, src_factor_rgb = .SRC_ALPHA, dst_factor_rgb = .ONE_MINUS_SRC_ALPHA, ..)
    colour.blend.enabled = true;
    colour.blend.src_factor_rgb = .SRC_ALPHA;
    colour.blend.dst_factor_rgb = .ONE_MINUS_SRC_ALPHA;
    // I think you need this if you do z index stuff and it doesn't work without it. 
    // For now the player is the only non-opaque thing so its easy to just draw things in the right order. 
    //desc.alpha_to_coverage_enabled = true;
    //desc.depth.write_enabled = true;
    //desc.depth.compare = .LESS_EQUAL;
    
    state.pipe = sgl_make_pipeline(desc&);
    state.pass_action.colors&[0].load_action = .CLEAR;
    state.pass_action.colors&[0].clear_value = (r = 0.3.cast(), g = 0.3.cast(), b = 0.3.cast(), a = 1.0.cast());
    
    state.world&.load_default_world();
    
    state.x = 0.0;
    state.y = 0.0;
    state.dx = 0.2;
    state.dy = 0.2;
};

Colour :: @struct(r: i64, g: i64, b: i64, a := 255);
Pos :: @struct(x: f64, y: f64);
red: Colour : (r = 255, g = 0, b = 0);
green: Colour : (r = 0, g = 255, b = 0);
blue: Colour : (r = 0, g = 0, b = 255);
yellow: Colour : (r = 250, g = 250, b = 0);
brown: Colour : (r = 150, g = 70, b = 20);
light_brown: Colour : (r = 180, g = 110, b = 70);
black_transparent: Colour : (r = 0, g = 0, b = 0, a = 100);

Rect :: @struct(pos: Pos, w: f64, h: f64);
base_size :: 50.0;

do_render :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    state.x += state.dx;
    state.y += state.dy;
    
    sgl_defaults();
    sgl_viewport(0.intcast(), 0.intcast(), sapp_width(), sapp_height(), true);
    sgl_load_pipeline(state.pipe);
    sdtx_color3f(0.0.cast(), 0.0.cast(), 1.0.cast());
    sdtx_canvas(sapp_width().intcast().float().div(2.0).cast(), sapp_height().intcast().float().div(2.0).cast());
    sdtx_pos(state.x.cast(), state.y.cast());
    sdtx_puts("hello world".maybe_borrow_cstr(temp()));
    
    sgl_begin_quads();
    
    fn draw(area: Rect, colour: Colour) void = {
        sgl_c4b(colour.r.trunc(), colour.g.trunc(), colour.b.trunc(), colour.a.trunc());
        
        w := sapp_width().intcast().float();
        h := sapp_height().intcast().float();
        
        x1 := area.pos.x.sub(0.0).div(w).sub(1.0).cast();
        x2 := area.pos.x.add(area.w).div(w).sub(1.0).cast();
        y1 := area.pos.y.sub(0.0).div(h.neg()).add(1.0).cast();
        y2 := area.pos.y.add(area.h).div(h.neg()).add(1.0).cast();
        
        sgl_v2f(x1, y1);
        sgl_v2f(x2, y1);
        sgl_v2f(x2, y2);
        sgl_v2f(x1, y2);
    }
    
    fn draw_square(x: f64, y: f64, size: f64, colour: Colour) void = 
        draw(@as(Rect) (pos = (x = x, y = y), w = size, h = size), colour);
    
    
    // TODO
    //fn draw_object(ty: Object, pos: Pos) void = {
    //    @match(ty) {
    //    }
    //}
    
    sgl_load_identity();
    draw_square(100.0, 100.0, 20.0, yellow);
    draw_square(200.0, 200.0, 20.0, green);
    draw_square(0.0, 0.0, 20.0, blue);
    
    state.world.farm_area.draw(light_brown);
    each state.world.shelves {obj|
        draw_square(obj.pos.x, obj.pos.y, base_size, brown);
    };
    each state.world.shops {obj|
        draw_square(obj.pos.x, obj.pos.y, base_size, light_brown);
    };
    
    fn draw(player: *Player) void = {
        draw_square(player.pos.x, player.pos.y, base_size, black_transparent);
    }
    
    state.world.player&.draw();
    
    
    sgl_end();
    
    width := sapp_width().intcast().float().div(16.0);
    if(state.x.gt(width.sub(11.0)).or(=> state.x.lt(0.0))){|
        state.dx *= 1.0.neg();
    };
    height := sapp_height().intcast().float().div(16.0);
    if(state.y.gt(height.sub(1.0)).or(=> state.y.lt(0.0))){|
        state.dy *= 1.0.neg();
    };
    
    desc := SgPass.zeroed();
    desc.action = state.pass_action;
    desc.swapchain = sglue_swapchain();
    desc.swapchain.width = sapp_width();
    desc.swapchain.height = sapp_height();
    sg_begin_pass(desc&);
    
    sgl_draw();
    sdtx_draw();
    
    sg_end_pass();
    sg_commit();
};

// TODO: dependency problem so can't go in the eq overload set :(
fn eqq(a: SappEventType, b: SappEventType) bool = (@as(i32) a).eq(@as(i32) b);
fn eqq(a: SappKeycode, b: SappKeycode) bool = (@as(i32) a).eq(@as(i32) b);

do_event :: fn(event: *SappEvent, userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    
    if(event.type.eqq(.KEY_DOWN).and(=> event.key_code.eqq(.Q))) {|
        exit(0);
    };
};

fn main() void = {
    println("Hello World");
    state := State.zeroed();
    desc := SappDesc.zeroed();
    desc.init_userdata_cb = do_init;
    desc.frame_userdata_cb = do_render;
    desc.event_userdata_cb = do_event;
    desc.user_data = State.raw_from_ptr(state&);
    // TODO: I can't decide if this would be creepy as an auto cast.
    desc.logger.func = (@resolve(@type desc.logger.func) slog_func);
    desc.window_title = "Arstotzkan Farmer 4".maybe_borrow_cstr(temp());
    sapp_run(desc&);
}

SOKOL_MACOS_LINK_ARGS :: @array("-framework", "Metal", "-framework", "MetalKit", "-framework", "Cocoa", "-framework", "QuartzCore");

fn build_sokol_cached(env: Ty(Arch, Os), linking: LinkTime) Result(Str, void) = {
    path := save_path_for_lib(env, linking, "sokol");
    if(path.file_exists(), => return((Ok = path)));
    
    SOKOL_C :: """
        #include "sokol_app.h"
        #include "sokol_gfx.h"
        #include "sokol_glue.h"
        #include "sokol_log.h"
        #include "util/sokol_debugtext.h"
        #include "util/sokol_gl.h"
        #include "util/sokol_shape.h"
    """;
    c_file := open_temp_file();
    c_file.fd&.write(SOKOL_C);
    
    args: List(Str) = list(10, temp());
    
    args&.push_all(@slice ("-Ivendor/sokol", "-DSOKOL_IMPL", "-DSOKOL_NO_ENTRY"));
    if env._1.eq(.Macos) {|
        // macos_args must go first to treat source as objective c!
        if not(eq(linking, .Static)) {|
            a := SOKOL_MACOS_LINK_ARGS;
            args&.push_all(a&.slice());
        };
        args&.push_all(@slice ("-DSOKOL_METAL", "-x", "objective-c"));
    } {|
        panic("TODO: sokol build flags on not macos");
    };
    args&.push(c_file&.s_name());
    
    @switch(linking) {
        @case(.Static) => args&.push("-c");
        @case(.Dynamic) => args&.push_all(@slice ("-DSOKOL_DLL", "-dynamiclib"));
    };
    args&.push_all(@slice ("-o", path));
    
    // Since we save it, might as well take the extra hundred years to make it go fast. 
    args&.push("-O2");
    
    // TODO
    //if(is_x86) {|
    //    // cross compile for rosetta. 
    //    args&.push_all(@slice ("-target", "x86_64-apple-darwin"));
    //};
    
    @println("building sokol: %", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    if(not(success), => return(.Err));
    c_file.remove();
    
    (Ok = path)
}

::display_slice(Str);

fn driver(vtable: *ImportVTable) void #export = {
    args := cli_args();
    for(args){ arg |
        @println("- %", arg);
    };
    
    arch_os := {vtable.comptime_arch}(); // TODO: pattern match multiple returns. 
    // TODO: this whole thing where you have to write your program inside out is really annoying. 
    //       I want the user program to be in charge and call into the compiler as a library. 
    UserData :: @struct(
        vtable: *ImportVTable,
        sokol: DlHandle,
    );
    
    is_x86 := (@as(i64)arch_os._0).eq(@as(i64) Arch.X86_64);
    //if(not(is_x86), => print_stacktrace_on_panic()); // TODO: this doesn't work! the function doesn't exist when trying to compile driver even if we don't call it
    
    resolve_comptime_import :: fn(userdata: rawptr, comp: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = {
        userdata := UserData.ptr_from_raw(userdata);
        // TODO: can't call @println here?? oh it doesnt like when no %s?
        sokol_sym := {userdata.vtable.intern_string}(comp, "sokol");
        fn_name := {userdata.vtable.get_string}(comp, fn_name);
        ret :: return;
        //@println("Asked for a function %", fn_name);
        if(sokol_sym.eq(lib_name)){|
            fn_name := fn_name.maybe_borrow_cstr(temp());
            f := dlsym(userdata.sokol, fn_name);
            assert(f.is_null().not(), "bad sokol function name");
            ret((Some = f));
        };
        .None
    };

    dylib_path := build_sokol_cached(arch_os, .Dynamic);  // TODO: should be able to unwrap in the same expression like you can later but it hasn't been instantated yet. 
    dylib_path := dylib_path.unwrap(); 

    dylib_path_c := dylib_path.maybe_borrow_cstr(temp());
    sokol := dlopen(dylib_path_c, DlFlag.Lazy);
    assert(sokol.lib.is_null().not(), "failed to open sokol for comptime");
    @println("Opened %", dylib_path);
    
    my_vtable: ExportVTable = (
        resolve_comptime_import = (Some = resolve_comptime_import),
    );
    data: UserData = (vtable = vtable, sokol = sokol);
    
    src := "#include_std(\"core.fr\");".clone(temp());
    the_code := temp().read_to_string("examples/farm_game.fr");  // TODO: don't depend on cwd.
    src&.push_all(the_code.items());
    sokol_bindings := temp().read_to_string("vendor/sokol.fr");
    src&.push_all(sokol_bindings.items());
    
    ::if(Backend);
    comp := vtable.new_with_src(src.items(), if(is_x86, => .Cranelift, => .Aarch64));
    {vtable.give_vtable}(comp, my_vtable&, UserData.raw_from_ptr(data&));
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    {vtable.compile_func}(comp, main_f, .Jit).unwrap();

    ptr := {vtable.get_jitted_ptr}(comp, main_f).unwrap();
    {vtable.make_jitted_exec}(comp);
    f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
    //f();
    //print_stacktrace_on_panic();
    
    obj_path := build_sokol_cached(arch_os, .Static).unwrap();
    
    ir_text := emit_llvm((data = comp, vtable = vtable), temp(), @slice (main_f), .ExportWithNames);
    out := open_temp_file();
    for(ir_text&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());
    a := SOKOL_MACOS_LINK_ARGS;
    args := a&.slice().clone(temp());
    args&.push_all(@slice (obj_path, "-x", "ir", out&.s_name(), "-o", "farm.out"));    
    //args&.push("-O2");
    @println("building aot exe: %", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "clang failed");
    
    out.remove(); // TODO: defer
    
}

#include_std("compiler/backend/llvm.fr");
#include_std("compiler/backend/walk_bc.fr");