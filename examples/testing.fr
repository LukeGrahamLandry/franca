// #foreign("curl", "unzip", "tar");  

#reexport("@/lib/sys/subprocess.fr");
#reexport("@/lib/sys/process.fr");
#use("@/lib/sys/fs.fr");

#generic 
fn run_tests_main($Task: Type, tasks: []Task, $get_name: @Fn(t: *Task) Str, $run: @Fn(t: *Task) Ty(bool, List(u8), List(u8), Str)) void = {
    ::FmtPad(Str);
    passed := 0;
    failed := 0;
    start := timestamp();
    each tasks { task |
        mark := mark_temporary_storage();
        start := timestamp();
        name := get_name(task);
        @print("%", f_pad(name, 40, .After));
        ok, out, err, stats := run(task);
        (@if(ok, passed&, failed&))[] += 1;
        @println("[%] % [%ms]", if(ok, => "ok", => "failed run"), stats, timestamp() - start);
        if !ok {
            print(out.items());
            println(err.items());
        };
        reset_temporary_storage(mark);
    };
    report_test_count(start, passed, failed);
}

report_test_count :: fn(start: i64, passed: i64, failed: i64) void = {
    if failed == 0 {
        @println("\nAll is fine! (passed % tests in %ms)", passed, timestamp() - start);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
    };
    if failed != 0 {
        panic("failed tests");
    };
};

#use("@/lib/sys/threads.fr");

#generic 
fn run_tests_main_threaded($Ctx: Type, $Task: Type, ctx: Ctx, tasks: []Task, get_name: @FnPtr(ctx: Ctx, t: *Task) Str, run: @FnPtr(ctx: Ctx, t: *Task) Ty(bool, List(u8), List(u8), Str)) void = {
    ::FmtPad(Str);
    nthreads := 3;  // TODO: pick this in a good way
    
    //run_tests_main(Task, tasks, fn(it) => get_name(ctx, it), fn(it) => run(ctx, it));
    //return();
    
    State :: @struct {
        passed: i64 = 0;
        failed: i64 = 0;
        ctx: Ctx;
        tasks: []Task;
        next_task: i64 = 0;
        get_name: @FnPtr(ctx: Ctx, t: *Task) Str;
        run: @FnPtr(ctx: Ctx, t: *Task) Ty(bool, List(u8), List(u8), Str);
        results: []RawList(u8); 
    };
    start := timestamp();
    out := temp().alloc_zeroed(RawList(u8), tasks.len);
    state: State = (ctx = ctx, tasks = tasks, results = out, get_name = get_name, run = run);
    threads := temp().alloc_init(*Thread, nthreads, fn(_) => start_thread(State, worker, state&));
    
    worker :: fn(self: *State) void = {
        a := general_allocator();
        loop {
            i := i64.atomic_inc(self.next_task&);
            if i >= self.tasks.len {
                return();
            };
            task := self.tasks.index(i);
            start := timestamp();
            mark := temp().mark();
            name := self'get_name(self.ctx, task);
            ok, out, err, stats := self'run(self.ctx, task);
            i64.atomic_inc(@if(ok, self.passed&, self.failed&));
            
            result := u8.list(a);
            @fmt(result&, "%", f_pad(name, 40, .After));
            ::FmtPad(i64);
            @fmt(result&, "[%] %ms | %", if(ok, => "ok", => "FAIL"), f_pad(timestamp() - start, 4, .Before), stats);
            if !ok {
                @fmt(result&, "\n%\n%", out.items(), err.items());
            };
            @fmt(result&, "\n");
            self.results[i] = result.as_raw();
            temp().reset(mark);
            print("-");
        }
    };
    
    for threads { it |
        it.join();
    };
    print("\n");
    for out { it |
        print(it.items());
        it&.drop(general_allocator());
    };
    
    report_test_count(start, state.passed, state.failed);
}

chop_file_name :: fn(s: Str) Str = {
    while => s.len > 0 && !s.ends_with(".") {
        s.len -= 1;
    };
    s.len -= s.ends_with(".").int();
    i := s.len - 1;
    while => s[i] != "/".ascii() && i > 0 {
        i -= 1;
    };
    i += int(s[i] == "/".ascii());
    s := s.rest(i);
    @debug_assert(s.len > 0, "chop_file_name expected XXX/YYY.ZZZ -> YYY");
    s
};

fn collect_with_extension(path: Str, extension: Str) Result(List(Str), void) = {
    @debug_assert(extension.starts_with("."));
    entries := collect_directory_ordered(path, temp(), temp()) 
        || return(.Err);
    out := Str.list(temp());
    each entries { e |
        if e.name.ends_with(extension) && e.name.len != extension.len {
            out&.push(e.name);
        };
    };
    (Ok = out)
}

// TODO: go through everything and stop messing around with paths
//       especially relative paths! do everything with file descriptors. 
FRANCA_CACHE_PATH :: "target/franca/deps";
// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
// cached download of a compressed resource 
// returns path to the output folder
// for now we assume the zip file will contain a directory named `HACK_name`
// TODO: this is stupid. we can't just be execing random shit. 
// TODO: don't directly dump stuff into the cache directory. 
//       check hash at the beginning, do the work, check hash again, then rename it, 
//       so you don't clobber another process that has the same dependency. t
fn fetch_or_crash(url: Str, zip_size_bytes: i64, sha256_hash: Str, HACK_name: Str) Str = {    
    folder_path := @tfmt("%/%", FRANCA_CACHE_PATH, HACK_name);
    if path_exists(folder_path) {
        return(folder_path);
    };
    mark := temp().mark();
    make_dirs_or_crash(FRANCA_CACHE_PATH);
    
    // ðŸ¤¡ no just look at whats in the file my guy
    extension := @if_else { 
        @if(url.ends_with(".tar.gz")) => "tar.gz";
        @if(url.ends_with(".zip")) => "zip";
        @else => panic("expected zip or tar.gz");
    };
    
    // TODO: this is stupid. should be able to pipe to a process. 
    zip_file_path := @tfmt("%.%", folder_path, extension);
    
    zip_bytes := "";
    if !file_exists(zip_file_path) {
        @eprintln(">>> downloading [%]...", url);
        ok, out, err := exec_and_catch("curl", @slice(url, "-s", "-L"), temp());
        @assert(ok, "failed curl %\n%", url, err.items());
        zip_bytes = out.items();
        
        @eprintln(">>> verifying [%]...", zip_file_path);
        @assert_eq(zip_bytes.len, zip_size_bytes, "bad size: %", url);
        digest := Sha256'hex(zip_bytes);
        @assert_eq(digest, sha256_hash, "bad hash %", url);
        
        write_entire_file_or_crash(zip_file_path, zip_bytes);
    };
    @eprintln(">>> unpacking [%]...", zip_file_path);
    
    if extension == "zip" {
        ok, out, err := exec_and_catch("unzip", @slice("-oq", "-d", FRANCA_CACHE_PATH, zip_file_path), temp());
    } else {
        if zip_bytes.len == 0 {
            zip_bytes = read_entire_file_or_crash(temp(), zip_file_path);
        };
        extract_tar_gz(zip_bytes, FRANCA_CACHE_PATH, HACK_name);
    };
    // not checking !ok because it doesn't like strange filenames 
    // this is why we can't be using whatever random shit i happen to have installed. 
    
    temp().reset(mark);
    folder_path
}

extract_tar_gz :: fn(compressed: []u8, dir: Str, HACK_name: Str) void = {
    @debug_assert(!dir.ends_with(PATH_SEP) && dir.len > 0);
    Deflate :: import("@/lib/encoding/deflate.fr");
    GZip :: import("@/lib/encoding/gzip.fr");
    Tar :: import("@/lib/encoding/tar.fr");
    o := u8.list(temp());
    skip := GZip'header_size(compressed) 
        || @panic("missing gzip header");
    _, err := Deflate'decompress(compressed.rest(skip), o&);
    ::enum(@type err);
    @assert_eq(err, .Ok, "failed to un-gzip (for output path: %/%)", dir, HACK_name);
    
    File :: @struct {
        name: Str;
        contents: Str;
        dir: bool;
    };
    
    files := File.list(temp());
    err := Tar'iter(o.items()) { h, b |
        name: CStr = (ptr = h.name&.as_ptr());
        name := name.str();
        @assert(name.starts_with(HACK_name), "'%' does not have prefix '%'", name, HACK_name);
        @assert(!name.has_path_escapes(), "'%' is a path with special dots, i don't like that", name);
        
        // TODO: use prefix for longer than 100 char names
        //       (careful of checking for /../ that spans between prefix and name)
        @switch(h.typeflag) {
            @case(Tar.TYPE.REG) => {
                // TODO: maybe want to set executable bit based on mode field
                files&.push(name = name, contents = b, dir = false);
            };
            @case(Tar.TYPE.DIR) => {
                @assert_eq(b.len, 0, "non zero size directory: %", name);
                files&.push(name = name, contents = b, dir = true);
            };
            @case(Tar.TYPE.PAX) => ();  // TODO: get whatever data's in there since it might change the meaning of other stuff?
            @default => @panic("unhandled tar block type % for %", h.typeflag, name);
        }
    };
    ::enum(@type err.Err);
    err.or(fn(e) => @panic("%: failed to un-tar (for output path: %)", e, dir));
    
    // make the order fixed so the hash doesn't change based on how the archive was made
    Sort :: import("@/lib/sort.fr");
    sort :: Sort'quicksort(File, fn(a, b) => Sort'order_strings(a.name&, b.name&));
    sort(files.items());
    
    // TODO: i skip extract_tar_gz if the directory exists, so if any of these writes fail
    //       i need to delete the outer directory so trying again doesn't just assume it's fine. 
    
    p := u8.list(temp());
    each files { it |
        p&.clear();
        p&.push_all(dir);
        p&.push_all("/");
        p&.push_all(it.name);
        
        // lua-5.4.7-tests.tar.gz: 
        // - you're allowed to have files in nested directories without explicitly making them
        // - you're allowed to have directories with no files and they need to get made 
        //   (like attrib.lua needs libs/P1 to pre-exist)
        if it.dir {
            make_dirs_or_crash(p.items());
        } else {
            {  // :SLOW
                n := p.len;
                p&.pop_path_segment();
                @debug_assert(p.items().ends_with(PATH_SEP) && p.items().starts_with(dir));
                if p.len > dir.len + 1 {
                    make_dirs_or_crash(p.items());  
                };
                p.len = n;
            };
            
            write_entire_file_or_crash(p.items(), it.contents);
        }
    };
};

// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
fn fetch_text_or_crash(url: Str, size: i64, sha256_hash: Str, a: Alloc) Str = {
    path := @tfmt("%/%.txt", FRANCA_CACHE_PATH, sha256_hash);
    if read_entire_file(a, path) { s |
        return s;
    };
    make_dirs_or_crash(FRANCA_CACHE_PATH);
    
    @eprintln(">>> downloading [%]...", url);
    ok, out, err := exec_and_catch("curl", @slice(url, "-s", "-L"), a);
    @assert(ok, "failed curl %\n%", url, err.items());
    err&.drop();
    
    @eprintln(">>> verifying [%]...", path);
    @assert_eq(out.len, size, "bad size: %", url);
    digest := Sha256'hex(out.items());
    @assert_eq(digest, sha256_hash, "bad hash %", url);
    
    write_entire_file_or_crash(path, out.items());
    
    // TODO: need a `shink_to_fit(List) -> Slice` so you can free it in allocators that don't track size.
    out.items()
}

// ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡ðŸ¤¡
fn fetch_git_commit(commit: Str, name: Str, url: Str) Str = {
    make_dirs_or_crash("target/franca/deps");
    root := @tfmt("target/franca/deps/%-%", name, commit);
    println(root);
    if root.dir_exists() {
        return(root);
    };
    start := get_working_directory(temp()).items();
    root.make_dir().assert("failed to makedir");
    Syscall'chdir(root.as_cstr()) || @panic("failed to set cwd to %", root);
    // TODO: this is annoying. it doesn't fit with my general pattern of just give me a url to a .tar.gz file. 
    //       but i can't really blame them for not wanting to use the microsoft thing. 
    //       i don't really want to use some random persons mirror of it but maybe that would be a better option.
    //       there's a hash so it doesn't really matter what the url is. 
    //       also my program should be hashing some bytes itself. trusting whatever we exec does not spark joy. 
    // TODO: since the making the directory isn't atmoic with cloning into it you can get into a broken state if you 
    //       kill the program while this is happening. 
    sh(@slice("git", "clone", "--depth=1", url, "."));
    sh(@slice("git", "config", "advice.detachedHead", "false"));  // shutup!!
    sh(@slice("git", "fetch", "--depth=1", "origin", commit));
    sh(@slice("git", "checkout", commit));
    sh(@slice("git", "fsck"));
    Syscall'chdir(start.as_cstr()) || @panic("failed to set cwd");
    root
}

// macos doesn't like when you run an executable that crashes 
// and then write over the same path with a new program and run that. 
fn three_trillion_dollars_does_not_buy_an_operating_system_that_works(path: Str) void = {
    if query_current_os() == .macos {
        _ := remove(as_cstr path);
    };
}

sh :: fn(a: []Str) void = {
    show :: fn() => {
        for a { a |
            @print("% ", a);
        };
        println("");
    };
    show();
    ok := if false {
        ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
        if !ok {
            print(out.items());
            print(err.items());
        };
        ok
    } else {
        run_cmd_blocking(a[0], a.slice(1, a.len))
    };
    if !ok {
        print("Failed to run: ");
        show();
        panic("sh failed");
    };
};

hush :: fn(a: []Str) Str = {
    ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
    if !ok {
        print(out.items());
        print(err.items());
        ::display_slice(Str);
        
        print("Failed to run: ");
        for a { a |
            @print("% ", a);
        };
        println("");
        panic("sh failed");
    };
    out.items()
};

// weird names that won't come out right:
// - "a//b" means "a/b" because can't have directory called ""
// - "a/../b" means "b" because ".." is parent directory
// - "a/./b" means "a/b" because "." means current directory 
// - similarly can't end with "." or ".." as a file name because they're taken
// - leading "/" is root, which doesn't matter if im putting a prefix anyway but still seems like a weird thing to do.  
// idk if i should just allow the ones that aren't harmful just confusing. 
has_path_escapes :: fn(path: Str) bool = {
    @run @ct_assert(PATH_SEP == "/", @source_location(), "");
    while => path.len > 0 {
        prefix := path.pop_path_segment();
        segment := path.rest(prefix.len);  // will end with a / when its not the last one. 
        if segment == "../" || segment == "./" || segment == ".." || segment == "." || segment == "/" {
            return(true);
        };
        path = prefix;
    };
    path.starts_with("/")
};
