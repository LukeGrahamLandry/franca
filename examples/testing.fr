// #foreign("curl", "git");  

#reexport("@/lib/sys/subprocess.fr");
#reexport("@/lib/sys/process.fr");
#use("@/lib/sys/fs.fr");

#generic 
fn run_tests_main($Task: Type, tasks: []Task, $get_name: @Fn(t: *Task) Str, $run: @Fn(t: *Task) Ty(bool, List(u8), List(u8), Str)) void = {
    ::FmtPad(Str);
    passed := 0;
    failed := 0;
    start := timestamp();
    each tasks { task |
        mark := mark_temporary_storage();
        start := timestamp();
        name := get_name(task);
        @print("%", f_pad(name, 40, .After));
        ok, out, err, stats := run(task);
        (@if(ok, passed&, failed&))[] += 1;
        @println("[%] % [%ms]", if(ok, => "ok", => "failed run"), stats, timestamp() - start);
        if !ok {
            print(out.items());
            println(err.items());
        };
        reset_temporary_storage(mark);
    };
    report_test_count(start, passed, failed);
}

report_test_count :: fn(start: i64, passed: i64, failed: i64) void = {
    if failed == 0 {
        @println("\nAll is fine! (passed % tests in %ms)", passed, timestamp() - start);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
    };
    if failed != 0 {
        panic("failed tests");
    };
};

#use("@/lib/sys/threads.fr");

#generic 
fn run_tests_main_threaded($Ctx: Type, $Task: Type, ctx: Ctx, tasks: []Task, get_name: @FnPtr(ctx: Ctx, t: *Task) Str, run: @FnPtr(ctx: Ctx, t: *Task) Ty(bool, List(u8), List(u8), Str)) void = {
    ::FmtPad(Str);
    // TODO: pick this in a good way
    nthreads := get_environment_variable("FRANCA_DASH_J") || "3";  
    nthreads := parse_int(nthreads.str());
    
    if nthreads <= 1 {
        run_tests_main(Task, tasks, fn(it) => get_name(ctx, it), fn(it) => run(ctx, it));
        return();
    };
    State :: @struct {
        passed: i64 = 0;
        failed: i64 = 0;
        ctx: Ctx;
        tasks: []Task;
        next_task: i64 = 0;
        get_name: @FnPtr(ctx: Ctx, t: *Task) Str;
        run: @FnPtr(ctx: Ctx, t: *Task) Ty(bool, List(u8), List(u8), Str);
        results: []RawList(u8); 
    };
    start := timestamp();
    out := temp().alloc_zeroed(RawList(u8), tasks.len);
    state: State = (ctx = ctx, tasks = tasks, results = out, get_name = get_name, run = run);
    threads := temp().alloc_init(*Thread, nthreads, fn(_) => start_thread(State, worker, state&));
    
    worker :: fn(self: *State) void = {
        a := general_allocator();
        loop {
            i := i64.atomic_inc(self.next_task&);
            if i >= self.tasks.len {
                return();
            };
            task := self.tasks.index(i);
            start := timestamp();
            mark := temp().mark();
            name := self'get_name(self.ctx, task);
            ok, out, err, stats := self'run(self.ctx, task);
            i64.atomic_inc(@if(ok, self.passed&, self.failed&));
            
            result := u8.list(a);
            @fmt(result&, "%", f_pad(name, 40, .After));
            ::FmtPad(i64);
            @fmt(result&, "[%] %ms | %", if(ok, => "ok", => "FAIL"), f_pad(timestamp() - start, 4, .Before), stats);
            if !ok {
                @fmt(result&, "\n%\n%", out.items(), err.items());
            };
            @fmt(result&, "\n");
            self.results[i] = result.as_raw();
            temp().reset(mark);
            print("-");
        }
    };
    
    for threads { it |
        it.join();
    };
    print("\n");
    for out { it |
        print(it.items());
        it&.drop(general_allocator());
    };
    
    report_test_count(start, state.passed, state.failed);
}

chop_file_name :: fn(s: Str) Str = {
    while => s.len > 0 && !s.ends_with(".") {
        s.len -= 1;
    };
    s.len -= s.ends_with(".").int();
    i := s.len - 1;
    while => s[i] != "/".ascii() && i > 0 {
        i -= 1;
    };
    i += int(s[i] == "/".ascii());
    s := s.rest(i);
    @debug_assert(s.len > 0, "chop_file_name expected XXX/YYY.ZZZ -> YYY");
    s
};

fn collect_with_extension(path: Str, extension: Str) Result(List(Str), void) = {
    @debug_assert(extension.starts_with("."));
    
    out := Str.list(temp());
    ok := walk_directory_unordered(path.as_cstr()) { e |
        if e.name.ends_with(extension) && e.name.len != extension.len {
            out&.push(e.name.shallow_copy(temp()));
        };
    };
    // TODO: deal with error while iterating dir seperatly from err while opening. 
    @if(!ok) return(.Err);
    Sort :: import("@/lib/sort.fr");
    sort :: Sort'quicksort(Str, Sort'order_strings);
    sort(out.items());
    (Ok = out)
}

// TODO: go through everything and stop messing around with paths
//       especially relative paths! do everything with file descriptors. 
FRANCA_PATH_DEPS :: "target/franca/deps";
FRANCA_PATH_FETCH :: "target/franca/fetch";
// ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡
// cached download of a compressed resource 
// returns path to the output folder
// for now we assume the zip file will contain a directory named `HACK_name`
fetch_or_crash :: fn(url: Str, zip_size_bytes: i64, sha256_hash: Str, HACK_name: Str) Str = { 
    @debug_assert(!HACK_name.ends_with("/"));
    folder_path := @tfmt("%/%", FRANCA_PATH_DEPS, HACK_name);
    if dir_exists(folder_path) {
        return(folder_path);
    };
    mark := temp().mark();
    
    // ğŸ¤¡ no just look at whats in the file my guy
    extension := @if_else { 
        @if(url.ends_with(".tar.gz")) => "tar.gz";
        @if(url.ends_with(".zip")) => "zip";
        @else => panic("expected zip or tar.gz");
    };
    
    zip_bytes := fetch(url, zip_size_bytes, sha256_hash) 
        || @panic("failed to download dependency");

    // i skip the extract if the final path exists so if the extract fails for some reason, 
    // and you rerun the program, don't treat it as though it succeeded. 
    make_dirs_or_crash(FRANCA_PATH_DEPS);
    scratch_path := @tfmt("%/%.%", FRANCA_PATH_DEPS, sha256_hash, timestamp());
    make_dirs_or_crash(scratch_path);
    extract_archive(zip_bytes, scratch_path, HACK_name, extension == "zip");
    if dir_exists(folder_path) {
        // another thread won the race.
        // TODO: don't leak scratch_path. but need to do a whole recursive delete situation
    } else {
        // TODO: this is still fragile if you write to the directory, which i shouldn't do but i do in tests/external/wuffs,lua,tcc
        rename(scratch_path.as_cstr(), folder_path.as_cstr())
            || @panic("failed to rename to %", folder_path);
    };
    
    temp().reset(mark);
    folder_path
};

fetch :: fn(url: Str, zip_size_bytes: i64, sha256_hash: Str) ?[]u8 = {
    @debug_assert_eq(sha256_hash.len, 64);
    for(sha256_hash, fn(c) => @debug_assert(hex_digit(c).is_some()));
    zip_file_path := @tfmt("%/%.out", FRANCA_PATH_FETCH, sha256_hash);
    
    zip_bytes := "";
    if !file_exists(zip_file_path) {
        make_dirs_or_crash(FRANCA_PATH_FETCH);
        s, h, p := (zip_size_bytes, sha256_hash, zip_file_path);
        // sometimes github is down but not cloudflare... 
        zip_bytes = fetch_one(url, s, h, p) 
            || fetch_one(@tfmt("https://lukegrahamlandry.ca/franca/mirror/%", sha256_hash), s, h, p)
            || return(.None);
    };
    
    if zip_bytes.len == 0 {
        zip_bytes = read_entire_file_or_crash(temp(), zip_file_path);
    };
    (Some = zip_bytes)
};

// uncached!
fetch_one :: fn(url: Str, zip_size_bytes: i64, sha256_hash: Str, zip_file_path: Str) ?[]u8 = {
    @eprintln(">>> downloading [%]...", url);
    zip_bytes := if query_current_arch() == .wasm32 {
        js_write :: fn(id: i64, ptr: *u8, len: i64) i64 #weak #import("libc");
        dest := temp().alloc_uninit(u8, zip_size_bytes);
        dest.slice(0, sha256_hash.len).copy_from(sha256_hash);
        result := js_write(0xBBBB0002, dest.ptr, dest.len);
        @if(result == -1) return(.None);
        dest.slice(0, result)
    } else {
        ok, out, err := exec_and_catch("curl", @slice(url, "-s", "-L", "-f"), temp());
        if !ok {
            @eprintln("failed curl %\n%", url, err.items());
            return(.None);
        };
        out.items()
    };
    @eprintln(">>> verifying [%]...", zip_file_path);
    if zip_bytes.len != zip_size_bytes {
        @eprintln("bad size: %\n%\n%", url, zip_bytes.len, zip_size_bytes);
        return(.None);
    };
    digest := Sha256'hex(zip_bytes);
    if digest != sha256_hash {
        @eprintln("bad hash %\n%\n%", url, digest, sha256_hash);
        return(.None);
    };
    
    write_entire_file_or_crash(zip_file_path, zip_bytes);
    (Some = zip_bytes)
};

extract_archive :: fn(compressed: []u8, dir: Str, HACK_name: Str, is_zip: bool) void = {
    @debug_assert(!dir.ends_with(PATH_SEP) && dir.len > 0);
    Deflate :: import("@/lib/encoding/deflate.fr");
    GZip :: import("@/lib/encoding/gzip.fr");
    Zip :: import("@/lib/encoding/pkzip.fr");
    Tar :: import("@/lib/encoding/tar.fr");
    
    File :: @struct {
        name: Str;
        contents: Str;
        dir: bool;
    };
    
    files := File.list(temp());
    if is_zip {
        ecd := Zip'find(compressed)
            || @panic("invalid zip for %", dir);
        Zip'iter(compressed, ecd) { it |
           files&.push(
                name = it.name,
                contents = it&.data(temp()),
                dir = it.name.ends_with("/") && it.data.len == 0
            );
        };
    } else {
        o := u8.list(temp());
        skip := GZip'header_size(compressed) 
            || @panic("missing gzip header");
        _, err := Deflate'decompress(compressed.rest(skip), o&);
        ::enum(@type err);
        @assert_eq(err, .Ok, "failed to un-gzip (for output path: %/%)", dir, HACK_name);
        err := Tar'iter(o.items()) { h, b |
            name: CStr = (ptr = h.name&.as_ptr());
            prefix: CStr = (ptr = h.prefix&.as_ptr());
            name := name.str();
            prefix := prefix.str();
            if prefix.len != 0 {
                name = @tfmt("%/%", prefix, name);
            };

            @switch(h.typeflag) {
                @case(Tar.TYPE.REG) => {
                    // TODO: maybe want to set executable bit based on mode field
                    files&.push(name = name, contents = b, dir = false);
                };
                @case(Tar.TYPE.DIR) => {
                    @assert_eq(b.len, 0, "non zero size directory: %", name);
                    files&.push(name = name, contents = b, dir = true);
                };
                @case(Tar.TYPE.PAX) => ();  // TODO: get whatever data's in there since it might change the meaning of other stuff?
                @case(Tar.TYPE.PAX2) => ();
                @case(Tar.TYPE.SYM) => {
                    @eprintln("WARNING: ignoring symlink in tar. %", name);
                };
                @default => @panic("unhandled tar block type % for %", h.typeflag, name);
            }
        };
        ::enum(@type err.Err);
        err.or(fn(e) => @panic("%: failed to un-tar (for output path: %)", e, dir));
    };
    // make the order fixed so the hash doesn't change based on how the archive was made
    Sort :: import("@/lib/sort.fr");
    sort :: Sort'quicksort(File, fn(a, b) => Sort'order_strings(a.name&, b.name&));
    sort(files.items());
    // TODO: instead of hashing the compressed archive before, hash the file contents now. 
    
    p := u8.list(temp());
    each files { it |
        p&.clear();
        p&.push_all(dir);
        p&.push_all("/");
        if it.name.starts_with(HACK_name) {
            it.name = it.name.rest(HACK_name.len + 1);
        };
        p&.push_all(it.name);
        @assert(!it.name.has_path_escapes(), "'%' is a path with special dots, i don't like that", it.name);
        
        // lua-5.4.7-tests.tar.gz: 
        // - you're allowed to have files in nested directories without explicitly making them
        // - you're allowed to have directories with no files and they need to get made 
        //   (like attrib.lua needs libs/P1 to pre-exist)
        if it.dir {
            make_dirs_or_crash(p.items());
        } else {
            {  // :SLOW
                n := p.len;
                p&.pop_path_segment();
                @debug_assert(p.items().ends_with(PATH_SEP) && p.items().starts_with(dir));
                if p.len > dir.len + 1 {
                    make_dirs_or_crash(p.items());  
                };
                p.len = n;
            };
            
            write_entire_file_or_crash(p.items(), it.contents);
        }
    };
};

// ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡
fetch_text_or_crash :: fn(url: Str, size: i64, sha256_hash: Str) Str = {
    fetch(url, size, sha256_hash) 
        || @panic("failed to download dependency")
};

// ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡ğŸ¤¡
fetch_git_commit :: fn(commit: Str, name: Str, url: Str) Str = {
    make_dirs_or_crash("target/franca/deps");
    root := @tfmt("target/franca/deps/%-%", name, commit);
    println(root);
    if root.dir_exists() {
        return(root);
    };
    start := get_working_directory(temp()).items();
    root.make_dir().assert("failed to makedir");
    Syscall'chdir(root.as_cstr()) || @panic("failed to set cwd to %", root);
    // TODO: this is annoying. it doesn't fit with my general pattern of just give me a url to a .tar.gz file. 
    //       but i can't really blame them for not wanting to use the microsoft thing. 
    //       i don't really want to use some random persons mirror of it but maybe that would be a better option.
    //       there's a hash so it doesn't really matter what the url is. 
    //       also my program should be hashing some bytes itself. trusting whatever we exec does not spark joy. 
    // TODO: since the making the directory isn't atmoic with cloning into it you can get into a broken state if you 
    //       kill the program while this is happening. 
    sh(@slice("git", "clone", "--depth=1", url, "."));
    sh(@slice("git", "config", "advice.detachedHead", "false"));  // shutup!!
    sh(@slice("git", "fetch", "--depth=1", "origin", commit));
    sh(@slice("git", "checkout", commit));
    sh(@slice("git", "fsck"));
    Syscall'chdir(start.as_cstr()) || @panic("failed to set cwd");
    root
};

// macos doesn't like when you run an executable that crashes 
// and then write over the same path with a new program and run that. 
fn three_trillion_dollars_does_not_buy_an_operating_system_that_works(path: Str) void = {
    if query_current_os() == .macos {
        _ := remove(as_cstr path);
    };
}

sh :: fn(a: []Str) void = {
    show :: fn() => {
        for a { a |
            @print("% ", a);
        };
        println("");
    };
    show();
    ok := if false {
        ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
        if !ok {
            print(out.items());
            print(err.items());
        };
        ok
    } else {
        run_cmd_blocking(a[0], a.slice(1, a.len))
    };
    if !ok {
        print("Failed to run: ");
        show();
        panic("sh failed");
    };
};

hush :: fn(a: []Str) Str = {
    ok, out, err := exec_and_catch(a[0], a.rest(1), temp());
    if !ok {
        print(out.items());
        print(err.items());
        ::display_slice(Str);
        
        print("Failed to run: ");
        for a { a |
            @print("% ", a);
        };
        println("");
        panic("sh failed");
    };
    out.items()
};

// weird names that won't come out right:
// - "a//b" means "a/b" because can't have directory called ""
// - "a/../b" means "b" because ".." is parent directory
// - "a/./b" means "a/b" because "." means current directory 
// - similarly can't end with "." or ".." as a file name because they're taken
// - leading "/" is root, which doesn't matter if im putting a prefix anyway but still seems like a weird thing to do.  
// idk if i should just allow the ones that aren't harmful just confusing. 
has_path_escapes :: fn(path: Str) bool = {
    @run @ct_assert(PATH_SEP == "/", @source_location(), "");
    while => path.len > 0 {
        prefix := path.pop_path_segment();
        segment := path.rest(prefix.len);  // will end with a / when its not the last one. 
        if segment == "../" || segment == "./" || segment == ".." || segment == "." || segment == "/" {
            return(true);
        };
        path = prefix;
    };
    path.starts_with("/")
};

main :: fn() void = {
    args := cli_args();
    @assert_ge(args.len, 6, "not enough arguments to fetch");
    @assert_eq(args[1].str(), "fetch");
    result := fetch_or_crash(args[2].str(), args[3].str().parse_int(), args[4].str(), args[5].str());
    print(result);
};
