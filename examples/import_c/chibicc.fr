Token :: @rec @struct(
    kind: Tokens.TokenKind,
    next: *Token,
    val: i64,
    fval: f64, // Long double,
    loc: CStr,
    len: i32,
    ty: *CType,
    str: CStr,
    file: *File,
    filename: CStr,
    line_no: i32,
    line_delta: i32,
    at_bol: bool,
    has_space: bool,
    hideset: *Hideset,
    origin: *Token,
);
fn error(fmt: CStr) void #import("chibicc");
fn error_at(loc: CStr, fmt: CStr) void #import("chibicc");
fn warn_tok(tok: *Token, fmt: CStr) void #import("chibicc") #c_variadic;
fn convert_pp_tokens(tok: *Token) void #import("chibicc");
fn get_input_files() **File #import("chibicc");
fn new_file(name: CStr, file_no: i32, contents: CStr) *File #import("chibicc");
fn tokenize_string_literal(tok: *Token, basety: *CType) *Token #import("chibicc");
fn tokenize(file: *File) *Token #import("chibicc");
fn tokenize_file(filename: CStr) *Token #import("chibicc");
fn search_include_paths(filename: CStr) CStr #import("chibicc");
fn init_macros() void #import("chibicc");
fn define_macro(name: CStr, buf: CStr) void #import("chibicc");
fn undef_macro(name: CStr) void #import("chibicc");
fn preprocess(tok: *Token) *Token #import("chibicc");
Obj :: @rec @struct(
    next: *Obj,
    name: CStr,
    ty: *CType,
    tok: *Token,
    is_local: bool,
    align: i32,
    stack_slot: Qbe.Ref, 
    is_function: bool,
    is_definition: bool,
    is_static: bool,
    is_tentative: bool,
    is_tls: bool,
    init_data: []u8,
    init_data_needs_null_terminator: bool,
    rel: *Relocation,
    is_inline: bool,
    params: *Obj,
    body: *Node,
    locals: *Obj,
    va_area: *Obj,
    alloca_bottom: *Obj,
    stack_size: i32,
    is_live: bool,
    is_root: bool,
    refs: StringArray,
    f: *Qbe.Fn,
    par_r: Qbe.Ref,
);
Relocation :: @rec @struct(
    next: *Relocation,
    offset: i32,
    label: CStr,  // TODO: why does chibicc have an extra *indirection here?
    addend: i64,
);
Node :: @rec @struct(
    kind: NodeKind,
    next: *Node,
    ty: *CType,
    tok: *Token,
    lhs: *Node,
    rhs: *Node,
    cond: *Node,
    then: *Node,
    else: *Node,
    body: *Node,
    member: *Member,
    func_ty: *CType,
    args: *Node,
    ret_buffer: *Obj,
    var: *Obj,
    r: Qbe.Ref,
    lvalue: Qbe.Ref,  // what would you get if you took the & of this expression
    current_block: *Qbe.Blk,   // TODO: remove
);

CType :: @rec @struct(
    kind: TypeKind,
    size: i32,
    align: i32,
    is_unsigned: bool,
    is_atomic: bool,
    origin: *CType,
    base: *CType,
    name: *Token,
    name_pos: *Token,
    array_len: i32,
    vla_len: Qbe.Ref,
    vla_size: Qbe.Ref,
    members: *Member,
    is_flexible: bool,
    is_packed: bool,
    return_ty: *CType,
    params: *CType,
    is_variadic: bool,
    next: *CType,
);
Member :: @rec @struct(
    next: *Member,
    ty: *CType,
    tok: *Token,
    name: *Token,
    idx: i32,
    align: i32,
    offset: i32,
    is_bitfield: bool,
    bit_offset: i32,
    bit_width: i32,
);
fn encode_utf8(buf: CStr, c: u32) i32 #import("chibicc");
fn decode_utf8(new_pos: *CStr, p: CStr) u32 #import("chibicc");

fn display_width(p: CStr, len: i32) i32 #import("chibicc");

fn file_exists(path: CStr) bool #import("chibicc");

TypeKind :: @enum(i32) (
    TY_VOID,
    TY_BOOL,
    TY_CHAR,
    TY_SHORT,
    TY_INT,
    TY_LONG,
    TY_FLOAT,
    TY_DOUBLE,
    TY_LDOUBLE,
    TY_ENUM,
    TY_PTR,
    TY_FUNC,
    TY_ARRAY,
    TY_VLA, // variable-length array
    TY_STRUCT,
    TY_UNION,
);

NodeKind :: @enum(i32) (
    ND_NULL_EXPR, // Do nothing
    ND_STMT,
    ND_ADD,       // +
    ND_SUB,       // -
    ND_MUL,       // *
    ND_DIV,       // /
    ND_NEG,       // unary -
    ND_MOD,       // %
    ND_BITAND,    // &
    ND_BITOR,     // |
    ND_BITXOR,    // ^
    ND_SHL,       // <<
    ND_SHR,       // >>
    ND_EQ,        // ==
    ND_NE,        // !=
    ND_LT,        // <
    ND_LE,        // <=
    ND_ASSIGN,    // =
    ND_COND,      // ?:
    ND_COMMA,     // ,
    ND_MEMBER,    // . (struct member access)
    ND_ADDR,      // unary &
    ND_DEREF,     // unary *
    ND_NOT,       // !
    ND_BITNOT,    // ~
    ND_LOGAND,    // &&
    ND_LOGOR,     // ||
    ND_FUNCALL,   // Function call
    ND_VAR,       // Variable
    ND_VLA_PTR,   // VLA designator
    ND_NUM,       // Integer
    ND_CAST,      // Type cast
    ND_MEMZERO,   // Zero-clear a stack variable
    //ND_ASM,       // "asm"
    //ND_CAS,       // Atomic compare-and-swap
    //ND_EXCH,      // Atomic exchange
    ND_INVALID,
);

fn strarray_push(arr: *StringArray, s: CStr) void #import("chibicc");
StringArray :: @struct(ptr: *CStr, cap: i32, len: i32);

File :: @struct(
    name: CStr,
    file_no: i32,
    contents: CStr,
    
    // For #line directive
    display_name: CStr,
    line_delta: i32,
);

Hideset :: @rec @struct(
    next: *Hideset,
    name: CStr,
);
