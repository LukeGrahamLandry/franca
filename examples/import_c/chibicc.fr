Token :: @rec @struct(
    kind: TokenKind,
    next: *Token,
    val: i64,
    fval: f64, // Long double,
    loc: CStr,
    len: i32,
    ty: *Type,
    str: CStr,
    file: *File,
    filename: CStr,
    line_no: i32,
    line_delta: i32,
    at_bol: bool,
    has_space: bool,
    hideset: *Hideset,
    origin: *Token,
);
fn error(fmt: CStr) void #import("chibicc");
fn error_at(loc: CStr, fmt: CStr) void #import("chibicc");
fn error_tok(tok: *Token, fmt: CStr) void #import("chibicc");
fn warn_tok(tok: *Token, fmt: CStr) void #import("chibicc");
fn equal(tok: *Token, op: CStr) bool #import("chibicc");
fn skip(tok: *Token, op: CStr) *Token #import("chibicc");
fn consume(rest: **Token, tok: *Token, str: CStr) bool #import("chibicc");
fn convert_pp_tokens(tok: *Token) void #import("chibicc");
fn get_input_files() **File #import("chibicc");
fn new_file(name: CStr, file_no: i32, contents: CStr) *File #import("chibicc");
fn tokenize_string_literal(tok: *Token, basety: *Type) *Token #import("chibicc");
fn tokenize(file: *File) *Token #import("chibicc");
fn tokenize_file(filename: CStr) *Token #import("chibicc");
fn search_include_paths(filename: CStr) CStr #import("chibicc");
fn init_macros() void #import("chibicc");
fn define_macro(name: CStr, buf: CStr) void #import("chibicc");
fn undef_macro(name: CStr) void #import("chibicc");
fn preprocess(tok: *Token) *Token #import("chibicc");
Obj :: @rec @struct(
    next: *Obj,
    name: CStr,
    ty: *Type,
    tok: *Token,
    is_local: bool,
    align: i32,
    stack_slot: Qbe.Ref, 
    is_function: bool,
    is_definition: bool,
    is_static: bool,
    is_tentative: bool,
    is_tls: bool,
    init_data: CStr,
    rel: *Relocation,
    is_inline: bool,
    params: *Obj,
    body: *Node,
    locals: *Obj,
    va_area: *Obj,
    alloca_bottom: *Obj,
    stack_size: i32,
    is_live: bool,
    is_root: bool,
    refs: StringArray,
);
Relocation :: @rec @struct(
    next: *Relocation,
    offset: i32,
    label: *CStr,
    addend: i64,
);
Node :: @rec @struct(
    kind: NodeKind,
    next: *Node,
    ty: *Type,
    tok: *Token,
    lhs: *Node,
    rhs: *Node,
    cond: *Node,
    then: *Node,
    els: *Node,
    init: *Node,
    inc: *Node,
    brk_label: CStr,
    cont_label: CStr,
    body: *Node,
    member: *Member,
    func_ty: *Type,
    args: *Node,
    pass_by_stack: bool,
    ret_buffer: *Obj,
    label: CStr,
    unique_label: CStr,
    goto_next: *Node,
    case_next: *Node,
    default_case: *Node,
    begin: i64,
    end: i64,
    asm_str: CStr,
    cas_addr: *Node,
    cas_old: *Node,
    cas_new: *Node,
    atomic_addr: *Obj,
    atomic_expr: *Node,
    var: *Obj,
    val: i64,
    fval: f64, // Long double,
);
fn new_cast(expr: *Node, ty: *Type) *Node #import("chibicc");
fn const_expr(rest: **Token, tok: *Token) i64 #import("chibicc");
fn parse(tok: *Token) *Obj #import("chibicc");
Type :: @rec @struct(
    kind: TypeKind,
    size: i32,
    align: i32,
    is_unsigned: bool,
    is_atomic: bool,
    origin: *Type,
    base: *Type,
    name: *Token,
    name_pos: *Token,
    array_len: i32,
    vla_len: *Node,
    vla_size: *Obj,
    members: *Member,
    is_flexible: bool,
    is_packed: bool,
    return_ty: *Type,
    params: *Type,
    is_variadic: bool,
    next: *Type,
);
Member :: @rec @struct(
    next: *Member,
    ty: *Type,
    tok: *Token,
    name: *Token,
    idx: i32,
    align: i32,
    offset: i32,
    is_bitfield: bool,
    bit_offset: i32,
    bit_width: i32,
);
fn is_integer(ty: *Type) bool #import("chibicc");
fn is_flonum(ty: *Type) bool #import("chibicc");
fn is_numeric(ty: *Type) bool #import("chibicc");
fn is_compatible(t1: *Type, t2: *Type) bool #import("chibicc");
fn copy_type(ty: *Type) *Type #import("chibicc");
fn pointer_to(base: *Type) *Type #import("chibicc");
fn func_type(return_ty: *Type) *Type #import("chibicc");
fn array_of(base: *Type, size: i32) *Type #import("chibicc");
fn vla_of(base: *Type, expr: *Node) *Type #import("chibicc");
fn enum_type() *Type #import("chibicc");
fn struct_type() *Type #import("chibicc");
fn add_type(node: *Node) void #import("chibicc");
fn codegen(prog: *Obj, out: *FILE) void #import("chibicc");
fn align_to(n: i32, align: i32) i32 #import("chibicc");
fn encode_utf8(buf: CStr, c: u32) i32 #import("chibicc");
fn decode_utf8(new_pos: *CStr, p: CStr) u32 #import("chibicc");
fn is_ident1(c: u32) bool #import("chibicc");
fn is_ident2(c: u32) bool #import("chibicc");
fn display_width(p: CStr, len: i32) i32 #import("chibicc");
fn hashmap_get(map: *HashMap, key: CStr) rawptr #import("chibicc");
fn hashmap_get2(map: *HashMap, key: CStr, keylen: i32) rawptr #import("chibicc");
fn hashmap_put(map: *HashMap, key: CStr, val: rawptr) void #import("chibicc");
fn hashmap_put2(map: *HashMap, key: CStr, keylen: i32, val: rawptr) void #import("chibicc");
fn hashmap_delete(map: *HashMap, key: CStr) void #import("chibicc");
fn hashmap_delete2(map: *HashMap, key: CStr, keylen: i32) void #import("chibicc");
fn hashmap_test() void #import("chibicc");
fn file_exists(path: CStr) bool #import("chibicc");

TokenKind :: @enum(i32) (
    TK_IDENT,   // Identifiers
    TK_PUNCT,   // Punctuators
    TK_KEYWORD, // Keywords
    TK_STR,     // String literals
    TK_NUM,     // Numeric literals
    TK_PP_NUM,  // Preprocessing numbers
    TK_EOF,     // End-of-file markers
);

TypeKind :: @enum(
    TY_VOID,
    TY_BOOL,
    TY_CHAR,
    TY_SHORT,
    TY_INT,
    TY_LONG,
    TY_FLOAT,
    TY_DOUBLE,
    TY_LDOUBLE,
    TY_ENUM,
    TY_PTR,
    TY_FUNC,
    TY_ARRAY,
    TY_VLA, // variable-length array
    TY_STRUCT,
    TY_UNION,
);

NodeKind :: @enum(i32) (
    ND_NULL_EXPR, // Do nothing
    ND_ADD,       // +
    ND_SUB,       // -
    ND_MUL,       // *
    ND_DIV,       // /
    ND_NEG,       // unary -
    ND_MOD,       // %
    ND_BITAND,    // &
    ND_BITOR,     // |
    ND_BITXOR,    // ^
    ND_SHL,       // <<
    ND_SHR,       // >>
    ND_EQ,        // ==
    ND_NE,        // !=
    ND_LT,        // <
    ND_LE,        // <=
    ND_ASSIGN,    // =
    ND_COND,      // ?:
    ND_COMMA,     // ,
    ND_MEMBER,    // . (struct member access)
    ND_ADDR,      // unary &
    ND_DEREF,     // unary *
    ND_NOT,       // !
    ND_BITNOT,    // ~
    ND_LOGAND,    // &&
    ND_LOGOR,     // ||
    ND_RETURN,    // "return"
    ND_IF,        // "if"
    ND_FOR,       // "for" or "while"
    ND_DO,        // "do"
    ND_SWITCH,    // "switch"
    ND_CASE,      // "case"
    ND_BLOCK,     // { ... }
    ND_GOTO,      // "goto"
    ND_GOTO_EXPR, // "goto" labels-as-values
    ND_LABEL,     // Labeled statement
    ND_LABEL_VAL, // [GNU] Labels-as-values
    ND_FUNCALL,   // Function call
    ND_EXPR_STMT, // Expression statement
    ND_STMT_EXPR, // Statement expression
    ND_VAR,       // Variable
    ND_VLA_PTR,   // VLA designator
    ND_NUM,       // Integer
    ND_CAST,      // Type cast
    ND_MEMZERO,   // Zero-clear a stack variable
    ND_ASM,       // "asm"
    ND_CAS,       // Atomic compare-and-swap
    ND_EXCH,      // Atomic exchange
);

StringArray :: @struct(ptr: *CStr, cap: i32, len: i32);

File :: @struct(
    name: CStr,
    file_no: i32,
    contents: CStr,
    
    // For #line directive
    display_name: CStr,
    line_delta: i32,
);

Hideset :: @rec @struct(
    next: *Hideset,
    name: CStr,
);
