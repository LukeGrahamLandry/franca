// TODO: make this smaller!
Token :: @rec @struct(
    kind: Tokens.TokenKind,
    next: *Token,
    val: i64,  // number
    fval: f64, // number
    loc: CStr,
    len: i32,
    ty: *CType,  // string, number
    str_buf: *u8,  // string TODO: make this a rawptr?
    file: *File,
    line_no: i32,
    line_delta: i32,
    at_bol: bool,
    has_space: bool,
    hideset: *import("@/examples/import_c/preprocess.fr").Hideset, // ident
    origin: *Token,
);

Obj :: @rec @struct(
    next: *Obj,
    name: CStr,
    ty: *CType,
    tok: *Token,
    is_local: bool,
    align: i32,
    stack_slot: Qbe.Ref, 
    is_function: bool,
    is_definition: bool,
    is_static: bool,
    is_tentative: bool,
    is_tls: bool,
    init_data: []u8,
    init_data_needs_null_terminator: bool,
    rel: *Relocation,
    is_inline: bool,
    params: *Obj,
    body: *Node,
    locals: *Obj,
    stack_size: i32,
    f: *Qbe.Fn,
    par_r: Qbe.Ref,
    global_symbol: ?u32,  // TODO: use this more
);
Relocation :: @rec @struct(
    next: *Relocation,
    offset: i32,
    label: CStr,  // TODO: why does chibicc have an extra *indirection here?
    addend: i64,
);
Node :: @rec @struct(
    kind: NodeKind,
    next: *Node,
    ty: *CType,
    tok: *Token,
    lhs: *Node,
    rhs: *Node,
    cond: *Node,
    then: *Node,
    else: *Node,
    body: *Node,
    member: *Member,
    func_ty: *CType,
    args: *Node,
    ret_buffer: *Obj,
    var: *Obj,
    r: Qbe.Ref,
    lvalue: Qbe.Ref,  // what would you get if you took the & of this expression
    current_block: *Qbe.Blk,   // TODO: remove
);

CType :: @rec @struct(
    kind: TypeKind,
    size: i32,
    align: i32,
    is_unsigned: bool,
    is_atomic: bool,
    origin: *CType,
    base: *CType,
    name: *Token,
    name_pos: *Token,
    array_len: i32,
    vla_len: Qbe.Ref,
    vla_size: Qbe.Ref,
    members: *Member,
    is_flexible: bool,
    is_packed: bool,
    ir_index: i32,
    return_ty: *CType,
    params: *CType,
    is_variadic: bool,
    next: *CType,
);
Member :: @rec @struct(
    next: *Member,
    ty: *CType,
    tok: *Token,
    name: *Token,
    idx: i32,
    align: i32,
    offset: i32,
    is_bitfield: bool,
    bit_offset: i32,
    bit_width: i32,
);

TypeKind :: @enum(i32) (
    TY_VOID,
    TY_BOOL,
    TY_CHAR,
    TY_SHORT,
    TY_INT,
    TY_LONG,
    TY_FLOAT,
    TY_DOUBLE,
    TY_LDOUBLE,
    TY_ENUM,
    TY_PTR,
    TY_FUNC,
    TY_ARRAY,
    TY_VLA, // variable-length array
    TY_STRUCT,
    TY_UNION,
);

NodeKind :: @enum(i32) (
    ND_NULL_EXPR, // Do nothing
    ND_STMT,
    ND_ADD,       // +
    ND_SUB,       // -
    ND_MUL,       // *
    ND_DIV,       // /
    ND_NEG,       // unary -
    ND_MOD,       // %
    ND_BITAND,    // &
    ND_BITOR,     // |
    ND_BITXOR,    // ^
    ND_SHL,       // <<
    ND_SHR,       // >>
    ND_EQ,        // ==
    ND_NE,        // !=
    ND_LT,        // <
    ND_LE,        // <=
    ND_ASSIGN,    // =
    ND_COND,      // ?:
    ND_COMMA,     // ,
    ND_MEMBER,    // . (struct member access)
    ND_ADDR,      // unary &
    ND_DEREF,     // unary *
    ND_NOT,       // !
    ND_BITNOT,    // ~
    ND_LOGAND,    // &&
    ND_LOGOR,     // ||
    ND_FUNCALL,   // Function call
    ND_VAR,       // Variable
    ND_VLA_PTR,   // VLA designator
    ND_NUM,       // Integer
    ND_CAST,      // Type cast
    ND_MEMZERO,   // Zero-clear a stack variable
    //ND_ASM,       // "asm"
    //ND_CAS,       // Atomic compare-and-swap
    //ND_EXCH,      // Atomic exchange
    ND_INVALID,
);

File :: @struct(
    name: Str,
    contents: Str,
    
    // For #line directive
    display_name: Str,
    line_delta: i32,
);


