// cd bindings/chibicc && clang hashmap.c parse.c tokenize.c type.c unicode.c preprocess.c strings.c codegen.c -dynamiclib ../../examples/import_c/temp.c -o ../../examples/import_c/chibicc.dylib

CC :: import("@/examples/import_c/chibicc.fr");

ENABLE_TRACY :: false;
#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");

:: {
    ctx := current_compiler_context();
    cg := dlopen("examples/import_c/chibicc.dylib", DlFlag.Lazy);
    @assert(!cg.lib.is_null(), "failed to open chibicc");
    ctx.add_comptime_library(@symbol "chibicc", cg);
};

fn preprocess();

fn main() void = {
    tests_folder := "bindings/chibicc/test";
    ::FmtPad(Str);
    passed := 0;
    failed := 0;
    walk_directory(@fmt_cstr("%", tests_folder)) { e |
        if e.name.ends_with(".c") {
            continue :: local_return;
            if e.name == "tls.c" || e.name == "asm.c" {
                continue();
            };
            path := @tfmt("%/%", tests_folder, e.name);
            @print("%", f_pad(path, 40, .After));
            
            ok, out, err := fork_and_catch(temp()) {  // TODO: i don't care enough to reset the statics in the c code
                println("========");
                compile_one_file(path);
                println("========");
                ok := run_cmd_blocking("./c.out", empty());
                assert(ok, "failed run");
            };
            ok := ok && out.items().ends_with("OK\n");
            (@if(ok, passed&, failed&))[] += 1;
            @println("[%]", if(ok, => "ok", => "failed"));
            println(out.items());
            println(err.items());
            //
            //if !ok {
            //    println("FAILED");
            //};
        };
    };
    if failed == 0 {
        @println("\nAll is fine! (passed % tests)", passed);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
    };
    exit((failed != 0).int());
}

fn compile_one_file(path: Str) void = {
    m := @uninitialized QbeModule;
    a := query_current_arch();
    init_default_module(m&, (arch = a.unwrap(), os = query_current_os(), type = .Exe), use_threads);
    //m.debug["P".char()] = true;
    ctx: *CodegenShared = init(m&, libc_allocator, @as(CodegenWorker) codegen_thread_main);

    // Tokenize and parse.
    CC;
    tok2 := tokenize_file(path) || panic("failed tokenize_file");
    tok := CC.Token.zeroed(); tok := tok&;
    tok  = append_tokens(tok, tok2);
    tok  = preprocess(tok);
    //print_tokens(tok);
    prog := parse(tok);
    emit_the_code(ctx, prog);
    join_codegen_thread(ctx);

    outpath := "c.out";
    outfile := fopen(outpath.maybe_borrow_cstr(temp()), "w".sym().c_str());
    chunks := {m.target.finish_module}(m&);
    for chunks { chunk | 
        write(outfile, chunk);
    };
    fclose(outfile);
    drop(m&);
}

fn emit_the_code(ctx: *CodegenShared, obj: *CC.Obj) void = {
    :: ptr_utils(CC.Obj);
    while => !obj.next.is_null() {
        @assert(!obj.is_tls, "Thread Local Storage is not supported");
        if obj.is_definition {
            entry := bouba_acquire(ctx, ctx.bouba_idx&);
            push_dynamic_context {
                context(DefaultContext)[].temporary_allocator = entry.arena&;
                if obj.is_function {
                    f := temp().box_zeroed(Qbe.Fn);
                    f.default_init(ctx.m);
                    fill_lnk(f.lnk&, obj, ctx.m);
                    translate_func(f, obj);
                    entry.task = (Func = f);
                } else {
                    entry.task = (AotVar = translate_data(ctx.m, obj));
                };
            };
            enqueue_task(ctx, entry);
        };
        obj = obj.next;
    };
}

// TODO: do i need a way of asking for a certain alignment?
fn translate_data(m: *QbeModule, obj: *CC.Obj) []Qbe.Dat = {
    out := Qbe.Dat.list(3, temp());
    lnk := temp().box(Qbe.Lnk);
    fill_lnk(lnk, obj, m);
    
    next_dat :: fn() => {
        out&.push(Qbe.Dat.zeroed());
        dat := out.index(out.len - 1);
        dat.lnk = lnk;
        dat
    };
    
    { dat := next_dat(); dat.type = .DStart; };
    
    if obj.init_data.ptr.is_null() {
        dat := next_dat(); 
        dat.type = .DZ; 
        dat.u.num = obj.ty.size.intcast();
    } else {
        ::ptr_utils(@type obj.rel[]);
        if obj.rel.is_null() {
            dat := next_dat(); 
            dat.type = .DB; 
            dat.is_str = true;
            dat.u.str = obj.init_data.str();
            dat.u.str.len += 1;  // null terminator
        } else {
            panic("TODO: pointers in data");
        };
    };
    
    { dat := next_dat(); dat.type = .DEnd; };
    out.items()
}

fn translate_func(f: *Qbe.Fn, obj: *CC.Obj) void = {
    f.rpo = new(1);
    start := f.new_block();
    f.start = start;
    
    loc := obj.params;
    for_linked loc { loc |
        loc.stack_slot = f.newtmp("c", .Kl);
        // TODO: other types + parc
        emit(start, .par, .Kl, loc.stack_slot, QbeNull, QbeNull); 
    };
    
    scalars := Qbe.Ins.list(temp());
    
    loc := obj.locals;
    for_linked loc { loc |
        value := loc.stack_slot;
        loc.stack_slot = f.newtmp(loc.name.str(), .Kl);
        emit(start, .alloc8, .Kl, loc.stack_slot, f.getcon(loc.ty.size.intcast()), QbeNull);  // TODO: smaller align stack slots
        // TODO: other types + parc
        if value != QbeNull {
            push(scalars&, make_ins(.storel, .Kw, QbeNull, value, loc.stack_slot));
        };
    };
    for scalars { ins |
        push(start, ins);
    };
    gen_expr(f, obj.body);
    if f.start.jmp.type == .Jxxx {
        f.start.jmp = (type = .retw, arg = QbeConZero);
    };
    f.start = start;
    
    prev := Qbe.Blk.ptr_from_int(0);
    for_rev f.rpo.slice(0, f.nblk.zext()) { b | 
        b.link = prev;
        prev = b;
    };
    
    if fails_typecheck(f) { err | 
        printfn(f, f.globals.debug_out);
        @panic("IR failed typecheck: %", err);
    };
}

#where(fn(T) => is_ptr(T) && has_field(Deref(T), @symbol next))
fn for_linked(head: ~T, $body: @Fn(it: T) void) void = {
    ::ptr_utils(Deref(T));
    while => !head.is_null() {
        body(head);
        head = head.next;
    };
}

fn emit(b: *Qbe.Blk, op: Qbe.O, k: Qbe.Cls, to: Qbe.Ref, arg0: Qbe.Ref, arg1: Qbe.Ref) void = {
    push(b, make_ins(op, k, to, arg0, arg1));
}

fn fill_lnk(lnk: *Qbe.Lnk, obj: *CC.Obj, m: *QbeModule) void = {
    lnk.export = !obj.is_static;
    lnk.id = m.mangle(obj);
}

fn mangle(m: *QbeModule, obj: *CC.Obj) u32 = {
    name := obj.name.str();
    if obj.is_static && !obj.tok.is_null() {
        name = @tfmt("%@%", name, obj.tok.filename); // not very rigorous
    };
    m.intern(name)
}

::enum(CC.NodeKind);

fn gen_expr(f: *Qbe.Fn, node: *CC.Node) Qbe.Ref = {
    ::enum(@type node.ty.kind);
    //@println("%", node.tok.loc.str().slice(0, node.tok.len.zext()));
    //@println("E % %", node.kind, CC.Node.int_from_ptr(node));
    B :: fn(o: Qbe.O) => binary(f, node, o);
    @match(node.kind) {
        fn ND_BLOCK() => {
            node.kind = .ND_STMT_EXPR;
            gen_expr(f, node);
            QbeUndef
        }
        fn ND_STMT_EXPR() => {
            // https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
            r := QbeUndef;
            s := node.body;
            for_linked s { s |
                r = gen_expr(f, s);
            };
            r
        }
        fn ND_EXPR_STMT() => gen_expr(f, node.lhs);
        fn ND_RETURN() => {
            ::ptr_utils(@type node.lhs[]);
            if node.lhs.is_null() {
                f.start.jmp.type = .ret0;
            } else {
                f.start.jmp.type = .retw; // TODO
                f.start.jmp.arg = gen_expr(f, node.lhs);
            };
            QbeUndef
        }
        fn ND_NULL_EXPR() => QbeUndef;
        fn ND_FUNCALL() => gen_call(f, node);
        fn ND_ADD()      => B(.add);
        fn ND_SUB()      => B(.sub);
        fn ND_MUL()      => B(.mul);
        fn ND_DIV()      => B(.div);  // TODO: sign
        fn ND_MOD()      => B(.rem);  // TODO: sign
        fn ND_BITAND()   => B(.and);
        fn ND_BITOR()    => B(.or);
        fn ND_BITXOR()   => B(.xor);
        fn ND_SHL()      => B(.shl);
        fn ND_SHR()      => B(.shr);
        // TODO: types
        fn ND_EQ()       => B(.ceqw);
        fn ND_NE()       => B(.cnew);
        fn ND_LT()       => B(.csltw);
        fn ND_LE()       => B(.cslew);
        fn ND_ADDR()     => f.gen_addr(node.lhs);
        fn ND_CAST() => {
            source := gen_expr(f, node.lhs);
            from, to := (node.lhs.ty, node.ty);
            k := to.cls();
            r := f.newtmp("c", k);
            if(to.kind == .TY_VOID, => return(QbeUndef));
            if to.kind == .TY_BOOL {
                // TODO: other classes. THIS IGNORES THE HIGH BITS.
                emit(f.start, .ceql, k, r, source, QbeConZero);
                return(r)
            };
            
            // TODO
            source
        }
        fn ND_VAR() => {
            if node.var.is_function {
                r := f.symcon(f.globals.mangle(node.var));
                return(r);
            };
            addr := f.gen_addr(node); 
            f.gen_load(addr, node.ty)
        }
        fn ND_DEREF() => {
            addr := f.gen_expr(node.lhs);
            f.gen_load(addr, node.ty)
        }
        fn ND_NEG() => {
            arg := f.gen_expr(node.lhs);
            r   := f.newtmp("c", .Kl);
            emit(f.start, .neg, .Kl, r, arg, QbeNull);
            r
        }
        fn ND_BITNOT() => {
            arg := f.gen_expr(node.lhs);
            r   := f.newtmp("c", .Kl);
            emit(f.start, .xor, .Kl, r, arg, f.getcon(-1));
            r
        }
        fn ND_NOT() => {  // TODO: do the trick with redirecting jump targets to emit better code when this is in an if condition. 
            arg := f.gen_expr(node.lhs);
            r   := f.newtmp("c", .Kw);
            emit(f.start, .xor, .Kw, r, arg, f.getcon(1));
            r
        }
        fn ND_NUM() => @match(node.ty.kind) {
            fn TY_FLOAT() => {
                v: f32 = node.fval.cast();
                v: u32 = v.bitcast();
                f.getcon(v.zext())
            }
            fn TY_DOUBLE() => {
                v: i64 = node.fval.bitcast();
                f.getcon(v)
            }
            fn TY_LDOUBLE() => {
                v: i64 = node.fval.bitcast();
                f.getcon(v)
            }
            @default => f.getcon(node.val);
        };
        fn ND_COMMA() => {
            _ := f.gen_expr(node.lhs);
            f.gen_expr(node.rhs)
        }
        fn ND_MEMZERO() => {
            dest := node.var.stack_slot;
            size: i64 = node.var.ty.size.intcast();
            off := 0;
            each blit_op_table { o |
                while => size >= o.size {
                    d := f.newtmp("c", .Kl);
                    emit(f.start, .add, .Kl, d, dest, f.getcon(off));
                    emit(f.start, o.store, .Kw, QbeNull, QbeConZero, d);
                    size -= o.size;
                    off  += o.size;
                };
            };
         
            QbeUndef
        }
        fn ND_ASSIGN() => { 
            addr  := f.gen_addr(node.lhs);
            value := f.gen_expr(node.rhs);
            if node.lhs.kind == .ND_MEMBER && node.lhs.member.is_bitfield {
                panic("TODO: bitfields");
            };
            f.gen_store(addr, value, node.ty);
            value
        }
        fn ND_IF() => {
            node.kind = .ND_COND;
            gen_expr(f, node);
            QbeUndef
        }
        fn ND_COND() => {
            cond         := f.gen_expr(node.cond);
            old_block    := f.start;
            old_block.jmp = (type = .jnz, arg = cond);
            old_block.s1  = f.new_block();
            old_block.s2  = f.new_block();
            join_block   := f.new_block();
            
            f.start = old_block.s1;
            then_value := f.gen_expr(node.then);
            if f.start.jmp.type == .Jxxx {
                f.start.jmp.type = .jmp;
                f.start.s1 = join_block;
            };
            f.start = old_block.s2;
            ::ptr_utils(@type node.else[]);
            else_value := @if(node.else.is_null(), QbeUndef, f.gen_expr(node.else));
            if f.start.jmp.type == .Jxxx {
                f.start.jmp.type = .jmp;
                f.start.s1 = join_block;
            };
            f.start = join_block;
            ::ptr_utils(@type node.ty[]);
            if node.ty.is_null() || node.ty.kind == .TY_VOID {
                QbeUndef
            } else {
                k := node.ty.cls();
                p := new_phi(f, join_block, k);
                p.push(old_block.s1, then_value);
                p.push(old_block.s2, else_value);
                p.to
            }
        }
        fn ND_MEMBER() => {
            addr := f.gen_addr(node); 
            f.gen_load(addr, node.ty)
        }
        @default => @panic("unexpected node for expr: %", node.kind);
    }
}

fn gen_call(f: *Qbe.Fn, node: *CC.Node) Qbe.Ref #once = {
    variadic_marker_index := 0;
    if node.lhs.ty.is_variadic {
        t := node.lhs.ty.params;
        for_linked t { t |
            variadic_marker_index += 1;
        };
    } else {
        variadic_marker_index = -1;
    };
    
    arguments := list(Qbe.Ins, temp());
    arg := node.args;
    for_linked arg { arg |
        if variadic_marker_index == 0 {
            arguments&.push(make_ins(.argv, .Kw, QbeNull, QbeNull, QbeNull));
        };
        variadic_marker_index -= 1;
        
        r := gen_expr(f, arg);
        // TODO: argc and other types
        arguments&.push(make_ins(.arg, arg.ty.cls(), QbeNull, r, QbeNull));
    };
    
    assert(node.ret_buffer.is_null(), "TODO: aggragate returns");
    for arguments { i |    
        push(f.start, i);
    };
    
    callee := gen_expr(f, node.lhs);
    r := f.newtmp("c", .Kl); // TODO: other types
    emit(f.start, .call, .Kl, r, callee, QbeNull);
    r
}

fn gen_store(f: *Qbe.Fn, addr: Qbe.Ref, value: Qbe.Ref, ty: *CC.Type) void = {
    if @is(ty.kind, .TY_STRUCT, .TY_UNION) {
        emit(f.start, .blit0, .Kw, QbeNull, value, addr);  // src, dest because we hate ourselves
        emit(f.start, .blit1, .Kw, QbeNull, INT(ty.size.intcast()), QbeNull);
        return();
    };
    if @is(ty.kind, .TY_DOUBLE, .TY_LDOUBLE) {
        emit(f.start, .stored, .Kw, QbeNull, value, addr);
        return();
    };
    if ty.kind == .TY_FLOAT {
        emit(f.start, .stores, .Kw, QbeNull, value, addr);
        return();
    };
    
    o: Qbe.O = @switch(ty.size) {
        @case(1) => .storeb;
        @case(2) => .storeh;
        @case(4) => .storew;
        @case(8) => .storel;
        @default => panic("invalid int size");
    };
    emit(f.start, o, .Kw, QbeNull, value, addr);
    return();
}

fn cls(ty: *CC.Type) Qbe.Cls = {
    if(@is(ty.kind, .TY_STRUCT, .TY_UNION),   => return(.Kl)); // ehhh
    if(@is(ty.kind, .TY_DOUBLE, .TY_LDOUBLE), => return(.Kd));
    if(ty.kind == .TY_FLOAT,                  => return(.Ks));
    if(ty.size == 8,                          => return(.Kl));
    .Kw
}

fn gen_load(f: *Qbe.Fn, addr: Qbe.Ref, type: *CC.Type) Qbe.Ref = {
    if @is(type.kind, .TY_ARRAY, .TY_STRUCT, .TY_UNION, .TY_FUNC, .TY_VLA) {
        return(addr);  // really?
    };
    if @is(type.kind, .TY_DOUBLE, .TY_LDOUBLE) {
        r := f.newtmp("c", .Kd);
        emit(f.start, .load, .Kd, r, addr, QbeNull);
        return(r);
    };
    if type.kind == .TY_FLOAT {
        r := f.newtmp("c", .Ks);
        emit(f.start, .load, .Ks, r, addr, QbeNull);
        return(r);
    };
    (o: Qbe.O, k: Qbe.Cls) := @switch(type.size) {
        @case(1) => (@if(type.is_unsigned, .loadub, .loadsb), .Kw);
        @case(2) => (@if(type.is_unsigned, .loadub, .loadsh), .Kw);
        @case(4) => (@if(type.is_unsigned, .loaduw, .loadsw), .Kw);
        @case(8) => (.load, .Kl);
        @default => panic("invalid int size");
    };
    r := f.newtmp("c", k);
    emit(f.start, o, k, r, addr, QbeNull);
    r
}

fn gen_addr(f: *Qbe.Fn, node: *CC.Node) Qbe.Ref = {
    //@println("% %", node.kind, int_from_ptr(@type node.var[], node.var));
    
    @match(node.kind) {
        fn ND_DEREF() => f.gen_expr(node.lhs);
        fn ND_VAR() => if !node.var.is_local {
            f.symcon(f.globals.mangle(node.var))
        } else {
            node.var.stack_slot
        };
        fn ND_MEMBER() => {
            base := gen_addr(f, node.lhs);
            r := f.newtmp("c", .Kl);
            emit(f.start, .add, .Kl, r, base, f.getcon(node.member.offset.intcast()));
            r
        }
        @default => {
            // TODO: compiler bug
            yy := @is(node.kind, .ND_ASSIGN, .ND_COND);
            xx := @is(node.ty.kind, .TY_STRUCT, .TY_UNION);
            if yy && xx {
                return(f.gen_expr(node));
            };
            @panic("TODO: gen_addr %", node.kind)
        };
    }
}

fn binary(f: *Qbe.Fn, node: *CC.Node, callee: Qbe.O) Qbe.Ref = {
    lhs := f.gen_expr(node.lhs);
    rhs := f.gen_expr(node.rhs);
    k   := node.ty.cls();
    r   := f.newtmp("c", k);
    emit(f.start, callee, k, r, lhs, rhs);
    r
}

::ptr_utils(CC.Token); ::enum(CC.TokenKind);

fn tokenize_file(path: Str) ?*CC.Token = {
    a := libc_allocator; // temp();
    src := read_to_string_or_crash(a, path);
    src&.push(0);
    path_c := maybe_borrow_cstr(path, a);
    //file_no only used for assembler directive so i dont care
    file := new_file(path_c, 0, src&.assert_c_str()); 
    t := tokenize(file);
    if t.is_null() {
        return(.None);
    };
    (Some = t)
}

fn append_tokens(tok1: *CC.Token, tok2: *CC.Token) *CC.Token = {
    if(!tok1.is_null() || tok1.kind == .TK_EOF, => return(tok2));
    t := tok1;
    while => t.next.kind != .TK_EOF {
        t = t.next;
    };
    t.next = tok2;
    tok1
}

fn print_tokens(tok: *CC.Token) void = {
    out := u8.list(temp());
    line := 0;
    while => tok.kind != .TK_EOF {
        if line > 1 && tok.at_bol {
            @fmt(out&, "\n");
        };
        if tok.has_space && !tok.at_bol {
            @fmt(out&, "  ");
        };
        @fmt(out&, "%", tok.loc.str().slice(0, tok.len.zext()));
        line += 1;
        tok = tok.next;
    };
    println(out.items());
}

new_block :: fn(f: *Qbe.Fn) *Qbe.Blk = {
    f.rpo&.grow(f.nblk.zext() + 1);
    b := newblk();
    @if(TRACK_IR_NAMES) {
        l := fixed_list(b.name&.items()); // :UnacceptablePanic
        @fmt(l&, "%", f.nblk);
    };
    b.id = f.nblk;
    f.rpo[f.nblk.zext()] = b;
    f.nblk += 1;
    b.ins = new(0);
    b
};

// TODO: move this and call it from elsewhere
fn new_phi(f: *Qbe.Fn, b: *Qbe.Blk, k: Qbe.Cls) *Qbe.Phi = {
    prev := b.phi;
    b.phi = temp().box(Qbe.Phi); 
    b.phi[] = (
        cls = k, 
        to = f.newtmp("c", k),
        narg = 0,
        blk = new(0),
        arg = new(0),
        link = prev,
    );
    b.phi
}
