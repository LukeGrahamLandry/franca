
AstExternal :: import("@/compiler/ast_external.fr");
Tokens      :: import("@/examples/import_c/tokenize.fr");
Types       :: import("@/examples/import_c/type.fr");
Preprocess  :: import("@/examples/import_c/preprocess.fr");
#use("@/lib/sys/jump.fr");
Compile :: import("@/examples/import_c/compile.fr");
#use("@/backend/lib.fr");
SPAM :: false;

fn init_ctx(c: *Compile.Ctx, m: *QbeModule, worker: *CodegenShared) void = {
    c.arena_storage = init(general_allocator(), 1.shift_left(15));
    c.arena = c.arena_storage&.borrow(); // TODO: free it in ffi.fr/include()
    c.transform = (fn(_0, _1, _2) = ());
    c.fill_primitives();
    c.current_fn = .None;
    c.emitter = worker;
    c.brk_label = .None;
    c.cont_label = .None;
    c.scope = c.arena.box_zeroed(Compile.Scope);
    c.scope.vars = init(c.arena);
    c.scope.tags = init(c.arena);
    c.error_buf = list(c.arena);
    c.cond_incl = .None;
    c.macros = init(c.arena);
    c.pragma_once = init(c.arena);
    c.include_guards = init(c.arena);
    c.filename_cache = init(c.arena);
    c.include_paths = list(c.arena);
    c.hide_stack = list(c.arena);
    c.allow_builtin_headers = true;
    c.tentative = init(c.arena);
    c.m = m;
    c.codemap = init(c.arena);
    
    if m.goal.os == .macos {  // TODO: do you ever need multiple?
        c.macos_framework_path = "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks";
    };
    
    // you need this before calling parse() in compile because the preprocessor calls into const_expr
    {
        // :TopLevelFunction
        c.init_function(c.arena);
        c.top_level_fn = c.f;
        
        // HACK: need to be able to generate instructions because when you parse `&some_global`, 
        //       thats a valid constant expression but we issue a load for the bare identifier before
        //       recursing back up and just taking the lvalue. 
        c.f.rpo = new(0); // HACK
        c.f.start = c.new_block();// HACK
        c.b = c.f.start; // HACK
    };
    
    enumerate c.cached_number_tokens& { i, it |
        // TODO: unfriendly that this returns memory in the temporary allocator but init_function does it wrong too 
        it[] = c.new_num_token(i, "literal");
    };
    
    catch_call(c, void, => Preprocess'init_macros(c)).or(fn(e) => panic(e));
}

fn catch_call(c: *Compile.Ctx, $T: Type, $body: @Fn() T) Result(T, Str) #generic = {
    return(@match(try(c.a_little_hidden_control_flow&)) {
        fn Try()   => (Ok = body());
        fn Catch() => (Err = c.error_buf.items());
    });
}

fn compile_file(c: *Compile.Ctx, path: Str) Result(void, Str) = {
    catch_call(c, void) {
        c.macro_base_file = path;
        src := read_entire_file(c.arena, path) ||
            @error_at(c, path.ptr, "Failed to open file: %", path);
        tok := c.tokenize_string(path, src);
        tok  = c.Preprocess'preprocess(tok);
        c.parse(tok);
    }
}

fn yield(c: *Compile.Ctx, obj: *Compile.Obj) void = {
    if obj.yielded {
        @error_tok(c, obj.tok, "double yield '%'", obj.name);
    };
    obj.yielded = true;
    // TODO: maybe export types etc for ffi here instead of waiting until the end?
    //       but need to be careful of fighting with the other thread over the writer if we allow threaded at the same time
        emit_one(c, obj);
}

// TODO: hoist this so temp() is in the arena of the entry
fn emit_one(c: *Compile.Ctx, obj: *Compile.Obj) void = {
    ctx := c.emitter;
    @assert(obj.yielded);
    enter_task ctx { entry | 
        if obj.is_function {
            f := obj.f;
            entry.task = (Func = f);
        } else {
            entry.task = (AotVar2 = translate_data(ctx.m, obj));
        };
        c'transform(c, obj, entry.task&);
    };
}

// TODO: implement _Alignas
fn translate_data(m: *QbeModule, obj: *Compile.Obj) []Dat2 = {
    no_init_data := obj.init_data.ptr.is_null();
    // can't just be obj.ty.size because it might have a flexible array member
    total_size   := if(no_init_data, => obj.ty.size.intcast(), => obj.init_data.len);
    is_zeroed    := no_init_data || is_all_zeroes(obj.init_data);
    
    out := Dat2.list(1, temp());
    out&.push(
        export = !obj.is_static,
        id = obj.global_symbol.expect("mangle"),
        template = @if(is_zeroed, (Zeroes = total_size), (Bytes = obj.init_data)),
        relocations = obj.rel,
    );    
    out.items()
}

#where(fn(T) => is_ptr(T) && has_field(Deref(T), @symbol next))
fn for_linked(head: ~T, $body: @Fn(it: T) void) void = {
    ::ptr_utils(Deref(T));
    while => !head.is_null() {
        body(head);
        head = head.next;
    };
}

fn mangle(m: *QbeModule, obj: *Compile.Obj) Qbe.Sym = {
    ::ptr_utils(@type obj.tok[]);
    name := obj.name;
    if obj.is_static {
        // TODO: using file name is nicer because it doesn't change everything if you add a file before it,
        //       but it makes the names long and annoying to read, just using an index is a bit less offensive. 
        //                        obj.tok.file.name
        // don't use @ because that's confusing to read because glibc symbol versions use that too. 
        name = @tfmt("%#%", name, obj.tok.file.mangle_index);
    };
    s := m.intern(name);
    obj.global_symbol = (Some = s);
    s
}

::ptr_utils(Tokens.Token);

#use("@/lib/collections/map.fr");
