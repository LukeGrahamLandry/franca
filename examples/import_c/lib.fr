// cd bindings/chibicc && clang hashmap.c parse.c tokenize.c type.c unicode.c preprocess.c strings.c codegen.c -dynamiclib ../../examples/import_c/temp.c -o ../../examples/import_c/chibicc.dylib

CC :: import("@/examples/import_c/chibicc.fr");

ENABLE_TRACY :: false;
#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");
AstExternal :: import("@/compiler/ast_external.fr");
Tokens      :: import("@/examples/import_c/tokenize.fr");
Types       :: import("@/examples/import_c/type.fr");

:: {
    ctx := current_compiler_context();
    cg := dlopen("examples/import_c/chibicc.dylib", DlFlag.Lazy);
    @assert(!cg.lib.is_null(), "failed to open chibicc");
    ctx.add_comptime_library(@symbol "chibicc", cg);
};

Compile :: import("@/examples/import_c/compile.fr");
:: (Compile.comptime_init_rules_table)();

JUST_ONE :: false;
USE_HOST_BACKEND :: true;
LOG_IR :: false;
SPAM :: false;

fn main() void = {
    :: assert(!USE_HOST_BACKEND, "cannot start from main() when USE_HOST_BACKEND");
    vtable := ImportVTable.zeroed();
    (AstExternal.fill_backend_vtable)(vtable&);
    run_tests(vtable&);
}

fn driver(vtable: *ImportVTable) void = {
    @if(USE_HOST_BACKEND, run_tests(vtable), main());
}

fn run_tests(vtable: *ImportVTable) void = {
    tests_folder := "examples/import_c/test";
    ::FmtPad(Str);
    passed := 0;
    failed := 0;
    //if true {
    walk_directory(@fmt_cstr("%", tests_folder)) { e |
        if e.name.ends_with(".c") {
            continue :: local_return;
            // TODO: this is silly
            //skip  := @const_slice("tls.c", "asm.c", "alignof.c", "complit.c");
            // includes: "atomic.c", "macro.c", "offsetof.c", "varargs.c"
            // TODO: "float.c", "function.c", "initializer.c", "line.c", "literal.c", "string.c", "usualconv.c", "vla.c"

            path := @tfmt("%/%", tests_folder, e.name);
            @if(JUST_ONE) {
                path = "examples/import_c/b.c";
            };
            
            @print("%", f_pad(e.name, 40, .After));
            or compile_one_file(vtable, path) { err |
                println("[failed compile]");
                println(err);
                failed += 1;
                @if(JUST_ONE) exit(1);
                continue();
            };
            ok, out, err := exec_and_catch("./c.out", empty(), todo_allocator);
            ok := ok && out.items().ends_with("OK\n");
            (@if(ok, passed&, failed&))[] += 1;
            @println("[%]", if(ok, => "ok", => "failed run"));
            if !ok {
                print(out.items());
                print(err.items());
            };
            @if(JUST_ONE) return();
        };
    };
    if failed == 0 {
        @println("\nAll is fine! (passed % tests)", passed);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
    };
    exit((failed != 0).int());
}

fn compile_one_file(vtable: *ImportVTable, path: Str) Result(void, Str) #use(Tokens) = {
    m := @uninitialized QbeModule;
    a := query_current_arch();
    
    (AstExternal.init_default_module_dyn)(m&, vtable, (arch = a.unwrap(), os = query_current_os(), type = .Exe));
    @if(LOG_IR) {
        m.debug["P".char()] = true;
        m.debug["R".char()] = true;
    };
    
    // TODO: this is ugly
    codegen_thread_main := ptr_cast_unchecked(@type vtable.codegen_thread_main, CodegenWorker, vtable.codegen_thread_main&)[];
    ctx: *CodegenShared = init(m&, libc_allocator, codegen_thread_main);

    tok2 := tokenize_file(path) || panic("failed tokenize_file");
    tok := CC.Token.zeroed(); tok := tok&;
    tok  = append_tokens(tok, tok2);
    tok  = preprocess(tok);
    
    for_linked tok { tok |
        a := @is(tok.kind, .TK_KEYWORD, .TK_PUNCT);
        if a || tok.str() == "_Generic" { // HACK :SLOW
            ::?TokenKind;
            tok.kind = TokenKind.from_name(tok.str()) || @panic("invalid c keyword %", tok.str());
        };
    };
    
    c := Compile.Ctx.zeroed();
    c.arena = temp();
    c.current_fn = .None;
    c.brk_label = .None;
    c.cont_label = .None;
    scope := Compile.Scope.zeroed();
    c.scope = scope&;
    c.scope.vars = init(c.arena);
    c.scope.tags = init(c.arena);
    c.error_buf = list(temp());
    c.m = m&;
    
    //print_tokens(tok);
    
    prog := @try(c&.parse(tok)) return;
    emit_the_code(c&, ctx, prog);
    join_codegen_thread(ctx);

    outpath := "./c.out";
    outfile := fopen(outpath.maybe_borrow_cstr(temp()), "w".sym().c_str());
    chunks := {m.target.finish_module}(m&);
    for chunks { chunk | 
        write(outfile, chunk);
    };
    fclose(outfile);
    drop(m&);
    .Ok
}

fn emit_the_code(c: *Compile.Ctx, ctx: *CodegenShared, obj: *CC.Obj) void = {
    :: ptr_utils(CC.Obj);
    while => !obj.next.is_null() {
        @assert(!obj.is_tls, "Thread Local Storage is not supported");
        if obj.is_definition {
            entry := bouba_acquire(ctx, ctx.bouba_idx&);
            push_dynamic_context {
                context(DefaultContext)[].temporary_allocator = entry.arena&;
                if obj.is_function {
                    f := obj.f;
                    fill_lnk(f.lnk&, obj, ctx.m);
                    entry.task = (Func = f);
                } else {
                    entry.task = (AotVar = translate_data(ctx.m, obj));
                };
            };
            enqueue_task(ctx, entry);
        };
        obj = obj.next;
    };
}

// TODO: do i need a way of asking for a certain alignment?
fn translate_data(m: *QbeModule, obj: *CC.Obj) []Qbe.Dat = {
    out := Qbe.Dat.list(3, temp());
    lnk := temp().box(Qbe.Lnk);
    fill_lnk(lnk, obj, m);
    
    next_dat :: fn() => {
        out&.push(Qbe.Dat.zeroed());
        dat := out.index(out.len - 1);
        dat.lnk = lnk;
        dat
    };
    
    { dat := next_dat(); dat.type = .DStart; };
    
    if obj.init_data.ptr.is_null() {
        dat := next_dat(); 
        dat.type = .DZ; 
        dat.u.num = obj.ty.size.intcast();
    } else {
        ::ptr_utils(@type obj.rel[]);
        if obj.rel.is_null() {
            dat := next_dat(); 
            dat.type = .DB; 
            dat.is_str = true;
            dat.u.str = obj.init_data;
            if obj.init_data_needs_null_terminator {
                dat := next_dat(); 
                dat.type = .DB; 
                dat.u.num = 0;
            };
        } else {
            pos := 0;
            rel := obj.rel;
            for_linked rel { rel |
                @assert_eq(rel.offset.mod(8), 0, "pointer in constant storage must be 8-byte aligned");
                before := obj.init_data.slice(pos, rel.offset.intcast());
                if before.len > 0 {
                    dat := next_dat(); 
                    dat.type = .DB; 
                    dat.is_str = true;
                    dat.u.str = before;
                };
                pos = rel.offset.intcast() + 8;
                dat := next_dat(); 
                dat.type = .DL; 
                dat.is_ref = true;
                dat.u.ref = (id = m.intern(rel.label.str()), off = rel.addend);
            };
            if pos < obj.ty.size.intcast() {
                dat := next_dat(); 
                dat.type = .DB; 
                dat.is_str = true;
                dat.u.str = obj.init_data.rest(pos);
            };
        };
    };
    
    { dat := next_dat(); dat.type = .DEnd; };
    out.items()
}

#where(fn(T) => is_ptr(T) && has_field(Deref(T), @symbol next))
fn for_linked(head: ~T, $body: @Fn(it: T) void) void = {
    ::ptr_utils(Deref(T));
    while => !head.is_null() {
        body(head);
        head = head.next;
    };
}


fn fill_lnk(lnk: *Qbe.Lnk, obj: *CC.Obj, m: *QbeModule) void = {
    lnk.export = !obj.is_static;
    lnk.id = m.mangle(obj);
}

fn mangle(m: *QbeModule, obj: *CC.Obj) u32 = {
    name := obj.name.str();
    ::ptr_utils(CC.Token);
    if obj.is_static && !obj.tok.is_null() {
        name = @tfmt("%@%", name, obj.tok.filename); // not very rigorous
    };
    m.intern(name)
}

::enum(CC.NodeKind);

::ptr_utils(CC.Token); ::enum(Tokens.TokenKind);

fn tokenize_file(path: Str) ?*CC.Token = {
    a := libc_allocator; // temp();
    src := read_to_string_or_crash(a, path);
    src&.push(0);
    path_c := maybe_borrow_cstr(path, a);
    //file_no only used for assembler directive so i dont care
    file := new_file(path_c, 0, src&.assert_c_str()); 
    t := tokenize(file);
    if t.is_null() {
        return(.None);
    };
    (Some = t)
}

fn append_tokens(tok1: *CC.Token, tok2: *CC.Token) *CC.Token = {
    if(!tok1.is_null() || tok1.kind == .TK_EOF, => return(tok2));
    t := tok1;
    while => t.next.kind != .TK_EOF {
        t = t.next;
    };
    t.next = tok2;
    tok1
}

fn print_tokens(tok: *CC.Token) void = {
    out := u8.list(temp());
    line := 0;
    while => tok.kind != .TK_EOF {
        if line > 1 && tok.at_bol {
            @fmt(out&, "\n");
        };
        if tok.has_space && !tok.at_bol {
            @fmt(out&, "  ");
        };
        @fmt(out&, "%", tok.loc.str().slice(0, tok.len.zext()));
        line += 1;
        tok = tok.next;
    };
    println(out.items());
}

// TODO: move this and call it from elsewhere
fn new_phi(f: *Qbe.Fn, b: *Qbe.Blk, k: Qbe.Cls) *Qbe.Phi = {
    prev := b.phi;
    b.phi = temp().box(Qbe.Phi); 
    b.phi[] = (
        cls = k, 
        to = f.newtmp("c", k),
        narg = 0,
        blk = new(0),
        arg = new(0),
        link = prev,
    );
    b.phi
}
