C :: import("@/examples/import_c/lib.fr");

#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");

// TODO: make worker something you can import nicely
ENABLE_TRACY :: false;

JUST_ONE :: false;
LOG_IR :: false;

fn main() void = {
    vtable := ImportVTable.zeroed();
    C'AstExternal'fill_backend_vtable(vtable&);
    import("@/lib/crash_report.fr")'hook_backtrace();
    run_tests(vtable&);
}

fn driver(vtable: *ImportVTable) void = {
    USE_HOST_BACKEND :: true;
    @if(USE_HOST_BACKEND) @eprintln(">>> USING HOST BACKEND");
    @if(USE_HOST_BACKEND, run_tests(vtable), main());
}

// TODO
// "alignof.c" needs backend support for _Alignas on globals
// "atomic.c" needs backend support for CAS
// "tls.c" implement _Thread_Local with env (higher level that uses franca's context?)
// "asm.c" not doing inline asm for now
// "builtin.c" __builtin_types_compatible_p (easy)
// extern.c
fn run_tests(vtable: *ImportVTable) void = {
    ::import("@/examples/testing.fr");
    tests_folder := "examples/import_c/test";
    
    // me when we live at the ugly factory
    // TODO: the obvious clean up here is i want a higher level thing that 
    //       lets you choose a host and target environment and run whatever 
    //       tests in that context. cause there's lots of ways to run things:  
    //       normal, rosetta, orb, blink, import_wasm, wasmtime 
    a := query_current_arch();
    outpath: CStr = "./c.out";
    exe_path := outpath;
    i := 0;
    args := cli_args();
    child_args: []Str = empty();
    while => i < args.len {
        if args[i] == "-w" {
            i += 1;
            a = .wasm32;
            exe_path = args[i];
            outpath = "./c.wasm";
            child_args = @slice("./c.wasm");
        }
        i += 1
    }
    
    outpath: CStr = @if(a == .wasm32, "./c.wasm", "./c.out");
    if JUST_ONE {
        file := "function.c";
        path := @tfmt("%/%", tests_folder, file);
        or compile_one_file(vtable, path, a, outpath) { err |
            panic(err);
        };
        ok, out, err := exec_and_catch(exe_path.str(), child_args, todo_allocator);
        println(out.items());
        println(err.items());
        exit(int(!ok));
    };
    
    files := collect_with_extension(tests_folder, ".c") || panic("didn't find tests. run from franca root dir");
    run_tests_main(Str, files.items(), fn(a) => a[]) { file | 
        yield :: local_return;
        path := @tfmt("%/%", tests_folder, file);
        or compile_one_file(vtable, path, a, outpath) { err |
            yield(false, fixed_list(empty()), err.assume_owned(temp()), "");
        };
        ok, out, err := exec_and_catch(exe_path.str(), child_args, todo_allocator);
        ok := ok && out.items().ends_with("OK\n");
        (ok, out, err, "")
    };
}

fn compile_one_file(vtable: *ImportVTable, path: Str, a: Arch, outpath: CStr) Result(void, Str) = {
    m := @uninitialized QbeModule;
    
    m&.C'AstExternal'init_default_module_dyn(vtable, (arch = a, os = query_current_os(), type = .Exe));
    @if(LOG_IR) {
        m.debug["P".char()] = true;
        m.debug["R".char()] = true;
        //m.debug["G".char()] = true;
        //m.debug["M".char()] = true;
    };
    
    // TODO: this is ugly
    codegen_thread_main := ptr_cast_unchecked(@type vtable.codegen_thread_main, CodegenWorker, vtable.codegen_thread_main&)[];
    ctx: *CodegenShared = init(m&, libc_allocator, codegen_thread_main, true);

    c := C'Compile.Ctx.zeroed();
    C'init_ctx(c&, m&);
    c.include_paths&.push("examples/import_c/test"); // for the macro.c test (chibicc's 'make test' does this). 
    
    prog := @try(c&.compile_file(path)) return;
    emit_the_code(c&, ctx, prog);
    join_codegen_thread(ctx);

    outfile := open_trunc(outpath).unwrap();
    chunks := {m.target.finish_module}(m&);
    for chunks { chunk | 
        write(outfile&, chunk);
    };
    close(outfile);
    drop(m&);
    .Ok
}

#use("@/lib/sys/subprocess.fr");
