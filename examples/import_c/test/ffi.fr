main :: fn() void = go();

c_scope :: import("@/examples/import_c/ffi.fr")'include(C_SRC);
go :: fn() void #use(c_scope) = {
    x := bar(1);
    s := bit_cast_unchecked(*i8, CStr, get_string()).str(); // ugh
    @assert_eq(s, "Hello World");
    @assert_eq(x, s.len.intcast() + 2);
    b: Baz = (a = 1.0, b = @array(2, 3));
    b := baz(b);  // pass + return struct by value
    @assert(b.a == 5.0 && b.b&[0] == 1 && b.b&[1] == 1);
    @assert_eq(fib0(5), 5);
    
    @assert_eq(add_many(3, @va(1, 2, 3)), 6);  // variadic
    // variadic call needs to work in immediate_eval_expr too
    @assert_eq(:: add_many(4, @va(1, 2, 3, 4)), 10);  
    // pass a pointer to variadic function defined in franca and call it from c
    @assert_eq(call_va(add_three, 5, 7), 15, "call_va");
    
    @assert_eq(square(.NUMBER_TWO), 4); 
    x := 123;  // pass a rawptr as *void
    @assert_eq(untyped(i64.raw_from_ptr(x&)), 123);
    @assert(count() == 0 && count() == 1);
    
    s2 := get_s();
    @assert(s2.b == 123 && s2.ref_b[] == 123);
    s2.ref_b[] = 456;
    @assert_eq(s2.b, 456);
}

add_three :: fn(va: CVariadic) i64 = {
    va := va&.start();
    a, b, c := (va.next(i64), va.next(i64), va.next(i64));
    a + b + c
}

C_SRC :: """
    int strlen(char*);  // this is an import from libc
    int foo(int a) {
        return a * 2;
    }
    char *strings[] = { "Hello World", "Another" };
    char *get_string(void) {
        return strings[0];
    }
    int bar(int a) {
        int x = strlen(get_string());
        return x + foo(a);
    }
    
    typedef struct Baz { float a; long b[2]; } Baz;
    Baz baz(Baz c) {
        return ((Baz) { .a = c.b[0] + c.b[1], .b = { c.a, c.a } });
    }
    
    // mutually recursive. make sure you don't get stuck in callees. 
    int fib0(int x);
    int fib1(int x) { return x <= 1 ? x : fib0(x - 1) + fib0(x - 2); }
    int fib0(int x) { return x <= 1 ? x : fib1(x - 1) + fib1(x - 2); }
        
    #include <stdarg> 
    int add_many(int n, ...) {
        int sum;
        va_list it;
        va_start(it);
        for (;n--;) {
            sum += va_arg(it, int); 
        }
        return sum;
    }
    
    typedef enum Number {
        NUMBER_ZERO,
        NUMBER_ONE,
        NUMBER_TWO,
        NUMBER_THREE,
    } Number; 
    
    int square(Number n) {
        return n*n;
    }
    
    long untyped(void *x) {
        long *y = x;
        return y[0];
    }
    
    long call_va(long (*f)(...), long a, long b) {
        return f(a, b, 3);
    }
    
    int count() {
        static int n = 0;
        return n++;
    }
    
    // self reference with addend
    struct S { long *ref_b; long b; } s = { .b = 123, .ref_b = &s.b, };
    struct S *get_s() {
        return &s;
    }
""";

#include_std("backend/lib.fr");
#use("@/lib/variadic.fr");
