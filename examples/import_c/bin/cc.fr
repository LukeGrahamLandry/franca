C :: import("@/examples/import_c/lib.fr");

#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");
ENABLE_TRACY :: false;  // TODO: make worker something you can import nicely

Args :: @struct {
    target: QbeTargetEnv;
    input_path: Str;
    output_path: Str;
    //defines: []Ty(Str, Str);
};

fn main() void = {
    ::?Arch;
    // TODO: cli
    args: Args = (
        target = (arch = .aarch64, os = .macos, type = .Exe), //(arch = query_current_arch().unwrap(), os = query_current_os(), type = .Exe), 
        //input_path = "target/wuffs/example/stb-imagedumper/stb-imagedumper.c", 
        //input_path = "target/wuffs/example/gifplayer/gifplayer.c", 
        input_path = "target/wuffs/test/c/std/gif.c", 
        output_path = "./c.out",
        //defines = @slice(("thisisatest", ""), ("WUFFS_CONFIG__AVOID_CPU_ARCH", "")),
    );
    //or compile(args) { err |
    //    panic(err);
    //};
    //return();
    
    ::import("@/examples/testing.fr");
    chdir("target/wuffs").unwrap();
    // TODO: without the `found :=` theres no error message for forgetting the `;` after `skip`
    skip :: @const_slice(
        "gzip.c", // test_wuffs_gzip_decode_infrequent_compaction: i=60: have "#deflate: bad distance", want "$base: short read"
    );
    // TODO: preload the wuffs lib file
    files := collect_with_extension("test/c/std", ".c") 
            || panic("didn't find tests. run from franca root dir and clone wuffs to target/wuffs");
    files&.unordered_retain(fn(it) => !skip.contains(it));
    run_tests_main(Str, files.items(), fn(a) => a[]) { file | 
        yield :: local_return;
        path := @tfmt("test/c/std/%", file[]);
        args.input_path = path;
        a := timestamp();
        or compile(args) { err |
            yield(false, fixed_list(empty()), err.assume_owned(temp()), "");
        };
        b := timestamp();
        ok, out, err := exec_and_catch("./c.out", empty(), todo_allocator);
        ok := ok && out.items().contains("cc      PASS (");
        (ok, out, err, @tfmt("%ms", b - a))
    };
}

fn compile(args: Args) Result(void, Str) = {
    m := @uninitialized QbeModule;
    
    init(m&, 1.shift_left(25), libc_allocator, args.target, false);
    //m.debug["G".char()] = true;
    //m.debug["P".char()] = true;
    
    ctx: *CodegenShared = init(m&, libc_allocator, codegen_thread_main);

    c := C'Compile.Ctx.zeroed();
    C'init_ctx(c&, m&);
    
    prog := @try(c&.compile_file(args.input_path)) return;
    emit_the_code(c&, ctx, prog);
    join_codegen_thread(ctx);

    outfile := fopen(args.output_path.maybe_borrow_cstr(temp()), "w".sym().c_str());
    chunks := {m.target.finish_module}(m&);
    for chunks { chunk | 
        write(outfile, chunk);
    };
    fclose(outfile);
    drop(m&);
    .Ok
}
