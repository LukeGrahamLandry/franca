/// Here we translate the c compiler's representation to the franca compiler's representation. 
/// This allows franca programs to use our types/functions/variables. 

//
// This mostly works: you can seamlessly use a library written in c without writing function/struct 
// signetures and call that code at comptime or runtime just like it were written in franca. 
// TODO: However, there are still some glaring problems: 
// - you can only import #libc things
// - should allow the c code to call franca without retyping signatures but that's hard
//   because the franca compiler wants to do everything out of order and the c compiler 
//   wants everything forward declared. you can't even parse until you know the type names. 
// - need more control over imports. should be able to redirect malloc to your own allocator, 
//   but you don't want to require typing out all the names. 
// - translate bit fields to @bit_fields (and make sure their abi matches). 
// - cross compilation doesn't work because my whole compilation model relies on being strict 
//   about only having target splits on a function call boundary, but c programs just 
//   use the preprocessor to change things at random. so i'm forced to compile everything twice. 
// - copying between modules in emit_ir is much less confusing than what i was trying to do before,
//   but feels wasteful. especially if i end up recompiling the thing anyway for cross compile. 
// - you can't access preprocessor stuff. if constants are #define instead of enum, we don't export them. 
//   or something like tracy that defines the public nice names as macros, you can't call that from franca. 
// - you can't access anon enums (they should just be constants i guess)
// - it would save a lot of effort if the c compiler used the franca data structures 
//   for everything. but then there's an awkward coupling. I like that this also works 
//   as a stand alone c compiler so it feels like a more impressive demo of "hey this is
//   just a normal program that we happen to run at comptime to generate some code sometimes". 
// - put `static` functions in an inner namespace for each file so we can mimic seperate compilation units
// - have a thing for removing prefixes since we have a higher level idea of scopes
// - currently i only export typedefs. need to be able to use things without like `struct Foo` or whatever
// - things from other header files are exported too too which might not be what you want. 
//   like what if you want to use a library that typedef-ed u32 for themselves? now you can't #use it. that sucks. 
// - support pragma pack/alignas so need to do the field layout / TypeMeta here
// - track no_return and export it as Never
// - #use anon struct fields
//
// TODO: allow passing in a namespace to lookup external functions in (and don't auto recurse upward) 
// so you can tell if you update a library and it starts calling weird shit suddenly or you can give it your
// own versions that limit its access to the file system or whatever.  
//

fn include(src: Str) ScopeId #fold = {
    fr := current_compiler_context();
    include(fr, src)
}

fn include(fr: CompCtx, c_source: Str) ScopeId = {
    c := import_c'init_fr(fr);
    bytes := import_c'compile_fr(fr.get_alloc(), c_source, c);
    fr'vtable'drop_qbe_module(QbeModule.raw_from_ptr(c.m));
    c.arena_storage&.deinit();
    result := fr'vtable'import_frc(fr.data, bytes);
    or result { err |
        fr.report_error(err)
    }
}

import_c :: import_module("@/examples/import_c/ffi.fr");

exports :: Type.scope_of(@struct {
    // TODO: somehow moving `init_fr` to the end of this struct causes 
    //       `panic! ICE: tried to call got null jit_addres` (when import_module caching is enabled)  :compilerbug -- Oct 13, 2025
    init_fr: (@Fn(fr: CompCtx) *C.Compile.Ctx) : init_for_include;
    compile_fr: (@Fn(out_alloc: Alloc, c_source: Str, c: *C.Compile.Ctx) []u8) : compile_to_module;
    init_c: (@Fn(c: *C.Compile.Ctx, m: *QbeModule) void) : init_ctx;
    compile_c: (@Fn(c: *C.Compile.Ctx, filename: Str, contents: Str) Result(void, Str)) : fn(c, filename, contents) = {
        catch_call(c, void) {
            tok := c.tokenize_string(filename, contents);
            tok  = c.C'Preprocess'preprocess(tok);
            c.C'Compile'parse(tok);
        }
    };
});

// for now this uses compiler's exported backend functions instead of import_module(backend/lib.fr) 
// so abi is more likely to work out. this might change eventually, it feels kinda hacky to expose backend stuff. 
fn init_for_include(fr: CompCtx) *C.Compile.Ctx = {
    m := fr.get_alloc().box_uninit(QbeModule);
    c := fr.get_alloc().box_zeroed(C'Compile.Ctx);
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, fr.vtable, (arch = query_current_arch(), os = query_current_os(), type = .CachedEarly));
    // TODO: annoying that it can't inherit set_debug_types from when you pass -d to default_driver
    //       because the early passes only run before giving the .frc to the franca compiler. 
    //       tho maybe that's a dumb design anyway because you're doing a lot of work
    //       if you import a big library but only call one function (but it makes caching easier... not that i do that tho). 
    // TODO: this should work when not through the vtable but this is better anyway
    codegen_thread_main := ptr_cast_unchecked(@type fr.vtable.codegen_thread_main, C'Compile'CodegenWorker, fr.vtable.codegen_thread_main&)[];
    // "todo: make this work threaded"
    ctx: *C.Compile.CodegenShared = init_codegen_worker(m, general_allocator(), codegen_thread_main, false);
    C'init_ctx(c, m);
    c.emitter = (Some = ctx);
    c.enqueue_task = bit_cast_unchecked(@type fr.vtable.enqueue_task, @type c.enqueue_task, fr.vtable.enqueue_task);
    c.preserve_franca_env = true;
    range(0, FTy.COUNT) { _ |
        m.save.unwrap()[].fty&.push(zeroed FTy);   // skip builtin types so offsets work out
    };
    c
}

fn compile_to_module(out_alloc: Alloc, c_source: Str, c: *C.Compile.Ctx) []u8 = {
    writer := c.m.save.unwrap();
    mark := mark_temporary_storage();
    result := catch_call(c, One(FTy)) {
        src: List(u8) = assume_owned(c_source, temp());
        tok := c.tokenize_string("import_cTODO", src&.items());
        tok  = c.C'Preprocess'preprocess(tok);
        _ := c.parse(tok);
        
        c.emitter.unwrap().join_codegen_thread();
        
        // add all the functions/globals/typedefs to a scope
        args := Fld.list(c.arena);
        sc := c.scope;
        each sc.vars& { name, value |
            ::ptr_utils(@type value.type_def[]);
            if !value.type_def.is_null() {
                type := export_type(c, value.type_def, false);
                args&.push(
                    name = writer.push(name),
                    type = (off = FTy.TYPE),
                    payload = (type = type),
                );
            }
            obj := value.var;
            ::ptr_utils(@type obj[]);
            // TODO: don't export the fake alloca()
            if !obj.is_null() {
                sym := map_sym(writer, c.m, obj.global_symbol.expect("mangle"));
                // TODO: can't just skip when !obj.is_definition because i still need to know the types of imports, 
                //       but i'd rather not have every c module re-export the libc types, so idk what to do about that. 
                ty := @if(obj.is_function, obj.ty, c.pointer_to(obj.ty));
                args&.push(
                    name = writer.sym[sym].name,
                    type = export_type(c, ty, false),
                    payload = (offset = trunc sym),
                );
                
                s := writer.sym[sym].segment&;
                ::enum(@type s[]);
                if !obj.is_definition && s[] == .Invalid {
                    s[] = .Import;
                    // rn this defaults to "libc" cause that's 0 but probably i want a different 
                    // sentinal for "we don't know where it comes from, just give me a symbol with this name"
                }
            };
        }
        
        save_fields(writer, .Scope, args.items())
    };
    root_scope := or result { err | 
        panic(err)
    };
    
    meta: Meta = (arch_os = 0x0F0F, root_scope = root_scope);
    b := writer.to_bytes(meta, c.m);
    
    // We're done with all the c compiler state. Copy out the compiled module and then free everything. 
    // (can't drop(m) here because it was inited-dyn so need the caller to drop it because they have the vtable)
    bytes := concat(b, out_alloc);
    //write_entire_file_or_crash("target/a.frc", bytes);
    reset_temporary_storage(mark);
    bytes
}

#use("@/backend/incremental.fr");

fn export_type(c: *Ctx, type: *CType, decay_arrays: bool) One(FTy) = {
    writer := c.m.save.unwrap();
    ::enum(C.Types.TypeKind);
    use_cache := !(decay_arrays && type.kind == .TY_ARRAY);
    if(type.franca != 0 && use_cache, => return(off = type.franca));
    nominal := @is(type.kind, .TY_STRUCT, .TY_UNION, .TY_ENUM);
    
    @match(type.kind) {
        fn TY_VOID()    => return(off = FTy.VOID);
        fn TY_BOOL()    => return(off = FTy.BOOL);
        fn TY_FLOAT()   => return(off = FTy.F32);
        fn TY_DOUBLE()  => return(off = FTy.F64);
        fn TY_LDOUBLE() => return(off = FTy.F64);
        fn TY_PTR()     => @match(type.base.kind) {
            fn TY_VOID() => return(off = FTy.RAWPTR);
            fn TY_FUNC() => return(c.export_type(type.base, false));
            @default     => ();
        };
        @default        => ();
    };
    
    id := writer.fty.len;
    writer.fty&.push(zeroed FTy);
    if use_cache {
        type.franca = trunc id;
    }
    writer.fty[id] = c.export_type_info(type, decay_arrays);
    ::enum(FTy.Tag);
    
    (off = trunc id)
}

fn export_type_info(c: *Ctx, type: *CType, decay_arrays: bool) FTy = {
    is_int := @is(type.kind, .TY_CHAR, .TY_SHORT, .TY_INT, .TY_LONG);
    if(is_int, => return(
        tag = .Number, 
        payload = (int = (bits = type.size.bitcast() * 8, signed = !type.is_unsigned)),
    ));
    
    writer := c.m.save.unwrap();
    @match(type.kind) {
        fn TY_ENUM() => {
            args := Fld.list(type.param_names.len, c.arena);
            enumerate type.param_names { i, it |
                // this wont work if it was declared in an inner scope, 
                // but i guess then you wouldn't be able to export it anyway. 
                var := c.find_var(it[]) || @panic("failed to find enum value %", it[].str());
                @assert(identical(var.enum_ty, type), "expected '%' to be an enum", it[].str());
                if var.enum_val.bit_and(0xffffffff) != var.enum_val {
                    @println("TODO: export large enum to franca % = %", it[].str(), var.enum_val);
                };
                args&.push(
                    name = writer.push(it[].str()),
                    type = (off = FTy.U32),
                    payload = (offset = trunc var.enum_val),
                );
            };
            save_fields_fty(writer, .Enum, args.items())
        }
        fn TY_PTR() => (
            tag = .Ptr, 
            payload = (array = (
                inner = c.export_type(type.base, false),
            )),
        );
        // C arrays decay to pointers when passed to functions, so this needs to be 
        // treated differently depending if it's inside a struct body. 
        fn TY_ARRAY() => (
            tag = @if(decay_arrays, .Ptr, .Array),
            payload = (array = (
                inner = c.export_type(type.base, decay_arrays), 
                count = type.array_len.bitcast(),
            )),
        );
        fn TY_VLA()    => panic("todo: export vla to franca"); // (Ptr = c.export_type(type.base, false));
        fn TY_STRUCT() => c.export_members(type, false);
        fn TY_UNION()  => c.export_members(type, true);
        fn TY_FUNC() => (
            tag = .Func,
            payload = (func = (
                arg = @if_else {
                    @if(type.params.len == 0) => (off = @if(type.is_variadic, FTy.VARIADIC, FTy.VOID));
                    @if(type.params.len == 1 && !type.is_variadic) => c.export_type(type.params[0], true);
                    @else => {
                        args := Fld.list(type.params.len, c.arena);
                        for type.params { par | 
                            args&.push(type = c.export_type(par, true));
                        };
                        if type.is_variadic {
                            args&.push(type = (off = FTy.VARIADIC));
                        };
                        save_fields(writer, .Params, args.items())
                    };
                }, 
                ret = c.export_type(type.return_ty, false), 
            )),
        );
        @default => panic("TODO: import_c export missing type");
    }
}

fn export_members(c: *Ctx, type: *CType, is_union: bool) FTy = {
    writer := c.m.save.unwrap();
    args := Fld.list(c.arena);  // TODO: cap
    for_linked type.members { mem |
        if mem.is_bitfield {
            @eprintln("TODO: export bit field to franca: %->%", type.name.str(), mem.name.str());
        };
        args&.push(
            name = writer.push(mem.name.str()),
            type = c.export_type(mem.ty, false),
            payload = (offset = mem.offset.bitcast()), 
        );
    };
    save_fields_fty(writer, @if(is_union, .Union, .Struct), args.items())
}

// 
// import_cache_files and friends are used when the c compiler wants to #include a .frc file. 
// For example when using a module generated by import_wuffs. 
// 

fn import_cache_file(c: *Ctx, tok: *C.Tokens.Token) void = {
    ::Result(*Header, Str);
    h: *Header = or check(tok.file.contents) { e |
        @error_tok(c, tok, "include frc: %", e)
    };
    
    root_scope := h.get(h.root_scope);
    for(h, root_scope.payload.fields) { i, it |
        continue :: local_return;
        name_str := h.get(it.name);
        if it.type.off == FTy.TYPE {
            ty := c.import_c_type(h, it.payload.type, false);
            c.push_scope(name_str)[].type_def = ty;
            continue();
        };
        
        ty := c.import_c_type(h, it.type, false);
        
        // TODO: should find_func in case it was forward declared 
        obj := c.new_gvar(name_str, ty, tok, false);
        obj.is_function = ty.kind == .TY_FUNC;
    };
    
    @assert(c.emitter.is_none() || !c.emitter.Some.threaded, "TODO: import_c import_cache_file on another thread");
    
    // TODO: if the c Ctx is also being compiled to a .frc file, 
    //       there's no need to duplicate everything. it should probably just reference 
    //       the symbols as imports. and it's the last guy's job to merge everything when actually making an exe. 
    compile_all_symbols(h, c.m);
}

// TODO: cache these so it's not allocating a new type every time it's referenced. 
fn import_c_type(c: *Ctx, h: *Qbe.Incremental.Header, ty_i: One(Qbe.Incremental.FTy), array_would_decay: bool) *CType = {
    @switch(ty_i.off) {
        @case(1) => return(c.ty_void);
        @case(3) => return(c.ty_long);
        @case(5) => @panic("TODO: import_c_type variadic function");
        @case(7) => return(c.ty_double);
        @case(10) => return(c.ty_uint);
        @case(12) => return(c.ty_float);
        @default => ();
    }
    ty := h.get(ty_i);
    ::enum(@type ty.tag);
    @match(ty.tag) {
        fn Func() => {
            ret := c.import_c_type(h, ty.payload.func.ret, true);
            f_ty := c.func_type(ret);
            
            params := list(*CType, c.arena);
            arg := h.get(ty.payload.func.arg);
            @match(arg.tag) {
                fn Params() => {
                    for(h, arg.payload.fields) { i, it |
                        params&.push(c.import_c_type(h, it.type, true));
                    };
                }
                // TODO: why does this need extra {}?
                @default => {if ty.payload.func.arg.off != 1 {
                    params&.push(c.import_c_type(h, ty.payload.func.arg, true));
                }};
            }
            
            f_ty.is_variadic = false; // TODO
            f_ty.params = params.items();
            f_ty
        }
        fn Array() => {
            inner := c.import_c_type(h, ty.payload.array.inner, false);
            if !array_would_decay {
                return c.array_of(inner, ty.payload.array.count.zext());
            };
            // TODO: this sucks. i can't represent value type of an array when passing to a function 
            panic("TODO: import_c_type wrap array in struct to prevent it from decaying")
        }
        // TODO: proably want to have the imported module say field offsets so you can pack in different ways. 
        fn Struct() => {
            result := c.new_type(.TY_STRUCT, 0, 0);
            
            // TODO: make this not a linked list :(
            head := C.Types.Member.zeroed();
            cur  := head&;
            idx  := 0;
            for(h, ty.payload.fields) { i, it |
                mem := c.arena.box_zeroed(C.Types.Member);
                mem.ty = c.import_c_type(h, it.type, false);
                name := h.get(it.name);
                if name.len == 0 {
                    name = "-";
                };
                // TODO: new_file
                mem.name = c.new_token(.TK_IDENT, name.index(0), name.index_unchecked(name.len));
                mem.idx = idx.intcast();
                idx += 1;
                mem.align = mem.ty.align;
                cur.next = mem;
                cur = cur.next;
            };
            result.members = head.next;
            
            c.struct_layout(result);
            result
        }
        @default => @panic("TODO: import_c import frc type % %", ty.tag, ty_i.off);
    }
}

#use("@/compiler/ast_external.fr");
C :: import("@/examples/import_c/lib.fr");
Ctx :: C.Compile.Ctx;
Obj :: C.Compile.Obj;
CType :: C.Types.CType;

#use("@/backend/lib.fr");
