/// Here we translate the c compiler's representation to the franca compiler's representation. 
/// This allows franca programs to use our types/functions/variables. 

//
// This mostly works: you can seamlessly use a library written in c without writing function/struct 
// signetures and call that code at comptime or runtime just like it were written in franca. 
// TODO: However, there are still some glaring problems: 
// - you can only import #libc things
// - should allow the c code to call franca without retyping signatures but that's hard
//   because the franca compiler wants to do everything out of order and the c compiler 
//   wants everything forward declared. you can't even parse until you know the type names. 
// - need more control over imports. should be able to redirect malloc to your own allocator, 
//   but you don't want to require typing out all the names. 
// - translate bit fields to @bit_fields (and make sure their abi matches). 
// - cross compilation doesn't work because my whole compilation model relies on being strict 
//   about only having target splits on a function call boundary, but c programs just 
//   use the preprocessor to change things at random. so i'm forced to compile everything twice. 
// - copying between modules in emit_ir is much less confusing than what i was trying to do before,
//   but feels wasteful. especially if i end up recompiling the thing anyway for cross compile. 
// - you can't access preprocessor stuff. if constants are #define instead of enum, we don't export them. 
//   or something like tracy that defines the public nice names as macros, you can't call that from franca. 
// - you can't access anon enums (they should just be constants i guess)
// - it would save a lot of effort if the c compiler used the franca data structures 
//   for everything. but then there's an awkward coupling. I like that this also works 
//   as a stand alone c compiler so it feels like a more impressive demo of "hey this is
//   just a normal program that we happen to run at comptime to generate some code sometimes". 
// - put `static` functions in an inner namespace for each file so we can mimic seperate compilation units
// - have a thing for removing prefixes since we have a higher level idea of scopes
// - currently i only export typedefs. need to be able to use things without like `struct Foo` or whatever
// - things from other header files are exported too too which might not be what you want. 
//   like what if you want to use a library that typedef-ed u32 for themselves? now you can't #use it. that sucks. 
// - support pragma pack/alignas so need to do the field layout / TypeMeta here
// - track no_return and export it as Never
// - #use anon struct fields
//
// TODO: allow passing in a namespace to lookup external functions in (and don't auto recurse upward) 
// so you can tell if you update a library and it starts calling weird shit suddenly or you can give it your
// own versions that limit its access to the file system or whatever.  
//

fn include(src: Str) ScopeId #fold = {
    fr := current_compiler_context();
    include(fr, src)
}

fn include(fr: CompCtx, c_source: Str) ScopeId = {
    msg :: "import_c: frc module abi mismatch\nrecompile your franca compiler";
    @assert_eq(fr.vtable.frc_module_magic_v, Incremental.MAGIC, msg);

    #use("@/lib/sys/fs.fr");
    no_cache := Foreign.ENV.FRANCA_NO_CACHE.get_environment_variable().is_some();
    // TODO: using a hash for the name is annoying because if you change the source it won't replace the old one, 
    //       so it just leaks them and you have to delete the cache directory occasionally to reclaim disk space. 
    name := Sha256'hex(c_source);
    cachepath := FrIncr'choose_cache_filename(name);
    if !no_cache {
        if FrIncr'read_cached(fr.get_alloc(), cachepath) { header |
            entry_source := header.get(header.entry_source);
            // checking entry_source is redundant rn because its hash is used as the file name 
            if FrIncr'files_unchanged(header, read_entire_file, fr.vtable.self_hash) && entry_source == c_source {
                @if(show_backend_stats()) @eprintln(">>> (c) hit: %", cachepath);
                result := fr'vtable'import_frc(fr.data, header.as_bytes());
                return result.or(fn(err) => fr.report_error(err));
            };
        };
    };
    
    // force a jit shim so the c compiler isn't recompiled if it isn't going to be called
    // TODO: should have a macro that does this so it's more explicit and you can grep for where i do it
    include_cold: (@FnPtr(fr: CompCtx, c_source: Str, name: Str) ScopeId) = include_cold;
    include_cold(fr, c_source, name)
}

include_cold :: fn(fr: CompCtx, c_source: Str, name: Str) ScopeId = {
    c := import_c'init_fr(fr);
    bytes := import_c'compile_fr(fr, c_source, c, mangle_name_for_cache(name));
    no_cache := Foreign.ENV.FRANCA_NO_CACHE.get_environment_variable().is_some();
    if query_current_arch() != .wasm32 && !no_cache {
        cachepath := FrIncr'choose_cache_filename(name);
        @if(show_backend_stats()) @eprintln(">>> (c) save: %", cachepath);
        make_dirs(FrIncr'cache_dir()) && write_entire_file(cachepath, bytes);
    };
    fr'vtable'drop_qbe_module(QbeModule.raw_from_ptr(c.m));
    c.arena_storage&.deinit();
    result := fr'vtable'import_frc(fr.data, bytes);
    result.or(fn(err) => fr.report_error(err))
}

import_c :: import_module("@/examples/import_c/ffi.fr");

exports :: Type.scope_of(@struct {
    // TODO: somehow moving `init_fr` to the end of this struct causes 
    //       `panic! ICE: tried to call got null jit_addres` (when import_module caching is enabled)  :compilerbug -- Oct 13, 2025
    init_fr: (@Fn(fr: CompCtx) *C.Compile.Ctx) : init_for_include;
    compile_fr: (@Fn(fr: CompCtx, c_source: Str, c: *C.Compile.Ctx, debug_name: Str) []u8) : compile_to_module;
    init_c: (@Fn(c: *C.Compile.Ctx, m: *QbeModule, worker: *CodegenShared) void) : init_ctx;
    compile_c: (@Fn(c: *C.Compile.Ctx, filename: Str, contents: Str) Result(void, Str)) : fn(c, filename, contents) = {
        catch_call(c, void) {
            tok := c.tokenize_string(filename, contents);
            tok  = c.C'Preprocess'preprocess(tok);
            c.C'Compile'parse(tok);
        }
    };
});

// for now this uses compiler's exported backend functions instead of import_module(backend/lib.fr) 
// so abi is more likely to work out. this might change eventually, it feels kinda hacky to expose backend stuff. 
fn init_for_include(fr: CompCtx) *C.Compile.Ctx = {
    m := fr.get_alloc().box_uninit(QbeModule);
    c := fr.get_alloc().box_zeroed(C'Compile.Ctx);
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, fr.vtable, (arch = query_current_arch(), os = query_current_os(), type = .CachedEarly));
    // TODO: annoying that it can't inherit set_debug_types from when you pass -d to default_driver
    //       because the early passes only run before giving the .frc to the franca compiler. 
    //       tho maybe that's a dumb design anyway because you're doing a lot of work
    //       if you import a big library but only call one function (but it makes caching easier... not that i do that tho). 
    // TODO: this should work when not through the vtable but this is better anyway
    // "todo: make this work threaded"
    ctx := init_codegen_worker(m, false, fr.vtable);
    C'init_ctx(c, m, ctx);
    range(0, FTy.COUNT) { _ |
        m.save.unwrap()[].fty&.push(zeroed FTy);   // skip builtin types so offsets work out
    };
    
    c
}

fn compile_to_module(fr: CompCtx, c_source: Str, c: *C.Compile.Ctx, debug_name: Str) []u8 = {
    out_alloc := fr.get_alloc();
    writer := c.m.save.unwrap();
    mark := mark_temporary_storage();
    entry_source := writer.push(c_source);
    result := catch_call(c, One(FTy)) {
        src: List(u8) = assume_owned(c_source, temp());
        tok := c.tokenize_string("import_cTODO", src&.items());
        tok  = c.C'Preprocess'preprocess(tok);
        _ := c.parse(tok);
        
        c.emitter.join_codegen_thread();
        
        // add all the functions/globals/typedefs to a scope
        args := Fld.list(c.arena);
        sc := c.scope;
        each sc.vars& { name, value |
            ::ptr_utils(@type value.type_def[]);
            if !value.type_def.is_null() {
                type := export_type(c, value.type_def, false);
                args&.push(
                    name = writer.push(name),
                    type = (off = FTy.TYPE),
                    payload = (type = type),
                );
            }
            obj := value.var;
            ::ptr_utils(@type obj[]);
            if !obj.is_null() {
                sym := map_sym(writer, c.m, obj.global_symbol.expect("mangle"));
                // TODO: can't just skip when !obj.is_definition because i still need to know the types of imports, 
                //       but i'd rather not have every c module re-export the libc types, so idk what to do about that. 
                ty := @if(obj.is_function, obj.ty, c.pointer_to(obj.ty));
                args&.push(
                    name = writer.sym[sym].name,
                    type = export_type(c, ty, false),
                    payload = (offset = trunc sym),
                );
                
                s := writer.sym[sym].segment&;
                if !obj.is_definition && s[] == .Invalid {
                    s[] = .Import;
                    // rn this defaults to "libc" cause that's 0 but probably i want a different 
                    // sentinal for "we don't know where it comes from, just give me a symbol with this name"
                }
            };
        }
        
        save_fields(writer, .Scope, args.items())
    };
    root_scope := or result { err | 
        panic(err)
    };
    
    // TODO: need to include import_c as a dep as well
    _, all_deps := FrIncr'write_deps(writer, c.codemap&, "", fr.vtable.self_hash);
    
    // TODO: needs to include __os,__arch because include.fr observes them, 
    //       but i want to fix that by providing a stable abi from my libc instead. 
    //       cross compiling already doesn't work if you ifdef on the target because 
    //       you can't import_frc needs to use the same code at comptime and runtime. 
    meta: Meta = (
        arch_os = 0x0F0F, 
        root_scope = root_scope, 
        entry_source = entry_source,
        // TODO: don't call this debug_name if im going to use it for stuff
        debug_name = writer.push(debug_name),
        all_deps = all_deps,
    );
    b := writer.to_bytes(meta, c.m);
    
    // We're done with all the c compiler state. Copy out the compiled module and then free everything. 
    // (can't drop(m) here because it was inited-dyn so need the caller to drop it because they have the vtable)
    bytes := concat(b, out_alloc);
    reset_temporary_storage(mark);
    bytes
}

#use("@/backend/incremental.fr");

fn export_type(c: *Ctx, type: *CType, decay_arrays: bool) One(FTy) = {
    writer := c.m.save.unwrap();
    use_cache := !(decay_arrays && type.kind == .TY_ARRAY);
    if(type.franca != 0 && use_cache, => return(off = type.franca));
    nominal := @is(type.kind, .TY_STRUCT, .TY_UNION, .TY_ENUM);
    
    @match(type.kind) {
        fn TY_VOID()    => return(off = FTy.VOID);
        fn TY_BOOL()    => return(off = FTy.BOOL);
        fn TY_FLOAT()   => return(off = FTy.F32);
        fn TY_DOUBLE()  => return(off = FTy.F64);
        fn TY_LDOUBLE() => return(off = FTy.F64);
        fn TY_PTR()     => @match(type.base.kind) {
            fn TY_VOID() => return(off = FTy.RAWPTR);
            fn TY_FUNC() => return(c.export_type(type.base, false));
            @default     => ();
        };
        @default        => ();
    };
    
    id := writer.fty.len;
    writer.fty&.push(zeroed FTy);
    if use_cache {
        type.franca = trunc id;
    }
    writer.fty[id] = c.export_type_info(type, decay_arrays);
    
    (off = trunc id)
}

fn export_type_info(c: *Ctx, type: *CType, decay_arrays: bool) FTy = {
    is_int := @is(type.kind, .TY_CHAR, .TY_SHORT, .TY_INT, .TY_LONG);
    if(is_int, => return(
        tag = .Number, 
        payload = (int = (bits = type.size.bitcast() * 8, signed = !type.is_unsigned)),
    ));
    
    writer := c.m.save.unwrap();
    @match(type.kind) {
        fn TY_ENUM() => {
            args := Fld.list(type.param_names.len, c.arena);
            enumerate type.param_names { i, it |
                // this wont work if it was declared in an inner scope, 
                // but i guess then you wouldn't be able to export it anyway. 
                var := c.find_var(it[]) || @panic("failed to find enum value %", it[].str());
                @assert(identical(var.enum_ty, type), "expected '%' to be an enum", it[].str());
                if var.enum_val.bit_and(0xffffffff) != var.enum_val {
                    @println("TODO: export large enum to franca % = %", it[].str(), var.enum_val);
                };
                args&.push(
                    name = writer.push(it[].str()),
                    type = (off = FTy.U32),
                    payload = (offset = trunc var.enum_val),
                );
            };
            save_fields_fty(writer, .Enum, args.items())
        }
        fn TY_PTR() => (
            tag = .Ptr, 
            payload = (array = (
                inner = c.export_type(type.base, false),
            )),
        );
        // C arrays decay to pointers when passed to functions, so this needs to be 
        // treated differently depending if it's inside a struct body. 
        fn TY_ARRAY() => (
            tag = @if(decay_arrays, .Ptr, .Array),
            payload = (array = (
                inner = c.export_type(type.base, decay_arrays), 
                count = type.array_len.bitcast(),
            )),
        );
        fn TY_VLA()    => panic("todo: export vla to franca"); // (Ptr = c.export_type(type.base, false));
        fn TY_STRUCT() => c.export_members(type, false);
        fn TY_UNION()  => c.export_members(type, true);
        fn TY_FUNC() => (
            tag = .Func,
            payload = (func = (
                arg = @if_else {
                    @if(type.params.len == 0) => (off = @if(type.is_variadic, FTy.VARIADIC, FTy.VOID));
                    @if(type.params.len == 1 && !type.is_variadic) => c.export_type(type.params[0], true);
                    @else => {
                        args := Fld.list(type.params.len, c.arena);
                        for type.params { par | 
                            args&.push(type = c.export_type(par, true));
                        };
                        if type.is_variadic {
                            args&.push(type = (off = FTy.VARIADIC));
                        };
                        save_fields(writer, .Params, args.items())
                    };
                }, 
                ret = c.export_type(type.return_ty, false), 
            )),
        );
        @default => panic("TODO: import_c export missing type");
    }
}

fn export_members(c: *Ctx, type: *CType, is_union: bool) FTy = {
    writer := c.m.save.unwrap();
    args := Fld.list(c.arena);  // TODO: cap
    for_linked type.members { mem |
        if mem.is_bitfield {
            // TODO: at least just put the backing type so layout is right even if franca can't access it properly
            @eprintln("TODO: export bit field to franca: %->%", type.name.str(), mem.name.str());
        };
        args&.push(
            name = writer.push(mem.name.str()),
            type = c.export_type(mem.ty, false),
            payload = (offset = mem.offset.bitcast()), 
        );
    };
    save_fields_fty(writer, @if(is_union, .Union, .Struct), args.items())
}

// 
// import_cache_files and friends are used when the c compiler wants to #include a .frc file. 
// For example when using a module generated by import_wuffs. 
// 

fn import_cache_file(c: *Ctx, tok: *C.Tokens.Token) void = {
    ::Result(*Header, Str);
    c.current_file = tok.file;
    @if(show_backend_stats()) @eprintln(">>> import_cache_file %", tok.file.name);
    h: *Header = or check(tok.file.contents) { e |
        @error_tok(c, tok, "include frc: %", e)
    };
    
    root_scope := h.get(h.root_scope);
    c.import_type_cache = temp().alloc_zeroed(Array(*CType, 2), h.fty.count.zext());
    for(h, root_scope.payload.fields) { i, it |
        continue :: local_return;
        name_str := h.get(it.name);
        if it.type.off == FTy.TYPE {
            ty := c.import_c_type(h, it.payload.type, false);
            c.import_type_cache[it.payload.type.off.zext()]&[0] = ty;
            c.push_scope(name_str)[].type_def = ty;
            continue();
        };
        
        ty := c.import_c_type(h, it.type, false);
        c.import_type_cache[it.type.off.zext()]&[0] = ty;
        
        if h.get(it.type)[].tag == .Func {
            @debug_assert(ty.kind == .TY_PTR && ty.base.kind == .TY_FUNC);
            ty = ty.base;
        };
        
        // TODO: if it was static (not exported) it won't get remangled so can collide because i just mangle by appending file index. 
        // TODO: should find_func in case it was forward declared 
        obj := c.new_gvar(name_str, ty, tok, false);
        obj.is_function = ty.kind == .TY_FUNC;

        // != name_str if its from franca and mangled as foo = foo__FUNCID
        // TODO: there will be duplicates if reexported by compile_to_module
        sym := h.get(it.payload.sym);  
        sym_name := c.m.intern(h.get(sym.name));
        obj.global_symbol = (Some = sym_name);
    };
    c.import_type_cache = empty();
    
    // TODO: if the c Ctx is also being compiled to a .frc file, 
    //       there's no need to duplicate everything. it should probably just reference 
    //       the symbols as imports. and it's the last guy's job to merge everything when actually making an exe. 
        enter_task c.emitter { entry | 
            entry.task = (All = h);
        };
}

// TODO: the fields for Array/Tagged don't have a name (can't be a string outside the "file")
//       so get_struct_member will treat them as anon which isn't what you want. 
//       also makes a franca Tagged value unusable from the c, i just don't have an example that wants to do that yet. 
fn import_c_type(c: *Ctx, h: *Qbe.Incremental.Header, ty_i: One(Qbe.Incremental.FTy), array_would_decay: bool) *CType = {
    cache_slot := c.import_type_cache[ty_i.off.zext()]&[int(array_would_decay)]&;
    if !cache_slot[].is_null() {
        return cache_slot[];
    };
    // TODO: size_of(void)=1 in c so franca's void is kinda a different type 
    //       (the problem being void fields, need to strip them when importing?)
    @switch(ty_i.off) {
        @case(1) => return(c.ty_void);
        @case(3) => return(c.ty_long);
        @case(4) => return(c.ty_bool);
        @case(5) => @panic("VARIADIC is just a marker in func params");
        @case(6) => return(c.ty_void);  // Never
        @case(7) => return(c.ty_double);
        @case(10) => return(c.ty_uint);
        @case(11) => return(c.pointer_to(c.ty_void));
        @case(12) => return(c.ty_float);
        @default => ();
    }
    ty := h.get(ty_i);
    @match(ty.tag) {
        fn Func() => {
            ret := c.import_c_type(h, ty.payload.func.ret, true);
            f_ty := c.func_type(ret);
            f_ty.is_variadic = false;
            
            params := list(*CType, c.arena);
            arg := h.get(ty.payload.func.arg);
            @match(arg.tag) {
                fn Params() => {
                    args := h.get(arg.payload.fields);
                    if args.len > 0 && args[args.len - 1].type.off == 5 {
                        f_ty.is_variadic = true;
                        args.len -= 1;
                    };
                    each args { it |
                        params&.push(c.import_c_type(h, it.type, true));
                    };
                }
                // TODO: why does this need extra {}?
                @default => {@switch(ty.payload.func.arg.off) {
                    @case(1) => ();
                    @case(5) => {
                        f_ty.is_variadic = true;
                    };
                    @default => params&.push(c.import_c_type(h, ty.payload.func.arg, true));
                }};
            };
            
            f_ty.params = params.items();
            c.pointer_to(f_ty)
        }
        fn Array() => {
            inner := c.import_c_type(h, ty.payload.array.inner, false);
            array := c.array_of(inner, ty.payload.array.count.zext());
            if !array_would_decay {
                return array;
            };
            
            // if it's for a function param, wrapping it in another struct is the only way to prevent decay. 
            result := c.new_type(.TY_STRUCT, 0, 1);
            head := C.Types.Member.zeroed();
            cur  := head&;
            
            mem := c.arena.box_zeroed(C.Types.Member);
            mem.name = c.hack_field_name(h, "data");
            mem.ty = array;
            mem.idx = 0;
            mem.align = mem.ty.align;
            cur.next = mem;
            cur = cur.next;
            
            result.members = head.next;
            c.struct_layout(result);
            result
        }
        // TODO: proably want to have the imported module say field offsets so you can pack in different ways. 
        fn Struct() => c.import_members(h, ty, .TY_STRUCT);
        fn Params() => c.import_members(h, ty, .TY_STRUCT);
        fn Union() => c.import_members(h, ty, .TY_UNION);
        fn Ptr() => {
            cache_slot[] = c.pointer_to(c.ty_void);  // break cycles
            inner := c.import_c_type(h, ty.payload.array.inner, true);
            cache_slot[][] = c.pointer_to(inner)[];
            cache_slot[]
        }
        fn Number() => {
            it := ty.payload.int&;
            @assert(!it.bitfield, "TODO: import_c import frc bitfield");
            ::[]@type c.prims;
            fields := (*CType).reinterpret_bytes(interpret_as_bytes(c.prims&.slice(1)));
            for fields { check |
                if it.signed == !check.is_unsigned && it.bits == check.size.bitcast() * 8 && it.float == check.is_flonum() && check.is_numeric() {
                    return(check);
                };
            };
            @panic("TODO: import_c import frc type % %", ty.tag, ty_i.off);
        }
        fn Enum() => {
            result := c.new_type(.TY_ENUM, 4, 4);
            
            // TODO: make this not a linked list :(
            head := C.Types.Member.zeroed();
            cur  := head&;
            idx  := 0;
            result.param_names = alloc_zeroed(c.arena, *C.Compile.Token, ty.payload.fields.count.zext());
            idx := 0;
            for(h, ty.payload.fields) { i, it |
                name := h.get(it.name);
                result.param_names[idx] = c.new_token(.TK_IDENT, name.index(0), name.index_unchecked(name.len));
                sc := c.push_scope(name);
                sc.enum_ty = c.ty_uint;
                sc.enum_val = it.payload.offset.zext();
                idx += 1;
            };
            result
        }
        fn Tagged() => {
            result := c.new_type(.TY_STRUCT, 0, 0);
            head := C.Types.Member.zeroed();
            cur  := head&;
            
            mem := c.arena.box_zeroed(C.Types.Member);
            mem.name = c.hack_field_name(h, "tag");
            mem.ty = c.ty_long;
            mem.idx = 0;
            mem.align = mem.ty.align;
            cur.next = mem;
            cur = cur.next;
            
            mem := c.arena.box_zeroed(C.Types.Member);
            // name=null means anonymous so you just access by case name. 
            mem.ty = c.import_members(h, ty, .TY_UNION);
            mem.idx = 1;
            mem.align = mem.ty.align;
            cur.next = mem;
            cur = cur.next;
            
            result.members = head.next;
            c.struct_layout(result);
            result
        }
        fn Alias() => c.import_c_type(h, ty.payload.alias, array_would_decay);
        fn AbiOnly() => panic("TODO: should use AbiOnly when its not exported (more efficient) but i don't");
        fn Invalid() => unreachable();
        fn Scope() => unreachable();
    }
}

// the Token's off,len can only point to bytes inside the file. 
// hacky way to cope without creating a fake file:
// there's a field reserved in the Header that stores the bytes needed for these synthetic names. 
hack_field_name :: fn(c: *Ctx, h: *Qbe.Incremental.Header, $s: Str) *C.Compile.Token = {
    it := h.meta.hack_name_bytes_for_importc&;
    @debug_assert_eq(it[], "tagdata\0".peek_type(i64)[]);
    lo, hi := @inline_switch(s) {
        @case("tag")  => (0, 3);
        @case("data") => (3, 7);
        @default => @run unreachable();
    };
    it := it.slice(1).interpret_as_bytes();
    c.new_token(.TK_IDENT, it.index(lo), it.index(hi))
}

import_members :: fn(c: *Ctx, h: *Qbe.Incremental.Header, ty: *Qbe.Incremental.FTy, kind: C.Compile.TypeKind) *CType = { 
    result := c.new_type(kind, 0, 1);
    
    // TODO: make this not a linked list :(
    head := C.Types.Member.zeroed();
    cur  := head&;
    idx  := 0;
    for(h, ty.payload.fields) { i, it |
        mem := c.arena.box_zeroed(C.Types.Member);
        mem.ty = c.import_c_type(h, it.type, false);
        name := h.get(it.name);
        
        mem.name = c.new_token(.TK_IDENT, name.index(0), name.index_unchecked(name.len));
        mem.idx = idx.intcast();
        idx += 1;
        mem.align = mem.ty.align;
        cur.next = mem;
        cur = cur.next;
    };
    result.members = head.next;
    
    if result.kind == .TY_UNION {
        c.union_layout(result);
    } else {
        c.struct_layout(result);
    };
    result
}

gen_builtin_includes :: fn(out: *HashMap(Str, Str)) void = {
    remap: ?Ty(One(FTy), One(FTy)) = .None;
    s := fr_to_header("@/examples/os/user/libc/string.fr", remap&);
    out.insert("string", s);
}

// TODO: make the binary format less bloated. it's like 4x the byte size as the header. 
fr_to_header :: fn(path: Str, remap: *?Ty(One(FTy), One(FTy))) []u8 = {
    fr := current_compiler_context();
    m := temp().box_uninit(QbeModule);
    // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
    init_default_module_dyn(m, fr.vtable, (arch = .aarch64, os = .macos, type = .CachedEarly));
    
    c: FrIncr.ExportCtx = (
        fr = fr, 
        m = m,
        writer = m.save.unwrap(),
        types = init(temp()),
    ); c := c&;

    // TODO: making everyone remember to do this is kinda lame
    range(0, FTy.COUNT) { i |
        c.types&.insert(bit_cast_unchecked(u32, Type, i.trunc()), (off = i.trunc()));
        c.writer.fty&.push(zeroed Incremental.FTy);   // skip builtin types so offsets work out
    };
    
    fns, names := FrIncr'collect_fns_from_scope(fr, import(path));
    decls := Fld.list(temp());
    range(0, fns.len) { i | 
        fid, export_name := (fns[i], names[i]);
        id := c.m.intern(export_name);
        idx := c.writer.map_sym(c.m, id);
        
        func := get_function_ast(fid, true, false, true, false);
        // TODO: copy paste
        f_ty := func.finished_ty() || @panic("unfinished type for %", c.fr.log(func));
        require_layout_ready(f_ty.arg);
        f_ty := c.fr.intern_type(FnPtr = (ty = f_ty));
        f_ty := FrIncr'export_type(c, f_ty);
        
        decls&.push(
            name = c.writer.push(export_name),
            type = f_ty,
            payload = (offset = trunc idx)
        );
    };
    root_scope := save_fields(c.writer, .Scope, decls.items());
    meta: Incremental.Meta = (
        arch_os = 0x0F0F,
        root_scope = root_scope,
        debug_name = c.writer.push(path),
    );
    s := c.writer.to_bytes(meta, c.m);
    s := s.concat(fr.get_alloc());
    drop(m);
    
    h: Result(*Header, Str) = check(s);
    h := h.unwrap();
    root_scope := h.get(h.root_scope);
    for(h, root_scope.payload.fields) { i, it |
        h.get(it.payload.sym)[] = (
            segment = .Import,
            name = it.name,
            payload = (imp = (lib = (off = 0))),  // :DefaultToLibc
        );
    };
    
    h: *Header = check(s).unwrap();
    root_scope := h.get(h.root_scope);
    
    if remap.is_none() {
        remap[] = (Some = find_cstr_type(h));
    }
    if remap[] { cstr_type, charstar_type |
        h.get(cstr_type)[] = (tag = .Alias, payload = (alias = charstar_type));
    };
    
    s
};

find_cstr_type :: fn(h: *Header) Ty(One(FTy), One(FTy)) = {
    strcpy_type: ?One(FTy) = .None;
    for(h, h.get(h.root_scope)[].payload.fields) { i, it |
        if h.get(it.name) == "strcpy" {
            strcpy_type = (Some = it.type);
        };
    };
    strcpy_type := strcpy_type.expect("to do string.fr first and find strcpy to remap CStr");
    t := h.get(strcpy_type);
    @assert_eq(t.tag, .Func);
    cstr_type := t.payload.func.ret;
    t := h.get(cstr_type);
    @assert_eq(t.tag, .Struct);
    t := h.get(t.payload.fields);
    charstar_type := t[0].type;
    (cstr_type, charstar_type)
}

#use("@/compiler/ast_external.fr");
C :: import("@/examples/import_c/lib.fr");
Ctx :: C.Compile.Ctx;
Obj :: C.Compile.Obj;
CType :: C.Types.CType;
FrIncr :: import("@/compiler/incremental.fr");

#use("@/backend/lib.fr");
