// Adapted from chibicc. MIT License. Copyright (c) 2019 Rui Ueyama

fn fixed_type(tag: CC.TypeKind, size: i64, unsigned: bool) *CC.CType = {
    t := ast_alloc().box_zeroed(CC.CType);
    t.kind = tag;
    t.size = size.intcast();
    t.align = size.intcast();
    t.is_unsigned = unsigned;
    t.ir_index = -1;
    t
}

ty_void   :: fixed_type(.TY_VOID,   1, false);
ty_bool   :: fixed_type(.TY_BOOL,   1, false);
ty_char   :: fixed_type(.TY_CHAR,   1, false);
ty_short  :: fixed_type(.TY_SHORT,  2, false);
ty_int    :: fixed_type(.TY_INT,    4, false);
ty_long   :: fixed_type(.TY_LONG,   8, false);
ty_uchar  :: fixed_type(.TY_CHAR,   1,  true);
ty_ushort :: fixed_type(.TY_SHORT,  2,  true);
ty_uint   :: fixed_type(.TY_INT,    4,  true);
ty_ulong  :: fixed_type(.TY_LONG,   8,  true);
ty_float  :: fixed_type(.TY_FLOAT,  4, false);
ty_double :: fixed_type(.TY_DOUBLE, 8, false);
ty_ldouble :: fixed_type(.TY_LDOUBLE, 8, false);

fn new_type(c: *Ctx, kind: CC.TypeKind, size: i64, align: i64) *CC.CType = {
    ty := c.arena.box_zeroed(CC.CType);
    ty.kind = kind;
    ty.size = size.intcast();
    ty.align = align.intcast();
    ty.ir_index = -1;
    ty
}

fn is_integer(ty: *CC.CType) bool = 
    @is(ty.kind, .TY_BOOL, .TY_CHAR, .TY_SHORT, .TY_INT, .TY_LONG, .TY_ENUM);

fn is_flonum(ty: *CC.CType) bool = 
    @is(ty.kind, .TY_FLOAT, .TY_DOUBLE, .TY_LDOUBLE);

fn is_numeric(ty: *CC.CType) bool = 
    is_integer(ty) || is_flonum(ty);

fn is_void(ty: *CC.CType) bool = 
    ty.kind == .TY_VOID;

fn is_compatible(t1: *CC.CType, t2: *CC.CType) bool = {
    if(t1.identical(t2),     => return(true));
    if(!t1.origin.is_null(), => return(is_compatible(t1.origin, t2)));
    if(!t2.origin.is_null(), => return(is_compatible(t1, t2.origin)));
    if(t1.kind != t2.kind,   => return(false));
    if(@is(t1.kind, .TY_CHAR, .TY_SHORT, .TY_INT, .TY_LONG), => return(t1.is_unsigned == t2.is_unsigned));
    if(@is(t1.kind, .TY_FLOAT, .TY_DOUBLE, .TY_LDOUBLE), => return(true));
    @match(t1.kind) {
        fn TY_PTR()  => is_compatible(t1.base, t2.base);
        fn TY_FUNC() => {
            if(!is_compatible(t1.return_ty, t2.return_ty), => return(false));
            if(!(t1.is_variadic == t2.is_variadic), => return(false));
            p1 := t1.params;
            p2 := t2.params;
            while => !p1.is_null() && !p2.is_null() {
                if(!is_compatible(p1, p2), => return(false));
                p1 = p1.next;
                p2 = p2.next;
            };
            p1.is_null() && p2.is_null()  // are linked lists the same length?
        }
        fn TY_ARRAY() => {
            if(!is_compatible(t1.base, t2.base), => return(false));
            t1.array_len < 0 && t2.array_len < 0 && t1.array_len == t2.array_len
        }
        @default => false;
    }
}

fn copy_type(c: *Ctx, ty: *CC.CType) *CC.CType = {
    ret := c.arena.box_zeroed(CC.CType);
    ret[] = ty[];
    ret.origin = ty;
    ret
}

fn pointer_to(c: *Ctx, base: *CC.CType) *CC.CType = {
    ty := c.new_type(.TY_PTR, 8, 8);
    ty.base = base;
    ty.is_unsigned = true;
    ty
}

fn func_type(c: *Ctx, return_ty: *CC.CType) *CC.CType = {
    // The C spec disallows sizeof(<function type>), but
    // GCC allows that and the expression is evaluated to 1.
    ty := c.new_type(.TY_FUNC, 1, 1);
    ty.return_ty = return_ty;
    ty
}

fn array_of(c: *Ctx, base: *CC.CType, len: i64) *CC.CType = {
    ty := c.new_type(.TY_ARRAY, base.size.intcast() * len, base.align.intcast());
    ty.base = base;
    ty.array_len = len.intcast();
    ty
}

fn vla_of(c: *Ctx, base: *CC.CType, len: *CC.Node) *CC.CType = {
    ty := c.new_type(.TY_VLA, 8, 8);
    ty.base = base;
    len = c.new_cast(len, ty_ulong);
    ty.vla_len = c.gen_expr(len);
    ty
}

fn enum_type(c: *Ctx) *CC.CType =
    c.new_type(.TY_ENUM, 4, 4);

fn struct_type(c: *Ctx) *CC.CType =
    c.new_type(.TY_STRUCT, 0, 1);

fn get_common_type(c: *Ctx, ty1: *CC.CType, ty2: *CC.CType) *CC.CType = {
    if(!ty1.base.is_null(), => return(c.pointer_to(ty1.base)));
    
    k1, k2 := (ty1.kind, ty2.kind);
    if(k1 == .TY_FUNC, => return(c.pointer_to(ty1)));
    if(k2 == .TY_FUNC, => return(c.pointer_to(ty2)));
    
    if(k1 == .TY_LDOUBLE || k2 == .TY_LDOUBLE, => return(ty_ldouble));
    if(k1 == .TY_DOUBLE  || k2 == .TY_DOUBLE,  => return(ty_double));
    if(k1 == .TY_FLOAT   || k2 == .TY_FLOAT,   => return(ty_float));
    
    if ty1.size < 4 {
        ty1 = ty_int;
    };
    if ty2.size < 4 {
        ty2 = ty_int;
    };
    
    if(ty1.size != ty2.size, => return(if(ty1.size < ty2.size, => ty2, => ty1)));
    if(ty2.is_unsigned, => ty2, => ty1)
}

// For many binary operators, we implicitly promote operands so that
// both operands have the same type. Any integral type smaller than
// int is always promoted to int. If the type of one operand is larger
// than the other's (e.g. "long" vs. "int"), the smaller operand will
// be promoted to match with the other.
//
// This operation is called the "usual arithmetic conversion".
fn usual_arith_conv(c: *Ctx, lhs: **CC.Node, rhs: **CC.Node) void = {
    ty   := c.get_common_type(lhs.ty, rhs.ty);
    b := c.b;
    c.b = lhs.current_block;
    lhs[] = c.new_cast(lhs[], ty);
    c.b = lhs.current_block;
    rhs[] = c.new_cast(rhs[], ty);
    c.b = b;
}

Ctx :: Compile.Ctx;

fn add_type(c: *Ctx, node: *CC.Node) void #inline = {
    ::ptr_utils(CC.Node);
    ::ptr_utils(CC.CType);
    if(node.is_null() || !node.ty.is_null(), => return());
    if(@is(node.kind, .ND_NULL_EXPR, .ND_STMT, .ND_MEMZERO), => return());
    add_type_inner(c, node);
}

fn add_type_inner(c: *Ctx, node: *CC.Node) void = {
    @if(SPAM) 
    @println("add type %", node.kind);
    c.add_type(node.lhs);
    c.add_type(node.rhs);
    c.add_type(node.cond);
    c.add_type(node.then);
    c.add_type(node.else);
    
    //n := node.body;
    //for_linked n { n |
    //    c.add_type(n);
    //};
    //n := node.args;
    //for_linked n { n |
    //    c.add_type(n);
    //};
    k := node.kind;
    node.ty = @if_else {
        @if(@is(k, .ND_ADD, .ND_SUB, .ND_MUL, .ND_DIV, .ND_MOD, .ND_BITAND, .ND_BITOR, .ND_BITXOR)) => {
            c.usual_arith_conv(node.lhs&, node.rhs&);
            node.lhs.ty
        };
        @if(@is(k, .ND_EQ, .ND_NE, .ND_LT, .ND_LE)) => {
            c.usual_arith_conv(node.lhs&, node.rhs&);
            ty_int
        };
        @if(@is(k, .ND_NOT, .ND_LOGOR, .ND_LOGAND)) => ty_int;
        @if(@is(k, .ND_BITNOT, .ND_SHL, .ND_SHR))   => node.lhs.ty;
        @if(@is(k, .ND_VAR, .ND_VLA_PTR))           => node.var.ty;
        @else => (@match(k) {
            fn ND_NUM()     => ty_int;
            fn ND_COMMA()   => node.rhs.ty;
            fn ND_MEMBER()  => node.member.ty;
            fn ND_FUNCALL() => node.func_ty.return_ty;
            fn ND_NEG() => {
                ty := c.get_common_type(ty_int, node.lhs.ty);
                node.lhs = c.new_cast(node.lhs, ty);
                ty
            }
            fn ND_ASSIGN() => {
                if(node.lhs.ty.kind == .TY_ARRAY, => @error_tok(c, node.lhs.tok, "not an lvalue"));
                if node.lhs.ty.kind != .TY_STRUCT {
                    node.rhs = c.new_cast(node.rhs, node.lhs.ty);
                };
                node.lhs.ty
            }
            fn ND_COND() => if node.then.ty.kind == .TY_VOID || node.else.ty.kind == .TY_VOID {
                ty_void
            } else {
                c.usual_arith_conv(node.then&, node.else&);
                node.then.ty
            };
            fn ND_ADDR() => panic("addr should have known type");
            fn ND_DEREF() => panic("deref should have known type");
            //fn ND_CAS() => {
            //    c.add_type(node.cas_addr);
            //    c.add_type(node.cas_old);
            //    c.add_type(node.cas_new);
            //    if(node.cas_addr.ty.kind != .TY_PTR, => @error_tok(c, node.cas_addr.tok, "pointer expected"));
            //    if(node.cas_old.ty.kind  != .TY_PTR, => @error_tok(c, node.cas_old.tok, "pointer expected"));
            //    ty_bool
            //}
            //fn ND_EXCH() => {
            //    if(node.lhs.ty.kind != .TY_PTR, => @error_tok(c, node.cas_addr.tok, "pointer expected"));
            //    node.lhs.ty.base
            //}
            @default => return();
        });
    };
}

fn add_type(c: *Ctx, k: CC.NodeKind, lhs: **CC.Node, rhs: **CC.Node) *CC.CType = {
    if lhs.ty.is_null() {
        @error_tok(c, lhs.tok, "unknown type for left of %", k);
    };
    if rhs.ty.is_null() {
        @error_tok(c, rhs.tok, "unknown type for right of %", k);
    };
@if_else {
    @if(@is(k, .ND_ADD, .ND_SUB, .ND_MUL, .ND_DIV, .ND_MOD, .ND_BITAND, .ND_BITOR, .ND_BITXOR)) => {
        c.usual_arith_conv(lhs, rhs);
        lhs.ty
    };
    @if(@is(k, .ND_EQ, .ND_NE, .ND_LT, .ND_LE)) => {
        c.usual_arith_conv(lhs, rhs);
        ty_int
    };
    @if(@is(k, .ND_NOT, .ND_LOGOR, .ND_LOGAND)) => ty_int;
    @if(@is(k, .ND_BITNOT, .ND_SHL, .ND_SHR))   => lhs.ty;
    @else => (@match(k) {
        fn ND_NUM()     => ty_int;
        fn ND_COMMA()   => rhs.ty;
        fn ND_NEG() => {
            ty := c.get_common_type(ty_int, lhs.ty);
            lhs[] = c.new_cast(lhs[], ty);
            ty
        }
        fn ND_ASSIGN() => {
            if(lhs.ty.kind == .TY_ARRAY, => @error_tok(c, lhs.tok, "not an lvalue"));
            if lhs.ty.kind != .TY_STRUCT {
                rhs[] = c.new_cast(rhs[], lhs.ty);
            };
            lhs.ty
        }
        fn ND_COND() => if lhs.ty.kind == .TY_VOID || rhs.ty.kind == .TY_VOID {
            ty_void
        } else {
            c.usual_arith_conv(lhs, rhs);
            lhs.ty
        };
        @default => panic("unhandled expression kind in new add_type");
    });
}
}

fn copy_struct_type(c: *Ctx, ty: *CC.CType) *CC.CType = {
    ty = c.copy_type(ty);

    head := CC.Member.zeroed();
    cur  := head&;
    mem  := ty.members;
    for_linked mem { mem |
        m := c.arena.box_zeroed(CC.Member);
        m[] = mem[];
        cur.next = m;
        cur = cur.next;
    };

    ty.members = head.next;
    ty
}

CPrimType :: @enum(B, I8, I16, I32, I64, U8, U16, U32, U64, F32, F64); // , F80);

fn get_type_id(ty: *CC.CType) CPrimType = @match(ty.kind) {
    fn TY_BOOL()  => .B;
    fn TY_CHAR()  => @if(ty.is_unsigned,  .U8,  .I8);
    fn TY_SHORT() => @if(ty.is_unsigned, .U16, .I16);
    fn TY_INT()   => @if(ty.is_unsigned, .U32, .I32);
    fn TY_LONG()  => @if(ty.is_unsigned, .U64, .I64);
    fn TY_FLOAT()   => .F32;
    fn TY_DOUBLE()  => .F64;
    fn TY_LDOUBLE() => .F64;  // nothing special. spec says it can be the same as double. 
    @default => .U64;  // TODO: assert it's not a struct or something insane 
};

fn cls(ty: *CC.CType) Qbe.Cls = {
    if(@is(ty.kind, .TY_STRUCT, .TY_UNION),   => return(.Kl)); // ehhh
    if(@is(ty.kind, .TY_DOUBLE, .TY_LDOUBLE), => return(.Kd));
    if(ty.kind == .TY_FLOAT,                  => return(.Ks));
    if(ty.size == 8 || ty.kind == .TY_ARRAY || ty.kind == .TY_VLA,  => return(.Kl));  // array decays to pointer
    .Kw
}

fn ir_index(c: *Ctx, ty: *CC.CType) i32 = {
    if(ty.ir_index != -1 || !@is(ty.kind, .TY_STRUCT, .TY_UNION), => return(ty.ir_index));
    type_info := Qbe.Typ.zeroed();
    type_info.fields = new_long_life(c.m, 0);
    len := 0;
    out := type_info.fields&;
    @if(TRACK_IR_NAMES) {
        l := fixed_list(type_info.name&.items());
        name := ty.name.str();
        @fmt(l&, "%", name.slice(0, min(80, name.len)));
    };
    @match(ty.kind) {
        fn TY_STRUCT() => {
            type_info.nunion = 1;
            off := 0;
            mem := ty.members;
            for_linked mem { mem | 
                add_padding(out, len&, off&, mem.offset.intcast());
                c.push_as_fields(mem.ty, out, len&);
            };
            add_padding(out, len&, off&, ty.size.intcast());
            push(out, len&, (type = .FEnd, len = 0));
        }
        fn TY_UNION() => {
            mem := ty.members;
            type_info.is_union = true;
            for_linked mem { mem | 
                c.push_as_fields(mem.ty, out, len&);
                push(out, len&, (type = .FEnd, len = 0));
                type_info.nunion += 1;
            };
        }
        @default => unreachable();
    };
    type_info.size = ty.size.intcast();
    type_info.align_log2 = (@as(i64) ty.align.zext()).trailing_zeros().intcast();
    ty.ir_index = c.m.new_type(type_info).intcast();
    ty.ir_index
}

fn push_as_fields(c: *Ctx, ty: *CC.CType, out: *QList(Qbe.Field), len: *i64) void = {
    @debug_assert_ne(ty.kind, .TY_VLA, "cannot have vla in a struct");
    if ty.kind == .TY_ARRAY {
        if(ty.is_flexible, => return());
        // TODO: could be more efficient with nested arrays by making an ir_index
        //       here too, it just gets confusing because you'd need to carefully not use that when passing by value. 
        range(0, ty.array_len.intcast()) { _ |
            c.push_as_fields(ty.base, out, len);
        };
        return();
    };
    if @is(ty.kind, .TY_STRUCT, .TY_UNION) {
        push(out, len, (type = .FTyp, len = c.ir_index(ty).bitcast()));
        return();
    };
    tag: Qbe.FieldType = @match(ty.kind) {
        fn TY_FLOAT()   => .Fs;
        fn TY_DOUBLE()  => .Fd;
        fn TY_LDOUBLE() => .Fd;
        @default => {
            @switch(ty.size) {
                @case(1) => .Fb;
                @case(2) => .Fh;
                @case(4) => .Fw;
                @case(8) => .Fl;
                @default => panic("invalid size for primitive in push_fields");
            }
        };
    };
    push(out, len, (type = tag, len = ty.size.bitcast()));
}