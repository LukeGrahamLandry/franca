/*********************
*   Parser Helpers   *
**********************/

fn str(tok: *CC.Token) Str = 
    (ptr = tok.loc.ptr, len = tok.len.intcast());

// Consumes the current token if it matches `op`.
fn consume(rest: **CC.Token, tok: *CC.Token, $str: Str) bool #inline = {
    b := equal(tok, str);
    ::if(@type tok);
    rest[] = if(b, => tok.next, => tok);
    b
}

fn equal(tok: *CC.Token, $op: Str) bool #inline = 
    @inline_match(@static(?TokenKind) TokenKind.from_name(op)) {  // TODO: make @inline_match work on values
        fn Some(kind) => tok.kind == kind[];
        fn None() => tok.str() == op;
    };

// Ensure that the current token is `op`.
fn skip(c: *Ctx, tok: *CC.Token, $op: Str) *CC.Token #inline = {
    if !equal(tok, op) {
        @error_tok(c, tok, "expected %", op);
    };
    tok.next
}

fn consume_end(tok: **CC.Token, $end: Str) bool #inline = {
    if equal(tok[], end) {
        tok[] = tok.next;
        return(true);
    };
    if equal(tok[], ",") && equal(tok.next, end) {
        tok[] = tok.next.next;
        return(true);
    };
    false
}

//error_tok :: fn(tok: *CC.Token, fmt: CStr) Never #import("chibicc") #c_variadic;

fn error_tok(ee: FatExpr) FatExpr #macro = {
    e := ee&.items();
    @ct_assert(e.len >= 3, ee.loc, "@error_tok expected (*Ctx, *Token, \"msg\", ...)");
    c, tok := (e[0], e[1]);
    @{
        c := @[c];
        out := c.error_buf&;
        fmt_error_prefix(@[tok], out);
        @[format_into(@{ out }, e.rest(2), ee.loc)];
        throw(c.a_little_hidden_control_flow&)
    }
}

// Reports an error message in the following format.
//
// foo.c:10: x = y + 1;
//               ^ <error message here>
fn fmt_error_prefix(tok: *CC.Token, msg: *List(u8)) void = {
    // Find a line containing `loc`.
    line := tok.loc;
    while => ptr_diff(tok.file.contents.ptr, line.ptr) > 0 && line.ptr.offset(-1)[] != "\n".ascii() {  // TODO: make sure this is safe
        line.ptr = line.ptr.offset(-1);
    };
    end := tok.loc;
    while => end.ptr[] != 0 && end.ptr[] != "\n".ascii() {
        end.ptr = end.ptr.offset(1);
    };
    
    // Print out the line.
    start := msg.len;
    col_no := ptr_diff(line.ptr, tok.loc.ptr);
    @fmt(msg, "%:%:%: ", tok.file.name, tok.line_no, col_no + 1);
    pos := msg.len - start + col_no;  // TODO: handle unicode variable width stuff. for now just aligning by byte length. 
    line_str: Str = (ptr = line.ptr, len = ptr_diff(line.ptr, end.ptr));
    ::FmtPad(Str);
    @fmt(msg, "%\n%^ ", line_str, f_pad("", pos, .Before)); 
    
    // Then the caller prints the error message
}

TokenKind :: @enum(i32) (
    TK_IDENT,   // Identifiers
    TK_PUNCT,   // Punctuators
    TK_KEYWORD, // Keywords
    TK_STR,     // String literals
    TK_NUM,     // Numeric literals
    TK_PP_NUM,  // Preprocessing numbers
    TK_EOF,     // End-of-file markers
    
    // TK_KEYWORD and TK_PUNCT get converted to one of these:
    
    return,    if,         else,
    for,       while,      __attribute__,
    case,      default,    do,
    sizeof,    asm,        _Alignof,
    break,     continue,   switch,
    // start is_type_name
    short,     inline,     long,
    void,      typedef,    _Bool,
    enum,      static,     union,
    struct,    _Alignas,   extern,
    signed,    unsigned,   const,
    volatile,  auto,       register,
    restrict,  __restrict, __restrict__,
    _Noreturn, float,      double,
    typeof,    char,       _Thread_local,
    __thread,  _Atomic,    int,
    // end is_type_name
    goto,     _Generic,
    
    @"...", @".", @",", @"(", @")", @":", @"?", @"{", @"}", @";",
    @"<<=", @">>=", @"...", @"==", @"!=", @"<=", @">=", @"->", @"+=", @"-=", @"*=", @"/=",
    @"++",  @"--",  @"%=",  @"&=", @"|=", @"^=", @"&&", @"||", @"<<", @">>", @"##",
    @"=", @"!", @"<", @">", @"-", @"+", @"*", @"/",
    @"%",  @"&", @"|", @"^", @"#", @"[", @"]", @"~",
); 
