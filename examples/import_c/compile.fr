// Adapted from chibicc. MIT License. Copyright (c) 2019 Rui Ueyama

// TODO: i don't understand why assign for a _Atomic doesn't have to do something to flush the cacheline. 
// TODO: https://github.com/rui314/chibicc/issues/
//      #153 #141 #138 #110 #107 #99 #86 #84 more...
//      - https://github.com/fuhsnn/slimcc/issues?q=is%3Aissue+is%3Aclosed+label%3Aupstream-chibicc&page=2
//      _Static_assert (tho maybe C23 wants to get rid of it)
// _Alignas needs more backend support
// TODO: unary const expr

// TODO: want to let all the state (like Qbe.Fn) be allocated in Ctx.arena
//       so you can do all the c frontend stuff up front (because you kinda need 
//       to do preprocessor stuff in order) but defer actually compiling it until 
//       the function gets called (and still use temp() as scratch space). ie. a 
//       franca program using a c library should get dead code elimination the same 
//       as it would using a franca library. 

#use(CC);

// Scope for local variables, global variables, typedefs
// or enum constants
VarScope :: @struct {
    var: *Obj;
    type_def: *CType;
    enum_ty: *CType;
    enum_val: i64;
};

// Represents a block scope.
Scope :: @rec @struct {
    next: *Scope;

    // C has two block scopes; one is for variables/typedefs and
    // the other is for struct/union/enum tags.
    vars: HashMap(Str, *VarScope);
    tags: HashMap(Str, *CType);
};

// Variable attributes such as typedef or extern.
VarAttr :: @struct {
    is_typedef: bool;
    is_static:  bool;
    is_extern:  bool;
    is_inline:  bool;
    is_tls:     bool;
    align:       i32;
};

// This struct represents a variable initializer. Since initializers
// can be nested (e.g. `int x[2][2] = {{1, 2}, {3, 4}}`), this struct
// is a tree data structure.
Initializer :: @rec @struct {
    next: *Initializer;
    ty: *CType;
    tok: *Token;
    is_flexible: bool;

    // If it's not an aggregate type and has an initializer,
    // `expr` has an initialization expression.
    expr: *Node;

    // If it's an initializer for an aggregate type (e.g. array or struct),
    // `children` has initializers for its children.
    children: []*Initializer;

    // Only one member can be initialized for a union.
    // `mem` is used to clarify which member is initialized.
    mem: *Member;
};

// For local variable initializer.
InitDesg :: @rec @struct {
    next: *InitDesg;
    idx: i64;
    member: *Member;
    var: *Obj;
};

#use(Preprocess);

Ctx :: @rec @struct {
    // All local variable instances created during parsing are
    // accumulated to this list.
    locals: *Obj;
    
    // Likewise, global variables are accumulated to this list.
    globals: *Obj;
    
    scope: *Scope;
    
    // Points to the function object the parser is currently parsing.
    current_fn: ?*Obj;
    
    m: *QbeModule;
    f: *Qbe.Fn;
    b: *Qbe.Blk;
    
    labels: HashMap(Str, *Qbe.Blk);
    brk_label: ?*Qbe.Blk;
    cont_label: ?*Qbe.Blk;
    
    // Points to a node representing a switch if we are parsing
    // a switch statement.
    current_switch: ?*Qbe.SwitchPayload;
    
    builtin_alloca: *Obj;
    
    arena: Alloc;
    next_var_id: i64;
    
    // I'm probably going to regret this. 
    error_buf: List(u8);
    a_little_hidden_control_flow: JumpBuf;
    
    speculate: bool; // hack
    
    /// Tokenize
    current_file: *File;
    at_bol: bool;  // True if the current position is at the beginning of a line
    has_space: bool;  // True if the current position follows a space character
    
    /// Preprocess
    macros: HashMap(Str, *Macro);
    cond_incl: ?*CondIncl;
    pragma_once: HashMap(Str, void);
    include_guards: HashMap(Str, Str);  // path -> guard name
    include_next_idx: i64;
    counter_macro_next_id: i64;
    macro_time: BigTime;  // for __TIME__ and __DATE__, you can set this to something specific for reproducible builds. 
    filename_cache: HashMap(Str, Str);
    include_paths: List(Str);
    macro_base_file: Str;
};

fn align_down(n: i64, align: i64) i64 = 
    align_to(n - align + 1, align);

:: {
    assert_eq(align_to(5, 8), 8);
    assert_eq(align_to(11, 8), 16);
    assert_eq(align_to(-1, 8), 0);
};

fn enter_scope(c: *Ctx) void = {
    sc := temp().box_zeroed(Scope);
    sc.next = c.scope;
    sc.vars = init(c.arena);
    sc.tags = init(c.arena);
    c.scope = sc;
}

fn leave_scope(c: *Ctx) void = {
    c.scope = c.scope.next;
}

// Find a variable by name.
fn find_var(c: *Ctx, tok: *Token) ?*VarScope = {
    sc := c.scope;
    for_linked sc { sc |
        if sc.vars&.get(tok.str()) { sc2 |
            return(Some = sc2);
        };
    };
    .None
}

fn find_tag(c: *Ctx, tok: *Token) ?*CType = {
    sc := c.scope;
    for_linked sc { sc |
        if sc.tags&.get(tok.str()) { ty |
            return(Some = ty);
        };  
    };
    .None
}

fn push_scope(c: *Ctx, name: Str) *VarScope = {
    ::ptr_utils(Scope);
    @debug_assert(!c.scope.is_null(), "uninit Ctx.scope");
    sc := temp().box_zeroed(VarScope);
    insert(c.scope.vars&, name, sc);
    sc
}

fn new_node(c: *Ctx, kind: NodeKind, tok: *Token) *Node = {
    node := temp().box_zeroed(Node);
    node.kind = kind;
    node.tok = tok;
    node.current_block = c.b;
    node
}

fn new_binary(c: *Ctx, kind: NodeKind, lhs: *Node, rhs: *Node, tok: *Token) *Node = {
    node := c.new_node(kind, tok);
    node.lhs = lhs;
    node.rhs = rhs;
    node
}

fn new_deref(c: *Ctx, expr: *Node, tok: *Token) *Node = {
    node := c.new_node(.ND_DEREF, tok);
    node.lhs = expr;
    node.lvalue = expr.r;
    
    // :CInferType
    c.add_type(node.lhs);
    if(node.lhs.ty.base.is_null(),        => @error_tok(c, node.tok, "invalid pointer dereference"));
    if(node.lhs.ty.base.kind == .TY_VOID, => @error_tok(c, node.tok, "dereferencing a void pointer"));
    node.ty = node.lhs.ty.base;
    
    c.gen_expr(node);  // TODO: extra loads in &*&*&*& chains
    node
}

fn new_addr(c: *Ctx, expr: *Node, tok: *Token) *Node #once = {
    node := c.new_node(.ND_ADDR, tok);
    node.lhs = expr;
    c.gen_addr(expr);
    node.r = expr.lvalue;
    
    // :CInferType
    ty := node.lhs.ty;
    node.ty = c.pointer_to(if(ty.kind == .TY_ARRAY, => ty.base, => ty));
    
    c.gen_expr(node);
    node
}

fn new_unary(c: *Ctx, kind: NodeKind, expr: *Node, tok: *Token) *Node = {
    node := c.new_node(kind, tok);
    node.lhs = expr;
    node
}

fn new_num(c: *Ctx, val: i64, tok: *Token, ty: *CType) *Node = {
    node := c.new_node(.ND_NUM, tok);
    node.ty = ty;
    if !c.f.is_null() {
        node.r = c.f.getcon(val);
    };
    node
}

fn new_num(c: *Ctx, val: i64, tok: *Token) *Node = 
    c.new_num(val, tok, ty_int);

fn new_long(c: *Ctx, val: i64, tok: *Token) *Node = 
    c.new_num(val, tok, ty_long);

fn new_ulong(c: *Ctx, val: i64, tok: *Token) *Node = 
    c.new_num(val, tok, ty_ulong);

fn new_var_node(c: *Ctx, var: *Obj, tok: *Token) *Node = {
    node := c.new_node(.ND_VAR, tok);
    node.var = var;
    node.ty = var.ty;
    
    if var.global_symbol { id |
        node.lvalue = c.f.symcon(id);
    };
    
    if !c.speculate && !node.var.is_function {
        node.lvalue = c.gen_addr(node);
        if var.ty.kind == .TY_ARRAY {
            // arrays decay to pointers: `array` === `&array` === `&array[0]`
            node.r = node.lvalue;
        };
    };
    
    node
}

fn new_vla_ptr(c: *Ctx, var: *Obj, tok: *Token) *Node = {
    node := c.new_node(.ND_VLA_PTR, tok);
    node.var = var;
    node.ty = var.ty;
    node
}

fn new_cast(c: *Ctx, expr: *Node, ty: *CType) *Node = {
    c.add_type(expr);
    if(expr.ty.identical(ty), => return(expr));
    
    node := temp().box_zeroed(Node);
    node.kind = .ND_CAST;
    node.tok = expr.tok;
    node.lhs = expr;
    node.ty = c.copy_type(ty);
    node.current_block = expr.current_block; // HACK: this is super confusing, hopefully it will go away with asts
    
    //node.lvalue = expr.lvalue;  // :FrontendConstantFolding, TODO: but this is wrong, we're assuming its a noop cast but what if its a truncation
    c.gen_expr(node);
    node
}

fn new_initializer(c: *Ctx, ty: *CType, is_flexible: bool) *Initializer = {
    init := temp().box_zeroed(Initializer);
    init.ty = ty;

    if ty.kind == .TY_ARRAY {
        if is_flexible && ty.size < 0 {
            init.is_flexible = true;
            return(init);
        };

        init.children = temp().alloc(*Initializer, ty.array_len.intcast());
        each init.children { it |
            it[] = c.new_initializer(ty.base, false);
        };
    };

    if ty.kind == .TY_STRUCT || ty.kind == .TY_UNION {
        // Count the number of struct members.
        len := 0;
        mem := ty.members;
        for_linked mem { mem |
            len += 1;
        };
        init.children = temp().alloc(*Initializer, len);

        for_linked mem { mem |
            ::if(*Initializer);
            init.children[mem.idx.intcast()] = 
                if is_flexible && ty.is_flexible && mem.next.is_null() {
                    child := temp().box_zeroed(Initializer);
                    child.ty = mem.ty;
                    child.is_flexible = true;
                    child
                } else {
                    c.new_initializer(mem.ty, false)
                };
        };
    };

    init
}

fn new_var(c: *Ctx, name: Str, ty: *CType) *Obj = {
    var := temp().box_zeroed(Obj);
    var.name = name.slow_convert_to_c_string();
    var.ty = ty;
    var.align = ty.align;
    var.global_symbol = .None;
    c.push_scope(name)[].var = var;
    
    var
}

fn new_lvar(c: *Ctx, name: Str, ty: *CType) *Obj = {
    var := c.new_var(name, ty);
    var.is_local = true;
    var.next = c.locals;
    c.locals = var;

    if c.current_fn { current_fn |
        if var.ty.size >= 0 {  // :StaticArrayOfUnknownLength
            if !c.f.start.is_null() {  // HACK: fix create_params_lvars instead of having an insane ordering where we delay making the start block so this knows to delay making variables for no reason
                c.create_stack_slot(var);
            };
        };
    };
    
    var
}

// fixed size allocs always go in the start block so they can be fast-locals. 
fn create_stack_slot(c: *Ctx, var: *Obj) void = {
    // :ZeroSizeTypes chibicc has empty structs with sizeof(0) but thats an extension
    // what if you tried to diy static_assert with that, now we broke your code?
    if var.ty.size < 0 {
        @error_tok(c, var.tok, "tried to create stack slot for a variable with negative size (%)", var.ty.size);
    };
    if var.stack_slot == QbeNull {
        var.stack_slot = c.f.newtmp(var.name.str(), .Kl);
    };
    push(c.f.start, make_ins(.alloc8, .Kl, var.stack_slot, c.f.getcon(var.ty.size.intcast()), QbeNull));  // TODO: smaller align stack slots
}

fn new_gvar(c: *Ctx, name: Str, ty: *CType) *Obj = {
    var := c.new_var(name, ty);
    var.next = c.globals;
    var.is_static = true;
    var.is_definition = true;
    var.global_symbol = (Some = c.m.mangle(var));
    c.globals = var;
    var
}

fn new_unique_name(c: *Ctx) Str = {
    s := @tfmt(".L..%", c.next_var_id);  // TODO: c.arena?
    c.next_var_id += 1;
    s
}

fn new_anon_gvar(c: *Ctx, ty: *CType) *Obj = 
    c.new_gvar(c.new_unique_name(), ty);

fn new_string_literal(c: *Ctx, p: []u8, ty: *CType) *Obj = {
    var := c.new_anon_gvar(ty);
    var.init_data = p;
    var.init_data_needs_null_terminator = true;
    var
}

fn get_ident(c: *Ctx, tok: *Token) Str = {
    if tok.kind != .TK_IDENT {
        @error_tok(c, tok, "expected an identifier");
    };
    tok.str()  // TODO: make sure we never mutate this (its not a copy!)
}

fn find_typedef(c: *Ctx, tok: *Token) ?*CType = {
    if tok.kind == .TK_IDENT {
        if c.find_var(tok) { sc |
            if !sc.type_def.is_null() {
                return(Some = sc.type_def);
            };
        };
    };
    .None
}

fn push_tag_scope(c: *Ctx, tok: *Token, ty: *CType) void = {
    c.scope.tags&.insert(tok.str(), ty);
}

// declspec = ("void" | "_Bool" | "char" | "short" | "int" | "long"
//                         | "typedef" | "static" | "extern" | "inline"
//                         | "_Thread_local" | "__thread"
//                         | "signed" | "unsigned"
//                         | struct-decl | union-decl | typedef-name
//                         | enum-specifier | typeof-specifier
//                         | "const" | "volatile" | "auto" | "register" | "restrict"
//                         | "__restrict" | "__restrict__" | "_Noreturn")+
//
// The order of typenames in a type-specifier doesn't matter. For
// example, `int long static` means the same as `static long int`.
// That can also be written as `static long` because you can omit
// `int` if `long` or `short` are specified. However, something like
// `char int` is not a valid type specifier. We have to accept only a
// limited combinations of the typenames.
//
// In this function, we count the number of occurrences of each typename
// while keeping the "current" type object that the typenames up
// until that point represent. When we reach a non-typename token,
// we return the current type object.
fn declspec(c: *Ctx, rest: **Token, tok: *Token, attr: ?*VarAttr) *CType = {
    // We use a single integer as counters for all typenames.
    // For example, bits 0 and 1 represents how many times we saw the
    // keyword "void" so far. With this, we can use a switch statement
    // as you can see below.
    S :: @enum(i64) (
        void     = 0,
        _Bool    = 2,
        char     = 4,
        short    = 6,
        int      = 8,
        long     = 10,
        float    = 12,
        double   = 14,
        // other = 16,
        signed   = 17,
        unsigned = 18,
    );  :: enum(S);
    Specifier_Other :: 16;
    
    ty        := ty_int;
    counter   := 0;
    is_atomic := false;

    if true {
        break :: local_return;
        while => c.is_type_name(tok) {
            continue :: local_return;
            
            // Handle storage class specifiers.
            if @is(tok.kind, .typedef, .static, .extern, .inline, ._Thread_local, .__thread) {
                attr := attr || @error_tok(c, tok, "storage class specifier is not allowed in this context");
                field := @match(tok.kind) {
                    fn typedef() => attr.is_typedef&;
                    fn static()  => attr.is_static&;
                    fn extern()  => attr.is_extern&;
                    fn inline()  => attr.is_inline&;
                    @default     => attr.is_tls&;
                };
                field[] = true;
    
                disallow_typedef := attr.is_static || attr.is_extern || attr.is_inline || attr.is_tls;
                if attr.is_typedef && disallow_typedef {
                    @error_tok(c, tok, "typedef may not be used together with static, extern, inline, __thread or _Thread_local");
                };
                tok = tok.next;
                continue();
            };
    
            // These keywords are recognized but ignored.
            !ignore(tok&, tok, @const_slice(
                "const", "volatile", "auto", "register", "restrict", "__restrict", "__restrict__", "_Noreturn", 
            )) || continue();
            
            if equal(tok, "_Atomic") {
                tok = tok.next;
                if (equal(tok , "(")) {
                    ty = c.typename(tok&, tok.next);
                    tok = c.skip(tok, ")");
                };
                is_atomic = true;
                continue();
            };
    
            if (equal(tok, "_Alignas")) {
                attr := attr || @error_tok(c, tok, "_Alignas is not allowed in this context");
                tok = c.skip(tok.next, "(");
    
                attr.align = if c.is_type_name(tok) {
                    c.typename(tok&, tok)[].align
                } else {
                    c.const_expr(tok&, tok).intcast()
                };
                tok = c.skip(tok, ")");
                continue();
            };
    
            // Handle user-defined types.
            ty2 := c.find_typedef(tok);
            if (equal(tok, "struct") || equal(tok, "union") || equal(tok, "enum") ||
                    equal(tok, "typeof") || ty2.is_some()) {
                if(counter != 0, => break());
    
                ty = @match(tok.kind) {
                    fn struct() => c.struct_decl(tok&, tok.next);
                    fn union()  => c.union_decl(tok&, tok.next);
                    fn enum()   => c.enum_specifier(tok&, tok.next);
                    fn typeof() => c.typeof_specifier(tok&, tok.next);
                    @default    => {
                        tok = tok.next;
                        ty2.unwrap()
                    };
                };
    
                counter += 1.shift_left(Specifier_Other);
                continue();
            };
    
            // Handle built-in types.
            inline_for_enum S { $s |
                if equal(tok, s[].name_str()) {
                    if (:: @is(s[], .signed, .unsigned)) {
                        counter = counter.bit_or(:: 1.shift_left(s[].raw()));
                    } else {
                        counter += :: 1.shift_left(s[].raw());
                    };
                };
            };
            
            SS :: fn(e: FatExpr) FatExpr #macro = {
                i := 0;
                each e&.items() { e |
                    i += 1.shift_left(const_eval(S)(e[]).raw());
                };
                @literal i
            };
            
            ty = @switch(counter) {
                @case(@SS(.void))  => ty_void;
                @case(@SS(._Bool)) => ty_bool;
                @case(@SS(.char))          => ty_char;
                @case(@SS(.signed, .char)) => ty_char;
                @case(@SS(.unsigned, .char)) => ty_uchar;
                @case(@SS(.short))                => ty_short;
                @case(@SS(.short, .int))          => ty_short;
                @case(@SS(.short, .signed))       => ty_short;
                @case(@SS(.short, .signed, .int)) => ty_short;
                @case(@SS(.short, .unsigned))       => ty_ushort;
                @case(@SS(.short, .unsigned, .int)) => ty_ushort;
                @case(@SS(.int))          => ty_int;
                @case(@SS(.signed))       => ty_int;
                @case(@SS(.signed, .int)) => ty_int;
                @case(@SS(.unsigned))       => ty_uint;
                @case(@SS(.unsigned, .int)) => ty_uint;
                @case(@SS(.long))                       => ty_long;
                @case(@SS(.long, .int))                 => ty_long;
                @case(@SS(.long, .long))                => ty_long;
                @case(@SS(.long, .long, .int))          => ty_long;
                @case(@SS(.signed, .long))              => ty_long;
                @case(@SS(.signed, .long, .int))        => ty_long;
                @case(@SS(.signed, .long, .long))       => ty_long;
                @case(@SS(.signed, .long, .long, .int)) => ty_long;
                @case(@SS(.unsigned, .long))              => ty_ulong;
                @case(@SS(.unsigned, .long, .int))        => ty_ulong;
                @case(@SS(.unsigned, .long, .long))       => ty_ulong;
                @case(@SS(.unsigned, .long, .long, .int)) => ty_ulong;
                @case(@SS(.float)) => ty_float;
                @case(@SS(.double))        => ty_double;
                @case(@SS(.double, .long)) => ty_double;  // the spec says this is at least as precise as double, so there you go. 
                @default => @error_tok(c, tok, "invalid type");
            };
            tok = tok.next;
        };
    };

    if is_atomic {
        ty = c.copy_type(ty);
        ty.is_atomic = true;
    };

    rest[] = tok;
    ty
}

// func-params = ("void" | param ("," param)* ("," "...")?)? ")"
// param             = declspec declarator
fn func_params(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType = {
    if equal(tok, "void") && equal(tok.next, ")") {
        rest[] = tok.next.next;
        return(c.func_type(ty));
    };

    head := CType.zeroed();
    cur  := head&;
    is_variadic := false;

    if true {
        break :: local_return;
        while => !equal(tok, ")") {
            if !cur.identical(head&) {
                tok = c.skip(tok, ",");
            };
    
            if equal(tok, "...") {
                is_variadic = true;
                tok = tok.next;
                c.skip(tok, ")");
                break();
            };
    
            ty2 := c.declspec(tok&, tok, .None);
            ty2  = c.declarator(tok&, tok, ty2);
    
            name := ty2.name;
            @match(ty2.kind) {
                // "array of T" is converted to "pointer to T" only in the parameter
                // context. For example, *argv[] is converted to **argv by this.
                fn TY_ARRAY() => { 
                    ty2 = c.pointer_to(ty2.base);
                    ty2.name = name;
                }
                // Likewise, a function is converted to a pointer to a function
                // only in the parameter context.
                fn TY_FUNC() => {
                    ty2 = c.pointer_to(ty2);
                    ty2.name = name;
                }
                @default => ();
            };
            t := c.copy_type(ty2);
            cur.next = t;
            cur = t;
        };
    };

    if cur.identical(head&) {
        is_variadic = true;
    };

    ty = c.func_type(ty);
    ty.params = head.next;
    ty.is_variadic = is_variadic;
    rest[] = tok.next;
    ty
}

// array-dimensions = ("static" | "restrict")* const-expr? "]" type-suffix
fn array_dimensions(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType #once = {
    dowhile {
        ignore(tok&, tok, @const_slice("static", "restrict"))
    };

    if equal(tok, "]") {
        ty = c.type_suffix(rest, tok.next, ty);
        // :StaticArrayOfUnknownLength
        // We don't know the length of the array until we parse the initializer list. 
        // Which is painful because we want to make the var at the beginning but now need to defer creating a stack slot for it. 
        // Should communicate this in a more clear way than just randomly having some sizes be negative. 
        return(c.array_of(ty, -1));  
    };

    expr := c.parse_expr(tok&, tok, .Conditional);
    tok   = c.skip(tok, "]");
    ty    = c.type_suffix(rest, tok, ty);

    if ty.kind == .TY_VLA || !c.is_const_expr(expr) {
        c.vla_of(ty, expr)
    } else {
        // :ZeroSizeTypes
        length := c.eval(expr);
        if length < 0 {
            @error_tok(c, tok, "array length cannot be negative");
        };
        c.array_of(ty, length)
    }
}

// type-suffix = "(" func-params
//                         | "[" array-dimensions
//                         | Îµ
fn type_suffix(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType = {
    if(equal(tok, "("), => return(c.func_params(rest, tok.next, ty)));
    if(equal(tok, "["), => return(c.array_dimensions(rest, tok.next, ty)));
    rest[] = tok;
    ty
}

// pointers = ("*" ("const" | "volatile" | "restrict")*)*
fn pointers(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType = {
    while => consume(tok&, tok, "*") {
        ty = c.pointer_to(ty);
        dowhile {
            ignore(tok&, tok, @const_slice("const", "volatile", "restrict", "__restrict", "__restrict__"))
        };
    };
    rest[] = tok;
    ty
}

fn ignore(rest: **Token, tok: *Token, $ignored: []Str) bool #inline = {
    inline_for ignored { $kw |
        if(consume(rest, tok, ::kw[]), => return(true));
    };
    false
}

// declarator = pointers ("(" ident ")" | "(" declarator ")" | ident) type-suffix
fn declarator(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType = {
    ty = c.pointers(tok&, tok, ty);

    if equal(tok, "(") {
        start := tok;
        dummy := CType.zeroed();
        c.declarator(tok&, start.next, dummy&);
        tok = c.skip(tok, ")");
        ty = c.type_suffix(rest, tok, ty);
        return(c.declarator(tok&, start.next, ty));
    };

    name := Token.ptr_from_int(0);
    name_pos := tok;

    if tok.kind == .TK_IDENT {
        name = tok;
        tok = tok.next;
    };

    ty = c.type_suffix(rest, tok, ty);
    ty.name = name;
    ty.name_pos = name_pos;
    ty
}

// abstract-declarator = pointers ("(" abstract-declarator ")")? type-suffix
fn abstract_declarator(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *CType = {
    ty = c.pointers(tok&, tok, ty);
    if equal(tok, "(") {
        start := tok;
        dummy := CType.zeroed();
        c.abstract_declarator(tok&, start.next, dummy&);
        tok = c.skip(tok, ")");
        ty  = c.type_suffix(rest, tok, ty);
        c.abstract_declarator(tok&, start.next, ty)
    } else {
        c.type_suffix(rest, tok, ty)
    }
}

// type-name = declspec abstract-declarator
fn typename(c: *Ctx, rest: **Token, tok: *Token) *CType = {
    ty := c.declspec(tok&, tok, .None);
    c.abstract_declarator(rest, tok, ty)
}

fn is_end(tok: *Token) bool = 
    equal(tok, "}") || (equal(tok, ",") && equal(tok.next, "}"));

// enum-specifier = ident? "{" enum-list? "}"
//                                | ident ("{" enum-list? "}")?
//
// enum-list            = ident ("=" num)? ("," ident ("=" num)?)* ","?
fn enum_specifier(c: *Ctx, rest: **Token, tok: *Token) *CType #once = {
    ty := c.enum_type();

    // Read a struct tag.
    tag: ?*Token = .None;
    if tok.kind == .TK_IDENT {
        tag = (Some = tok);
        tok = tok.next;
    };

    if tag { tag |
        if !equal(tok, "{") {
            ty := c.find_tag(tag) || @error_tok(c, tag, "unknown enum type");
            if(ty.kind != .TY_ENUM, => @error_tok(c, tag, "not an enum tag"));
            rest[] = tok;
            return(ty);
        };
    };

    tok = c.skip(tok, "{");

    // Read an enum-list.
    val := 0;
    comma_sep(c, tok&, "}") {
        name := c.get_ident(tok);
        tok = tok.next;

        if equal(tok, "=") {
            val = c.const_expr(tok&, tok.next);
        };

        sc := c.push_scope(name);
        sc.enum_ty = ty;
        sc.enum_val = val;
        val += 1;
    };
    rest[] = tok;

    if tag { tag |
        c.push_tag_scope(tag, ty);
    };
    ty
}

// typeof-specifier = "(" (expr | typename) ")"
fn typeof_specifier(c: *Ctx, rest: **Token, tok: *Token) *CType #once = {
    tok = c.skip(tok, "(");
    ty := if c.is_type_name(tok) {
        c.typename(tok&, tok)
    } else {
        node := c.speculate(tok&, tok, .None);
        c.add_type(node);
        node.ty
    };
    rest[] = c.skip(tok, ")");
    ty
}

// Generate code for computing a VLA size.
fn compute_vla_size(c: *Ctx, ty: *CType) Qbe.Ref = {
    if(ty.vla_size != QbeNull, => return(ty.vla_size));
    if !ty.base.is_null() {
        c.compute_vla_size(ty.base);
    };

    if(ty.kind != .TY_VLA, => return(QbeNull));

    base_sz := if ty.base.kind == .TY_VLA {
       ty.base.vla_size
    } else {
       c.f.getcon(ty.base.size.intcast())
    };

    @debug_assert_ne(ty.vla_len, QbeNull, "compute_vla_size with unknown length");
    // TODO: emit this up front when the type is created because otherwise the first sizeof() might not dominate cached uses. 
    ty.vla_size = c.emit(.mul, .Kl, ty.vla_len, base_sz);
    ty.vla_size
}

// declaration = declspec (declarator ("=" expr)? ("," declarator ("=" expr)?)*)? ";"
fn declaration(c: *Ctx, tok: *Token, basety: *CType, attr: ?*VarAttr) *Token = {
    start := tok;

    comma_sep(c, tok&, ";") {
        continue :: local_return;
        ty := c.declarator(tok&, tok, basety);
        if(ty.kind == .TY_VOID, => @error_tok(c, tok, "variable declared void"));
        if ty.name.is_null() {
            @error_tok(c, ty.name_pos, "variable name omitted");
        };

        if attr { attr |
            if attr.is_static {
                // static locals are secretly globals
                var := c.new_anon_gvar(ty);
                c.push_scope(c.get_ident(ty.name))[].var = var;
                if equal(tok, "=") {
                    c.gvar_initializer(tok&, tok.next, var);
                };
                continue();
            }
        };

        // Generate code for computing a VLA size. We need to do this
        // even if ty is not VLA because ty may be a pointer to VLA
        // (e.g. int (*foo)[n][m] where n and m are variables.)
        vla_size := c.compute_vla_size(ty);

        if ty.kind == .TY_VLA {
            if(equal(tok, "="), => @error_tok(c, tok, "variable-sized object must not be initialized"));

            // Variable length arrays (VLAs) are translated to alloca() calls.
            // For example, `int x[n+2]` is translated to `tmp = n + 2,
            // x = alloca(tmp)`.
            name := c.get_ident(ty.name);
            var := c.new_lvar(name, ty);
            var.stack_slot = c.f.newtmp(name, .Kl);
            c.emit(.alloc16, .Kl, var.stack_slot, vla_size, QbeNull);
            continue();
        };
        
        var := c.new_lvar(c.get_ident(ty.name), ty);
        if attr { attr |
            if attr.align != 0 {
                var.align = attr.align;
            };
        };

        if equal(tok, "=") {
            c.lvar_initializer(tok&, tok.next, var);
        };

        if(var.ty.size < 0,         => @error_tok(c, ty.name, "variable has incomplete type"));
        if(var.ty.kind == .TY_VOID, => @error_tok(c, ty.name, "variable declared void"));
    };
    
    tok  // already ate the semicolon
}

fn skip_excess_element(c: *Ctx, tok: *Token) *Token = {
    if equal(tok, "{") {
        tok = c.skip_excess_element(tok.next);
        tok = c.skip(tok, "}");
    } else {
        c.parse_expr(tok&, tok, .Assign);
    };
    tok
}

// string-initializer = string-literal
fn string_initializer(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void #once = {
    if init.is_flexible {
        init[] = c.new_initializer(c.array_of(init.ty.base, tok.ty.array_len.intcast()), false)[];
    };

    len := min(init.ty.array_len, tok.ty.array_len);

    // TODO: this is so garbage :SLOW
    slow :: fn($T) => {
        ::ptr_utils(T);
        str := ptr_cast_unchecked(u8, T, tok.str_buf);
        range(0, len.intcast()) { i |
            init.children[i].expr = c.new_num(str.offset(i)[].int(), tok);
        };
    };
    @switch(init.ty.base.size) {
        @case(1) => slow(u8);
        @case(2) => slow(u16);
        @case(4) => slow(u32);
        @default => unreachable();
    };
    
    rest[] = tok.next;
}

// array-designator = "[" const-expr "]"
//
// C99 added the designated initializer to the language, which allows
// programmers to move the "cursor" of an initializer to any element.
// The syntax looks like this:
//
//     int x[10] = { 1, 2, [5]=3, 4, 5, 6, 7 };
//
// `[5]` moves the cursor to the 5th element, so the 5th element of x
// is set to 3. Initialization then continues forward in order, so
// 6th, 7th, 8th and 9th elements are initialized with 4, 5, 6 and 7,
// respectively. Unspecified elements (in this case, 3rd and 4th
// elements) are initialized with zero.
//
// Nesting is allowed, so the following initializer is valid:
//
//     int x[5][10] = { [5][8]=1, 2, 3 };
//
// It sets x[5][8], x[5][9] and x[6][0] to 1, 2 and 3, respectively.
//
// Use `.fieldname` to move the cursor for a struct initializer. E.g.
//
//     struct { int a, b, c; } x = { .c=5 };
//
// The above initializer sets x.c to 5.
fn array_designator(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) Ty(i64, i64) = {  // (begin, end)
    begin := c.const_expr(tok&, tok.next);
    if(begin >= ty.array_len.intcast(), => @error_tok(c, tok, "array designator index (%) exceeds array bounds (%)", begin, ty.array_len));
    
    end := begin;
    if equal(tok, "...") {
        end = c.const_expr(tok&, tok.next);
        if(end >= ty.array_len.intcast(), => @error_tok(c, tok, "array designator index exceeds array bounds"));
        if(end < begin, => @error_tok(c, tok, "array designator range [%d, %d] is empty", begin, end));
    };

    rest[] = c.skip(tok, "]");
    (begin, end)
}

// struct-designator = "." ident
fn struct_designator(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) *Member = {
    start := tok;
    tok = c.skip(tok, ".");
    if(tok.kind != .TK_IDENT, => @error_tok(c, tok, "expected a field designator"));

    mem := ty.members;
    for_linked mem { mem |
        continue :: local_return;
        is_anon := mem.ty.kind == .TY_STRUCT && mem.name.is_null();
        if is_anon {
            if get_struct_member(mem.ty, tok) { _ |
                rest[] = start;
                return(mem);
            };
            continue();
        };

        // Regular struct member
        if mem.name.str() == tok.str() {
            rest[] = tok.next;
            return(mem);
        };
    };

    @error_tok(c, tok, "struct has no such member")
}

// designation = ("[" const-expr "]" | "." ident)* "="? initializer
fn designation(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void = {
    if equal(tok, "[") {
        if(init.ty.kind != .TY_ARRAY, => @error_tok(c, tok, "array index in non-array initializer"));

        begin, end := c.array_designator(tok&, tok, init.ty);

        //tok2: *Token;  // TODO: sane error message for this!
        tok2 := Token.ptr_from_int(0);
        range(begin, end + 1) { i |
            c.designation(tok2&, tok, init.children[i]);
        };
        c.array_initializer2(rest, tok2, init, begin + 1);
        return();
    };

    @if(equal(tok, ".")) @match(init.ty.kind) {
        fn TY_STRUCT() => {
            mem := c.struct_designator(tok&, tok, init.ty);
            c.designation(tok&, tok, init.children[mem.idx.intcast()]);
            init.expr = Node.ptr_from_int(0);
            c.struct_initializer2(rest, tok, init, mem.next);
            return();
        }
        fn TY_UNION() => {
            mem := c.struct_designator(tok&, tok, init.ty);
            init.mem = mem;
            c.designation(rest, tok, init.children[mem.idx.intcast()]);
            return();
        }
        @default => @error_tok(c, tok, "field name not in struct or union initializer"); 
    };
    if equal(tok, "=") {
        tok = tok.next;
    };
    c.initializer2(rest, tok, init);
}

// TODO: parsing everything twice is gross
// An array length can be omitted if an array has an initializer
// (e.g. `int x[] = {1,2,3}`). If it's omitted, count the number
// of initializer elements.
fn count_array_init_elements(c: *Ctx, tok: *Token, ty: *CType) i64 = {
    dummy := c.new_initializer(ty.base, true);

    i, hi := (0, 0);
    
    comma_sep(c, tok&, "}") {
        if equal(tok, "[") {
            i = c.const_expr(tok&, tok.next);
            if equal(tok, "...") {
                i = c.const_expr(tok&, tok.next);
            };
            tok = c.skip(tok, "]");
            c.designation(tok&, tok, dummy);
        } else {
            c.initializer2(tok&, tok, dummy);
        };
        i += 1;
        hi = max(hi, i);
    };
    hi
}

fn comma_sep(c: *Ctx, tok: **Token, $end: Str, $body: @Fn() void) void = {
    first := true;
    while => !consume_end(tok, end) {
        if !first {
            tok[] = c.skip(tok[], ",");
        };
        first = false;
        body();
    };
}

// array-initializer1 = "{" initializer ("," initializer)* ","? "}"
fn array_initializer1(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void = {
    tok = c.skip(tok, "{");

    if init.is_flexible {
        len := c.count_array_init_elements(tok, init.ty);
        init[] = c.new_initializer(c.array_of(init.ty.base, len), false)[];
    };

    if init.is_flexible {
        len := c.count_array_init_elements(tok, init.ty);
        init[] = c.new_initializer(c.array_of(init.ty.base, len), false)[];
    };
    i := 0;
    comma_sep(c, tok&, "}") {
        continue :: local_return;
        if equal(tok, "[") {
            begin, end := c.array_designator(tok&, tok, init.ty);

            tok2 := Token.ptr_from_int(0);
            range(begin, end + 1) { j |
                c.designation(tok2&, tok, init.children[j]);
            };
            tok = tok2;
            i = end + 1;
            continue();
        };

        if i < init.ty.array_len.intcast() {
            c.initializer2(tok&, tok, init.children[i]);
        } else {
            tok = c.skip_excess_element(tok);
        };
        i += 1;
    };
    rest[] = tok;
}

// array-initializer2 = initializer ("," initializer)*
fn array_initializer2(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer, i: i64) void = {
    if init.is_flexible {
        len := c.count_array_init_elements(tok, init.ty);
        init[] = c.new_initializer(c.array_of(init.ty.base, len), false)[];
    };

    while => i < init.ty.array_len.intcast() && !is_end(tok) {
        start := tok;
        if i > 0 {
            tok = c.skip(tok, ",");
        };
        if equal(tok, "[") || equal(tok, ".") {
            rest[] = start;
            return();
        };

        c.initializer2(tok&, tok, init.children[i]);
        i += 1;
    };
    rest[] = tok;
}

// struct-initializer1 = "{" initializer ("," initializer)* ","? "}"
fn struct_initializer1(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void = {
    tok = c.skip(tok, "{");
    mem := init.ty.members;

    comma_sep(c, tok&, "}") {
        continue :: local_return;
        if equal(tok, ".") {
            mem = c.struct_designator(tok&, tok, init.ty);
            c.designation(tok&, tok, init.children[mem.idx.intcast()]);
            mem = mem.next;
            continue();
        };

        if !mem.is_null() {
            c.initializer2(tok&, tok, init.children[mem.idx.intcast()]);
            mem = mem.next;
        } else {
            tok = c.skip_excess_element(tok);
        }
    };
    rest[] = tok;
}

// struct-initializer2 = initializer ("," initializer)*
fn struct_initializer2(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer, mem: *Member) void = {
    first := true;
    while => !mem.is_null() && !is_end(tok) {
        start := tok;
        if !first {
            tok = c.skip(tok, ",");
        };
        first = false;

        if equal(tok, "[") || equal(tok, ".") {
            rest[] = start;
            return();
        };

        c.initializer2(tok&, tok, init.children[mem.idx.intcast()]);
        mem = mem.next;
    };
    rest[] = tok;
}

fn union_initializer(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void = {
    // Unlike structs, union initializers take only one initializer,
    // and that initializes the first union member by default.
    // You can initialize other member using a designated initializer.
    if equal(tok, "{") && equal(tok.next, ".") {
        mem := c.struct_designator(tok&, tok.next, init.ty);
        init.mem = mem;
        c.designation(tok&, tok, init.children[mem.idx.intcast()]);
        rest[] = c.skip(tok, "}");
        return();
    };

    init.mem = init.ty.members;

    if equal(tok, "{") {
        c.initializer2(tok&, tok.next, init.children[0]);
        consume(tok&, tok, ",");
        rest[] = c.skip(tok, "}");
    } else {
        c.initializer2(rest, tok, init.children[0]);
    };
}

// initializer = string-initializer | array-initializer
//                         | struct-initializer | union-initializer
//                         | assign
fn initializer2(c: *Ctx, rest: **Token, tok: *Token, init: *Initializer) void = @match(init.ty.kind) {
    fn TY_ARRAY() => @if_else {
        @if(tok.kind == .TK_STR) => c.string_initializer(rest, tok, init);
        @if(equal(tok, "{")) => c.array_initializer1(rest, tok, init);
        @else => c.array_initializer2(rest, tok, init, 0);
    };
    fn TY_STRUCT() => if equal(tok, "{") {
        c.struct_initializer1(rest, tok, init);
    } else {
        // A struct can be initialized with another struct. E.g.
        // `struct T x = y;` where y is a variable of type `struct T`.
        // Handle that case first.
        expr := c.parse_expr(rest, tok, .Assign);
        c.add_type(expr);
        if expr.ty.kind == .TY_STRUCT {
            init.expr = expr;
        } else {
            c.struct_initializer2(rest, tok, init, init.ty.members);
        };
    };
    fn TY_UNION() => c.union_initializer(rest, tok, init);
    @default => (if equal(tok, "{") {
        // An initializer for a scalar variable can be surrounded by
        // braces. E.g. `int x = {3};`. Handle that case.
        c.initializer2(tok&, tok.next, init);
        rest[] = c.skip(tok, "}");
    } else {
        init.expr = c.parse_expr(rest, tok, .Assign);
    }); // TODO: this shouldn't need the extra brackets?
};

fn initializer(c: *Ctx, rest: **Token, tok: *Token, ty: *CType, new_ty: **CType) *Initializer = {
    init := c.new_initializer(ty, true);
    c.initializer2(rest, tok, init);

    has_flex := ty.is_flexible && @is(ty.kind, .TY_STRUCT, .TY_UNION);
    ::if(@type init.ty);
    new_ty[] = if(!has_flex, => init.ty) {
        ty = c.copy_struct_type(ty);
        hack := ty.members;
        mem := hack.end_linked();
        mem.ty = init.children[mem.idx.intcast()].ty;
        ty.size += mem.ty.size;
        ty
    };
    init
}

#where(fn(T) => is_ptr(T) && has_field(Deref(T), @symbol next))
fn end_linked(head: ~T) T = {
    ::ptr_utils(Deref(T));
    while => !head.is_null() && !head.next.is_null() {
        head = head.next;
    };
    head
}

fn init_desg_expr(c: *Ctx, desg: *InitDesg, tok: *Token) *Node = {
    if(!desg.var.is_null(), => return(c.new_var_node(desg.var, tok)));
    
    if !desg.member.is_null() {
        node := c.new_unary(.ND_MEMBER, c.init_desg_expr(desg.next, tok), tok);
        node.member = desg.member;
        return(node);
    };

    lhs := c.init_desg_expr(desg.next, tok);
    rhs := c.new_num(desg.idx, tok);
    c.new_add(lhs&, rhs&, tok);
    node := c.new_binary(.ND_ADD, lhs, rhs, tok);
    //@println("gen init_desg_expr: %", lhs.kind);
    if lhs.kind == .ND_VAR {
        //@println("var % %", lhs.var.name, lhs.var.stack_slot);
        if lhs.var.global_symbol { id |
            //@println("%", c.m.str(id));
        };
    };
    c.gen_expr(node);
    c.new_deref(node, tok)
}

fn create_lvar_init(c: *Ctx, init: *Initializer, ty: *CType, desg: *InitDesg, tok: *Token) *Node = {
    if ty.kind == .TY_ARRAY {
        //println("arr create_lvar_init");
        node := c.new_node(.ND_NULL_EXPR, tok);
        range(0, ty.array_len.intcast()) { i |
            desg2: InitDesg = (next = desg, idx = i, member = Member.ptr_from_int(0), var = Obj.ptr_from_int(0));
            rhs := c.create_lvar_init(init.children[i], ty.base, desg2&, tok);
            node = c.new_binary(.ND_COMMA, node, rhs, tok);
        };
        return(node);
    };

    if ty.kind == .TY_STRUCT && init.expr.is_null() {
        node := c.new_node(.ND_NULL_EXPR, tok);

        mem := ty.members;
        for_linked mem { mem |
            desg2: InitDesg = (next = desg, idx = 0, member = mem, var = Obj.ptr_from_int(0));
            rhs := c.create_lvar_init(init.children[mem.idx.intcast()], mem.ty, desg2&, tok);
            node = c.new_binary(.ND_COMMA, node, rhs, tok);
        };
        return(node);
    };

    if ty.kind == .TY_UNION {
        ::if(@type init.mem);
        mem := if(!init.mem.is_null(), => init.mem, => ty.members);
        desg2: InitDesg = (next = desg, idx = 0, member = mem, var = Obj.ptr_from_int(0));
        return(c.create_lvar_init(init.children[mem.idx.intcast()], mem.ty, desg2&, tok));
    };

    if(init.expr.is_null(), => return(c.new_node(.ND_NULL_EXPR, tok)));

    //@println("start init_desg_expr % %", tok.str(), ty.kind);
    lhs := c.init_desg_expr(desg, tok);
    c.new_binary(.ND_ASSIGN, lhs, init.expr, tok)
}

// A variable definition with an initializer is a shorthand notation
// for a variable definition followed by assignments. This function
// generates assignment expressions for an initializer. For example,
// `int x[2][2] = {{6, 7}, {8, 9}}` is converted to the following
// expressions:
//
//     x[0][0] = 6;
//     x[0][1] = 7;
//     x[1][0] = 8;
//     x[1][1] = 9;
fn lvar_initializer(c: *Ctx, rest: **Token, tok: *Token, var: *Obj) *Node = {
    init := c.initializer(rest, tok, var.ty, var.ty&);
    desg := InitDesg.zeroed();
    desg.var = var;
    
    // If a partial initializer list is given, the standard requires
    // that unspecified elements are set to 0. Here, we simply
    // zero-initialize the entire memory region of a variable before
    // initializing it with user-supplied values.
    lhs := c.new_node(.ND_MEMZERO, tok);
    lhs.var = var;

    static_array_of_unknown_length := var.stack_slot == QbeNull;  // :StaticArrayOfUnknownLength
    if static_array_of_unknown_length {
        // This ref needs to exist because create_lvar_init will generate offsets from it to store the elements. 
        var.stack_slot = c.f.newtmp(var.name.str(), .Kl);
    };
    
    rhs := c.create_lvar_init(init, var.ty, desg&, tok);
    if static_array_of_unknown_length {  
        c.create_stack_slot(var);
    };
    
    node := c.new_binary(.ND_COMMA, lhs, rhs, tok);
    c.gen_expr(node);
    node
}

// TODO: is alignment real? 
// TODO: if we always made sure the buffer was 8 aligned we could just read/write off the end and mask it because little endian. 
fn read_buf(buf: *u8, sz: i64) i64 = {
    @switch(sz) {
        @case(1) => buf[].zext();
        @case(2) => ptr_cast_unchecked(u8, u16, buf)[].zext();
        @case(4) => ptr_cast_unchecked(u8, u32, buf)[].zext();
        @case(8) => ptr_cast_unchecked(u8, i64, buf)[];
        @default => unreachable();
    }
}

fn write_buf(buf: *u8, val: i64, sz: i64) void = {
    @switch(sz) {
        @case(1) => { buf[] = val.trunc(); };
        @case(2) => { ptr_cast_unchecked(u8, u16, buf)[] = val.trunc(); };
        @case(4) => { ptr_cast_unchecked(u8, u32, buf)[] = val.trunc(); };
        @case(8) => { ptr_cast_unchecked(u8, i64, buf)[] = val; };
        @default => unreachable();
    };
}

fn write_gvar_data(c: *Ctx, cur: *Relocation, init: *Initializer, ty: *CType, buf: []u8, off: i64) *Relocation = {
    ::enum(TypeKind);
    if ty.kind == .TY_ARRAY {
        sz := ty.base.size.intcast();
        range(0, ty.array_len.intcast()) { i |
            cur = c.write_gvar_data(cur, init.children[i], ty.base, buf, off + sz * i);
        };
        return(cur);
    };

    if ty.kind == .TY_STRUCT {
        mem := ty.members;
        if true {
            break :: local_return;
            for_linked mem { mem | 
                if mem.is_bitfield {
                    expr := init.children[mem.idx.intcast()].expr;
                    ::ptr_utils(Node);
                    if(expr.is_null(), => break());
                    loc      := buf.ptr.offset(off + mem.offset.intcast());
                    oldval   := read_buf(loc, mem.ty.size.intcast());
                    newval   := c.eval(expr);
                    mask     := 1.shift_left(mem.bit_width.intcast()) - 1;
                    combined := oldval.bit_or(newval.bit_and(mask).shift_left(mem.bit_offset.intcast()));
                    write_buf(loc, combined, mem.ty.size.intcast());
                    @debug_assert_eq(combined, read_buf(loc, mem.ty.size.intcast()), "failed write_buf");
                } else {
                    cur = c.write_gvar_data(cur, init.children[mem.idx.intcast()], mem.ty, buf, off + mem.offset.intcast());
                };
            };
        };
        return(cur);
    };

    if ty.kind == .TY_UNION {
        if(init.mem.is_null(), => return(cur));
        return(c.write_gvar_data(cur, init.children[init.mem.idx.intcast()], init.mem.ty, buf, off));
    };

    if(init.expr.is_null(), => return(cur));

    if ty.kind == .TY_FLOAT {
        ptr_cast_unchecked(u8, f32, buf.ptr.offset(off))[] = c.eval_double(init.expr).cast();
        return(cur);
    };

    if ty.kind == .TY_DOUBLE {
        ptr_cast_unchecked(u8, f64, buf.ptr.offset(off))[] = c.eval_double(init.expr);
        return(cur);
    };

    val, label := c.eval2(init.expr);

    label := label || {
        write_buf(buf.ptr.offset(off), val, ty.size.intcast());
        return(cur)
    };

    rel := c.arena.box(Relocation);
    rel.offset = off.intcast();
    rel.label = label;
    rel.addend = val;
    cur.next = rel;
    cur.next
}

// Initializers for global variables are evaluated at compile-time and
// embedded to .data section. This function serializes Initializer
// objects to a flat byte array. It is a compile error if an
// initializer list contains a non-constant expression.
fn gvar_initializer(c: *Ctx, rest: **Token, tok: *Token, var: *Obj) void = {
    init := c.initializer(rest, tok, var.ty, var.ty&);
    head := Relocation.zeroed();
    buf := c.arena.alloc_zeroed(u8, var.ty.size.intcast());
    c.write_gvar_data(head&, init, var.ty, buf, 0);
    var.init_data = buf;
    var.rel = head.next;
}

fn is_type_name(c: *Ctx, tok: *Token) bool #inline #use(Tokens) = {
    is_type_keyword := tok.kind.raw() >= TokenKind.short.raw() && tok.kind.raw() <= TokenKind.int.raw();
    is_type_keyword || c.find_typedef(tok).is_some()
}

fn slow_convert_to_c_string(s: Str) CStr = // :SLOW
    (ptr = @tfmt("%\0", s).as_ptr());
    
fn push_loop(c: *Ctx, $body: @Fn(brk: *Qbe.Blk, cnt: *Qbe.Blk) void) Ty(*Qbe.Blk, *Qbe.Blk) = {
    brk  := c.brk_label;
    cont := c.cont_label;
    brk_label := c.new_block();
    cont_label := c.new_block();
    c.brk_label = (Some = brk_label);
    c.cont_label = (Some = cont_label);

    body(brk_label, cont_label);
    
    c.brk_label = brk;
    c.cont_label = cont;
    (brk_label, cont_label)
}

// compound-stmt = (typedef | declaration | stmt)* "}"
fn compound_stmt(c: *Ctx, rest: **Token, tok: *Token) *Node = {
    cur: ?*Node = .None;

    c.enter_scope();

    while => !equal(tok, "}") {
        if c.is_type_name(tok) && !equal(tok.next, ":") {
            @if(SPAM) @println("type name! %", tok.str());
            attr   := VarAttr.zeroed();
            basety := c.declspec(tok&, tok, (Some = attr&));
            tok = @if_else {
                @if(attr.is_typedef)  => c.parse_typedef(tok, basety);
                @if(c.is_function(tok)) => c.function(tok, basety, attr&);
                @if(attr.is_extern)   => c.global_variable(tok, basety, attr&);
                @else => c.declaration(tok, basety, (Some = attr&));
            };
        } else {
            cur = (Some = c.stmt(tok&, tok));
        };
        if cur { cur |
            c.add_type(cur);
            c.gen_expr(cur);
        };
    };

    c.leave_scope();

    rest[]    = tok.next;
    cur || c.new_node(.ND_NULL_EXPR, tok)
}

// expr-stmt = expr? ";"
fn expr_stmt(c: *Ctx, rest: **Token, tok: *Token) *Node = if equal(tok, ";") {
    rest[] = tok.next;
    c.new_node(.ND_NULL_EXPR, tok)
} else {
    node := c.parse_expr(tok&, tok, .None);
    rest[] = c.skip(tok, ";");
    node
};

// struct-members = (declspec declarator (","    declarator)* ";")*
fn struct_members(c: *Ctx, rest: **Token, tok: *Token, ty: *CType) void = {
    head := Member.zeroed();
    cur  := head&;
    idx  := 0;

    while => !equal(tok, "}") {
        continue :: local_return;
        attr   := VarAttr.zeroed();
        basety := c.declspec(tok&, tok, (Some = attr&));

        is_anon := (@is(basety.kind, .TY_STRUCT, .TY_UNION)) && consume(tok&, tok, ";");
        if is_anon {
            mem := c.arena.box_zeroed(Member);
            mem.tok = tok;
            mem.ty  = basety;
            mem.idx = idx.intcast();
            idx += 1;
            mem.align = if(attr.align != 0, => attr.align, => mem.ty.align);
            cur.next = mem;
            cur = cur.next;
            continue();
        };

        // Regular struct members
        comma_sep(c, tok&, ";") {
            mem := c.arena.box_zeroed(Member);
            mem.tok = tok;
            mem.ty = c.declarator(tok&, tok, basety);
            mem.name = mem.ty.name;
            mem.idx = idx.intcast();
            idx += 1;
            mem.align = if(attr.align != 0, => attr.align, => mem.ty.align);

            if consume(tok&, tok, ":") {
                mem.is_bitfield = true;
                mem.bit_width = c.const_expr(tok&, tok).intcast();
            };
            cur.next = mem;
            cur = cur.next;
        };
    };

    // If the last element is an array of incomplete type, it's
    // called a "flexible array member". It should behave as if
    // if were a zero-sized array.
    ty.is_flexible = !cur.identical(head&) && cur.ty.kind == .TY_ARRAY && cur.ty.array_len < 0; 
    if ty.is_flexible {
        cur.ty = c.array_of(cur.ty.base, 0);
    };

    rest[] = tok.next;
    ty.members = head.next;
}

// attribute = ("__attribute__" "(" "(" "packed" ")" ")")*
fn attribute_list(c: *Ctx, tok: *Token, ty: *CType) *Token = {
    while => consume(tok&, tok, "__attribute__") {
        tok = c.skip(tok, "(");
        tok = c.skip(tok, "(");

        comma_sep(c, tok&, ")") {
            continue :: local_return;
            if consume(tok&, tok, "packed") {
                ty.is_packed = true;
                continue();
            };

            if consume(tok&, tok, "aligned") {
                tok = c.skip(tok, "(");
                ty.align = c.const_expr(tok&, tok).intcast();
                tok = c.skip(tok, ")");
                continue();
            };

            @error_tok(c, tok, "unknown attribute");
        };

        tok = c.skip(tok, ")");
    };

    tok
}

// struct-union-decl = attribute? ident? ("{" struct-members)?
fn struct_union_decl(c: *Ctx, rest: **Token, tok: *Token) *CType = {
    ty := c.struct_type();
    tok = c.attribute_list(tok, ty);

    // Read a tag.
    tag: ?*Token = .None;
    if tok.kind == .TK_IDENT {
        tag = (Some = tok);
        tok = tok.next;
    };

    if tag { tag |
        if !equal(tok, "{") {
            rest[] = tok;
            if c.find_tag(tag) { ty2 |
                return(ty2);
            };
            ty.size = -1;
            c.push_tag_scope(tag, ty);
            return(ty);
        }
    };

    tok = c.skip(tok, "{");

    // Construct a struct object.
    c.struct_members(tok&, tok, ty);
    rest[] = c.attribute_list(tok, ty);

    if tag { tag |
        // If this is a redefinition, overwrite a previous type.
        // Otherwise, register the struct type.
        if get(c.scope.tags&, tag.str()) { ty2 |
            ty2[] = ty[];
            return(ty2);
        };

        c.push_tag_scope(tag, ty);
    };

    ty
}

// struct-decl = struct-union-decl
fn struct_decl(c: *Ctx, rest: **Token, tok: *Token) *CType = {
    ty := c.struct_union_decl(rest, tok);
    ty.kind = .TY_STRUCT;
    if(ty.size < 0, => return(ty));

    // Assign offsets within the struct to members.
    bits := 0;
    mem := ty.members;
    for_linked mem { mem |
        if mem.is_bitfield {
            if mem.ty.is_atomic {
                @error_tok(c, mem.tok, "the type backing a bitfield cannot be _Atomic");
            };
            if mem.bit_width == 0 {
                // [https://www.sigbus.info/n1570#6.7.2.1p12]
                // "As a special case, a bit-field structure member with a width of 0 indicates 
                // that no further bit-field is to be packed into the unit in which the previous 
                // bit-field, if any, was placed."
                bits = align_to(bits, mem.ty.size.intcast() * 8);
            } else {
                sz := mem.ty.size.intcast();
                unaligned := (bits / (sz * 8)) != (bits + mem.bit_width.intcast() - 1) / (sz * 8);
                if unaligned {
                    bits = align_to(bits, sz * 8);
                };
                mem.offset = align_down(bits / 8, sz).intcast();
                mem.bit_offset = bits.mod(sz * 8).intcast();
                bits += mem.bit_width.intcast();
            };
        } else {
            if !ty.is_packed {
                bits = align_to(bits, mem.align.intcast() * 8);
            };
            mem.offset = bits.intcast() / 8;
            bits += mem.ty.size.intcast() * 8;
        };

        if !ty.is_packed && ty.align < mem.align {
            ty.align = mem.align;
        };
    };

    ty.size = align_to(bits, ty.align.intcast() * 8).intcast() / 8;
    ty
}

// union-decl = struct-union-decl
fn union_decl(c: *Ctx, rest: **Token, tok: *Token) *CType = {
    ty := c.struct_union_decl(rest, tok);
    ty.kind = .TY_UNION;
    if(ty.size < 0, => return(ty));

    // If union, we don't have to assign offsets because they
    // are already initialized to zero. We need to compute the
    // alignment and the size though.
    mem := ty.members;
    for_linked mem { mem |
        ty.align = max(ty.align, mem.align);
        ty.size  = max(ty.size, mem.ty.size);
    };
    ty.size = align_to(ty.size.intcast(), ty.align.intcast()).intcast();
    ty
}

fn next_is_paren_typename(c: *Ctx, tok: *Token) bool = 
    equal(tok.next, "(") && c.is_type_name(tok.next.next);

fn parse_typedef(c: *Ctx, tok: *Token, basety: *CType) *Token = {
    comma_sep(c, tok&, ";") {
        ty := c.declarator(tok&, tok, basety);
        if(ty.name.is_null(), => @error_tok(c, ty.name_pos, "typedef name omitted"));
        c.push_scope(c.get_ident(ty.name))[].type_def = ty;
    };
    tok
}

fn create_param_lvars(c: *Ctx, param: *CType) void = {  // TODO: why isn't this a loop?
    if(param.is_null(), => return()); 
    c.create_param_lvars(param.next);
    if(param.name.is_null(), => @error_tok(c, param.name_pos, "parameter name omitted"));
    c.new_lvar(c.get_ident(param.name), param);
}

fn find_func(c: *Ctx, name: Str) ?*Obj = {
    ::ptr_utils(Scope);
    hack := c.scope;
    sc := hack.end_linked();

    if sc.vars&.get(name) { sc2 |
        if !sc2.var.is_null() && sc2.var.is_function {
            return(Some = sc2.var);
        };
    };
    .None
}

// TODO: this clears a bunch of state that won't work if nested function decls are allowed
fn function(c: *Ctx, tok: *Token, basety: *CType, attr: *VarAttr) *Token = {
    ty := c.declarator(tok&, tok, basety);
    if(ty.name.is_null(), => @error_tok(c, ty.name_pos, "function name omitted"));
    name_str := c.get_ident(ty.name);

    f := if c.find_func(name_str) { f |
        if(!f.is_function,                     => @error_tok(c, tok, "redeclared as a different kind of symbol"));
        if(f.is_definition && equal(tok, "{"), => @error_tok(c, tok, "redefinition of %s", name_str));
        if(!f.is_static && attr.is_static,     => @error_tok(c, tok, "static declaration follows a non-static declaration"));
        f.is_definition = f.is_definition || equal(tok, "{");
        f
    } else {
        f := c.new_gvar(name_str, ty);
        f.is_function = true;
        f.is_definition = equal(tok, "{");
        f.is_static = attr.is_static || (attr.is_inline && !attr.is_extern);
        f.is_inline = attr.is_inline;
        f
    };
    
    //f.is_root = !(f.is_static && f.is_inline);
    if(consume(tok&, tok, ";"), => return(tok));

    @if(SPAM) println("start function body");
    c.current_fn = (Some = f);
    
    c.f = c.arena.box(Qbe.Fn);
    c.f.default_init(c.m);
    //c.speculate = false;
    c.f.rpo = new(1);
    c.b = c.f.start;
    
    c.labels = init(temp());
    c.locals = ptr_from_int(@type c.locals[], 0);
    c.enter_scope();
    c.create_param_lvars(ty.params);

    // A buffer for a struct/union return value is passed
    // as the hidden first parameter.
    rty := ty.return_ty;
    if rty.size > 16 && @is(rty.kind, .TY_STRUCT, .TY_UNION) {
        c.new_lvar("", c.pointer_to(rty));
    };

    f.params = c.locals;

    if ty.is_variadic {
        f.va_area = c.new_lvar("__va_area__", c.array_of(ty_char, 136));
    };
    f.alloca_bottom = c.new_lvar("__alloca_size__", c.pointer_to(ty_char));

    tok = c.skip(tok, "{");

    f_name := f.name.str();
    f_name.len += 1;  // null terminator
    
    // TODO: we are doing extra work for every single function to support a feature that is rarely used. that's not what you want. 
    //       detect it after failing a name lookup instead and just add it then? 
    
    // [https://www.sigbus.info/n1570#6.4.2.2p1] "__func__" is
    // automatically defined as a local variable containing the
    // current function name.
    c.push_scope("__func__")[].var =
        c.new_string_literal(f_name, c.array_of(ty_char, f_name.len));

    // [GNU] __FUNCTION__ is yet another name of __func__.
    c.push_scope("__FUNCTION__")[].var =
        c.new_string_literal(f_name, c.array_of(ty_char, f_name.len));
    
    c.gen_par();
    _ := c.compound_stmt(tok&, tok);
    if c.b.jmp.type == .Jxxx {
        // void functions are allowed to just fall off the end
        // it would be nice to give an error otherwise but it's non-trivial to decide if this codepath is reachable. 
        // also for main() falling off the end means returning 0
        c.b.jmp = @if(rty.is_void(), (type = .ret0, arg = QbeNull), (type = .retw, arg = QbeConZero));
    };
    
    c.f.link_blocks_from_rpo();
    f.f = c.f;
    
    f.locals = c.locals;
    c.leave_scope();
    c.labels&.clear();
    c.current_fn = .None;
    tok
}

fn global_variable(c: *Ctx, tok: *Token, basety: *CType, attr: *VarAttr) *Token = {
    comma_sep(c, tok&, ";") {
        ty := c.declarator(tok&, tok, basety);
        if(ty.name.is_null(), => @error_tok(c, ty.name_pos, "variable name omitted"));

        var := c.new_gvar(c.get_ident(ty.name), ty);
        var.is_definition = !attr.is_extern;
        var.is_static = attr.is_static;
        var.is_tls = attr.is_tls;
        if attr.align > 0 {
            var.align = attr.align;
        };
        
        if equal(tok, "=") {
            c.gvar_initializer(tok&, tok.next, var);
        } else {
            var.is_tentative = var.is_tentative || (!attr.is_extern && !attr.is_tls);
        };
    };
    tok
}

// Lookahead tokens and returns true if a given token is a start
// of a function definition or declaration.
fn is_function(c: *Ctx, tok: *Token) bool = {
    if(equal(tok, ";"), => return(false));
    dummy := CType.zeroed();
    ty    := c.declarator(tok&, tok, dummy&);
    ty.kind == .TY_FUNC
}

// Remove redundant tentative definitions.
fn scan_globals(c: *Ctx) void = {
    head := Obj.zeroed();
    cur  := head&;

    var := c.globals;
    for_linked var { var |
        continue :: local_return;
        if !var.is_tentative {
            cur.next = var;
            cur = cur.next;
            continue();
        };
        
        // If there's another definition, the tentative definition
        // is redundant
        if find_matching_name(c.globals, var).is_none() {
            cur.next = var;
            cur = cur.next;
        };
    };

    cur.next = Obj.ptr_from_int(0);
    c.globals = head.next;
}

// Find another definition of the same identifier.
fn find_matching_name(first: *Obj, goal: *Obj) ?*Obj = {
    for_linked first { var2 |
        if !goal.identical(var2) && var2.is_definition && goal.name.str() == var2.name.str() {
            return(Some = var2);
        };
    };
    .None
}

fn declare_builtin_functions(c: *Ctx) void = {
    ty := c.func_type(c.pointer_to(ty_void));
    ty.params = c.copy_type(ty_int);
    c.builtin_alloca = c.new_gvar("alloca", ty);
    c.builtin_alloca.is_definition = false;
}

// program = (typedef | function-definition | global-variable)*
fn parse(c: *Ctx, tok: *Token) *Obj = {
    c.declare_builtin_functions();

    //c.speculate = true;
    while => tok.kind != .TK_EOF {
        attr := VarAttr.zeroed();
        basety := c.declspec(tok&, tok, (Some = attr&));
        tok = @if_else {
            @if(attr.is_typedef)    => c.parse_typedef(tok, basety);
            @if(c.is_function(tok)) => {
                prev := c.f;   // :TopLevelFunction
                tok := c.function(tok, basety, attr&);
                c.f = prev;
                c.b = c.f.start; // HACK
                tok
            };
            @else                   => c.global_variable(tok, basety, attr&);
        };
        
        // TODO: reset temp() here? but then if want to delay adding functions to the module, 
        //       need to have them not in temp(), or copy them out at the end. 
    };

    var := c.globals;

    // Remove redundant tentative definitions.
    c.scan_globals();
    c.globals
}

/**************************
*   Parsing Expressions   *
**************************/

Prec :: @enum(i32) (
    Invalid,
    Stmt,
    None, 
    Comma,
    Assign, 
    Conditional,  // ?:
    LogOr, LogAnd, 
    BitOr, BitXor, BitAnd, 
    Equality, Relational, 
    Shift, Term, Factor, 
    Unary, PostFix, Primary,
);

N1: ParseFn1 : fn(c, b, t) = @error_tok(c, t, "unexpected (prefix) token %", t.str()); 
N2: ParseFn2 : fn(c, b, t, d) = @error_tok(c, t, "unexpected (infix) token %", t.str()); 
ParseFn1   :: @FnPtr(c: *Ctx, rest: **Token, tok: *Token) *Node;
ParseFn2   :: @FnPtr(c: *Ctx, rest: **Token, tok: *Token, node: *Node) *Node;
ParseRule :: @struct(prefix: ParseFn1 = N1, infix: ParseFn2 = N2, prec := Prec.Invalid, op := NodeKind.ND_INVALID);

rules :: @static EnumMap(Tokens.TokenKind, ParseRule);

// not just a '::' here because it needs to happen after the dylib is initilized or we think there are missing functions. 
fn comptime_init_rules_table() void #use(Tokens) = {
    h := rules;
    each h { k, v |
        v[] = ();
    };
    
    ::if(*Node);
    ::enum(NodeKind);
    ::enum(Prec);
    ::enum(TypeKind);
    ::ptr_utils(Scope);
    ::if(*CType); 
    
    binary := @slice(@as(Ty(TokenKind, Prec, NodeKind))
        (.@"+", .Term,   .ND_INVALID),
        (.@"-", .Term,   .ND_INVALID),
        (.@"*", .Factor, .ND_MUL),
        (.@"/", .Factor, .ND_DIV),
        (.@"%", .Factor, .ND_MOD),
        (.@"|", .BitOr,  .ND_BITOR),
        (.@"^", .BitXor, .ND_BITXOR),
        (.@"&", .BitAnd, .ND_BITAND),
        (.@">>", .Shift, .ND_SHR),
        (.@"<<", .Shift, .ND_SHL),
        
        (.@"+=", .Assign,  .ND_INVALID),
        (.@"-=", .Assign,  .ND_INVALID),
        (.@"*=", .Assign,  .ND_MUL),
        (.@"/=", .Assign,  .ND_DIV),
        (.@"%=", .Assign,  .ND_MOD),
        (.@"|=", .Assign,  .ND_BITOR),
        (.@"^=", .Assign,  .ND_BITXOR),
        (.@"&=", .Assign,  .ND_BITAND),
        (.@">>=", .Assign, .ND_SHR),
        (.@"<<=", .Assign, .ND_SHL),
        
        (.@"==", .Equality,   .ND_EQ),
        (.@"!=", .Equality,   .ND_NE),
        (.@">=", .Relational, .ND_LE), // ND_GE
        (.@">", .Relational,  .ND_LT), // ND_GT
        (.@"<=", .Relational, .ND_LE),
        (.@"<", .Relational,  .ND_LT),
        
        (.@",", .Comma,  .ND_COMMA),
        (.@"=", .Assign, .ND_ASSIGN),
    );
    each binary { it |
        h[it._0] = (infix = parse_binary, prec = it._1, op = it._2);
    };
    
    s := scope_of(Type, parsers);
    names := get_constants(s);
    for names { name |
        fid := get_constant(FuncId, s, name).unwrap();
        func := get_function_ast(fid, true, false, false, false);
        each func.annotations { ann |
            continue :: local_return;
            args := ann.args&.items();
            keyword := const_eval(TokenKind)(args[0]);
            rule := h[keyword]&;
            ::?ParseFn2; ::?ParseFn1;
            op_index := @switch(ann.name) {
                @case(@symbol prefix) => {
                    rule.prefix = get_constant(ParseFn1, s, name).unwrap();
                    1
                };
                @case(@symbol infix) => {
                    rule.infix = get_constant(ParseFn2, s, name).unwrap();
                    new := const_eval(Prec)(args[1]);
                    @assert(rule.prec == .Invalid, "multiple precedences for % (% vs %)", keyword, rule.prec, new);
                    rule.prec = new;
                    2
                };
                @default => continue();
            };
            if args.len > op_index {
                new := const_eval(NodeKind)(args[op_index]);
                @assert(rule.op == .ND_INVALID, "multiple operations for % (% vs %)", keyword, rule.op, new);
                rule.op = new;
            };
        };
    };
};

fn parse_expr(c: *Ctx, rest: **Token, tok: *Token, prec: Prec) *Node = {
    @if(SPAM) @println("Prefix: % %", tok.str(), tok.kind);

    rules := rules;  // TODO: shouldn't need to do this but otherwise if can't call the function ?? 
    rule := rules.index(tok.kind);
    node := (rule.prefix)(c, rest, tok);
    tok   = rest[];
    ::enum(@type prec);
    rule := rules.index(tok.kind);
    while => prec.raw() <= rule.prec.raw() {
        @if(SPAM) @println("Infix: % %", tok.str(), tok.kind);
        node = (rule.infix)(c, rest, tok, node);
        tok  = rest[];
        rule = rules.index(tok.kind);
    };
    @if(SPAM) @println("End Expression: % % %", tok.str(), tok.kind, node.kind);
    c.gen_expr(node);
    node
}

fn parse_binary(c: *Ctx, rest: **Token, tok: *Token, lhs: *Node) *Node = {
    node := c.parse_binary_inner(rest, tok, lhs);
    c.gen_expr(node);
    node
}

fn parse_binary_inner(c: *Ctx, rest: **Token, tok: *Token, lhs: *Node) *Node = {
    rule := rules.index(tok.kind);
    prec := rule.prec;
    
    // assignment is right associative. everything else is left. 
    // you can work out why this works on a whiteboard. or you can just trust that this trick works. 
    if prec != .Assign {
        prec = @as(Prec) @as(i32) prec.raw() + 1;  
    }; 
    
    rhs  := parse_expr(c, rest, tok.next, prec);
    @match(tok.kind) {
        fn @"+="()  => {
            c.new_add(lhs&, rhs&, tok);
            node := c.to_assign(.ND_ADD, lhs, rhs, tok);
            return(node);
        }
        fn @"-="()  => {
            node := c.new_sub(lhs, rhs, tok);
            node := c.to_assign(node.kind, node.lhs, node.rhs, node.tok);
            return(node);
        }
        fn @"+"()   => {
            c.new_add(lhs&, rhs&, tok);
            return(c.new_binary2(.ND_ADD, lhs, rhs, tok));
        }
        fn @"-"()   => return(c.new_sub(lhs, rhs, tok));
        @default    => ();
    };
    
    needs_flip := @is(tok.kind, .@">=", .@">");
    if needs_flip { // TODO: just have ops for this. 
        t := lhs; lhs = rhs; rhs = t; 
    };
    is_update_assign := @is(tok.kind, .@"*=", .@"/=", .@"%=", .@"&=", .@"|=", .@"^=", .@"<<=", .@">>=");
    node := if is_update_assign {
        c.to_assign(rule.op, lhs, rhs, tok)
    } else {
        if tok.kind != .@"=" && tok.kind != .@"," {
            c.new_binary2(rule.op, lhs, rhs, tok)
        } else {
            c.new_binary(rule.op, lhs, rhs, tok)
        }
    };
    node
}

::if(*Node);

parsers :: @struct {
// TODO: less dumb ir for if conditions
// short-circuiting, output is always 0 or 1
#infix(.@"||", .LogOr, .ND_BITOR) #infix(.@"&&", .LogAnd, .ND_BITAND) 
parse_logical :: fn(c, rest, tok, cond) = {
    fold_op := rules.index(tok.kind)[].op;
    cond := c.new_cast(cond, ty_bool);  // jnz only looks at low 32 bits but we might be jumping on a long
    
    else_block := c.new_block();
    join_block := c.new_block();
    
    prev_block := c.b;
    need_jump := prev_block.jmp.type == .Jxxx && !c.speculate;
    if need_jump {
        prev_block.jmp = (type = .jnz, arg = cond.r);
    };
    
    c.b = else_block; 
    rule := rules.index(tok.kind);
    rhs  := parse_expr(c, rest, tok.next, @as(Prec) @as(i32) rule.prec.raw() + 1);
    rhs  := c.new_cast(rhs, ty_bool);
    else_block_end := c.b;
    then, else, s1, s2, phi1, phi2 := @match(tok.kind) {
        fn @"&&"() => (rhs, c.new_num(0, tok), else_block, join_block, else_block, prev_block);
        fn @"||"() => (c.new_num(1, tok), rhs, join_block, else_block, prev_block, else_block);
        @default   => unreachable();
    };
    c.gen_expr(then);
    c.gen_expr(else);
    
    c.jmp_if_unterminated(join_block);
    if need_jump {
        prev_block.s1 = s1;
        prev_block.s2 = s2;
    };
    
    c.b = join_block;
    n := c.new_node(.ND_COND, tok);
    n.cond = cond;
    n.then = then;
    n.else = else;
    c.add_type(n);

    if rtype(cond.r) == .RCon && rtype(rhs.r) == .RCon {
        // :FrontendConstantFolding 
        n.r = c.gen_binary(fold_op, cond.r, rhs.r, ty_bool, ty_bool, tok);
    } else {
        if !c.speculate {
            p := new_phi(c.f, join_block, .Kw);
            p.push(phi1, then.r);
            p.push(phi2, else.r);
            n.r = p.to;
        };
    };
    
    n
};

// the ternary operator
conditional :: fn(c, rest, tok, cond) #infix(.@"?", .Conditional) = {
    // note: the [GNU] case below still uses the old `cond` node without this cast. 
    cond_r := c.new_cast(cond, ty_bool)[].r;
    
    cond_block := c.b;
    then_block := c.new_block();
    else_block := c.new_block();
    join_block := c.new_block();
    
    ::if(Ty(*Node, *Qbe.Blk, *Node));
    node, then_phi_src, cond_node := if equal(tok.next, ":") {
        // [GNU] Compile `a ?: b` as `tmp = a, tmp ? tmp : b`.
        then_block = join_block;
        var := c.new_lvar("", cond.ty);
        lhs := c.new_binary(.ND_ASSIGN, c.new_var_node(var, tok), cond, tok);
        rhs := c.new_node(.ND_COND, tok);
        rhs.cond = c.new_var_node(var, tok);
        rhs.then = c.new_var_node(var, tok);
        //c.gen_expr(rhs.then);
        c.b = else_block;
        rhs.else = c.parse_expr(rest, tok.next.next, .Conditional);
        c.gen_expr(rhs.else);
        node := c.new_binary(.ND_COMMA, lhs, rhs, tok);
        c.gen_expr(node);
        (node, cond_block, rhs)
    } else {
        node := c.new_node(.ND_COND, tok);
        node.cond = cond;
        c.gen_expr(node.cond);
        c.b = then_block;
        node.then = c.parse_expr(tok&, tok.next, .None);
        c.gen_expr(node.then);
        then_phi_src := c.b;
        c.jmp_if_unterminated(join_block);
        tok = c.skip(tok, ":");
        c.b = else_block;
        node.else = c.parse_expr(rest, tok, .Conditional);
        c.gen_expr(node.else);
        (node, then_phi_src, node)
    };
    else_phi_src := c.b;
    c.jmp_if_unterminated(join_block);
    //c.add_type(node);
    c.gen_expr(node);
    c.b = cond_block;
    c.jnz_if_unterminated(cond_r, then_block, else_block);
    c.b = join_block;
    
    if rtype(cond_r) == .RCon {  
        // :FrontendConstantFolding (only matters if the values are RCon too)
        // TODO: need to use Ref instead of creating a new var for [GNU] :?
        is_false := iscon(c.f.get_constant(cond_r), false, 0);
        node.r = if(is_false, => cond_node.else.r, => cond_node.then.r);
    } else {
        if !c.speculate {
            p := new_phi(c.f, join_block, node.ty.cls());
            p.push(then_phi_src, cond_node.then.r);
            p.push(else_phi_src, cond_node.else.r);
            node.r = p.to;
        };
    };
    node.current_block = join_block; // this makes a cast from the result go to the right place (when gen_expr gets called again by our caller)
    node
};

parse_bracketed :: fn(c, rest, tok) #prefix(.@"(") = {
    node := if c.is_type_name(tok.next) {
        start := tok;
        ty := c.typename(tok&, tok.next);
        tok = c.skip(tok, ")");

        is_compound_literal := equal(tok, "{");
        if is_compound_literal {
            if c.scope.next.is_null() {  // global
                var := c.new_anon_gvar(ty);
                c.gvar_initializer(rest, tok, var);
                c.new_var_node(var, start)
            } else {  // local
                var := c.new_lvar("", ty);
                lhs := c.lvar_initializer(rest, tok, var);
                rhs := c.new_var_node(var, tok);
                c.new_binary(.ND_COMMA, lhs, rhs, start)
            }
        } else {  // type cast
            node := parse_expr(c, rest, tok, .Unary);
            node := c.new_cast(node, ty);
            node.tok = start;
            node
        }
    } else {
        node := if equal(tok.next, "{") {
            // This is a [GNU] statement expresssion.
            node := c.compound_stmt(tok&, tok.next.next);
            @if(node.ty.is_null() || node.ty.kind == .TY_VOID)
            @error_tok(c, node.tok, "statement expression returning void is not supported");
            node
        } else {
            // just a braketed expression like in math
            parse_expr(c, tok&, tok.next, .None)
        };
        rest[] = c.skip(tok, ")");
        node
    };
    c.gen_expr(node);
    node
};

label :: fn(c, rest, tok, prev) #infix(.@":", .Stmt) = {
    // :LabelAsInfix
    if !@is(prev.kind, .ND_VAR, .ND_STMT) {
        @error_tok(c, tok, "treating infix ':' as a label but the expression on the left was not an indentifier");
    };
    unique_label := c.get_block(prev.tok.str());
    c.jmp_if_unterminated(unique_label);
    c.b = unique_label;
    c.stmt(rest, tok.next)
};

parse_ident :: fn(c, rest, tok) #prefix(.TK_IDENT) = {
    // Variable or enum constant
    sc := c.find_var(tok);
    rest[] = tok.next;
    
    // For "static inline" function
    ::ptr_utils(Obj);
    ::?*Obj;
    if sc { sc |
        if !sc.var.is_null() {
            var := sc.var;
            if var.is_function {
                if c.current_fn { current_fn |
                    //strarray_push(current_fn.refs&, var.name);
                } else {
                    //var.is_root = true;
                };
            }; 
            node := c.new_var_node(var, tok);
            node.ty = var.ty;
            return(node);
        };
        if(!sc.enum_ty.is_null(), => return(c.new_num(sc.enum_val, tok)));
    };

    if(equal(tok.next, "("), => @error_tok(c, tok, "implicit declaration of a function"));
    if equal(tok.next, ":") {
        // :LabelAsInfix
        // might be a label: the colon will be treated as an infix operator
        // this case can't skip the var lookup tho because of `a?b:c;`, from here we can't tell that b is not a label.
        node := c.new_node(.ND_STMT, tok);
        // Undef makes sure gen_expr/gen_addr skip it
        node.r = QbeUndef;
        node.lvalue = QbeUndef;
        node.ty = ty_int;  // HACK: without this, it crashes on `"" + a` when a is undeclared 
        return(node);
    };  
    @error_tok(c, tok, "undefined variable")
};

parse_string :: fn(c, rest, tok) #prefix(.TK_STR) = {
    s: []u8 = (ptr = tok.str_buf, len = tok.ty.size.intcast());
    var := c.new_string_literal(s, tok.ty);
    rest[] = tok.next;
    node := c.new_var_node(var, tok);
    c.gen_expr(node);
    node
};

parse_number :: fn(c, rest, tok) #prefix(.TK_NUM) = {
    ::if(*Node);
    node := if is_flonum(tok.ty) {
        n := c.new_node(.ND_NUM, tok);
        n.r = c.f.getcon(tok.fval.bitcast());
        c.f.get_constant(n.r)[].flt = 2;
        n
    } else {
       c.new_num(tok.val, tok)
    };
    node.ty = tok.ty;
    rest[] = tok.next;
    node
};

unary_plus :: fn(c, rest, tok) #prefix(.@"+") = 
    c.parse_expr(rest, tok.next, .Unary);

unary_amp :: fn(c, rest, tok) #prefix(.@"&") = {
    lhs := c.parse_expr(rest, tok.next, .Unary);
    c.add_type(lhs);
    bf := lhs.kind == .ND_MEMBER && lhs.member.is_bitfield;
    !bf || @error_tok(c, tok, "cannot take address of bitfield");
    node := c.new_addr(lhs, tok);
    c.gen_expr(node);
    node
};

unary_star :: fn(c, rest, tok) #prefix(.@"*") = {
    // [https://www.sigbus.info/n1570#6.5.3.2p4] This is an oddity
    // in the C spec, but dereferencing a function shouldn't do
    // anything. If foo is a function, `*foo`, `**foo` or `*****foo`
    // are all equivalent to just `foo`.
    node := c.parse_expr(rest, tok.next, .Unary);
    c.add_type(node);
    node := if(node.ty.kind == .TY_FUNC, => node, => c.new_deref(node, tok));
    c.gen_expr(node);
    node
};

#prefix(.@"-", .ND_NEG) #prefix(.@"~", .ND_BITNOT) #prefix(.@"!", .ND_NOT) 
parse_unary :: fn(c, rest, tok) = {
    rule := rules.index(tok.kind);
    node := c.parse_expr(rest, tok.next, .Unary);
    node := c.new_unary(rule.op, node, tok);
    c.gen_expr(node);
    node
};

pre_inc :: fn(c, rest, tok) #prefix(.@"++") = { // Read ++i as i+=1
    lhs := c.parse_expr(rest, tok.next, .Unary);
    c.gen_expr(lhs);
    rhs := c.new_num(1, tok);
    c.new_add(lhs&, rhs&, tok);
    node := c.to_assign(.ND_ADD, lhs, rhs, tok);
    c.gen_expr(node);
    node
};

pre_dec :: fn(c, rest, tok) #prefix(.@"--") = { // Read --i as i-=1
    node := c.new_sub(c.parse_expr(rest, tok.next, .Unary), c.new_num(1, tok), tok);
    node := c.to_assign(node.kind, node.lhs, node.rhs, node.tok);
    c.gen_expr(node);
    node
};

// generic-selection = "(" assign "," generic-assoc ("," generic-assoc)* ")"
//
// generic-assoc = type-name ":" assign
//                             | "default" ":" assign
//
// This is just a switch statement over types. 
// A branch is chosen based on the ~type~ of the first expression. 
generic_selection :: fn(c, rest, tok) #prefix(._Generic) = {
    start := tok;
    tok = c.skip(tok.next, "(");

    ctrl := c.speculate(tok&, tok, .Assign);
    c.add_type(ctrl);

    t1 := ctrl.ty;
    t1 := @match(t1.kind) {
        fn TY_FUNC()  => c.pointer_to(t1);
        fn TY_ARRAY() => c.pointer_to(t1.base);
        @default => t1;
    };
    
    // Now choose one of the branches to use based on that type. 
    ret: ?*Node = .None;
    use_default := false; 
    while => !consume(rest, tok, ")") {
        tok = c.skip(tok, ",");

        if equal(tok, "default") {
            tok = c.skip(tok.next, ":");
            node := c.speculate(tok&, tok, .Assign);
            if ret.is_none() {
                ret = (Some = node);
                use_default = true;
            };
        } else {
            t2 := c.typename(tok&, tok);
            tok = c.skip(tok, ":");
            if is_compatible(t1, t2) {
                if ret.is_some() && !use_default {
                    @error_tok(c, tok, "conflicting branches for generic association type");  
                };
                node := c.parse_expr(tok&, tok, .Assign);
                ret = (Some = node);
                use_default = false;
            } else {
                _ := c.speculate(tok&, tok, .Assign);
            };
        };
    };
    node := ret || @error_tok(c, start, "controlling expression type not compatible with any generic association type");
    if use_default {
        // HACK: because default might not be the last case. 
        // this relies on gen_expr recursing. better would be to 
        // emit default into a different branch and discard the other one
        c.gen_expr(node);
    };
    node
};

sizeof :: fn(c, rest, tok) #prefix(.sizeof) = {
    start := tok;
    ty := if c.next_is_paren_typename(tok) {  // | "sizeof" "(" type-name ")"
        ty := c.typename(tok&, tok.next.next);
        rest[] = c.skip(tok, ")");
        ty
    } else {  // | "sizeof" unary
        node := c.speculate(rest, tok.next, .Unary);
        if(node.kind == .ND_MEMBER && node.member.is_bitfield, => @error_tok(c, tok, "sizeof(bitfield) is illegal"));
        node.ty
    };
    r := if(ty.kind == .TY_VLA, => c.compute_vla_size(ty), => c.f.getcon(ty.size.intcast()));
    c.ir_node(ty_ulong, r, QbeNull, start)
};

alignof :: fn(c, rest, tok) #prefix(._Alignof) = {
    start := tok;
    ty := if c.next_is_paren_typename(tok) {
        ty := c.typename(tok&, tok.next.next);
        rest[] = c.skip(tok, ")");
        ty
    } else {
        c.speculate(rest, tok.next, .Unary)[].ty
    };
    c.new_ulong(ty.align.intcast(), start)
};

prefix_ampamp :: fn(c, rest, tok) #prefix(.@"&&") = {
    label := c.get_ident(tok.next);
    @error_tok(c, tok, "[GNU] labels-as-values is not supported (name = %)", label);
};

// funcall = (assign ("," assign)*)? ")"
funcall :: fn(c, rest, tok, f) #infix(.@"(", .PostFix) = {
    tok = tok.next;
    c.add_type(f);

    if (f.ty.kind != .TY_FUNC && (f.ty.kind != .TY_PTR || f.ty.base.kind != .TY_FUNC)) {
        @error_tok(c, f.tok, "not a function");
    };

    ty := if(f.ty.kind == .TY_FUNC, => f.ty, => f.ty.base);
    param_ty := ty.params;

    head := Node.zeroed();
    cur := head&;
    while => !equal(tok, ")") {
        if !cur.identical(head&) {
            tok = c.skip(tok, ",");
        };

        arg := c.parse_expr(tok&, tok, .Assign);
        c.add_type(arg);

        if param_ty.is_null() && !ty.is_variadic {
            @error_tok(c, tok, "too many arguments");
        };

        if !param_ty.is_null() {
            if !@is(param_ty.kind, .TY_STRUCT, .TY_UNION) {
                arg = c.new_cast(arg, param_ty);
            };
            param_ty = param_ty.next;
        } else {
            if arg.ty.kind == .TY_FLOAT {
                // If parameter type is omitted (e.g. in "..."), float
                // arguments are promoted to double.
                arg = c.new_cast(arg, ty_double);
            };
        };
        
        cur.next = arg;
        cur = cur.next;
    };

    if(!param_ty.is_null(), => @error_tok(c, tok, "too few arguments"));

    rest[] = c.skip(tok, ")");

    node := c.new_unary(.ND_FUNCALL, f, tok);
    node.func_ty = ty;
    node.ty = ty.return_ty;
    node.args = head.next;

    // If a function returns a struct, it is caller's responsibility
    // to allocate a space for the return value.
    if @is(node.ty.kind, .TY_STRUCT, .TY_UNION) {
        node.ret_buffer = c.new_lvar("", node.ty);
    };;
    c.gen_expr(node);
    node
};

square :: fn(c, rest, tok, node) #infix(.@"[", .PostFix) = {
    // x[y] is short for *(x+y)
    start := tok;
    idx := c.parse_expr(tok&, tok.next, .None);
    c.new_add(node&, idx&, start);
    node := c.new_binary(.ND_ADD, node, idx, start);
    c.gen_expr(node);
    node := c.new_deref(node, start);
    set_rest_and_gen(c, rest, c.skip(tok, "]"), node)
};
dot :: fn(c, rest, tok, node) #infix(.@".", .PostFix) = {
    node := c.struct_ref(node, tok.next);
    set_rest_and_gen(c, rest, tok.next.next, node)
};
arrow :: fn(c, rest, tok, node) #infix(.@"->", .PostFix) = {
    // x->y is short for (*x).y
    node := c.new_deref(node, tok);
    node := c.struct_ref(node, tok.next);
    set_rest_and_gen(c, rest, tok.next.next, node)
};
post_inc :: fn(c, rest, tok, node) #infix(.@"++", .PostFix) = {
    node := c.new_inc_dec(node, tok, 1);
    set_rest_and_gen(c, rest, tok.next, node)
};
post_dec :: fn(c, rest, tok, node) #infix(.@"--", .PostFix) = {
    node := c.new_inc_dec(node, tok, -1);
    set_rest_and_gen(c, rest, tok.next, node)
};

return :: fn(c, rest, tok) #prefix(.return) = {
    if(consume(rest, tok.next, ";"), => return(c.new_node(.ND_STMT, tok)));  // return void
    exp := c.parse_expr(tok&, tok.next, .None);
    c.assert_gen_expr(exp);
    rest[] = c.skip(tok, ";");

    c.add_type(exp);
    current_fn := c.current_fn || @error_tok(c, tok, "stray return");
    ty := current_fn.ty.return_ty;
    if !@is(ty.kind, .TY_STRUCT, .TY_UNION) {
        exp = c.new_cast(exp, ty);
    };

    r := c.assert_gen_expr(exp);
    
    if c.b.jmp.type == .Jxxx {
        j := Qbe.J.retw;
        c.b.jmp = (type = j, arg = r);
    };
    c.new_node(.ND_STMT, tok)
};
if_ :: fn(c, rest, tok) #prefix(.if) = {
    then_block := c.new_block();
    else_block := c.new_block();
    join_block := c.new_block();

    tok = c.skip(tok.next, "(");
    cond := c.parse_expr(tok&, tok, .None);
    tok = c.skip(tok, ")");
    cond := c.assert_gen_expr(cond);
    
    c.jnz_if_unterminated(cond, then_block, else_block);
    
    c.b = then_block;
    c.stmt(tok&, tok);
    c.jmp_if_unterminated(join_block);
    
    c.b = else_block;
    if equal(tok, "else") {
        c.stmt(tok&, tok.next);
    };
    c.jmp_if_unterminated(join_block);
    
    c.b = join_block;
    rest[] = tok;
    c.new_node(.ND_STMT, tok)
};
switch_ :: fn(c, rest, tok) #prefix(.switch) = {
    payload := temp().box_zeroed(Qbe.SwitchPayload);
    tok = c.skip(tok.next, "(");
    cond := c.parse_expr(tok&, tok, .None);
    tok = c.skip(tok, ")");
    payload.inspect = c.assert_gen_expr(cond);
    // backend switch lowering wants a Kl, but we want zero extension, not sign extension like casting to a long would be. 
    if cond.ty.cls() != .Kl && !c.speculate {
        r := c.f.newtmp("c", .Kl);
        c.emit(.extuw, .Kl, r, payload.inspect, QbeNull);
        payload.inspect = r;
    };
    payload.src = c.b;
    payload.cases = new(0);
    
    if payload.src.jmp.type == .Jxxx && !c.speculate {
        payload.src.jmp.type = .switch;
    };

    sw := c.current_switch;
    c.current_switch = (Some = payload);
    brk := c.brk_label;
    brk_label := c.new_block(); 
    c.brk_label = (Some = brk_label);

    c.b = c.new_block();  // TODO: should be redundant
    c.stmt(rest, tok);
    c.jmp_if_unterminated(brk_label);
    c.current_switch = sw;
    c.brk_label = brk;
    c.b = brk_label;
    if payload.default.is_null() {
        payload.default = brk_label;
    };
    
    if payload.src.jmp.type == .switch {
        payload.src.jmp.arg = INT(c.f.switch_count.zext());
        if c.f.switch_count == 0 {
            c.f.switches = new(1);
        };
        push(c.f.switches&, c.f.switch_count&, payload[]);
    };
    c.new_node(.ND_STMT, tok)
};
case :: fn(c, rest, tok) #prefix(.case) = {
    unique_label := c.new_block();
    c.jmp_if_unterminated(unique_label);
    c.b = unique_label;
    current_switch := c.current_switch || @error_tok(c, tok, "stray case");
    
    begin := c.const_expr(tok&, tok.next);

    if equal(tok, "...") {
        end := c.const_expr(tok&, tok.next);
        if(end < begin, => @error_tok(c, tok, "empty case range specified"));
        @error_tok(c, tok, "[GNU] Case ranges are not supported (% ... %)", begin, end);
    };

    tok = c.skip(tok, ":");
    c.stmt(rest, tok);
    push(current_switch.cases&, current_switch.case_count&, (unique_label, begin));
    
    next_block := c.new_block();  // TODO: wasteful, empty block for consecutive cases. 
    c.jmp_if_unterminated(next_block);
    c.b = next_block;
    c.new_node(.ND_STMT, tok)
};
default :: fn(c, rest, tok) #prefix(.default) = {
    unique_label := c.new_block();
    c.jmp_if_unterminated(unique_label);
    c.b = unique_label;
    current_switch := c.current_switch || @error_tok(c, tok, "stray default");
    
    tok = c.skip(tok.next, ":");
    c.stmt(rest, tok);
    current_switch.default = unique_label;
    
    next_block := c.new_block();
    c.jmp_if_unterminated(next_block);
    c.b = next_block;
    c.new_node(.ND_STMT, tok)
};
for_ :: fn(c, rest, tok) #prefix(.for) = {
    _, _ := push_loop c { brk_label, cont_label |
        cond_block := c.new_block();
        body_block := c.new_block();
        
        c.enter_scope();
        tok = c.skip(tok.next, "(");
        if c.is_type_name(tok) {
            basety := c.declspec(tok&, tok, .None);
            tok = c.declaration(tok, basety, .None);
        } else {
            c.expr_stmt(tok&, tok);
        };
        c.jmp_if_unterminated(body_block);

        c.b = cond_block;
        cond := if !equal(tok, ";") {
            c.new_cast(c.parse_expr(tok&, tok, .None), ty_bool)
        } else {
            c.new_num(1, tok)  // wasteful to rely on folding for this 
        };
        cond := c.assert_gen_expr(cond);
        tok = c.skip(tok, ";");
        
        c.jnz_if_unterminated(cond, body_block, brk_label);

        c.b = cont_label;
        inc := if !equal(tok, ")") {
            c.parse_expr(tok&, tok, .None)
        } else {
            c.new_num(0, tok)  // nop
        };
        c.assert_gen_expr(inc);
        tok = c.skip(tok, ")");
        c.jmp_if_unterminated(cond_block);

        c.b = body_block;
        c.stmt(rest, tok);
        c.jmp_if_unterminated(cont_label);

        c.leave_scope();
        c.b = brk_label;
    };
    c.new_node(.ND_STMT, tok)
};
while_ :: fn(c, rest, tok) #prefix(.while) = {
    push_loop c { brk_label, cont_label |
        c.jmp_if_unterminated(cont_label);
        c.b = cont_label;
        tok = c.skip(tok.next, "(");
        cond := c.new_cast(c.parse_expr(tok&, tok, .None), ty_bool);
        cond := c.assert_gen_expr(cond);
        tok = c.skip(tok, ")");
        body_block := c.new_block();

        c.jnz_if_unterminated(cond, body_block, brk_label);
        
        c.b = body_block;
        c.stmt(rest, tok);
        c.jmp_if_unterminated(cont_label);
        c.b = brk_label;
    };
    c.new_node(.ND_STMT, tok)
};
do :: fn(c, rest, tok) #prefix(.do) = {
    body_block := c.new_block();
    c.jmp_if_unterminated(body_block);
    brk_label, cont_label := push_loop c { _, _ |
        c.b = body_block;
        c.stmt(tok&, tok.next);
    };
    c.jmp_if_unterminated(cont_label);  // goto condition
    
    c.b = cont_label;  
    tok = c.skip(tok, "while");
    tok = c.skip(tok, "(");
    cond := c.new_cast(c.parse_expr(tok&, tok, .None), ty_bool);
    cond := cond.r;
    tok = c.skip(tok, ")");
    rest[] = c.skip(tok, ";");
    
    c.jnz_if_unterminated(cond, body_block, brk_label);
    c.b = brk_label;
    c.new_node(.ND_STMT, tok)
};
asm :: fn(c, rest, tok) #prefix(.asm) = {
    tok = tok.next;
    dowhile {
        ignore(tok&, tok, @const_slice("volatile", "inline"))
    };
    tok = c.skip(tok, "(");
    if tok.kind != .TK_STR || tok.ty.base.kind != .TY_CHAR {
        @error_tok(c, tok, "expected string literal");
    };
    rest[] = c.skip(tok.next, ")");
    @error_tok(c, tok, "asm stmt is not supported");
};
goto :: fn(c, rest, tok) #prefix(.goto) = {
    if equal(tok.next, "*") {
        _dest := c.parse_expr(tok&, tok.next.next, .None);
        @error_tok(c, tok, "[GNU] labels-as-values is not supported (goto *ptr)");
    };

    unique_label := c.get_block(c.get_ident(tok.next));
    c.jmp_if_unterminated(unique_label);
    rest[] = c.skip(tok.next.next, ";");
    c.b = c.new_block();
    c.new_node(.ND_STMT, tok)
};
break :: fn(c, rest, tok) #prefix(.break) = {
    brk_label := c.brk_label || @error_tok(c, tok, "stray break");
    unique_label := brk_label;
    rest[] = c.skip(tok.next, ";");
    c.jmp_if_unterminated(brk_label);
    c.b = c.new_block();
    c.new_node(.ND_STMT, tok)
};
continue :: fn(c, rest, tok) #prefix(.continue) = {
    cont_label := c.cont_label || @error_tok(c, tok, "stray continue");
    unique_label := cont_label;
    rest[] = c.skip(tok.next, ";");
    c.jmp_if_unterminated(cont_label);
    c.b = c.new_block();
    c.new_node(.ND_STMT, tok)
};
block :: fn(c, rest, tok) #prefix(.@"{") = {
    c.compound_stmt(rest, tok.next);
    c.new_node(.ND_STMT, tok)
};
empty_stmt :: fn(c, rest, tok) #prefix(.@";") = {
    rest[] = tok.next;
    c.new_node(.ND_STMT, tok)
};

};

fn set_rest_and_gen(c: *Ctx, rest: **Token, tok: *Token, node: *Node) *Node = {
    rest[] = tok;
    c.gen_expr(node);
    node
}

fn stmt(c: *Ctx, rest: **Token, tok: *Token) *Node = {
    node := c.parse_expr(rest, tok, .Stmt);
    if node.kind != .ND_STMT {
        consume(rest, rest[], ";");
    };
    node
}

// In C, `+` operator is overloaded to perform the pointer arithmetic.
// If p is a pointer, p+n adds not n but sizeof(*p)*n to the value of p,
// so that p+n points to the location n elements (not bytes) ahead of p.
// In other words, we need to scale an integer value before adding to a
// pointer value. This function takes care of the scaling.
fn new_add(c: *Ctx, lhs: **Node, rhs: **Node, tok: *Token) void = {
    //c.add_type(lhs);
    //c.add_type(rhs);
    c.gen_expr(lhs[]);
    c.gen_expr(rhs[]);

    // num + num
    if is_numeric(lhs.ty) && is_numeric(rhs.ty) {
        return();
    };

    if !lhs.ty.base.is_null() && !rhs.ty.base.is_null() {
        @error_tok(c, tok, "invalid operands");
    };

    // Canonicalize `num + ptr` to `ptr + num`.
    if lhs.ty.base.is_null() && !rhs.ty.base.is_null() {
        t := lhs[]; lhs[] = rhs[]; rhs[] = t;
    };

    // VLA + num
    if lhs.ty.base.kind == .TY_VLA {
        vla_size := c.ir_node(ty_ulong, lhs.ty.base.vla_size, QbeNull, tok);
        rhs[] = c.new_binary2(.ND_MUL, rhs[], vla_size, tok);
        return();
    };

    // ptr + num
    rhs[] = c.new_binary2(.ND_MUL, rhs[], c.new_long(lhs.ty.base.size.intcast(), tok), tok);
}

fn new_binary2(c: *Ctx, kind: NodeKind, lhs: *Node, rhs: *Node, tok: *Token) *Node = {
    if c.speculate {
        return(c.new_binary(kind, lhs, rhs, tok));
    };
    @debug_assert(!@is(kind, .ND_ASSIGN, .ND_COMMA), "new_binary2 doesn't work with %", kind);
    out_ty := c.add_type(kind, lhs&, rhs&);
    c.gen_expr(lhs);
    c.gen_expr(rhs);
    @debug_assert(lhs.r != QbeNull && rhs.r != QbeNull, "new_binary missing evaluated args");
    r := c.gen_binary(kind, lhs.r, rhs.r, out_ty, lhs.ty, tok);
    c.ir_node(out_ty, r, QbeNull, tok)
}

// Like `+`, `-` is overloaded for the pointer type.
fn new_sub(c: *Ctx, lhs: *Node, rhs: *Node, tok: *Token) *Node = {
    @if_else {
        // num - num
        @if(is_numeric(lhs.ty) && is_numeric(rhs.ty)) => {
            node := c.new_binary(.ND_SUB, lhs, rhs, tok);
            c.gen_expr(node);
            node
        };
        // VLA - num
        @if(lhs.ty.base.kind == .TY_VLA) => {
            vla_size := c.ir_node(ty_ulong, lhs.ty.base.vla_size, QbeNull, tok);
            rhs = c.new_binary2(.ND_MUL, rhs, vla_size, tok);
            node := c.new_binary(.ND_SUB, lhs, rhs, tok);
            node.ty = lhs.ty;
            c.gen_expr(node);
            node
        };
        // ptr - num
        @if(!lhs.ty.base.is_null() && is_integer(rhs.ty)) => {
            rhs = c.new_binary2(.ND_MUL, rhs, c.new_long(lhs.ty.base.size.intcast(), tok), tok);
            node := c.new_binary(.ND_SUB, lhs, rhs, tok);
            node.ty = lhs.ty;
            c.gen_expr(node);
            node
        };
        // ptr - ptr, which returns how many elements are between the two.
        @if(!lhs.ty.base.is_null() && !rhs.ty.base.is_null()) => {
            node := c.new_binary(.ND_SUB, lhs, rhs, tok);
            node.ty = ty_long;
            node := c.new_binary(.ND_DIV, node, c.new_num(lhs.ty.base.size.intcast(), tok), tok);
            c.gen_expr(node);
            node
        };
        @else => @error_tok(c, tok, "invalid operands");
    }
};

fn get_struct_member(ty: *CType, name: *Token) ?*Member = {
    mem := ty.members;
    for_linked mem { mem |
        is_anon := (@is(mem.ty.kind, .TY_STRUCT, .TY_UNION)) && mem.name.is_null();
        if is_anon {
            if get_struct_member(mem.ty, name) { _ |
                return(Some = mem);
            };
        } else {
            if(mem.name.str() == name.str(), => return(Some = mem));
        };
    };
    .None
}

// Create a node representing a struct member access, such as foo.bar
// where foo is a struct and bar is a member name.
//
// C has a feature called "anonymous struct" which allows a struct to
// have another unnamed struct as a member like this:
//
//     struct { struct { int a; }; int b; } x;
//
// The members of an anonymous struct belong to the outer struct's
// member namespace. Therefore, in the above example, you can access
// member "a" of the anonymous struct as "x.a".
//
// This function takes care of anonymous structs.
fn struct_ref(c: *Ctx, node: *Node, tok: *Token) *Node = {
    c.add_type(node);
    ty := node.ty;
    has_fields := @is(ty.kind, .TY_STRUCT, .TY_UNION);
    if(!has_fields, => @error_tok(c, node.tok, "not a struct nor a union (%, %)", node.kind, ty.kind));
    loop {
        mem := get_struct_member(ty, tok) || @error_tok(c, tok, "no such member");
        node = c.new_unary(.ND_MEMBER, node, tok);
        node.member = mem;
        if(!mem.name.is_null(), => return(node));
        ty = mem.ty;
    }
}

// Convert A++ to `(typeof A)((A += 1) - 1)`
fn new_inc_dec(c: *Ctx, node: *Node, tok: *Token, addend: i64) *Node = {
    c.add_type(node);
    rhs := c.new_num(addend, tok);
    c.new_add(node&, rhs&, tok);
    nn := c.to_assign(.ND_ADD, node, rhs, tok);
    nnn := c.new_num(-addend, tok);
    c.new_add(nn&, nnn&, tok);
    nnnn := c.new_binary(.ND_ADD, nn, nnn, tok);
    c.new_cast(nnnn, node.ty)
}

// for expressions that don't get evaluated (like sizeof, alignof, typeof),
// we just mask out all the emitted instructions/jumps. 
fn speculate(c: *Ctx, rest: **Token, tok: *Token, prec: Prec) *Node = {
    old_block := c.b;
    prev := c.speculate;
    c.speculate = true;
    node := c.parse_expr(rest, tok, prec);
    c.speculate = prev;
    new_block := c.b;
    if !old_block.identical(new_block) {
        c.b = old_block;
        c.jmp_if_unterminated(new_block);
        c.b = new_block;
    };
    c.add_type(node);
    node
}

fn primary(rest: **Token, tok: *Token) *Node = { // TODO
    Token *start = tok;
    @if_else {
        @if(equal(tok, "__builtin_types_compatible_p")) => {
            tok = c.skip(tok.next, "(");
            t1 := typename(tok&, tok);
            tok = c.skip(tok, ",");
            t2 := typename(tok&, tok);
            rest[] = c.skip(tok, ")");
            c.new_num(is_compatible(t1, t2), start)
        }
    };

    if (equal(tok, "__builtin_reg_class")) {
        tok = c.skip(tok.next, "(");
        ty := typename(tok&, tok);
        rest[] = c.skip(tok, ")");

        if(is_integer(ty) || ty.kind == .TY_PTR, => return(new_num(0, start)));
        if(is_flonum(ty), return(new_num(1, start));
        return(new_num(2, start));
    };

    if equal(tok, "__builtin_compare_and_swap") {
        node := c.new_node(.ND_CAS, tok);
        tok = c.skip(tok.next, "(");
        node.cas_addr = assign(tok&, tok);
        tok = c.skip(tok, ",");
        node.cas_old = assign(tok&, tok);
        tok = c.skip(tok, ",");
        node.cas_new = assign(tok&, tok);
        rest[] = c.skip(tok, ")");
        return(node);
    };

    if equal(tok, "__builtin_atomic_exchange") {
        node := c.new_node(.ND_EXCH, tok);
        tok = c.skip(tok.next, "(");
        node.lhs = assign(tok&, tok);
        tok = c.skip(tok, ",");
        node.rhs = assign(tok&, tok);
        rest[] = c.skip(tok, ")");
        return(node);
    };

    @error_tok(c, tok, "expected an expression");
}

fn eval(c: *Ctx, node: *Node) i64 = {
    off, label := c.eval2(node);
    if label.is_some() {
        @error_tok(c, node.tok, "expected a numeric constant");
    };
    off
}

// Evaluate a given node as a constant expression.
//
// A constant expression is either just a number or ptr+n where ptr
// is a pointer to a global variable and n is a postiive/negative
// number. The latter form is accepted only as an initialization
// expression for a global variable.
fn eval2(c: *Ctx, node: *Node) Ty(i64, ?CStr) = {  // (off, label)
    if !c.is_const_expr(node) {
        @error_tok(c, node.tok, "expected a constant expression");
    };
    
    // verbose sign extension:
    if node.ty.is_integer() && node.ty.size != 8 && !node.ty.is_unsigned {
        prev := c.speculate; // HACK
        c.speculate = false;
        //@println("% %", node.r, c.speculate);
        node = c.new_cast(node, ty_long);
        c.speculate = prev;
        //@println("%", node.r);
    };
    
    r := if(node.kind == .ND_ADDR, => node.lhs.lvalue, => node.r);
    if rtype(r) != .RCon {
        @error_tok(c, node.tok, "ICE: unevaluated constant");
    };
    con := c.f.get_constant(r);
    label: ?CStr = @if(con.type == .CAddr, (Some = c.m.str(con.sym.id).slow_convert_to_c_string()), .None);
    (con.bits.i, label)
}

//static int64_t eval_rval(Node *node, char ***label);

fn is_const_expr(c: *Ctx, node: *Node) bool = { 
    rtype(node.r) == .RCon || (node.kind == .ND_ADDR && node.lhs.lvalue.rtype() == .RCon)
}

fn const_expr(c: *Ctx, rest: **Token, tok: *Token) i64 = {
    node := c.parse_expr(rest, tok, .Conditional);
    c.eval(node)
}

fn eval_double(c: *Ctx, node: *Node) f64 = { 
    // verbose extension:
    {
        prev := c.speculate; // HACK
        c.speculate = false;
        node = c.new_cast(node, ty_double);
        c.speculate = prev;
    };
    
    if rtype(node.r) != .RCon {
        @error_tok(c, node.tok, "ICE: unevaluated constant");
    };
    con := c.f.get_constant(node.r);
    ::enum(@type con.type);
    @debug_assert_eq(con.type, .CBits);
    con.bits.d
}

// Convert op= operators to expressions containing an assignment.
//
// In general, `A op= C` is converted to ``tmp = &A, *tmp = *tmp op B`.
// However, if a given expression is of form `A.x op= C`, the input is
// converted to `tmp = &A, (*tmp).x = (*tmp).x op C` to handle assignments
// to bitfields.
fn to_assign(c: *Ctx, kind: NodeKind, lhs: *Node, rhs: *Node, tok: *Token) *Node = {
    if c.speculate {
        return(lhs);
    };
    //c.add_type(lhs);
    //c.add_type(rhs);
    
    is_bitfield := lhs.kind == .ND_MEMBER && lhs.member.is_bitfield;

    // If A is an atomic type, Convert `A op= B` to
    //
    // ({
    //     T1 *addr = &A; T2 val = (B); T1 old = *addr; T1 new;
    //     do {
    //        new = old op val;
    //     } while (!atomic_compare_exchange_strong(addr, &old, new));
    //     new;
    // })
    if lhs.ty.is_atomic && !is_bitfield {
        @error_tok(c, tok, "TODO: to_assign for _Atomic types");
    };

    // n1570#6.5.16p3: An assignment expression has the value of the left operand after the assignment, but is not an lvalue. 
    // Convert `A op= B` to ``tmp = &A, *tmp = *tmp op B`.
    // Bitfields need special handling because their address can't be taken. 

    //@match(kind) {
    //    fn ND_ADD() => c.new_add();
    //    fn ND_SUB() => c.new_sub();
    //    @default => ();
    //};
    
    addr  := c.gen_addr(lhs);
    delta := c.gen_cast(c.gen_expr(rhs), rhs.ty, lhs.ty, tok);
    start := if is_bitfield {
        c.gen_load_bitfield(addr, lhs.member)
    } else {
        c.gen_load(addr, lhs.ty)
    };
    final := c.gen_binary(kind, start, delta, lhs.ty, lhs.ty, tok);
    if is_bitfield {
        // this generates silly code that loads the other fields with the same storage again even though we already did that, but whatever
        c.gen_store_bitfield(addr, final, lhs.member);
    } else {
        c.gen_store(addr, final, lhs.ty);
    };
    
    c.ir_node(lhs.ty, final, QbeNull, tok)
}

fn ir_node(c: *Ctx, ty: *CType, r: Qbe.Ref, lvalue: Qbe.Ref, tok: *Token) *Node = {
    n := c.new_node(.ND_NULL_EXPR, tok);
    n.r = r;
    n.lvalue = lvalue;
    n.ty = ty;
    n
}

/*******************
*   Ir-ish Stuff   *
********************/

fn new_block(c: *Ctx) *Qbe.Blk = {
    f := c.f;
    f.rpo&.grow(f.nblk.zext() + 1);
    b := newblk();
    @if(TRACK_IR_NAMES) {
        l := fixed_list(b.name&.items()); // :UnacceptablePanic
        @fmt(l&, "%", f.nblk);
    };
    b.id = f.nblk;
    f.rpo[f.nblk.zext()] = b;
    f.nblk += 1;
    b.ins = new(0);
    b
}

fn get_block(c: *Ctx, name: Str) *Qbe.Blk = {
    c.labels&.get(name) || {
        b := c.new_block();
        c.labels&.insert(name, b);
        b
    }
}

fn jmp_if_unterminated(c: *Ctx, dest: *Qbe.Blk) void = {
    if c.b.jmp.type == .Jxxx && !c.speculate {
        c.b.s1 = dest;
        c.b.jmp.type = .jmp;
    };
}

fn jnz_if_unterminated(c: *Ctx, cond: Qbe.Ref, then: *Qbe.Blk, else: *Qbe.Blk) void = {
    if c.b.jmp.type == .Jxxx && !c.speculate {
        c.b.jmp = (type = .jnz, arg = cond);
        c.b.s1 = then;
        c.b.s2 = else;
    };
}

fn link_blocks_from_rpo(f: *Qbe.Fn) void = {
    prev := Qbe.Blk.ptr_from_int(0);
    for_rev f.rpo.slice(0, f.nblk.zext()) { b | 
        b.link = prev;
        prev = b;
    };
}

fn emit(c: *Ctx, op: Qbe.O, k: Qbe.Cls, to: Qbe.Ref, arg0: Qbe.Ref, arg1: Qbe.Ref) void = {
    @if(SPAM) @println("O % =% % % %", to, k, op, arg0, arg1);
    push(c.b, make_ins(op, k, to, arg0, arg1));
}

// TODO: should be with create_param_lvars instead of being super hacky
fn gen_par(c: *Ctx) void = {
    obj := c.current_fn.expect("gen_par() in function context");
    f := c.f; 
    f.start = c.new_block();
    c.b = f.start;
    
    loc := obj.params;
    for_linked loc { loc |
        loc.par_r = f.newtmp("c", .Kl);
        // TODO: other types + parc
        emit(c, .par, .Kl, loc.par_r, QbeNull, QbeNull); 
    };
    for_linked loc { var | // HACK
        c.create_stack_slot(var);
    };
    // some instructions (par/alloc) will always go in f.start, real code goes in its own block. 
    // but since all vars get stack slots, we need to store any scalar arguments. 
    body := c.new_block();
    c.jmp_if_unterminated(body);
    for_linked loc { loc |
        c.gen_store(loc.stack_slot, loc.par_r, loc.ty);
    };
    c.b = body;
}

fn assert_gen_expr(c: *Ctx, node: *Node) Qbe.Ref = {
    @debug_assert(node.r != QbeNull);    
    node.r
}

fn gen_expr(c: *Ctx, node: *Node) Qbe.Ref = {
    if(node.r != QbeNull, => return(node.r));
    c.add_type(node);
    if(c.f.is_null() || c.speculate, => return(node.r));
    prev := c.b;
    if !node.current_block.is_null() {  // HACK. should go away as i emit code more incrementally. 
        c.b = node.current_block;
    };
    node.r = c.gen_expr_inner(node);
    c.b = prev;
    node.r
}

fn gen_expr_inner(c: *Ctx, node: *Node) Qbe.Ref = {
    ::enum(NodeKind);
    @if(SPAM) @println("E % %; %", node.kind, Node.int_from_ptr(node), node.tok.str());
    @match(node.kind) {
        fn ND_NULL_EXPR() => QbeUndef;
        fn ND_STMT() => QbeUndef;
        fn ND_FUNCALL() => c.gen_call(node);
        fn ND_ADDR()    => c.gen_addr(node.lhs);
        fn ND_CAST() => {
            ::enum(TypeKind);
            source := c.gen_expr(node.lhs);
            from, to := (node.lhs.ty, node.ty);
            if(to.kind == .TY_VOID, => return(QbeUndef));
            c.gen_cast(source, from, to, node.tok)
        }
        fn ND_VAR() => {
            if node.var.is_function {
                r := c.f.symcon(c.m.mangle(node.var));
                return(r);
            };
            addr := c.gen_addr(node); 
            c.gen_load(addr, node.ty)
        }
        fn ND_DEREF() => {
            addr := c.gen_expr(node.lhs);
            c.gen_load(addr, node.ty)
        }
        fn ND_NEG() => {
            arg := c.assert_gen_expr(node.lhs);
            c.emit(.neg, node.ty.cls(), arg, QbeNull)
        }
        fn ND_BITNOT() => {
            arg := c.assert_gen_expr(node.lhs);
            c.emit(.xor, node.ty.cls(), arg, c.f.getcon(-1))
        }
        fn ND_NOT() => {  // TODO: do the trick with redirecting jump targets to emit better code when this is in an if condition. 
            arg := c.assert_gen_expr(node.lhs);
            // not just xor with 1 bit. it might not be a _Bool. 
            op_eq := cmp_base(node.lhs.ty.cls());
            c.emit(op_eq, .Kl, arg, QbeConZero)
        }
        fn ND_COMMA() => {
            _ := c.gen_expr(node.lhs);
            c.gen_expr(node.rhs)
        }
        fn ND_MEMZERO() => {
            dest := node.var.stack_slot;
            size: i64 = node.var.ty.size.intcast();
            off := 0;
            each blit_op_table { o |
                while => size >= o.size {
                    d := c.f.newtmp("c", .Kl);
                    c.emit(.add, .Kl, d, dest, c.f.getcon(off));
                    c.emit(o.store, .Kw, QbeNull, QbeConZero, d);
                    size -= o.size;
                    off  += o.size;
                };
            };
            
            QbeUndef
        }
        fn ND_ASSIGN() => { 
            addr  := c.gen_addr(node.lhs);
            value := c.assert_gen_expr(node.rhs);
            if node.lhs.kind == .ND_MEMBER && node.lhs.member.is_bitfield {
                c.gen_store_bitfield(addr, value, node.lhs.member);
            } else {
                c.gen_store(addr, value, node.ty);
            };
            value
        }
        fn ND_MEMBER() => {
            addr := c.gen_addr(node); 
            
            r := if node.member.is_bitfield {
                c.gen_load_bitfield(addr, node.member)
            } else {
                c.gen_load(addr, node.ty)
            };
            r
        }
        fn ND_COND() => {
            c.gen_expr(node.cond);
            c.gen_expr(node.then);
            c.gen_expr(node.else);
            QbeUndef // TODO: this is confusing but this is called before the phi is created in conditional()
        };
        @default => {
            if node.lhs.is_null() || node.rhs.is_null() || node.ty.is_null() {
                @error_tok(c, node.tok, "gen_binary invalid arg for %", node.kind);
            };
            lhs_r := c.gen_expr(node.lhs);
            rhs_r := c.gen_expr(node.rhs);
            c.gen_binary(node.kind, lhs_r, rhs_r, node.ty, node.lhs.ty, node.tok)
        };
    }
}

// Read the current value from memory and merge it with a new value.
fn gen_store_bitfield(c: *Ctx, addr: Qbe.Ref, value: Qbe.Ref, mem: *Member) void = {
    @debug_assert(mem.is_bitfield);
    k := mem.ty.cls();
    r := @uninitialized Array(Qbe.Ref, 4); r := r&;
    each r { it |
        it[] = c.f.newtmp("c", k);
    };
    
    prev := c.gen_load(addr, mem.ty);
    mask := 1.shift_left(mem.bit_width.intcast()) - 1;
    c.emit(.and, k, r[0], value, c.f.getcon(mask));
    c.emit(.shl, k, r[1], r[0], c.f.getcon(mem.bit_offset.intcast()));
    mask := mask.shift_left(mem.bit_offset.intcast()).bit_not();
    c.emit(.and, k, r[2], prev, c.f.getcon(mask));
    c.emit(.or, k, r[3], r[2], r[1]);
    
    c.gen_store(addr, r[3], mem.ty);
}

// TODO: you'd think gen_store_bitfield should call this
fn gen_load_bitfield(c: *Ctx, addr: Qbe.Ref, mem: *Member) Qbe.Ref = {
    @debug_assert(mem.is_bitfield);
    r := c.gen_load(addr, mem.ty);
    k := mem.ty.cls();
    r1, r2 := (c.f.newtmp("c", k), c.f.newtmp("c", k));
    c.emit(.shl, k, r1, r, c.f.getcon(64 - mem.bit_width.intcast() - mem.bit_offset.intcast()));
    o: Qbe.O = @if(mem.ty.is_unsigned, .shr, .sar);
    c.emit(o, k, r2, r1, c.f.getcon(64 - mem.bit_width.intcast()));
    r2
}

fn gen_binary(c: *Ctx, kind: NodeKind, lhs_r: Qbe.Ref, rhs_r: Qbe.Ref, out_ty: *CType, ctrl_ty: *CType, tok: *Token) Qbe.Ref = {
    o: Qbe.O = @match(kind) {
        fn ND_COMMA()    => return(rhs_r);
        fn ND_ADD()      => .add;
        fn ND_SUB()      => .sub;
        fn ND_MUL()      => .mul;
        fn ND_DIV()      => if(out_ty.is_unsigned, => .udiv, => .div);
        fn ND_MOD()      => if(out_ty.is_unsigned, => .urem, => .rem);
        fn ND_BITAND()   => .and;
        fn ND_BITOR()    => .or;
        fn ND_BITXOR()   => .xor;
        fn ND_SHL()      => .shl;
        fn ND_SHR()      => if(out_ty.is_unsigned, => .shr, => .sar);
        fn ND_EQ()       => ctrl_ty.cls().cmp_base();
        fn ND_NE()       => ctrl_ty.cls().cmp_ne();
        fn ND_LT()       => @match(ctrl_ty.cls()) {
            fn Kw() => if(ctrl_ty.is_unsigned, => .cultw, => .csltw);
            fn Kl() => if(ctrl_ty.is_unsigned, => .cultl, => .csltl);
            fn Ks() => .clts;
            fn Kd() => .cltd;
            @default => panic("bad cls");
        };
        fn ND_LE()       => @match(ctrl_ty.cls()){
            fn Kw() => if(ctrl_ty.is_unsigned, => .culew, => .cslew);
            fn Kl() => if(ctrl_ty.is_unsigned, => .culel, => .cslel);
            fn Ks() => .cles;
            fn Kd() => .cled;
            @default => panic("bad cls");
        };
        @default => @panic("unexpected binary expression but found: %", kind);
    };
    c.emit(o, out_ty.cls(), lhs_r, rhs_r)
}

fn emit(c: *Ctx, o: Qbe.O, k: Qbe.Cls, a0: Qbe.Ref, a1: Qbe.Ref) Qbe.Ref = {
    // :FrontendConstantFolding
    // The backend will do more aggressive constant folding later, 
    // but there are some language constructs that require 
    // known constants in the frontend (ie. array types). 
    // TODO: this needs to work at top level as well
    if can_fold(o) && rtype(a0) == .RCon && (@is(rtype(a1), .RCon, .RNull)) {
        a1 := if(a1 == QbeNull, => QbeConZero, => a1);
        lhs_c, rhs_c := (c.f.get_constant(a0), c.f.get_constant(a1));
        if try_fold(o, k, lhs_c, rhs_c) { result |
            return(c.f.newcon(result&));
        };
    };
    
    r := c.f.newtmp("c", k);
    c.emit(o, k, r, a0, a1);
    r
}
#use(Types);

// TODO: audit this. chibicc has a big table of x64 mnemonics to compare to. 
fn gen_cast(c: *Ctx, src: Qbe.Ref, from: *CType, to: *CType, tok: *Token) Qbe.Ref = {
    // array types know thier size for sizeof but when we look at size below we want to have decayed to a pointer. 
    from := @if(from.kind == .TY_ARRAY, ty_ulong, from);
    to   := @if(to.kind == .TY_ARRAY, ty_ulong, to);
    
    k_from, k_to := (from.cls(), to.cls());
    p_from, p_to := (from.get_type_id(), to.get_type_id());
    ::enum(@type p_from);
    @if(SPAM) @println("cast % % % -> %", src, from.kind, p_from, p_to);
    if !(c.speculate || src != QbeNull) {
        @error_tok(c, tok, "ICE: tried to cast Null ref");
    };
    if(p_from == p_to, => return(src));
    if p_to == .B {  
        // TODO: do i need to zero extend byte/short? 
        return(c.emit(cmp_ne(k_from), k_to, src, QbeConZero))
    };
    o: Qbe.O = if !k_to.is_int() {
        @match(p_from) {
            fn U64() => .ultof;
            fn I64() => .sltof;
            fn U32() => .uwtof;
            fn I32() => .swtof;
            fn F32() => .exts;
            fn F64() => .truncd;
            @default => {
                //  bool/byte/short to float/double cast
                src = c.gen_cast(src, from, ty_long, tok);
                .sltof
            };
        }
    } else {  // k_to is integer
        if(to.size == from.size && k_to == k_from, => return(src));  // if sizes are equal, it's a signedness cast which does nothing 
        if k_from.is_int() && to.size < from.size {
            // `(char) 256` needs to truncate
            mask := 1.shift_left(to.size.intcast() * 8) - 1;
            return(c.emit(.and, k_to, src, c.f.getcon(mask)));
        };
        @match(p_from) {
            fn B()   => .extub;
            fn U8()  => .extub;
            fn I8()  => .extsb;
            fn U16() => .extuh;
            fn I16() => .extsh;
            fn U32() => .extuw;
            fn I32() => .extsw;
            fn F32() => @if(to.is_unsigned, .stoui, .stosi);
            fn F64() => @if(to.is_unsigned, .dtoui, .dtosi);
            @default => @panic("bad type! % % % to % % %", p_from, k_from, from.kind, p_to, k_to, to.kind);  // *u64 is just a signedness cast
        }
    };

    c.emit(o, k_to, src, QbeNull)
}

fn gen_call(c: *Ctx, node: *Node) Qbe.Ref #once = {
    // TODO: don't just take random variable names!
    //       call this __builtin_alloca and provide alloca.h
    if node.lhs.kind == .ND_VAR && node.lhs.var.name.str() == "alloca" {
        size := c.gen_expr(node.args);
        r := c.f.newtmp("alloca", .Kl);
        c.emit(.alloc16, .Kl, r, size, QbeNull);
        return(r);
    };

    variadic_marker_index := 0;
    if node.lhs.ty.is_variadic {
        t := node.lhs.ty.params;
        for_linked t { t |
            variadic_marker_index += 1;
        };
    } else {
        variadic_marker_index = -1;
    };
    
    arguments := list(Qbe.Ins, temp());
    arg := node.args;
    for_linked arg { arg |
        if variadic_marker_index == 0 {
            arguments&.push(make_ins(.argv, .Kw, QbeNull, QbeNull, QbeNull));
        };
        variadic_marker_index -= 1;
        
        r := c.gen_expr(arg);
        // TODO: argc and other types
        arguments&.push(make_ins(.arg, arg.ty.cls(), QbeNull, r, QbeNull));
    };
    
    ::ptr_utils(Obj);
    assert(node.ret_buffer.is_null(), "TODO: aggragate returns");
    for arguments { i |    
        c.b.push(i);
    };
    
    callee := c.gen_expr(node.lhs);
    r := c.f.newtmp("c", .Kl); // TODO: other types
    c.emit(.call, .Kl, r, callee, QbeNull);
    r
}

fn gen_store(c: *Ctx, addr: Qbe.Ref, value: Qbe.Ref, ty: *CType) void = {
    if @is(ty.kind, .TY_STRUCT, .TY_UNION) {
        c.emit(.blit0, .Kw, QbeNull, value, addr);  // src, dest because we hate ourselves
        c.emit(.blit1, .Kw, QbeNull, INT(ty.size.intcast()), QbeNull);
        return();
    };
    if @is(ty.kind, .TY_DOUBLE, .TY_LDOUBLE) {
        c.emit(.stored, .Kw, QbeNull, value, addr);
        return();
    };
    if ty.kind == .TY_FLOAT {
        c.emit(.stores, .Kw, QbeNull, value, addr);
        return();
    };
    
    o: Qbe.O = @switch(ty.size) {
        @case(1) => .storeb;
        @case(2) => .storeh;
        @case(4) => .storew;
        @case(8) => .storel;
        @default => panic("invalid int size");
    };
    c.emit(o, .Kw, QbeNull, value, addr);
}

fn gen_load(c: *Ctx, addr: Qbe.Ref, type: *CType) Qbe.Ref = {
    if @is(type.kind, .TY_ARRAY, .TY_STRUCT, .TY_UNION, .TY_FUNC, .TY_VLA) {
        return(addr);  // really?
    };
    k := type.cls();
    r := c.f.newtmp("c", k);
    if @is(type.kind, .TY_DOUBLE, .TY_LDOUBLE, .TY_FLOAT) {
        c.emit(.load, k, r, addr, QbeNull);
        return(r);
    };
    o: Qbe.O = @switch(type.size) {
        @case(1) => @if(type.is_unsigned, .loadub, .loadsb);
        @case(2) => @if(type.is_unsigned, .loaduh, .loadsh);
        @case(4) => @if(type.is_unsigned, .loaduw, .loadsw);
        @case(8) => .load;
        @default => panic("invalid int size");
    };
    c.emit(o, k, r, addr, QbeNull);
    r
}

fn gen_addr(c: *Ctx, node: *Node) Qbe.Ref = {
    if node.lvalue != QbeNull {
        return(node.lvalue);
    };
    r := c.gen_addr_inner(node);
    node.lvalue = r;
    r
}

fn gen_addr_inner(c: *Ctx, node: *Node) Qbe.Ref = {
    @match(node.kind) {
        fn ND_DEREF() => c.gen_expr(node.lhs);
        fn ND_VAR() => if !node.var.is_local {
            c.f.symcon(c.m.mangle(node.var))
        } else {
            node.var.stack_slot
        };
        fn ND_MEMBER() => {
            base := c.gen_addr(node.lhs);
            c.emit(.add, .Kl, base, c.f.getcon(node.member.offset.intcast()))
        }
        fn ND_COMMA() => {
            c.gen_expr(node.lhs);
            c.gen_addr(node.rhs)
        }
        fn ND_VLA_PTR() => {
            node.var.stack_slot
        }
        @default => {
            // TODO: compiler bug
            yy := @is(node.kind, .ND_ASSIGN, .ND_COND);
            xx := @is(node.ty.kind, .TY_STRUCT, .TY_UNION);
            if yy && xx {
                return(c.gen_expr(node));
            };
            @error_tok(c, node.tok, "TODO: gen_addr %", node.kind)
        };
    }
}
