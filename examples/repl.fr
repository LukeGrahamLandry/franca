#include_std("lib/core.fr");
#include_std("compiler/lib.fr");

BOOTSTRAP_ONLY_MODE :: false;
DEBUG_SPAM_LOG :: false;
ENABLE_TRACY :: false;
ENABLE_LOGGING_CALLBACKS :: false;
DO_TERMINAL_COLOURS :: true;

allocator :: libc_allocator;

::eprintln("note: this program embeds a copy of the compiler. \nit can't run in the old jit backend, you have to use examples/default_driver.fr\nif you did that wrong you'll find out real soon!");

fn main() void = {
    // TODO: call functions directly instead of through the vtable and then we don't have to compile the llvm backend
    vtable := init_driver_vtable();
    update_global_stdlib_path();
    prelude := "#include_std(\"lib/core.fr\");\n";
    comp := {vtable.init_compiler}(vtable.default_build_options()); // TODO: comptime get the current arch
    c := vtable.with(comp);
    file := c.add_file("repl!", prelude);
    self := c.data.cast()[][];
    id := self.parser.push_parse(prelude, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RsVec(FatStmt), stmts); // TODO: don't return RsVec -- Jun 29
    stmts := stmts.items();
    {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts).unwrap();
    
    // TODO: these numbers are experimentally where it happens to put the prelude constants right now. should do something more robust where you can ask it. 
    scope_id := self.scopes.new_scope(TOP_LEVEL_SCOPE, self.get_alloc(), file);
    scope := self.scopes[scope_id]&;
    state: ReplState = (
        program = self, 
        variables = init(allocator),
        top_scope = scope_id,
    );
    loop {
        text := "".clone(libc_allocator);
        text&.interactive_read_line();
        text&.push_all(";");
        println("");
        //@println("We got code! \"%\"", text.items());    
        
        @match(state&.run_chunk(text.items())) {
            fn Ok() => ();
            fn Err(e) => {
                out: List(u8) = list(temp());
                self.fmt_error(e, out&);
                println(out.items());
            }
        };
    };
}

ReplState :: @struct(
    program: *SelfHosted,
    variables: HashMap(Var, Ty([]u8, Type)),
    top_scope: ScopeId,
);

fn run_chunk(state: *ReplState, src: Str) Res(void) = {
    :: WalkAst(ReplState, void);
    
    self := state.program;
    file := self.codemap.add_file("repl!", src);
    id := self.parser.push_parse(src, file);
    stmts := @try(self.parser.finish_pending_stmts(id)) return;
    
    r: ResolveScope = new(self, state.top_scope, file);
    each stmts { stmt | 
        //println(stmt.log(self));
        @try(r&.walk_stmt(stmt)) return;
        //println(stmt.log(self));
        state.walk_stmt(stmt);
        //println(stmt.log(self));
        
        @match(stmt.stmt&) {
            fn Noop() => ();
            fn Eval(e) => {
                value := @try(self.repl_eval(e, .None)) return;
            }
            fn DeclVar(f) => {
                // The normal lazy handling of constants is good enough, they don't depend on being inside a function context.  
                // Runtime variables expect to be stored on the callstack, but we want to make them work at the top level. 
                // So we have the repl allocate memory for them and rewrite future expressions to refer to them instead. 
                if f.name.kind == .Const {
                    self.scopes.put_constant(f.name, f.value, f.ty);
                } else {
                    value := @try(self.repl_eval(f.value&, .None)) return;
                    bytes := value&.bytes().clone(allocator).items();  // it might be small and stored inline
                    state.variables&.insert(f.name, (bytes, f.value.ty));
                };
            }
            fn Set(_) => {
                // Just wrap it in a block expression so we can execute it. 
                stmts: List(FatStmt) = list(1, self.get_alloc());
                stmts&.push(stmt[]);
                fake_expr: Expr = new_block(stmts.rs(), self.make_unit_expr(stmt.loc));
                fake_expr := synthetic_ty(fake_expr, stmt.loc, void);
                @try(self.repl_eval(fake_expr&, .None)) return;
            }
            @default => {
                self.last_loc = stmt.loc;
                return(@err("unhandled repl stmt type %", stmt.log(self)));
            };
        };
    };
    .Ok
}

fn repl_eval(self: *SelfHosted, e: *FatExpr, want: ResultType) Res(Values) = {
    self.poll_in_place(Values) {
        return :: local_return;
        @check(self.compile_expr(e, want)) return;
        self.immediate_eval_expr(e, e.ty)
    }
}

fn handle_expr(self: *ReplState, expr: *FatExpr) Result(DoMore, void) #once = {
    @match(expr.expr&){
        fn GetVar(name) => {
            if self.variables&.get_ptr(name) { bytes_type |
                ptr_val: Values = self.program.to_values(*u8, bytes_type._0.ptr);
                expr.expr = (Value = (bytes = ptr_val, coerced = false));
                expr.ty = self.program.ptr_ty(bytes_type._1);
                
                e := self.program.box(expr[]);
                expr[] = synthetic_ty((Deref = e), expr.loc, bytes_type._1);
            };
            (Ok = DoMore.Break)
        }
        @default => (Ok = DoMore.Continue);
    }
}
fn handle_stmt(self: *ReplState, stmt: *FatStmt) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_func(self: *ReplState, func: *Func) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_type(self: *ReplState, ty: *LazyType) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_pattern(self: *ReplState, p: *Pattern) Result(DoMore, void) #once = (Ok = .Continue);
