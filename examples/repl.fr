#include_std("lib/core.fr");
#include_std("compiler/lib.fr");
#include_std("compiler/build.fr");

allocator :: libc_allocator;

fn main() void = {
    vtable := init_driver_vtable();
    update_global_stdlib_path();
    prelude := "#include_std(\"lib/core.fr\");\n";
    comp := {vtable.init_compiler}(vtable.default_build_options()); // TODO: comptime get the current arch
    c := vtable.with(comp);
    file := {c.vtable.add_file}(c.data, "repl!", prelude);
    self := c.data.cast()[][];
    id := self.parser.push_parse(prelude, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RsVec(FatStmt), stmts); // TODO: don't return RsVec -- Jun 29
    stmts := stmts.items();
    {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts).unwrap();
    
    // TODO: these numbers are experimentally where it happens to put the prelude constants right now. should do something more robust where you can ask it. 
    scope_id := self.scopes.new_scope(from_index(1), 3);
    scope := self.scopes[scope_id]&;
    scope.vars&.push(@as(BlockScope) (
        vars = list(scope.vars.gpa), 
        const_lookup = init(scope.vars.gpa),
        parent = 0
    ));
    block_id := scope.vars.len - 1;
    
    state: ReplState = (
        program = self, 
        variables = init(allocator),
        top_scope = scope_id,
        top_block = block_id,
    );
    loop {
        text := "".clone(libc_allocator);
        text&.interactive_read_line();
        text&.push_all(";");
        println("");
        //@println("We got code! \"%\"", text.items());    
        
        @match(state&.run_chunk(text.items())) {
            fn Ok() => ();
            fn Err(e) => {
                out: List(u8) = list(temp());
                self.fmt_error(e, out&);
                println(out.items());
            }
        };
    };
}

ReplState :: @struct(
    program: *SelfHosted,
    variables: HashMap(Var, Ty([]u8, Type)),
    top_scope: ScopeId,
    top_block: i64,
);

fn run_chunk(state: *ReplState, src: Str) Res(void) = {
    :: WalkAst(ReplState, void);
    
    self := state.program;
    file := self.codemap.add_file("repl!", src);
    id := self.parser.push_parse(src, file);
    stmts := @try(self.parser.finish_pending_stmts(id)) return;
    
    r: ResolveScope = new(self, state.top_scope, file);
    r.block = state.top_block;
    each stmts { stmt | 
        //println(stmt.log(self));
        @try(r&.walk_stmt(stmt)) return;
        //println(stmt.log(self));
        state.walk_stmt(stmt);
        //println(stmt.log(self));
        
        @match(stmt.stmt&) {
            fn Noop() => ();
            fn Eval(e) => {
                value := @try(self.eval(e, .None)) return;
            }
            fn DeclVar(f) => {
                // The normal lazy handling of constants is good enough, they don't depend on being inside a function context.  
                // Runtime variables expect to be stored on the callstack, but we want to make them work at the top level. 
                // So we have the repl allocate memory for them and rewrite future expressions to refer to them instead. 
                if f.name.kind == .Const {
                    self.scopes.put_constant(f.name, f.value, f.ty);
                } else {
                    value := @try(self.eval(f.value&, .None)) return;
                    bytes := value&.bytes().clone(allocator).items();  // it might be small and stored inline
                    state.variables&.insert(f.name, (bytes, f.value.ty));
                };
            }
            fn Set(_) => {
                // Just wrap it in a block expression so we can execute it. 
                stmts: List(FatStmt) = list(1, self.get_alloc());
                stmts&.push(stmt[]);
                fake_expr: Expr = (Block = (body = stmts.rs(), result = self.make_unit_expr(stmt.loc), ret_label = .None, hoisted_constants = false));
                fake_expr := synthetic_ty(fake_expr, stmt.loc, void);
                @try(self.eval(fake_expr&, .None)) return;
            }
            @default => {
                self.last_loc = stmt.loc;
                return(@err("unhandled repl stmt type %", stmt.log(self)));
            };
        };
    };
    .Ok
}

fn eval(self: *SelfHosted, e: *FatExpr, want: ResultType) Res(Values) = {
    self.poll_in_place(Values) {
        return :: local_return;
        @check(self.compile_expr(e, want)) return;
        self.immediate_eval_expr(e, e.ty)
    }
}

fn handle_expr(self: *ReplState, expr: *FatExpr) Result(DoMore, void) #once = {
    @match(expr.expr&){
        fn GetVar(name) => {
            if self.variables&.get_ptr(name) { bytes_type |
                ptr_val: Values = self.program.to_values(*u8, bytes_type._0.ptr);
                expr.expr = (Value = (bytes = ptr_val, coerced = false));
                expr.ty = self.program.ptr_ty(bytes_type._1);
                
                e := self.program.box(expr[]);
                expr[] = synthetic_ty((Deref = e), expr.loc, bytes_type._1);
            };
            (Ok = DoMore.Break)
        }
        @default => (Ok = DoMore.Continue);
    }
}
fn handle_stmt(self: *ReplState, stmt: *FatStmt) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_func(self: *ReplState, func: *Func) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_type(self: *ReplState, ty: *LazyType) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_pattern(self: *ReplState, p: *Pattern) Result(DoMore, void) #once = (Ok = .Continue);


//////////////////////////////////////////////
// Driver
//

fn driver(vtable: *ImportVTable) void = {
    if !file_exists("compiler/main.fr") {
        panic("Working directory must be top level of the franca repository");
    };
    start := timestamp();
    src: List(u8) = temp().read_to_string("examples/repl.fr");
    cfg: CompilerBuildOptions = ();
    get_compiler_source(cfg, src&);
    opts := vtable.default_build_options();
    comp := vtable.new_with_src(src.items(), opts);
    c := vtable.with(comp);
    
    new_main := c.get_unique_named("main").unwrap();
    
    // TODO: make this work! we should be able to run on the comptime jit.
    //       it tries to call uncompiled function. -- Sep 3
    //callee := c.get_jitted(new_main);
    //callee := assume_types_fn(Arg = void, Ret = void, ptr = callee);
    //callee();
    
    exports := (@list(new_main) temp()).items();
    ir_text := {c.vtable.emit_llvm}(c, temp(), exports, .ExportWithNames, .aarch64);
    @println("Emitted % bytes of llvm ir.", ir_text.len);  // useful to see when i start trying to deduplicate bytecode. 
    end := timestamp();

    start := timestamp();
    args := @list ("-o", "target/franca/franca2repl", "-g", "-Os") temp();
    
    build_llvm(ir_text, args.items());
    end := timestamp();
    @println("LLVM time: % ms.", end.sub(start));
    exit(0);
    
    // TODO: return result
    fn build_llvm(ir: BucketArray(u8), args: Slice(Str)) void = {
        out := open_temp_file();
        for(ir&){bucket|
            out.fd&.write(bucket);
        };
        @println("Write llvm ir to %", out&.s_name());   
        args: List(Str) = args.clone(temp());
        args&.push("-x"); // don't check the file extension of source files that follow. 
        args&.push("ir"); 
        args&.push("-g"); 
        args&.push(out&.s_name());
        @println("%", args.items());
        success := run_cmd_blocking("clang", args.items());
        assert(success, "ICE: generated invalid llvm ir");
        out.remove();
    }
}
