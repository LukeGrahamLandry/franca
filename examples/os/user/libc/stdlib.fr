
malloc :: fn(size: i64) rawptr #inline =
    calloc(size, 1);

free :: fn(p: rawptr) void #inline = {
    realloc(p, 0);
}

calloc :: fn(n: i64, m: i64) rawptr #inline = 
    realloc(zeroed(rawptr), n * m);

realloc :: fn(old_mem: rawptr, new_size: i64) rawptr = {
    MAGIC :: 0xABCDEF;
    a := general_allocator();
    old := i64.ptr_from_raw(old_mem).offset(-2);
    old_size := @if(!old_mem.is_null(), old[], 0);
    old_buf := old.slice(old_size);
    
    if new_size == 0 {
        a.dealloc(i64, old_buf);
        return zeroed(rawptr);
    };
    
    new_size := new_size.ualign_to(16).udiv(8) + 2;
    @if(old_size >= new_size) return(old_mem);
    
    //             :SLOW
    buf := a.alloc_zeroed(i64, new_size);
    buf[0] = new_size;
    buf[1] = MAGIC;
    if old_size != 0 {
        @debug_assert_eq(old_buf[1], MAGIC, "bad pointer passed to realloc");
        buf.rest(2).copy_from(old_buf.rest(2));
        a.dealloc(i64, old_buf);
    };
    
    // TODO: needs 16 alignment
    i64.raw_from_ptr(buf.index(2))
}

system :: fn(command: CStr) i64 = {
    @eprintln("TODO: implment LIBC.system(%)", command);
    -1
};

atoi :: fn() void #static = 
    @panic("TODO: atoi");

abs :: fn(val: i32) i32 #static = 
    @if(val < 0, -val, val);

labs :: fn(val: i64) i64 #static = 
    @if(val < 0, -val, val);

strtod :: fn(s: CStr, end_out: *CStr) f64 #static = {
    s := s.str() /*:SLOW*/;
    // TODO: this one doesn't support all the syntax. 1e-2
    n, rest := parse_float(s);
    ::ptr_utils(*u8);
    if !end_out.is_null() {
        end_out.ptr = rest.ptr;
    };
    n
}

// TODO: this should't be in the part that's supposed to be platform agnostic
exit :: fn(status: i64) void = {
    @trace("exit(%)", status);
    args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
    Syscall'perform_syscall(args&, 94);  // exit
};

abort :: fn() void = exit(1);  // TODO: signal or whatever
