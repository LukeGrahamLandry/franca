
malloc :: fn(size: i64) rawptr #inline =
    calloc(size, 1);

free :: fn(p: rawptr) void #inline = {
    realloc(p, 0);
}

calloc :: fn(n: i64, m: i64) rawptr #inline = 
    realloc(zeroed(rawptr), n * m);

realloc :: fn(old_mem: rawptr, new_size: i64) rawptr = {
    old_mem := u8.ptr_from_raw(old_mem);
    @if(new_size == 0) return(zeroed(rawptr));  // TODO: free
    // TODO: needs 16 alignment
    buf := general_allocator().alloc_zeroed(u8, new_size);
    @assert(old_mem.is_null(), "TODO: realloc");  // TODO: copy & free
    u8.raw_from_ptr(buf.ptr)
}

system :: fn(command: CStr) i64 = {
    @eprintln("TODO: implment LIBC.system(%)", command);
    -1
};

atoi :: fn() void #static = 
    @panic("TODO: atoi");

abs :: fn(val: i32) i32 #static = 
    @if(val < 0, -val, val);

labs :: fn(val: i64) i64 #static = 
    @if(val < 0, -val, val);

strtod :: fn(s: CStr, end_out: *CStr) f64 #static = {
    // TODO: this one doesn't support all the syntax. 1e-2
    n, rest := parse_float(s.str() /*:SLOW*/);
    ::ptr_utils(*u8);
    if !end_out.is_null() {
        end_out.ptr = rest.ptr;
    };
    n
}

// TODO: this should't be in the part that's supposed to be platform agnostic
exit :: fn(status: i64) void = {
    @trace("exit(%)", status);
    args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
    Syscall'perform_syscall(args&, 94);  // exit
};

abort :: fn() void = exit(1);  // TODO: signal or whatever
