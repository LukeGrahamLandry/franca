
clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
    // TODO: other clock_id's
    time_spec[] = system_counter_uptime();
    0
};

// TODO: do this more efficiently. 
//       if multiple threads are sleeping, just have one yield like this for the shortest duration and the rest futex wait.
nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
    @trace("nanosleep(s = %, ns = %)", duration.seconds, duration.nanoseconds);
    @debug_assert_eq(nullable_remainder_out, 0, "todo: sleep remainder");
    zeroes := zeroed Array(i64, 6);
        now := system_counter_uptime();
        end := now + duration[];
        dowhile {
            _ := Syscall'perform_syscall(zeroes&, 0xFFFF0002);  // yield
            now := system_counter_uptime();
            end.ms() > now.ms()
        };
        0
};

localtime_r :: fn(time_in: *time_t, time_out: *BigTime) *BigTime = {
    // TODO
    time_out[] = zeroed(BigTime);
    time_out
};

// TODO: this is supposed to be calander time not system up time
time :: fn(out: *time_t) time_t = (seconds = timestamp() * 1000);
