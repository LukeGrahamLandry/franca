
clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
    // TODO: other clock_id's
    time_spec[] = system_counter_uptime();
    0
};

// TODO: do this more efficiently. 
//       if multiple threads are sleeping, just have one yield like this for the shortest duration and the rest futex wait.
nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
    @debug_assert_eq(nullable_remainder_out, 0, "todo: sleep remainder");
    ticks_per_s := i64.sys_get(.CNTFRQ_EL0);
    s, ns := (duration.seconds, duration.nanoseconds);
    ticks := (s * ticks_per_s) + ((ns * ticks_per_s) / NS_PER_S);
    until := i64.sys_get(.CNTVCT_EL0) + ticks;
    @trace("nanosleep(%)", duration[]);
    args: Array(i64, 6) = (until, 0, 0, 0, 0, 0);
    _ := Syscall'perform_syscall(args&, 0xFFFF0002);  // yield
    0
};

localtime_r :: fn(time_in: *time_t, time_out: *BigTime) *BigTime = {
    // TODO
    time_out[] = zeroed(BigTime);
    time_out
};


timeval :: @struct {
    tv_sec: i64;
    tv_usec: i64;  // US! not the same as timespec which is NS
};

// TODO: this is supposed to be calander time not system up time
time :: fn(out: *time_t) time_t = (seconds = timestamp() * 1000);

gettimeofday :: fn(out: *timeval) void = {
    now := zeroed TimeSpec;
    clock_gettime(0, now&);
    out[] = (tv_sec = now.seconds, tv_usec = now.nanoseconds / NS_PER_US);
}
