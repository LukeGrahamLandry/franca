
strlen :: fn(p: CStr) i64 #static =
    len(str(p));
strncasecmp :: fn() void #static = 
    @panic("TODO: strncasecmp");
strcasecmp :: fn() void #static = 
    @panic("TODO: strcasecmp");

strchr :: fn() void #static = 
    @panic("TODO: strchr");
strncmp :: fn() void #static = 
    @panic("TODO: strncmp");
// TODO: this is a paste from posix.readdir.fix
strncpy :: fn(d: *u8, s: *u8, n: i64) void #static = {
    while => s[] != 0 && n > 0 {
        d[] = s[];
        d = d.offset(1);
        s = s.offset(1);
        n -= 1;
    };
    d.slice(n).set_zeroed();
};
strcmp :: fn(a: *u8, b: *u8) i32 #static = {
    while => a[] == b[] && a[] != 0 {
        a = a.offset(1);
        b = b.offset(1);
    };
    a[].zext() - b[].zext()
}
strdup :: fn(src: CStr) CStr = {
    src := src.str();
    dest := general_allocator().alloc_uninit(u8, src.len + 1);
    dest.slice(0, src.len).copy_from(src);
    dest[src.len] = 0;
    (ptr = dest.ptr)
}

strrchr :: fn() void #static = 
    @panic("TODO: strrchr");

memset :: fn() void #static = 
    @panic("TODO: memset");

memcmp :: fn(a: *u8, b: *u8, n: i64) i32 #static = {
    i := 0;
    a := a.slice(n); b := b.slice(n);
    while => a[i] == b[i] {
        i += 1;
        @if(i == n) return(@as(i32)0);
    };
    a[i].zext() - b[i].zext()
}

memcpy :: fn(d: *u8, s: *u8, n: i64) *u8 #static = {
    d.slice(n).copy_from(s.slice(n));
    d
}
