
strlen :: fn(p: CStr) i64 #static =
    len(str(p));

strcasecmp :: fn(lhs: CStr, rhs: CStr) i32 #static = 
    strncasecmp(lhs.ptr, rhs.ptr, MAX_i64);
strncasecmp :: fn(lhs: *u8, rhs: *u8, size: i64) i32 #static = {
    lhs := lhs.slice(size);
    rhs := rhs.slice(size);
    range(0, size) { i |
        lower :: fn(c) i32 => zext(@if(c >= "A".ascii() && c <= "Z".ascii(), 
            @as(u8) (@as(i64)c.zext()).bit_xor(0x20).trunc(), 
            c));
        a, b := (lhs[i].lower(), rhs[i].lower());
        @if(a != b || a == 0) return(a - b);
    };
    0
};

strchr :: fn(s: CStr, c: i32) CStr #static = 
    @panic("TODO: strchr");

strncpy :: fn(d: *u8, s: *u8, n: i64) *u8 #static = {
    s1 := d;
    while => s[] != 0 && n > 0 {
        d[] = s[];
        d = d.offset(1);
        s = s.offset(1);
        n -= 1;
    };
    d.slice(n).set_zeroed();
    s1
};

strcmp :: fn(a: *u8, b: *u8) i32 #static = 
    strncmp(a, b, MAX_i64);

strncmp :: fn(a: *u8, b: *u8, n: i64) i32 #static = {
    while => a[] == b[] && a[] != 0 {
        a = a.offset(1);
        b = b.offset(1);
        n -= 1;
        @if(n == 0) return(0);
    };
    a[].zext() - b[].zext()
};

strdup :: fn(src: CStr) CStr = {
    src := src.str();
    dest := general_allocator().alloc_uninit(u8, src.len + 1);
    dest.slice(0, src.len).copy_from(src);
    dest[src.len] = 0;
    (ptr = dest.ptr)
};

strrchr :: fn(s: CStr, c: u8) *u8 #static = {
    s := s.str();
    s.len += 1;
    each_rev s { c2 |
        @if(c2[] == c) return(c2);
    };
    zeroed(*u8)
};

strcpy :: fn(dest: CStr, src: CStr) CStr #static = {
    todo()
}

strpbrk :: fn(a: CStr, b: CStr) CStr #static = {
    todo()
}

strspn :: fn(a: CStr, b: CStr) i64 #static = {
    todo()
}

strcoll :: fn(a: CStr, b: CStr) i32 #static = {
    todo()
}

strstr :: fn(a: CStr, b: CStr) CStr #static = {
    todo()
}

strnlen :: fn(s: CStr, max: i64) i64 #static = {
    todo()
}

strcat :: fn(a: CStr, b: CStr) CStr #static = {
    todo()
}

strerror :: fn(errno: i32) CStr = {
    todo()
}

memset :: fn(dest: *u8, to: u8, len: i64) *u8 #static = {
    set_bytes(dest.slice(len), to);
    dest
};

memcmp :: fn(a: *u8, b: *u8, n: i64) i32 #static = {
    i := 0;
    a := a.slice(n); b := b.slice(n);
    while => a[i] == b[i] {
        i += 1;
        @if(i == n) return(@as(i32)0);
    };
    a[i].zext() - b[i].zext()
};

memcpy :: fn(dest: rawptr, src: rawptr, count: i64) rawptr #static = 
    memmove(dest, src, count);

memmove :: fn(dest: rawptr, src: rawptr, count: i64) rawptr #static = {
    copy_bytes_static(dest, src, count);
    dest
};

memchr :: fn(s: rawptr, c: i32, n: i64) rawptr #static = {
    todo()
}

strcspn :: fn(a: CStr, b: CStr) i64 #static = {
    todo()
}

strncat :: fn(a: CStr, b: CStr, n: i64) CStr #static = {
    todo()
}
