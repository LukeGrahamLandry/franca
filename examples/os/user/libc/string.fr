
strlen :: fn(p: CStr) i64 #static =
    len(str(p));

strcasecmp :: fn(lhs: CStr, rhs: CStr) i32 #static = {
    // :SLOW
    lhs := lhs.str();
    rhs := rhs.str();
    strncasecmp(lhs.ptr, rhs.ptr, min(lhs.len, rhs.len) + 1)
}
    
strncasecmp :: fn(lhs: *u8, rhs: *u8, size: i64) i32 #static = {
    lhs := lhs.slice(size);
    rhs := rhs.slice(size);
    range(0, size) { i |
        lower :: fn(c) i32 => zext(@if(c >= "A".ascii() && c <= "Z".ascii(), 
            @as(u8) (@as(i64)c.zext()).bit_xor(0x20).trunc(), 
            c));
        a, b := (lhs[i].lower(), rhs[i].lower());
        @if(a != b) return(a - b);
    };
    0
};

strchr :: fn() void #static = 
    @panic("TODO: strchr");
strncmp :: fn() void #static = 
    @panic("TODO: strncmp");
// TODO: this is a paste from posix.readdir.fix
strncpy :: fn(d: *u8, s: *u8, n: i64) void #static = {
    while => s[] != 0 && n > 0 {
        d[] = s[];
        d = d.offset(1);
        s = s.offset(1);
        n -= 1;
    };
    d.slice(n).set_zeroed();
};
strcmp :: fn(a: *u8, b: *u8) i32 #static = {
    while => a[] == b[] && a[] != 0 {
        a = a.offset(1);
        b = b.offset(1);
    };
    a[].zext() - b[].zext()
}
strdup :: fn(src: CStr) CStr = {
    src := src.str();
    dest := general_allocator().alloc_uninit(u8, src.len + 1);
    dest.slice(0, src.len).copy_from(src);
    dest[src.len] = 0;
    (ptr = dest.ptr)
}

strrchr :: fn() void #static = 
    @panic("TODO: strrchr");

memset :: fn() void #static = 
    @panic("TODO: memset");

memcmp :: fn(a: *u8, b: *u8, n: i64) i32 #static = {
    i := 0;
    a := a.slice(n); b := b.slice(n);
    while => a[i] == b[i] {
        i += 1;
        @if(i == n) return(@as(i32)0);
    };
    a[i].zext() - b[i].zext()
}

memcpy :: fn(d: *u8, s: *u8, n: i64) *u8 #static = {
    d.slice(n).copy_from(s.slice(n));
    d
}
