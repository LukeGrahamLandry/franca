vsnprintf :: fn(dest: *u8, n: i64, fmt: CStr, va: *CVariadicArgumentList) i64 = {
    dest := dest.slice(n);
    fmt := fmt.str();  // :SLOW
    i := 0;
    j := 0;
    while => i < fmt.len {
        continue :: local_return;
        if fmt[i] != "%".ascii() {
            dest[j] = fmt[i];
            i += 1;
            j += 1;
            continue();
        };
        i += 1;
        @switch(fmt[i]) {  // TODO: bounds
            @case("i".ascii()) => {
                i += 1;
                value := va.next(i32);
                j += write_int_to_buffer(dest.rest(j), value.intcast());
            };
            // TODO
            @case("p".ascii()) => {
                i += 1;
                value := va.next(i64);
                j += write_int_to_buffer(dest.rest(j), value);
            };
            // TODO
            @case("x".ascii()) => {
                i += 1;
                value := va.next(i64);
                j += write_int_to_buffer(dest.rest(j), value);
            };
            @case("s".ascii()) => {
                i += 1;
                value := va.next(CStr).str();
                dest.subslice(j, value.len).copy_from(value);
                j += value.len;
            };
            @default => {
                @panic("TODO: printf fmt %\n%", fmt[i], fmt);
            };
        }
    };
    // TODO: its supposed to return the amount that would have been written if n was high enough
    //       (rn i panic if not enough space)
    dest[j] = 0;
    j
};
fopen :: fn(path: CStr, mode: CStr) i64 = {
    @eprintln("TODO: fopen(%, %)", path, mode);
    0
} 
ftell :: fn() void = 
    @panic("TODO: ftell");
fread :: fn() void = 
    @panic("TODO: fread");
fwrite :: fn() void = 
    @panic("TODO: fwrite");
fflush :: fn() void = 
    @panic("TODO: fflush");
fclose :: fn() void = 
    @panic("TODO: fclose");
// todo; I_ERROR faults, probably before fprintf(stderr, _) because stderr is unfilled fixup?
fprintf :: fn() void = 
    @panic("TODO: fprintf");
vfprintf :: fn() void = 
    @panic("TODO: vfprintf");
printf :: fn(fmt: CStr, va: CVariadic) i64 = {
    out := temp().alloc_uninit(u8, fmt.str().len() + 100);
    n := vsnprintf(out.ptr, out.len, fmt, va&.start());
    out := out.slice(0, n);
    print(out);
    out.len
}

fseek :: fn() void = 
    @panic("TODO: fseek");

snprintf :: fn() void = 
    @panic("TODO: snprintf");

sscanf :: fn() void = 
    @panic("TODO: sscanf");

puts :: fn(s: CStr) i32 = {
    println(s.str());
    0
}

putchar :: fn(c: u8) i32 = {
    print(c&.slice(1));
    c.zext()
}

#use("@/lib/variadic.fr");
