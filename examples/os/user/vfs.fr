// Virtual File System
// it's all in userspace, the kernel doesn't know anything about file descriptors. 
// some files are backed by a UQueue (which might be a Virt.Queue in the kernel). 
// libc functions that operate on file descriptors forward to a FileVTable. 

fs :: @static(@struct {
    fd: List(FileHandle); // indexed by Fd
    free: RawDeque(Fd);  // TODO: posix wants it to always reuse the lowest value not the oldest closed
    mutex: Mutex;  // locked when push to fd / reading an entry from fd. TODO: RWLock
    // TODO: decide which other things care about being thread safe
    stdin: UQueue;
    stdout: UQueue;
    strace: bool;
    timer: bool;
    root_dir: Fd;
    next_fuse_request_id: u64;
    allocator: Alloc;
    device_tree_bytes: []u8;
    have_fuse_target_dir: bool;
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    data: rawptr;
};

FileVTable :: @struct {
     read: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    write: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    lseek: @FnPtr(self: rawptr, offset: i64, whence: Whence) i64 = (fn(_0, _1, _2) = -1);
    close: @FnPtr(self: rawptr) void = fn(self) = ();
   openat: @FnPtr(self: rawptr, path: CStr, flags: i64, mode: i64) i64 = (fn(_0, _1, _2, _3) = -1);
    fstat: @FnPtr(self: rawptr, out: *Posix.Linux.StatArm64) i64 = (fn(_0, _1) = -1);
   access: @FnPtr(self: rawptr, mode: i64) i64 = (fn(_0, _1) = 0);
    mkdir: @FnPtr(self: rawptr, path: CStr, mode: i64) i64 = (fn(_0, _1, _2) = -1);
   rename: @FnPtr(self: rawptr, dest_dir: Fd, src_name: CStr, dest_name: CStr) i64 = (fn(_0, _1, _2, _3) = -1);
};

init_vfs :: fn() void = {
    fs.allocator = general_allocator();
    Pair :: Ty(u32, u32);
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        fs_i := Pair.list(fs.len_including_tombstones * 2, ast_alloc());
        each fs& { name, info |
            off := contents.len;
            contents&.push_all(name);
            push(fs_i&, (off.trunc(), name.len.trunc()));
            push(fs_i&, (info._0.trunc(), info._1.trunc()));
        };
        @assert_lt(contents.len, MAX_u32);
        (fs_i.items(), contents.items())
    };
    
    fs.stdin.pipe = init(fs.allocator, 2);
    if !virtq_create(fs.stdin&, "stdio.console", 0) {
        fs.stdin.poll = pl011_int_poll;
    };
    range(0, 2) { _ |
        bufs := fs.allocator.alloc_init([]u8, 1, fn(_) => fs.allocator.alloc_zeroed(u8, 256));
        fs.stdin.pipe.work&.push(bufs = bufs, n = (bufs_readable = 0));
    };
    fs'stdin'poll(fs.stdin&, 0);
    
    fs.stdout.pipe = init(fs.allocator, 1);
    if !virtq_create(fs.stdout&, "stdio.console", 1) {
        fs.stdout.poll = sys_debug_write_poll;
    };
    
    fs.fd = list(fs.allocator);
    push_file(StdinFile, (queue = fs.stdin&));
    push_file(StdoutFile, (queue = fs.stdout&));
    push_file(StdoutFile, (queue = fs.stdout&));
    
    // build a tree of MemDir with MemFileRO leaves containing all the baked files. 
    fs.root_dir = push_file(MemDir, (files = empty()));
    // TODO: deduplicate with follow_path
    while => fs_i.len > 0 {
        continue :: local_return;
        off, len := fs_i[0];
        info := fs_i[1];
        fs_i = fs_i.rest(2);
        name := contents.subslice(off.zext(), len.zext());
        
        if name.contains("target/") {
            // HACK: web version needs you to include a generated file but here i want to just share the whole directory,
            //       and i don't support like an overlay thing where you merge both. 
            continue();
        };
        
        cwd := get_file(fs.root_dir).unwrap();
        i := 0;
        while => i < name.len {
            continue :: local_return;
            start := i;
            while => i < name.len && name[i] != PATH_SEP.ascii() {
                i += 1;
            };
            part := name.slice(start, i);
            i += 1;
            self := MemDir.ptr_from_raw(cwd.data);
            if i >= name.len {  // file
                off, len := info;
                _ := create_child(self, part, MemFileRO, (
                    contents = contents.subslice(off.zext(), len.zext()),
                    pos = 0,
                ));
            } else {  // folder
                break :: local_return;
                it := self.files.find(fn(it) => it.name == part) || {
                    cwd = create_child(self, part, MemDir, (files = empty()));
                    break()
                };
                cwd = it.handle;
            }
        }
    };
    
    // TODO: let user iterate the tags and mount them manually 
    q := fs.allocator.box_zeroed(UQueue);
    if virtq_create(q, "Host.fs", 1) {
        fuse_root := init_fuse(q);
        cwd := get_file(fs.root_dir).unwrap();
        cwd := MemDir.ptr_from_raw(cwd.data);
        child := get_file(fuse_root).unwrap();
        child := FuseFile.ptr_from_raw(child.data)[];
        create_child(cwd, "target", FuseFile, child);
        fs.have_fuse_target_dir = true;
    };
    // else :leak
}

fn create_child(self: *MemDir, name: Str, $T: Type, data: T) FileHandle #generic = {
    each self.files { it |
        @assert_ne(it.name, name, "create_child: duplicate");
    };
    data := fs.allocator.boxed(T, data);
    fd: FileHandle = (vtable = get_vtable(T), data = T.raw_from_ptr(data));
    self.files&.push((name = name, handle = fd), fs.allocator);
    fd
}

// mechanisms, not policies :)
get_vtable :: fn($T: Type) *FileVTable = @static(FileVTable) {
    vtable: FileVTable = ();
    S :: Type.scope_of(T);

    fr := current_compiler_context();
    p := bit_cast_unchecked(*FileVTable, *rawptr, vtable&);
    for get_constants(S) { name |
        continue :: local_return;
        field := Fields(FileVTable).from_name(name.str())
            || continue();
        fid := FuncId.get_constant(S, name)
            || @panic("failed to get func %", name.str());
        
        func := get_function_ast(fid, false, false, false, false);
        fptrtype := FieldType(FileVTable, field).get_type_info_ref();
        @debug_assert(fptrtype.is(.FnPtr));
        args := fr.arg_types(fptrtype.FnPtr.ty.arg);
        @assert_eq(args.len, func.arg.bindings.len, "arity error in FileVTable");
        range(0, args.len) { i |
            func.arg.bindings[i].ty = (Finished = args[i]);
        };
        func.ret = (Finished = fptrtype.FnPtr.ty.ret);
        
        // self := Self.ptr_from_raw(self);
        @debug_assert_eq(args[0], rawptr);
        func.arg.bindings[0].ty = (Finished = *T);
        
        p.offset(@as(i64) field)[] = fr.get_jitted(fid);
    };
    
    vtable
};

MemFileRO :: @struct {
    contents: []u8;
    pos: i64;
    
    read :: fn(fd, dest) = {
        dest.len = min(dest.len, fd.contents.len - fd.pos).max(0);
        src := fd.contents.subslice(fd.pos, dest.len);
        dest.copy_from(src);
        fd.pos += dest.len;
        dest.len
    };
    lseek :: fn(fd, offset, whence) = {
        ::enum(Whence);
        fd.pos = @match(whence) {
            fn End() => fd.contents.len;
            fn Set() => offset;
            @default => todo();
        };
        fd.pos
    };
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFREG;
        0
    };
};

StdoutFile :: @struct {
    queue: *UQueue;
    
    write :: fn(self, src) = {
        q := self.queue;
        q'poll(q, 1);
        old := q.pipe.done.committed.bouba;
        q.pipe.work&.push(bufs = @slice(src), n = (bufs_readable = 1));
        while => q.pipe.done.committed.bouba == old {
            // TODO: can i get an interrupt for this instead of spinning?
            q'poll(q, 0);
        };
        done := q.pipe.done&.pop();
        @assert(identical(done.bufs[0].ptr, src.ptr));
        0
    };
};

StdinFile :: @struct {
    queue: *UQueue;
    bufs: [][]u8 = empty();
    buf: []u8 = empty();
    
    read :: fn(self, dest) = {
        // TODO: don't hardcode blocking + MIN=1 + timeout=infinity (which is what interactive_read_line wants)
        
        if self.buf.len == 0 {
            self'queue'poll(self.queue, 1);  
            entry := self.queue.pipe.done&.pop();
            @debug_assert_eq(entry.bufs.len, 1);
            self.bufs = entry.bufs;
            self.buf = entry.bufs[0].slice(0, entry.n.bytes_written.zext());
        };
        dest.len = min(dest.len, self.buf.len);
        dest.copy_from(self.buf.slice(0, dest.len));
        self.buf = self.buf.rest(dest.len);
        each dest { it |
            if it[] == "\r".ascii() {
                it[] = "\n".ascii();
            };
        };
        if self.buf.len == 0 {
            self.queue.pipe.work&.push(bufs = self.bufs, n = (bufs_readable = 0));
            self'queue'poll(self.queue, 0);
        };
        dest.len
    };
};

MemDir :: @struct {
    files: RawList(Entry);
    Entry :: @struct {
        name: Str;
        handle: FileHandle;
    };
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFDIR;
        0
    };
    openat :: fn(self, path, flags, _mode) = {
        path := path.str();
        for self.files { it |
            if it.name == path {
                fd := push_file(it.handle);
                return(fd.fd.intcast());
            };
        };
        -2
    };
};

fn push_file($T: Type, data: T) Fd #generic = {
    data := fs.allocator.boxed(T, data);
    push_file(vtable = get_vtable(T), data = T.raw_from_ptr(data))
}

fn push_file(it: FileHandle) Fd = {
    fs.mutex&.lock();
    fd := fs.fd.len;
    if fs.free&.pop_front() { old |
        fd = old.fd.intcast();
        fs.fd[fd] = it;
    } else {
        fs.fd&.push(it);
        @assert_ne(fd, MAX_i32, "TODO: wrap");
    };
    fs.mutex&.unlock();
    (fd = fd.intcast())
}

// translate user/vfs/libc requests into FUSE messages over a UQueue  
// (which might be backed by a virtio-fs device in the kernel). 
// TODO: qring needs to allow you to wait for a specific entry for this to be thread safe 
FuseFile :: @struct {
    q: *UQueue;
    nodeid: u64;
    fh: u64;
    position: u64 = 0;
    
    read :: fn(self, buf) = {
    split_io_chunks(buf) { buf |
        in := zeroed Fuse.ReadIn;
        in.fh = self.fh;
        in.offset = self.position;
        in.size = buf.len.trunc();
        result := fuse_blocking(self.q, .READ, self.nodeid, in, buf)
            .or(fn(e) => return(e));
        self.position += result.data.len.bitcast();
        result.data.len
    }
    };
    write :: fn(self, buf) = {
    split_io_chunks(buf) { buf |
        in := zeroed Fuse.WriteIn;
        in.fh = self.fh;
        in.size = buf.len.trunc();
        in.data = buf;
        in.offset = self.position;
        result := fuse_blocking(self.q, .WRITE, self.nodeid, in)
            .or(fn(e) => return(e));
        self.position += result.size.uext();
        result.size.zext()
    }
    };
    lseek :: fn(self, offset, whence) = {
        ::enum(Whence);
        self.position = @match(whence) {
            fn End() => {
                in: Fuse.LseekIn = (
                    fh = self.fh,
                    offset = offset.bitcast(),
                    whence = (@as(i64) whence).trunc(),
                );
                result := fuse_blocking(self.q, .LSEEK, self.nodeid, in)
                    .or(fn(e) => return(e));
                result.offset
            }
            fn Set() => offset.bitcast();
            @default => @panic("TODO: fuse whence=%", whence);
        };
        self.position.bitcast()
    };
    close :: fn(self) = {
        // for now only the root is stored in a MemDir, every other fd is unique to an open()
        @if(self.nodeid == 1) return();
        
        in := zeroed Fuse.ReleaseIn;
        in.fh = self.fh;
        fuse_blocking(self.q, .RELEASE, self.nodeid, in)
            .or(fn(e) => @println("RELEASE failed %", e));
        in := zeroed Fuse.ForgetIn;
        fuse_blocking(self.q, .FORGET, self.nodeid, in)
            .or(fn(e) => @println("FORGET failed %", e));

        fs.allocator.dealloc_one(FuseFile, self);
    };
    openat :: fn(fd: *FuseFile, path: CStr, flags: i64, mode: i64) i64 = {
        q := fd.q;
        create := flags.bit_and(LinuxLibc.O_arm.CREAT) != 0;
        flags = flags.bit_and(LinuxLibc.O_arm.CREAT.bit_not());
        
        in: Fuse.LookupIn = (name = path.cstr_with_null());
        fh, node := @match(fuse_blocking(q, .LOOKUP, fd.nodeid, in)) {
            fn Ok(result) => {
                node := result.nodeid;
                in: Fuse.OpenIn = (flags = flags.trunc(), open_flags = 0);
                result := fuse_blocking(q, .OPEN, node, in)
                    .or(fn(e) => return(e));
                (result.fh, node)
            }
            fn Err(e) => {
                @if(!create) return(e);
                @trace("create(%)", path);
                in: Fuse.CreateIn = (
                    flags = flags.trunc(),
                    mode = mode.trunc(),
                    open_flags = 0,
                    umask = 0,
                    name = path.cstr_with_null(),
                );
                result := fuse_blocking(q, .CREATE, fd.nodeid, in)
                    .or(fn(e) => return(e));
                (result.open.fh, result.lookup.nodeid)
            }
        };
        fd := push_file(FuseFile, (q = q, nodeid = node, fh = fh));
        fd.fd.intcast()
    };
    fstat :: fn(self, out) = {
        in := zeroed Fuse.StatxIn;
        result := fuse_blocking(self.q, .STATX, self.nodeid, in)
            .or(fn(e) => return(e));
        // TODO: rest of the fucking owl
        out.st_mode = result.stat.mode.zext();
        0
    };
    rename :: fn(self, dest_dir, src_name, dest_name) = {
        dest_dir := get_file(dest_dir) || return(-1);
        ::ptr_utils(FileVTable);
        @if(!identical(dest_dir.vtable, get_vtable(FuseFile))) return(-1);
        dest_dir := FuseFile.ptr_from_raw(dest_dir.data);
        
        in: Fuse.RenameIn = (
            newdir = dest_dir.nodeid, 
            name = src_name.cstr_with_null(),
            newname = dest_name.cstr_with_null(),
        );
        _ := fuse_blocking(self.q, .RENAME, self.nodeid, in)
            .or(fn(e) => return(e));
        
        0
    };
    mkdir :: fn(self, path, mode) = {
        @trace("fuse mkdir %", path);
        in: Fuse.MkdirIn = (
            mode = mode.trunc(),
            umask = 0,
            name = path.cstr_with_null(),
        );
        result := fuse_blocking(self.q, .MKDIR, self.nodeid, in)
            .or(fn(e) => {
                @if(e == -74) return(0);  // TODO: wtf does that mean, clearly its still makign the directory
                return(e)
            });
        0
    };
};

// HACK
split_io_chunks :: fn(buf: []u8, $body: @Fn(buf: []u8) i64) i64 = {
    // TODO: this means read/write are not atomic anymore! :FUCKED
    // TODO: get the limit from fuse init info?
    //       theres a max_write and a max_read_ahead (is that what i want?)
    // TODO: given that im doing a bunch, its stupid to block on each, one at a time :SLOW
    MAX :: 1.shift_left(14);  
    total := 0;
    dowhile {
        try_read := buf.len;
        partial := try_read > MAX; 
        if partial {
            try_read = MAX;
        };
        read_len := body(buf.subslice(0, try_read));
        total += read_len;
        buf = buf.rest(read_len);
        read_len != 0 && buf.len > 0 && partial
    };
    total
} 

cstr_with_null :: fn(it: CStr) []u8 = {
    s: []u8 = (ptr = it.ptr, len = it.str().len() + 1);
    @assert_eq(s[s.len - 1], 0);
    s
};

init_fuse :: fn(q: *UQueue) Fd = {
    q.pipe = init(fs.allocator, 128);
    
    in := zeroed Fuse.InitIn;
    in.major = Fuse.MAJOR;
    in.minor = Fuse.MINOR;
    result := fuse_blocking(q, .INIT, 0, in).unwrap();
    
    ::DeriveFmt(Fuse.InitOut);
    ::DeriveFmt(Array(u16, 11));
    ::display_slice(u16);
    @println("%", result&);
    push_file(FuseFile, (q = q, nodeid = 1, fh = 0))
}

Fuse :: import("@/examples/os/drivers/fs/fuse.fr");

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I) Result(FuseOutType(I), i64) #where = {
    _, out_dyn := @run count_bufs(FuseOutType(I));
    @assert(out_dyn == 0, "fuse_blocking: pass extra memory for out buffer");
    fuse_blocking(q, op, node, in, empty())
}

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I, e_out: []u8) Result(FuseOutType(I), i64) #where = {
    hi := zeroed Fuse.InHeader;
    hi.opcode = op;
    hi.nodeid = node;
    hi.unique = u64.atomic_inc(fs.next_fuse_request_id&);
    ho := zeroed Fuse.OutHeader;
    out := zeroed FuseOutType(I);
    old := q.pipe.done.committed.bouba;
    // TODO: putting stack memory in the queue relies on blocking
    send(q, hi&, in&, ho&, out&, e_out);
    while => q.pipe.done.committed.bouba == old {
        // TODO: interrupt instead of spinning but im not finding the intid?
        q'poll(q, 0);
    };
    _ := q.pipe.done&.pop();
    ::enum(@type op);
    @debug_assert(ho.len != 0 || op == .FORGET);  // no reply, virtio is just returning the buffer. 
    @debug_assert(ho.len == 0 || hi.unique == ho.unique);
    @if(ho.error != 0) return(Err = ho.error.intcast().abs().neg());
    extra := ho.len.zext() - size_of(@type out);
    extra := e_out.slice(0, extra.max(0).min(e_out.len));
    
    out_fixed, out_dyn := @run count_bufs(@type out);
    @debug_assert(out_dyn <= 1, "TODO: multiple output bufs");
    if out_dyn > 0 {
        @debug_assert(ho.len.zext() >= (@run size_of(@type ho)) + out_fixed);
        p := ptr_from_int([]u8, int_from_ptr(@type out, out&) + out_fixed);
        p[] = extra;
    };
    
    (Ok = out)
}

fn send(q: *UQueue, hi: *Fuse.InHeader, in: ~I, ho: *Fuse.OutHeader, out: ~O, eo: []u8) void #where #inline/*semantic*/ = {
    f :: fn(data: ~T) []u8 #where => {
        ::[]@type data[];
        data.slice(1).interpret_as_bytes()
    };
    // TODO: putting stack memory in the queue relies on blocking
    bufs := @uninitialized Array([]u8, 10); bi := 0;
    push_buf :: fn(b: []u8) => { bufs&[bi] = b; bi += 1; };
    
    hi.len = 0;
    ::[]@type hi[];
    push_buf(hi.slice(1).interpret_as_bytes());
    hi.len += size_of(@type hi[]);
    
    in_fixed, in_dyn := @run count_bufs(Deref(I));
    b := in.f().slice(0, in_fixed);
    push_buf(b);
    hi.len += b.len.trunc();
    range(0, in_dyn) { i |
        p := ptr_from_int([]u8, Deref(I).int_from_ptr(in) + in_fixed + i * @run size_of([]u8));
        push_buf(p[]);
        hi.len += p.len.trunc();
    };
    readable := bi;
    
    push_buf(ho.f());
    out_fixed, _ := @run count_bufs(Deref(O));
    b := out.f().slice(0, out_fixed);
    push_buf(b);
    push_buf(eo);
    
    bufs := bufs&.items().slice(0, bi);
    q.pipe.work&.push(bufs = bufs, n = (bufs_readable = readable.intcast()))
}

fn count_bufs(T: Type) Ty(i64, i64) #fold = {
    fields := get_fields(T);
    i := 0;
    direct_field_bytes := 0;
    while => i < fields.len && fields[i].ty != []u8 {
        direct_field_bytes += size_of(fields[i].ty);
        i += 1;
    };
    indirect_field_count := 0;
    while => i < fields.len && fields[i].ty == []u8 {
        indirect_field_count += 1;
        i += 1;
    };
    @assert_eq(i, fields.len, "all #inline fields must be after all normal fields");
    (direct_field_bytes, indirect_field_count)
}

FuseOutType :: fn(In: Type) Type #fold = {
    name := In.typename().str();
    @assert(name.ends_with("In"), "expected In type, found %", name);
    @assert(!name.starts_with("*"));
    name = name.slice(0, name.len - 2);
    name := @tfmt("%Out", name);
    Type.get_constant(Fuse, name.sym())
        || @panic("missing Fuse.%", name)
}

fn get_file(fd: Fd) ?FileHandle = {
    if fd.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd } {
        fd = fs.root_dir;
    };
    fs.mutex&.lock();
    @if(!fd.fd.intcast().ult(fs.fd.len)) return(.None);
    file := fs.fd[fd.fd.zext()];
    fs.mutex&.unlock();
    (Some = file)
}

FuseId :: @struct(nodeid: u64, fh: u64);
FRes :: fn($T: Type) Type = Result(T, i64);

fn follow_path_prefix(fd: Fd, path: Str) Result(Ty(Fd, CStr), i64) = {
    if path.starts_with("./") {
        path = path.rest(2);
    };
    while => path.ends_with("/") {
        path.len -= 1;
        path = @tfmt("%\0", path);
        path.len -= 1;
    };
    
    first := true;
    buf := u8.list(1024, Arena'stack_alloc(1024));
    loop {
        dir, rest := pop_dir_prefix(path) || {
            @assert(path != "" && path != "." && path != "..", "TODO: special");
            return(Ok = (fd, (ptr = path.ptr)));
        };
        @assert(dir != "" && dir != "." && dir != "..", "TODO: special");
        
        buf&.clear();
        buf&.push_all(dir);
        buf&.push(0);
        result := LIBC'FR_openat(fd, (ptr = buf&.as_ptr()), Posix.O.RDONLY, 0);
        if result < 0 {
            if !first {
                _ := LIBC'close(fd);
            };
            return(Err = result)
        };
        new_fd: Fd = (fd = result.intcast());
        @assert(new_fd.fd != fd.fd, "openat must return unique!!!");
        if !first {
            _ := LIBC'close(fd);
        };
        
        fd = new_fd;
        path = rest;
        first = false;
    };
}

fn pop_dir_prefix(path: Str) ?Ty(Str, Str) = {
    @if(path.len == 0) return(.None);
    i := 0;
    while => path[i] != PATH_SEP.ascii() {
        i += 1;
        @if(i == path.len) return(.None);
    };
    (Some = (path.slice(0, i), path.rest(i + 1)))
}

sys_debug_write_poll :: fn(q, who) = {
    @if(who == 1) return();
    entry := q.pipe.work&.pop();
    for entry.bufs { msg |
        sys_debug_write(msg);
    };
    q.pipe.done&.push(entry);
};
