// Virtual File System

fs :: @static(@struct {
    contents: []u8;
    index: RawHashMap(Str, Ty(i64, i64));
    fd: List(FileHandle); // indexed by Fd
    mutex: Mutex;  // locked when push to fd / reading an entry from fd. TODO: RWLock
    // TODO: decide which other things care about being thread safe
    stdin: import("@/lib/collections/deque.fr")'RawDeque(u8);
    strace: bool;
    root_fd: FileHandle;
    fuse_q: ?*UQueue;
    fuse_root: Fd;
    // TODO: put an allocator here instead of trusting general_allocator
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    data: rawptr;
};

FileVTable :: @struct {
     read: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    write: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    lseek: @FnPtr(self: rawptr, offset: i64, whence: Whence) i64 = (fn(_0, _1, _2) = -1);
    close: @FnPtr(self: rawptr) void = fn(self) = ();
  fstatat: @FnPtr(self: rawptr, path: CStr, out: Posix.Linux.StatArm64) i64 = (fn(_0, _1, _2) = -1);
   openat: @FnPtr(self: rawptr, path: CStr, flags: i64, mode: i64) i64 = (fn(_0, _1, _2, _3) = -1);
};

init_vfs :: fn() void = {
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        (fs, contents.items())
    };
    fs.index = fs_i;
    fs.contents = contents;
    fs.stdin = init(general_allocator(), 1.shift_left(16));
    fs.fd = list(general_allocator());
    push_file(StdinFile, ());
    push_file(StdoutFile, ());
    push_file(StdoutFile, ());
    
    it := general_allocator().boxed(MemDir, (files = empty()));
    fs.root_fd = (vtable = get_vtable(MemDir), data = MemDir.raw_from_ptr(it));
}

// mechanisms, not policies :)
get_vtable :: fn($T: Type) *FileVTable = @static(FileVTable) {
    vtable: FileVTable = ();
    S :: Type.scope_of(T);

    fr := current_compiler_context();
    p := bit_cast_unchecked(*FileVTable, *rawptr, vtable&);
    for get_constants(S) { name |
        continue :: local_return;
        field := Fields(FileVTable).from_name(name.str())
            || continue();
        fid := FuncId.get_constant(S, name)
            || @panic("failed to get func %", name.str());
        
        func := get_function_ast(fid, false, false, false, false);
        fptrtype := FieldType(FileVTable, field).get_type_info_ref();
        @debug_assert(fptrtype.is(.FnPtr));
        args := fr.arg_types(fptrtype.FnPtr.ty.arg);
        @assert_eq(args.len, func.arg.bindings.len, "arity error in FileVTable");
        range(0, args.len) { i |
            func.arg.bindings[i].ty = (Finished = args[i]);
        };
        func.ret = (Finished = fptrtype.FnPtr.ty.ret);
        
        // self := Self.ptr_from_raw(self);
        @debug_assert_eq(args[0], rawptr);
        func.arg.bindings[0].ty = (Finished = *T);
        
        p.offset(@as(i64) field)[] = fr.get_jitted(fid);
    };
    
    vtable
};

MemFileRO :: @struct {
    contents: []u8;
    pos: i64;
    
    read :: fn(fd, dest) = {
        dest.len = min(dest.len, fd.contents.len - fd.pos).max(0);
        src := fd.contents.subslice(fd.pos, dest.len);
        dest.copy_from(src);
        fd.pos += dest.len;
        dest.len
    };
    lseek :: fn(fd, offset, whence) = {
        ::enum(Whence);
        fd.pos = @match(whence) {
            fn End() => fd.contents.len;
            fn Set() => offset;
            @default => todo();
        };
        fd.pos
    };
};

// TODO: expose the console to userspace as a UQueue
StdoutFile :: @struct {
    write :: fn(_0, src) = with_syscalls {
        result := Syscall'write((fd = 1), src.ptr, src.len);
        result.value
    };
};

// TODO: expose the console to userspace as a UQueue
StdinFile :: @struct {
    read :: fn(_fd, dest) = {
        i := 0;
        while => i < dest.len {
            continue :: local_return;
            // TODO: this is a race with the interrupt handler adding more bytes
            c := fs.stdin&.pop_front()  // :SLOW
                || {
                if i == 0 {
                    // TODO: don't hardcode blocking + MIN=1 + timeout=infinity (which is what interactive_read_line wants)
                    // since send_signal clears Task.futex_wait, this sleeps until we get a byte if its the init process reading. 
                    p := bit_cast_unchecked(*i64, *u32, fs.stdin.len&);
                    Futex'wait(p, 0);
                    continue();
                };
                return(i)
            };
            dest[i] = c;
            i += 1;
        };
        i
    };
};

// TODO
MemDir :: @struct {
    files: RawList(Entry);
    Entry :: @struct {
        name: Str;
        handle: FileHandle;
    };

    fstatat :: fn(self, path, out) = {
        todo();
    };
    openat :: fn(self, path, flags, _mode) = {
        path := path.str();
        @assert(!path.contains("/".ascii())); // TODO
        for self.files { it |
            if it.name == path {
                fd := push_file(it.handle);
                return(fd.fd.intcast());
            };
        };
        -2
    };
};

fn push_file($T: Type, data: T) Fd #generic = {
    data := general_allocator().boxed(T, data);
    push_file(vtable = get_vtable(T), data = T.raw_from_ptr(data))
}

fn push_file(it: FileHandle) Fd = {
    fs.mutex&.lock();
    fd := fs.fd.len;
    fs.fd&.push(it);
    @assert_ne(fd, MAX_i32, "TODO: wrap");
    fs.mutex&.unlock();
    (fd = fd.intcast())
}

FuseFile :: @struct {
    q: *UQueue;
    nodeid: u64;
    fh: u64;
    
    read :: fn(self, buf) = {
        in := zeroed Fuse.ReadIn;
        in.fh = self.fh;
        in.size = buf.len.trunc();
        result := fuse_blocking(self.q, .READ, self.nodeid, in, buf)
            .or(fn(e) => return(e));
        result.data.len
    };
    write :: fn(self, buf) = {
        in := zeroed Fuse.WriteIn;
        in.fh = self.fh;
        in.size = buf.len.trunc();
        in.data = buf;
        result := fuse_blocking(self.q, .WRITE, self.nodeid, in)
            .or(fn(e) => return(e));
        result.size.zext()
    };
    lseek :: fn(self, offset, whence) = {
        todo();
    };
    close :: fn(self) = {
        in := zeroed Fuse.FlushIn;
        in.fh = self.fh;
        fuse_blocking(self.q, .FLUSH, self.nodeid, in)
            .or(fn(e) => @println("FLUSH failed %", e));
        in := zeroed Fuse.FsyncIn;
        in.fh = self.fh;
        fuse_blocking(self.q, .FSYNC, self.nodeid, in)
            .or(fn(e) => @println("FSYNC failed %", e));
        in := zeroed Fuse.ReleaseIn;
        in.fh = self.fh;
        fuse_blocking(self.q, .RELEASE, self.nodeid, in)
            .or(fn(e) => @println("RELEASE failed %", e));
        in := zeroed Fuse.ForgetIn;
        fuse_blocking(self.q, .FORGET, self.nodeid, in)
            .or(fn(e) => @println("FORGET failed %", e));
    };
    fstatat :: fn(self, path, out) = {
        todo();
    };
    openat :: fn(self, path, flags, mode) = {
        todo();
    };
};

fuse_openat :: fn(fd: Fd, path: CStr, flags: i64, mode: i64) i64 = {
    @assert(fd.fd == fs.fuse_root.fd, "TODO");
    fd := get_file(fd) || return(-1);
    fd := FuseFile.ptr_from_raw(fd.data);
    q := fd.q;
    
    name := path.str();
    name.len += 1;
    @assert(name[name.len - 1] == 0);
    in: Fuse.LookupIn = (name = name);
    result := fuse_blocking(q, .LOOKUP, fd.nodeid, in)
        .or(fn(e) => return(e));
    node := result.nodeid;

    in: Fuse.OpenIn = (flags = flags.trunc(), open_flags = 0);
    result := fuse_blocking(q, .OPEN, node, in)
        .or(fn(e) => return(e));
    
    fd := push_file(FuseFile, (q = q, nodeid = node, fh = result.fh));
    fd.fd.intcast()
};

init_fuse :: fn(q: *UQueue) Fd = {
    q.pipe = init(general_allocator(), 128);
    
    in := zeroed Fuse.InitIn;
    in.major = Fuse.MAJOR;
    in.minor = Fuse.MINOR;
    result := fuse_blocking(q, .INIT, 0, in).unwrap();
    
    ::DeriveFmt(Fuse.InitOut);
    ::DeriveFmt(Array(u16, 11));
    ::display_slice(u16);
    @println("%", result&);
    
    println("done init fuse");
    push_file(FuseFile, (q = q, nodeid = 1, fh = 0))
}

Fuse :: import("@/examples/os/drivers/fs/fuse.fr");

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I) Result(FuseOutType(I), i64) #where = {
    _, out_dyn := @run count_bufs(FuseOutType(I));
    @assert(out_dyn == 0, "fuse_blocking: pass extra memory for out buffer");
    fuse_blocking(q, op, node, in, empty())
}

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I, e_out: []u8) Result(FuseOutType(I), i64) #where = {
    hi := zeroed Fuse.InHeader;
    hi.opcode = op;
    hi.nodeid = node;
    ho := zeroed Fuse.OutHeader;
    out := zeroed FuseOutType(I);
    old := q.pipe.done.committed.bouba;
    // TODO: putting stack memory in the queue relies on blocking
    send(q, hi&, in&, ho&, out&, e_out);
    while => q.pipe.done.committed.bouba == old {
        q'poll(q);
    };
    @if(ho.error != 0) return(Err = ho.error.intcast());
    extra := ho.len.zext() - size_of(@type out);
    extra := e_out.slice(0, extra.max(0).min(e_out.len));
    
    out_fixed, out_dyn := @run count_bufs(@type out);
    @assert(out_dyn <= 1, "TODO: multiple output bufs");
    if out_dyn > 0 {
        p := ptr_from_int([]u8, int_from_ptr(@type out, out&) + out_fixed);
        p[] = extra;
    };
    
    (Ok = out)
}

fn send(q: *UQueue, hi: *Fuse.InHeader, in: ~I, ho: *Fuse.OutHeader, out: ~O, eo: []u8) void #where #inline/*semantic*/ = {
    f :: fn(data: ~T) []u8 #where => {
        ::[]@type data[];
        data.slice(1).interpret_as_bytes()
    };
    // TODO: putting stack memory in the queue relies on blocking
    bufs := @uninitialized Array([]u8, 10); bi := 0;
    push_buf :: fn(b: []u8) => { bufs&[bi] = b; bi += 1; };
    
    hi.len = 0;
    ::[]@type hi[];
    push_buf(hi.slice(1).interpret_as_bytes());
    hi.len += size_of(@type hi[]);
    
    in_fixed, in_dyn := @run count_bufs(Deref(I));
    b := in.f().slice(0, in_fixed);
    push_buf(b);
    hi.len += b.len.trunc();
    range(0, in_dyn) { i |
        p := ptr_from_int([]u8, Deref(I).int_from_ptr(in) + in_fixed + i * @run size_of([]u8));
        push_buf(p[]);
        hi.len += p.len.trunc();
    };
    readable := bi;
    
    push_buf(ho.f());
    out_fixed, _ := @run count_bufs(Deref(O));
    b := out.f().slice(0, out_fixed);
    push_buf(b);
    push_buf(eo);
    
    bufs := bufs&.items().slice(0, bi);
    q.pipe.work&.push(bufs = bufs, n = (bufs_readable = readable.intcast()))
}

fn count_bufs(T: Type) Ty(i64, i64) #fold = {
    fields := get_fields(T);
    i := 0;
    direct_field_bytes := 0;
    while => i < fields.len && fields[i].ty != []u8 {
        direct_field_bytes += size_of(fields[i].ty);
        i += 1;
    };
    indirect_field_count := 0;
    while => i < fields.len && fields[i].ty == []u8 {
        indirect_field_count += 1;
        i += 1;
    };
    @assert_eq(i, fields.len, "all #inline fields must be after all normal fields");
    (direct_field_bytes, indirect_field_count)
}

FuseOutType :: fn(In: Type) Type #fold = {
    name := In.typename().str();
    @assert(name.ends_with("In"), "expected In type, found %", name);
    @assert(!name.starts_with("*"));
    name = name.slice(0, name.len - 2);
    name := @tfmt("%Out", name);
    Type.get_constant(Fuse, name.sym())
        || @panic("missing Fuse.%", name)
}

fn get_file(fd: Fd) ?FileHandle = {
    @if(fd.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd }) return(Some = fs.root_fd);
    fs.mutex&.lock();
    @if(!fd.fd.intcast().ult(fs.fd.len)) return(.None);
    file := fs.fd[fd.fd.zext()];
    fs.mutex&.unlock();
    (Some = file)
}

FuseId :: @struct(nodeid: u64, fh: u64);
FRes :: fn($T: Type) Type = Result(T, i64);

fn follow_path(fd: Fd, path: CStr) SysResult(Fd) = {
    path := path.str();
    if path.starts_with("./") {
        path = path.rest(2);
    };
    
    first := true;
    i := 0;
    buf := temp().alloc_uninit(u8, path.len + 1);
    loop {
        continue :: local_return;
        start := i;
        while => path[i] != PATH_SEP.ascii() && path[i] != 0 {
            i += 1;
        };
        last := path[i] == 0;
        part := path.slice(start, i);
        buf.slice(0, part.len).copy_from(part);
        buf[part.len] = 0;
        name: Cstr = (ptr = buf.ptr);
        
        if part.len == 0 || part == "." {
            @if(last) return(Ok = fd);
            i += 1;
            continue();
        };
        if part == ".." {
            panic("TODO: go up a directory");
        };

        // :SLOW
        out := zeroed SysStat;
        Posix'fstatat(fd, name, out&, 0).or(fn(err) => {
            if !first {
                _ := Syscall'close(fd);
            };
            return(Err = err)
        });
        
        ifmt := out.st_mode.int().bit_and(Posix.S.IFMT);
        is_dir := ifmt == Posix.S.IFDIR;
        
        @if(!is_dir && !last) return(Err = 20);
        
        new_fd := Posix'openat(fd, name, out&, 0).or(fn(err) => {
            if !first {
                _ := Syscall'close(fd);
            };
            return(Err = err)
        });
        
        if !first {
            _ := Syscall'close(fd);
        };
        @if(last) return(Ok = new_fd);
        fd = new_fd;
        first = false;
        i += 1;
    }
}
