// Virtual File System
// it's all in userspace, the kernel doesn't know anything about file descriptors. 
// some files are backed by a UQueue (which might be a Virt.Queue in the kernel). 
// libc functions that operate on file descriptors forward to a FileVTable. 

// TODO: be consistant about whose job it is to free the FileHandle.data memory.
//       i need more separation between the part that's logically an inode on disk 
//       so shared between file handles and the part thats just state per file handle. 
//       the part where it gets confusing is devices / MemDir. 

fs :: @static(@struct {
    fd: List(FileHandle); // indexed by Fd
    free: RawDeque(Fd);  // TODO: posix wants it to always reuse the lowest value not the oldest closed
    mutex: Mutex;  // locked when push to fd / reading an entry from fd. TODO: RWLock
    // TODO: decide which other things care about being thread safe
    stdin: UQueue;
    stdout: UQueue;
    root_dir: Fd;
    cwd: Fd;
    next_fuse_request_id: u64;
    allocator: Alloc;
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    data: rawptr;
    position := 0;
};

FileVTable :: @struct {
     read: @FnPtr(self: rawptr, buf: []u8, position: i64) i64 = (fn(_0, _1, _2) = -1);
    write: @FnPtr(self: rawptr, buf: []u8, position: i64) i64 = (fn(_0, _1, _3) = -1);
    lseek: @FnPtr(self: rawptr, offset: i64, whence: Whence, position: *i64) i64 = (fn(_0, _1, _2, _4) = -1);
    close: @FnPtr(self: rawptr) void = fn(self) = ();
   openat: @FnPtr(self: rawptr, path: CStr, flags: i64, mode: i64) i64 = (fn(_0, _1, _2, _3) = -1);
    fstat: @FnPtr(self: rawptr, out: *Posix.Linux.StatArm64) i64 = (fn(_0, _1) = -1);
   access: @FnPtr(self: rawptr, mode: i64) i64 = (fn(_0, _1) = 0);
    mkdir: @FnPtr(self: rawptr, path: CStr, mode: i64) i64 = (fn(_0, _1, _2) = -1);
   rename: @FnPtr(self: rawptr, dest_dir: Fd, src_name: CStr, dest_name: CStr) i64 = (fn(_0, _1, _2, _3) = -1);
   posix_getdents: @FnPtr(self: rawptr, buf: []u8, pos: *i64) i64 = (fn(_0, _1, _2) = -1);
    ioctl: @FnPtr(self: rawptr, op: i64, data: rawptr) i64 = (fn(_0, _1, _2) = -1);
    ioctls: []Ty(i64, IoctlErased) = empty();
 truncate: @FnPtr(self: rawptr, a: i64) void = (fn(_0, _1) = ());
};

IoctlErased :: @FnPtr(self: rawptr, data: rawptr) i64;

init_vfs :: fn() void = {
    fs.allocator = general_allocator();
    Pair :: Ty(u32, u32);
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        fs_i := Pair.list(fs.len_including_tombstones * 2, ast_alloc());
        each fs& { name, info |
            off := contents.len;
            contents&.push_all(name);
            push(fs_i&, (off.trunc(), name.len.trunc()));
            push(fs_i&, (info._0.trunc(), info._1.trunc()));
        };
        @assert_lt(contents.len, MAX_u32);
        (fs_i.items(), contents.items())
    };
    
    fs.stdin.pipe = init(fs.allocator, 2);
    if !virtq_create(fs.stdin&, "stdio.console", 0) {
        fs.stdin.poll = pl011_int_poll;
    };
    range(0, 2) { _ |
        bufs := fs.allocator.alloc_init([]u8, 1, fn(_) => fs.allocator.alloc_zeroed(u8, 256));
        fs.stdin.pipe.work&.push(bufs = bufs, n = (bufs_readable = 0));
    };
    fs'stdin'poll(fs.stdin&, 0);
    
    fs.stdout.pipe = init(fs.allocator, 1);
    if !virtq_create(fs.stdout&, "stdio.console", 1) {
        fs.stdout.poll = sys_debug_write_poll;
    };
    
    fs.fd = list(fs.allocator);
    push_file(StdinFile, (queue = fs.stdin&));
    push_file(StdoutFile, (queue = fs.stdout&));
    push_file(StdoutFile, (queue = fs.stdout&));
    
    // build a tree of MemDir with MemFileRO leaves containing all the baked files. 
    fs.root_dir = push_file(MemDir, (files = empty()));
    fs.cwd = fs.root_dir;
    root_dir := get_file(fs.root_dir).unwrap();
    MemDir.ptr_from_raw(root_dir.data)[].files&.push((name = ".", handle = root_dir), fs.allocator);
    
    // TODO: let user iterate the tags and mount them manually 
    q := fs.allocator.box_zeroed(UQueue);
    have_fuse_target_dir := virtq_create(q, "Host.fs", 1);
    if have_fuse_target_dir {
        fuse_root := init_fuse(q);
        cwd := get_file(fs.root_dir).unwrap();
        cwd := MemDir.ptr_from_raw(cwd.data);
        child := get_file(fuse_root).unwrap();
        child := FuseFile.ptr_from_raw(child.data)[];
        create_child(cwd, "target", FuseFile, child);
    };
    // else :leak
    
    // TODO: deduplicate with follow_path
    while => fs_i.len > 0 {
        continue :: local_return;
        off, len := fs_i[0];
        info := fs_i[1];
        fs_i = fs_i.rest(2);
        name := contents.subslice(off.zext(), len.zext());
        
        if have_fuse_target_dir && name.contains("target/") {
            // HACK: web version needs you to include a generated file but here i want to just share the whole directory,
            //       and i don't support like an overlay thing where you merge both. 
            continue();
        };
        
        cwd := root_dir;
        i := 0;
        while => i < name.len {
            continue :: local_return;
            start := i;
            while => i < name.len && name[i] != PATH_SEP.ascii() {
                i += 1;
            };
            part := name.slice(start, i);
            i += 1;
            self := MemDir.ptr_from_raw(cwd.data);
            if i >= name.len {  // file
                off, len := info;
                _ := create_child(self, part, MemFileRO, (
                    contents = contents.subslice(off.zext(), len.zext()),
                ));
            } else {  // folder
                break :: local_return;
                it := self.files.find(fn(it) => it.name == part) || {
                    c, _ := create_child_dir(cwd, part);
                    cwd = c;
                    break()
                };
                cwd = it.handle;
            }
        }
    };
    
    // TODO: i need a thing for doing overlays.
    //       i want to be able to write a window manager and have you still
    //       be able to use programs that think they own the whole /dev/fb0 
    //       and they just get a little rectangle of the real screen. 
    // TODO: also don't want this as a blessed api, 
    //       programs that need it should call something to mount it at the beginning? 
    //       similarly, if a program doesn't need graphics it shouldn't be allowed them
    //       so this shouldn't exist implicitly
    _, dev := create_child_dir(root_dir, "dev");
    _ := create_child(dev, "fb0", import("@/examples/os/user/libc/impl/fb.fr").DeviceFile, ());
}

fn create_child_dir(parent: FileHandle, name: Str) Ty(FileHandle, *MemDir) = {
    p := MemDir.ptr_from_raw(parent.data);
    child := create_child(p, name, MemDir, (files = empty()));
    c := MemDir.ptr_from_raw(child.data);
    c.files&.push((name = ".", handle = child), fs.allocator);
    c.files&.push((name = "..", handle = parent), fs.allocator);
    (child, c)
}

fn create_child(self: *MemDir, name: Str, $T: Type, data: T) FileHandle #generic = {
    each self.files { it |
        @assert_ne(it.name, name, "create_child: duplicate");
    };
    data := fs.allocator.boxed(T, data);
    fd: FileHandle = (vtable = get_vtable(T), data = T.raw_from_ptr(data));
    self.files&.push((name = name, handle = fd), fs.allocator);
    fd
}

// mechanisms, not policies :)
get_vtable :: fn($T: Type) *FileVTable = @static(FileVTable) {
    vtable: FileVTable = ();
    S :: Type.scope_of(T);

    fr := current_compiler_context();
    p := bit_cast_unchecked(*FileVTable, *rawptr, vtable&);
    ioctls := Ty(i64, IoctlErased).list(ast_alloc());
    for get_constants(S) { name |
        continue :: local_return;
        val, ty := get_constant(S, name) || continue();
        @if(ty != FuncId) continue();
        fid := FuncId.ptr_from_raw(val)[];
        func := get_function_ast(fid, true, false, false, false);
        if func.annotations&.index_of(fn(it) => it.name == @symbol ioctl) { i |
            func.arg.bindings[0].ty = (Finished = *T);
            func.ret = (Finished = i64);
            ioctl := const_eval(i64)(func.annotations[i].args);
            callee := bit_cast_unchecked(rawptr, IoctlErased, fr.get_jitted(fid));
            push(ioctls&, (ioctl, callee));
            continue();
        };
        
        field := Fields(FileVTable).from_name(name.str())
            || continue();
        
        fptrtype := FieldType(FileVTable, field).get_type_info_ref();
        @debug_assert(fptrtype.is(.FnPtr));
        args := fr.arg_types(fptrtype.FnPtr.ty.arg);
        @ct_assert(args.len == func.arg.bindings.len, func.loc, "arity error in FileVTable");
        range(0, args.len) { i |
            func.arg.bindings[i].ty = (Finished = args[i]);
        };
        func.ret = (Finished = fptrtype.FnPtr.ty.ret);
        
        // self := Self.ptr_from_raw(self);
        @debug_assert_eq(args[0], rawptr);
        func.arg.bindings[0].ty = (Finished = *T);
        
        off := FileVTable.offset_of(field) / size_of(rawptr);
        p.offset(off)[] = fr.get_jitted(fid);
    };
    vtable.ioctls = ioctls.items();
    
    vtable
};

MemFileRO :: @struct {
    contents: []u8;
    
    read :: fn(fd, dest, pos) = {
        dest.len = min(dest.len, fd.contents.len - pos).max(0);
        src := fd.contents.subslice(pos, dest.len);
        dest.copy_from(src);
        dest.len
    };
    lseek :: fn(fd, offset, whence, position) = 
        lseek_impl(offset, whence, position, => fd.contents.len); 
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFREG;
        0
    };
};

MemFile :: @struct {
    contents: RawList(u8);
    
    read :: fn(self, dest, pos) = {
        dest.len = min(dest.len, self.contents.len - pos).max(0);
        src := self.contents.items().subslice(pos, dest.len);
        dest.copy_from(src);
        dest.len
    };
    lseek :: fn(self, offset, whence, position) = 
        lseek_impl(offset, whence, position, => self.contents.len); 
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFREG;
        0
    };
    write :: fn(self, src, pos) = {
        extra := (src.len + pos) - self.contents.len;
        if extra > 0 {
            self.contents&.reserve(extra, fs.allocator);
            self.contents.len += extra;
        };
        dest := self.contents.items().subslice(pos, src.len);
        dest.copy_from(src);
        dest.len
    }
    truncate :: fn(self, a) = {
        self.contents.len = 0;
    }
};

StdoutFile :: @struct {
    queue: *UQueue;
    
    write :: fn(self, src, _) = {
        q := self.queue;
        q'poll(q, 1);
        old := q.pipe.done.committed.bouba;
        q.pipe.work&.push(bufs = @slice(src), n = (bufs_readable = 1));
        while => q.pipe.done.committed.bouba == old {
            // TODO: can i get an interrupt for this instead of spinning?
            q'poll(q, 0);
        };
        done := q.pipe.done&.pop();
        @assert(identical(done.bufs[0].ptr, src.ptr));
        src.len
    };
};

StdinFile :: @struct {
    queue: *UQueue;
    bufs: [][]u8 = empty();
    buf: []u8 = empty();
    
    read :: fn(self, dest, _) = {
        // TODO: don't hardcode blocking + MIN=1 + timeout=infinity (which is what interactive_read_line wants)
        
        if self.buf.len == 0 {
            self'queue'poll(self.queue, 1);  
            entry := self.queue.pipe.done&.pop();
            @debug_assert_eq(entry.bufs.len, 1);
            self.bufs = entry.bufs;
            self.buf = entry.bufs[0].slice(0, entry.n.bytes_written.zext());
        };
        dest.len = min(dest.len, self.buf.len);
        dest.copy_from(self.buf.slice(0, dest.len));
        self.buf = self.buf.rest(dest.len);
        each dest { it |
            if it[] == "\r".ascii() {
                it[] = "\n".ascii();
            };
        };
        if self.buf.len == 0 {
            self.queue.pipe.work&.push(bufs = self.bufs, n = (bufs_readable = 0));
            self'queue'poll(self.queue, 0);
        };
        dest.len
    };
};

MemDir :: @struct {
    files: RawList(Entry);
    Entry :: @struct {
        name: Str;
        handle: FileHandle;
    };
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFDIR;
        0
    };
    openat :: fn(self, path, flags, _mode) = {
        path := path.str();
        trunc := flags.bit_and(LinuxLibc.O_arm.TRUNC) != 0;
        for self.files { it |
            if it.name == path {
                ::ptr_utils(FileVTable);
                if trunc {
                    it'handle'vtable'truncate(it.handle.data, 0);
                };
                fd := push_file(it.handle);
                return(fd.fd.intcast());
            };
        };
        create := flags.bit_and(LinuxLibc.O_arm.CREAT) != 0;
        directory := flags.bit_and(LinuxLibc.O_arm.DIRECTORY) != 0;
        @if(!create) return(-1);
        if directory {
            @trace("ERR: can't O_CREAT a directory");
            return(-1);
        };
        
        path := path.shallow_copy(fs.allocator);
        fd := create_child(self, path, MemFile, (contents = empty()));
        fd := push_file(fd);
        fd.fd.intcast()
    };
    mkdir :: fn(self, path, _mode) = {
        name := path.str();
        each self.files { it |
            @if(it.name == name) return(-1);
        };
        
        self: FileHandle = (vtable = get_vtable(MemDir), data = MemDir.raw_from_ptr(self));
        name := name.shallow_copy(fs.allocator);
        _ := create_child_dir(self, name);
        0
    };
    rename :: fn(self, dest_dir, src_name, dest_name) = {
        dest_dir := get_file(dest_dir) || return(-1);
        ::ptr_utils(FileVTable);
        @if(!identical(dest_dir.vtable, get_vtable(MemDir))) return(-1);
        dest_dir := MemDir.ptr_from_raw(dest_dir.data);
        
        src_name := src_name.str();
        i := self.files.index_of(fn(it) => it.name == src_name)
            || return(-1);
        src_file := self.files&.unordered_remove(i).unwrap();
        
        dest_name := dest_name.str();
        dest := dest_dir.files.find(fn(it) => it.name == dest_name) || {
            dest_dir.files&.push((
                name = dest_name.shallow_copy(fs.allocator), 
                handle = src_file.handle,
            ), fs.allocator);
            return(0)
        };
        dest.handle = src_file.handle;
        0
    };
    posix_getdents :: fn(self, buf, pos) = {
        capacity := buf.len;
        while => buf.len > size_of(LinuxLibc.DirEnt) && pos[] < self.files.len {
            it := buf&.pop_type(LinuxLibc.DirEnt);
            
            fd := self.files[pos[]]&;
            it.d_ino = bit_cast_unchecked(@type fd.handle.data, u64, fd.handle.data);  // idk
            it.d_seekoff = pos[].bitcast();
            it.d_reclen = size_of(LinuxLibc.DirEnt);
            it.d_name&.items().slice(0, fd.name.len).copy_from(fd.name);
            it.d_name&[fd.name.len] = 0;
            // TODO: d_type

            pos[] += 1;
        };
        capacity - buf.len
    };
    
};

fn push_file($T: Type, data: T) Fd #generic = {
    data := fs.allocator.boxed(T, data);
    push_file(vtable = get_vtable(T), data = T.raw_from_ptr(data))
}

fn push_file(it: FileHandle) Fd = {
    fs.mutex&.lock();
    fd := fs.fd.len;
    if fs.free&.pop_front() { old |
        fd = old.fd.intcast();
        fs.fd[fd] = it;
    } else {
        fs.fd&.push(it);
        @assert_ne(fd, MAX_i32, "TODO: wrap");
    };
    fs.mutex&.unlock();
    (fd = fd.intcast())
}

// translate user/vfs/libc requests into FUSE messages over a UQueue  
// (which might be backed by a virtio-fs device in the kernel). 
// TODO: qring needs to allow you to wait for a specific entry for this to be thread safe 
FuseFile :: @struct {
    q: *UQueue;
    nodeid: u64;
    fh: u64;
    is_dir: bool;  // sad
    
    fn do_read(self: *FuseFile, buf: []u8, position: i64) i64 = {
        op: Fuse.Opcode = @if(self.is_dir, .READDIR, .READ);
    split_io_chunks(buf) { buf |
        in := zeroed Fuse.ReadIn;
        in.fh = self.fh;
        in.offset = position.bitcast();
        in.size = buf.len.trunc();
        result := fuse_blocking(self.q, op, self.nodeid, in, buf)
            .or(fn(e) => return(e));
        position += result.data.len;
        result.data.len
    }
    };
    read :: fn(self, buf, position) = {
        @if(self.is_dir) return(-1);
        do_read(self, buf, position)
    };
    write :: fn(self, buf, position) = {
    split_io_chunks(buf) { buf |
        in := zeroed Fuse.WriteIn;
        in.fh = self.fh;
        in.size = buf.len.trunc();
        in.data = buf;
        in.offset = position.bitcast();
        result := fuse_blocking(self.q, .WRITE, self.nodeid, in)
            .or(fn(e) => return(e));
        position += result.size.zext();
        result.size.zext()
    }
    };
    lseek :: fn(self, offset, whence, position) = {
        lseek_impl(offset, whence, position) {
            in: Fuse.LseekIn = (
                fh = self.fh,
                offset = offset.bitcast(),
                whence = (@as(i64) whence).trunc(),
            );
            result := fuse_blocking(self.q, .LSEEK, self.nodeid, in)
                .or(fn(e) => return(e));
            result.offset.bitcast()
        }
    }
    close :: fn(self) = {
        // for now only the root is stored in a MemDir, every other fd is unique to an open()
        @if(self.nodeid == 1) return();
        
        in := zeroed Fuse.ReleaseIn;
        in.fh = self.fh;
        op: Fuse.Opcode = @if(self.is_dir, .RELEASEDIR, .RELEASE);
        ::enum(@type op);
        fuse_blocking(self.q, op, self.nodeid, in)
            .or(fn(e) => @trace("% failed %", op, e));
        in := zeroed Fuse.ForgetIn;
        fuse_blocking(self.q, .FORGET, self.nodeid, in)
            .or(fn(e) => @trace("FORGET failed %", e));

        fs.allocator.dealloc_one(FuseFile, self);
    };
    openat :: fn(fd: *FuseFile, path: CStr, flags: i64, mode: i64) i64 = {
        q := fd.q;
        create := flags.bit_and(LinuxLibc.O_arm.CREAT) != 0;
        directory := flags.bit_and(LinuxLibc.O_arm.DIRECTORY) != 0;
        flags = flags.bit_and(LinuxLibc.O_arm.CREAT.bit_not());
        flags = flags.bit_and(LinuxLibc.O_arm.DIRECTORY.bit_not());

        in: Fuse.LookupIn = (name = path.cstr_with_null());
        fh, node := @match(fuse_blocking(q, .LOOKUP, fd.nodeid, in)) {
            fn Ok(result) => {
                node := result.nodeid;
                op: Fuse.Opcode = @if(directory, .OPENDIR, .OPEN);
                in: Fuse.OpenIn = (flags = flags.trunc(), open_flags = 0);
                result := fuse_blocking(q, op, node, in)
                    .or(fn(e) => return(e));
                (result.fh, node)
            }
            fn Err(e) => {
                @if(!create) return(e);
                @trace("create(%)", path);
                @if(directory) @trace("ERR: can't O_CREAT a directory");
                in: Fuse.CreateIn = (
                    flags = flags.trunc(),
                    mode = mode.trunc(),
                    open_flags = 0,
                    umask = 0,
                    name = path.cstr_with_null(),
                );
                result := fuse_blocking(q, .CREATE, fd.nodeid, in)
                    .or(fn(e) => return(e));
                (result.open.fh, result.lookup.nodeid)
            }
        };
        fd := push_file(FuseFile, (q = q, nodeid = node, fh = fh, is_dir = directory));
        fd.fd.intcast()
    };
    fstat :: fn(self, out) = {
        in := zeroed Fuse.StatxIn;
        result := fuse_blocking(self.q, .STATX, self.nodeid, in)
            .or(fn(e) => return(e));
        // TODO: rest of the fucking owl
        out.st_mode = result.stat.mode.zext();
        0
    };
    rename :: fn(self, dest_dir, src_name, dest_name) = {
        dest_dir := get_file(dest_dir) || return(-1);
        ::ptr_utils(FileVTable);
        @if(!identical(dest_dir.vtable, get_vtable(FuseFile))) return(-1);
        dest_dir := FuseFile.ptr_from_raw(dest_dir.data);
        
        in: Fuse.RenameIn = (
            newdir = dest_dir.nodeid, 
            name = src_name.cstr_with_null(),
            newname = dest_name.cstr_with_null(),
        );
        _ := fuse_blocking(self.q, .RENAME, self.nodeid, in)
            .or(fn(e) => return(e));
        
        0
    };
    mkdir :: fn(self, path, mode) = {
        in: Fuse.MkdirIn = (
            mode = mode.trunc(),
            umask = 0,
            name = path.cstr_with_null(),
        );
        result := fuse_blocking(self.q, .MKDIR, self.nodeid, in)
            .or(fn(e) => {
                @if(e == -74) return(0);  // TODO: wtf does that mean, clearly its still makign the directory
                return(e)
            });
        0
    };
    
    posix_getdents :: fn(self, buf, pos) i64 = {
        @if(!self.is_dir) return(-1);
        @if(self.nodeid == 1) @panic("TODO: didn't opendir the mount point so this won't work");
        result := do_read(self, buf, pos[]);
        @if(result < 0) return(result);
        pos[] += result;
        buf.len = result;
        
        // remap between fuse and syscall layout. 
        // the fuse one has a bigger header so it can be done in-place 
        // (but you can't just use d_reclen to skip copying the name backwards)
        i := 0;
        o := 0;
        while => i < buf.len {
            @debug_assert(i >= o);
            in := buf.rest(i).peek_type(Fuse.Dirent);
            out := buf.rest(o).peek_type_unchecked(LinuxLibc.DirEnt);
            namelen: i64 = in.namelen.zext();
            type := in.type;
            
            out.d_ino = in.ino;
            out.d_seekoff = in.off;
            out.d_type = @as(DirEntType) @as(u8) type.trunc();  // TODO: unknown if extra bits? 
            out.d_reclen = trunc(19 + namelen + 1);
            if namelen > 255 {
                @trace("TODO: do i want to allow large file names somehow?");
                return(-1);
            };
            src := buf.subslice(i + size_of(Fuse.Dirent), namelen);
            dest := out.d_name&.items().slice(0, namelen);
            dest.copy_from(src);
            dest.end_pointer()[] = 0;
            
            // FUSE THINKS ALIGNMENT IS REAL
            i += (size_of(Fuse.Dirent) + namelen).ualign_to(8);
            o += out.d_reclen.zext();
        };
        
        o
    }
    
};

fn lseek_impl(offset: i64, whence: Whence, position: *i64, $get_size: @Fn() i64) i64 = {
    ::enum(@type whence);
    position[] = offset + @match(whence) {
        fn End() => get_size();
        fn Set() => 0;
        fn Cur() => position[];
    };
    position[]
}

// HACK
split_io_chunks :: fn(buf: []u8, $body: @Fn(buf: []u8) i64) i64 = {
    // TODO: this means read/write are not atomic anymore! :FUCKED
    // TODO: get the limit from fuse init info?
    //       theres a max_write and a max_read_ahead (is that what i want?)
    // TODO: given that im doing a bunch, its stupid to block on each, one at a time :SLOW
    MAX :: 1.shift_left(14);  
    total := 0;
    dowhile {
        try_read := buf.len;
        partial := try_read > MAX; 
        if partial {
            try_read = MAX;
        };
        read_len := body(buf.subslice(0, try_read));
        total += read_len;
        buf = buf.rest(read_len);
        read_len != 0 && buf.len > 0 && partial
    };
    total
} 

cstr_with_null :: fn(it: CStr) []u8 = {
    s: []u8 = (ptr = it.ptr, len = it.str().len() + 1);
    @assert_eq(s[s.len - 1], 0);
    s
};

init_fuse :: fn(q: *UQueue) Fd = {
    q.pipe = init(fs.allocator, 128);
    
    in := zeroed Fuse.InitIn;
    in.major = Fuse.MAJOR;
    in.minor = Fuse.MINOR;
    result := fuse_blocking(q, .INIT, 0, in).unwrap();
    
    ::DeriveFmt(Fuse.InitOut);
    ::DeriveFmt(Array(u16, 11));
    ::display_slice(u16);
    @tfmt("%", result&);  // coconut.jpg
    push_file(FuseFile, (q = q, nodeid = 1, fh = 0, is_dir = false))
}

Fuse :: import("@/examples/os/drivers/fs/fuse.fr");

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I) Result(FuseOutType(I), i64) #where = {
    _, out_dyn := @run count_bufs(FuseOutType(I));
    @assert(out_dyn == 0, "fuse_blocking: pass extra memory for out buffer");
    fuse_blocking(q, op, node, in, empty())
}

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I, e_out: []u8) Result(FuseOutType(I), i64) #where = {
    hi := zeroed Fuse.InHeader;
    hi.opcode = op;
    hi.nodeid = node;
    hi.unique = u64.atomic_inc(fs.next_fuse_request_id&);
    ho := zeroed Fuse.OutHeader;
    out := zeroed FuseOutType(I);
    old := q.pipe.done.committed.bouba;
    // TODO: putting stack memory in the queue relies on blocking
    send(q, hi&, in&, ho&, out&, e_out);
    while => q.pipe.done.committed.bouba == old {
        // TODO: interrupt instead of spinning but im not finding the intid?
        q'poll(q, 0);
    };
    _ := q.pipe.done&.pop();
    ::enum(@type op);
    @debug_assert(ho.len != 0 || op == .FORGET);  // no reply, virtio is just returning the buffer. 
    @debug_assert(ho.len == 0 || hi.unique == ho.unique);
    @if(ho.error != 0) return(Err = ho.error.intcast().abs().neg());
    extra := ho.len.zext() - size_of(@type out);
    extra := e_out.slice(0, extra.max(0).min(e_out.len));
    
    out_fixed, out_dyn := @run count_bufs(@type out);
    @debug_assert(out_dyn <= 1, "TODO: multiple output bufs");
    if out_dyn > 0 {
        @debug_assert(ho.len.zext() >= (@run size_of(@type ho)) + out_fixed);
        p := ptr_from_int([]u8, int_from_ptr(@type out, out&) + out_fixed);
        p[] = extra;
    };
    
    (Ok = out)
}

fn send(q: *UQueue, hi: *Fuse.InHeader, in: ~I, ho: *Fuse.OutHeader, out: ~O, eo: []u8) void #where #inline/*semantic*/ = {
    f :: fn(data: ~T) []u8 #where => {
        ::[]@type data[];
        data.slice(1).interpret_as_bytes()
    };
    // TODO: putting stack memory in the queue relies on blocking
    bufs := @uninitialized Array([]u8, 10); bi := 0;
    push_buf :: fn(b: []u8) => { bufs&[bi] = b; bi += 1; };
    
    hi.len = 0;
    ::[]@type hi[];
    push_buf(hi.slice(1).interpret_as_bytes());
    hi.len += size_of(@type hi[]);
    
    in_fixed, in_dyn := @run count_bufs(Deref(I));
    b := in.f().slice(0, in_fixed);
    push_buf(b);
    hi.len += b.len.trunc();
    range(0, in_dyn) { i |
        p := ptr_from_int([]u8, Deref(I).int_from_ptr(in) + in_fixed + i * @run size_of([]u8));
        push_buf(p[]);
        hi.len += p.len.trunc();
    };
    readable := bi;
    
    push_buf(ho.f());
    out_fixed, _ := @run count_bufs(Deref(O));
    b := out.f().slice(0, out_fixed);
    push_buf(b);
    push_buf(eo);
    
    bufs := bufs&.items().slice(0, bi);
    q.pipe.work&.push(bufs = bufs, n = (bufs_readable = readable.intcast()))
}

fn count_bufs(T: Type) Ty(i64, i64) #fold = {
    fields := get_fields(T);
    i := 0;
    direct_field_bytes := 0;
    while => i < fields.len && fields[i].ty != []u8 {
        direct_field_bytes += size_of(fields[i].ty);
        i += 1;
    };
    indirect_field_count := 0;
    while => i < fields.len && fields[i].ty == []u8 {
        indirect_field_count += 1;
        i += 1;
    };
    @assert_eq(i, fields.len, "all #inline fields must be after all normal fields");
    (direct_field_bytes, indirect_field_count)
}

FuseOutType :: fn(In: Type) Type #fold = {
    name := In.typename().str();
    @assert(name.ends_with("In"), "expected In type, found %", name);
    @assert(!name.starts_with("*"));
    name = name.slice(0, name.len - 2);
    name := @tfmt("%Out", name);
    Type.get_constant(Fuse, name.sym())
        || @panic("missing Fuse.%", name)
}

fn get_file(fd: Fd) ?FileHandle = {
    result: ?FileHandle = .None;
    use_file fd { it |
        result = (Some = it[]);
    };
    @if(result.is_none()) @trace("invalid_file(fd = %)", fd.fd);
    result
}

fn use_file(fd: Fd, $body: @Fn(it: *FileHandle) void) void = {
    if fd.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd } {
        fd = fs.cwd;
    };
    fs.mutex&.lock();
    if fd.fd.intcast().ult(fs.fd.len) {
        body(fs.fd[fd.fd.zext()]&);
    };
    fs.mutex&.unlock();
}

FuseId :: @struct(nodeid: u64, fh: u64);
FRes :: fn($T: Type) Type = Result(T, i64);

// [fd(a), str(b/c/d)] -> [fd(a/b/c), str(d)] 
fn follow_path_prefix(fd: Fd, path: Str) Result(Ty(Fd, CStr), i64) = {
    full_path := path;
    if path.starts_with("./") {
        path = path.rest(2);
    };
    if path.starts_with("/") {
        fd = fs.root_dir;
        path = path.rest(1);
    };
    while => path.ends_with("/") {
        path.len -= 1;
        path = @tfmt("%\0", path);
        path.len -= 1;
    };
    
    first := true;
    buf := u8.list(1024, Arena'stack_alloc(1024));
    loop {
        dir, rest := pop_dir_prefix(path) || {
            @assert(path != "", "TODO: special %", full_path);
            return(Ok = (fd, (ptr = path.ptr)));
        };
        @assert(dir != "", "TODO: special %", full_path);
        
        buf&.clear();
        buf&.push_all(dir);
        buf&.push(0);
        unistd :: import("@/examples/os/user/libc/impl/unistd.fr");
        result := unistd'FR_openat(fd, (ptr = buf&.as_ptr()), Posix.O.RDONLY, 0);
        if result < 0 {
            if !first {
                _ := Syscall'close(fd);
            };
            return(Err = result)
        };
        new_fd: Fd = (fd = result.intcast());
        @assert(new_fd.fd != fd.fd, "openat must return unique!!!");
        if !first {
            _ := Syscall'close(fd);
        };
        
        fd = new_fd;
        path = rest;
        first = false;
    };
}

// "a/b/c" -> ("a", "b/c")
fn pop_dir_prefix(path: Str) ?Ty(Str, Str) = {
    @if(path.len == 0) return(.None);
    i := 0;
    while => path[i] != PATH_SEP.ascii() {
        i += 1;
        @if(i == path.len) return(.None);
    };
    (Some = (path.slice(0, i), path.rest(i + 1)))
}

sys_debug_write_poll :: fn(q, who) = {
    @if(who == 1) return();
    entry := q.pipe.work&.pop();
    for entry.bufs { msg |
        sys_debug_write(msg);
    };
    q.pipe.done&.push(entry);
};
