// Virtual File System

fs :: @static(@struct {
    fd: List(FileHandle); // indexed by Fd
    mutex: Mutex;  // locked when push to fd / reading an entry from fd. TODO: RWLock
    // TODO: decide which other things care about being thread safe
    stdin: UQueue;
    strace: bool;
    fuse_q: ?*UQueue;
    root_dir: Fd;
    next_fuse_request_id: u64;
    // TODO: put an allocator here instead of trusting general_allocator
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    data: rawptr;
};

FileVTable :: @struct {
     read: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    write: @FnPtr(self: rawptr, buf: []u8) i64 = (fn(_0, _1) = -1);
    lseek: @FnPtr(self: rawptr, offset: i64, whence: Whence) i64 = (fn(_0, _1, _2) = -1);
    close: @FnPtr(self: rawptr) void = fn(self) = ();
   openat: @FnPtr(self: rawptr, path: CStr, flags: i64, mode: i64) i64 = (fn(_0, _1, _2, _3) = -1);
    fstat: @FnPtr(self: rawptr, out: *Posix.Linux.StatArm64) i64 = (fn(_0, _1) = -1);
};

init_vfs :: fn() void = {
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        // TODO: since i'm not actually using the hash table, store the constant data as a flat array
        (fs, contents.items())
    };
    
    fs.stdin.pipe = init(general_allocator(), 2);
    if !virtq_create(fs.stdin&, "stdio.console", 0) {
        fs.stdin.poll = pl011_int_poll;
    };
    range(0, 2) { _ |
        bufs := general_allocator().alloc_init([]u8, 1, fn(_) => general_allocator().alloc_zeroed(u8, 256));
        fs.stdin.pipe.work&.push(bufs = bufs, n = (bufs_readable = 0));
    };
    fs'stdin'poll(fs.stdin&, 0);
    
    fs.fd = list(general_allocator());
    push_file(StdinFile, (queue = fs.stdin&));
    push_file(StdoutFile, ());
    push_file(StdoutFile, ());
    
    // build a tree of MemDir with MemFileRO leaves containing all the baked files. 
    fs.root_dir = push_file(MemDir, (files = empty()));
    // TODO: deduplicate with follow_path
    each fs_i& { name, info |
        cwd := get_file(fs.root_dir).unwrap();
        i := 0;
        while => i < name.len {
            continue :: local_return;
            start := i;
            while => i < name.len && name[i] != PATH_SEP.ascii() {
                i += 1;
            };
            part := name.slice(start, i);
            i += 1;
            self := MemDir.ptr_from_raw(cwd.data);
            if i >= name.len {  // file
                off, len := info[];
                _ := create_child(self, part, MemFileRO, (
                    contents = contents.subslice(off, len),
                    pos = 0,
                ));
            } else {  // folder
                break :: local_return;
                each self.files { it |
                    if it.name == part {
                        cwd = it.handle;
                        break();
                    }
                };
                cwd = create_child(self, part, MemDir, (files = empty()));
            }
        }
    };
}

fn create_child(self: *MemDir, name: Str, $T: Type, data: T) FileHandle #generic = {
    data := general_allocator().boxed(T, data);
    fd: FileHandle = (vtable = get_vtable(T), data = T.raw_from_ptr(data));
    self.files&.push((name = name, handle = fd), general_allocator());
    fd
}

// mechanisms, not policies :)
get_vtable :: fn($T: Type) *FileVTable = @static(FileVTable) {
    vtable: FileVTable = ();
    S :: Type.scope_of(T);

    fr := current_compiler_context();
    p := bit_cast_unchecked(*FileVTable, *rawptr, vtable&);
    for get_constants(S) { name |
        continue :: local_return;
        field := Fields(FileVTable).from_name(name.str())
            || continue();
        fid := FuncId.get_constant(S, name)
            || @panic("failed to get func %", name.str());
        
        func := get_function_ast(fid, false, false, false, false);
        fptrtype := FieldType(FileVTable, field).get_type_info_ref();
        @debug_assert(fptrtype.is(.FnPtr));
        args := fr.arg_types(fptrtype.FnPtr.ty.arg);
        @assert_eq(args.len, func.arg.bindings.len, "arity error in FileVTable");
        range(0, args.len) { i |
            func.arg.bindings[i].ty = (Finished = args[i]);
        };
        func.ret = (Finished = fptrtype.FnPtr.ty.ret);
        
        // self := Self.ptr_from_raw(self);
        @debug_assert_eq(args[0], rawptr);
        func.arg.bindings[0].ty = (Finished = *T);
        
        p.offset(@as(i64) field)[] = fr.get_jitted(fid);
    };
    
    vtable
};

MemFileRO :: @struct {
    contents: []u8;
    pos: i64;
    
    read :: fn(fd, dest) = {
        dest.len = min(dest.len, fd.contents.len - fd.pos).max(0);
        src := fd.contents.subslice(fd.pos, dest.len);
        dest.copy_from(src);
        fd.pos += dest.len;
        dest.len
    };
    lseek :: fn(fd, offset, whence) = {
        ::enum(Whence);
        fd.pos = @match(whence) {
            fn End() => fd.contents.len;
            fn Set() => offset;
            @default => todo();
        };
        fd.pos
    };
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFREG;
        0
    };
};

// TODO: expose the console to userspace as a UQueue
StdoutFile :: @struct {
    write :: fn(_0, src) = with_syscalls {
        result := Syscall'write((fd = 1), src.ptr, src.len);
        result.value
    };
};

StdinFile :: @struct {
    queue: *UQueue;
    bufs: [][]u8 = empty();
    buf: []u8 = empty();
    
    read :: fn(self, dest) = {
        // TODO: don't hardcode blocking + MIN=1 + timeout=infinity (which is what interactive_read_line wants)
        
        if self.buf.len == 0 {
            self'queue'poll(self.queue, 1);  
            entry := self.queue.pipe.done&.pop();
            @debug_assert_eq(entry.bufs.len, 1);
            self.bufs = entry.bufs;
            self.buf = entry.bufs[0].slice(0, entry.n.bytes_written.zext());
        };
        dest.len = min(dest.len, self.buf.len);
        dest.copy_from(self.buf.slice(0, dest.len));
        self.buf = self.buf.rest(dest.len);
        each dest { it |
            if it[] == "\r".ascii() {
                it[] = "\n".ascii();
            };
        };
        if self.buf.len == 0 {
            self.queue.pipe.work&.push(bufs = self.bufs, n = (bufs_readable = 0));
            self'queue'poll(self.queue, 0);
        };
        dest.len
    };
};

MemDir :: @struct {
    files: RawList(Entry);
    Entry :: @struct {
        name: Str;
        handle: FileHandle;
    };
    fstat :: fn(self, out) = {
        out.st_mode = Posix.S.IFDIR;
        0
    };
    openat :: fn(self, path, flags, _mode) = {
        path := path.str();
        for self.files { it |
            if it.name == path {
                fd := push_file(it.handle);
                return(fd.fd.intcast());
            };
        };
        -2
    };
};

fn push_file($T: Type, data: T) Fd #generic = {
    data := general_allocator().boxed(T, data);
    push_file(vtable = get_vtable(T), data = T.raw_from_ptr(data))
}

fn push_file(it: FileHandle) Fd = {
    fs.mutex&.lock();
    fd := fs.fd.len;
    fs.fd&.push(it);
    @assert_ne(fd, MAX_i32, "TODO: wrap");
    fs.mutex&.unlock();
    (fd = fd.intcast())
}

// translate user/vfs/libc requests into FUSE messages over a UQueue  
// (which might be backed by a virtio-fs device in the kernel). 
// TODO: qring needs to allow you to wait for a specific entry for this to be thread safe 
FuseFile :: @struct {
    q: *UQueue;
    nodeid: u64;
    fh: u64;
    position: u64 = 0;
    
    read :: fn(self, buf) = {
        in := zeroed Fuse.ReadIn;
        in.fh = self.fh;
        in.offset = self.position;
        in.size = buf.len.trunc();
        result := fuse_blocking(self.q, .READ, self.nodeid, in, buf)
            .or(fn(e) => return(e));
        self.position += result.data.len.bitcast();
        result.data.len
    };
    write :: fn(self, buf) = {
        in := zeroed Fuse.WriteIn;
        in.fh = self.fh;
        in.size = buf.len.trunc();
        in.data = buf;
        in.offset = self.position;
        result := fuse_blocking(self.q, .WRITE, self.nodeid, in)
            .or(fn(e) => return(e));
        self.position += result.size.uext();
        result.size.zext()
    };
    lseek :: fn(self, offset, whence) = {
        ::enum(Whence);
        self.position = @match(whence) {
            fn End() => {
                in: Fuse.LseekIn = (
                    fh = self.fh,
                    offset = offset.bitcast(),
                    whence = (@as(i64) whence).trunc(),
                );
                result := fuse_blocking(self.q, .LSEEK, self.nodeid, in)
                    .or(fn(e) => return(e));
                result.offset
            }
            fn Set() => offset.bitcast();
            @default => @panic("TODO: fuse whence=%", whence);
        };
        self.position.bitcast()
    };
    close :: fn(self) = {
        // for now only the root is stored in a MemDir, every other fd is unique to an open()
        @if(self.nodeid == 1) return();
        
        in := zeroed Fuse.ReleaseIn;
        in.fh = self.fh;
        fuse_blocking(self.q, .RELEASE, self.nodeid, in)
            .or(fn(e) => @println("RELEASE failed %", e));
        in := zeroed Fuse.ForgetIn;
        fuse_blocking(self.q, .FORGET, self.nodeid, in)
            .or(fn(e) => @println("FORGET failed %", e));
    };
    openat :: fn(self, path, flags, mode) = {
        fuse_openat(self, path, flags, mode)
    };
    fstat :: fn(self, out) = {
        in := zeroed Fuse.StatxIn;
        result := fuse_blocking(self.q, .STATX, self.nodeid, in)
            .or(fn(e) => return(e));
        // TODO: rest of the fucking owl
        out.st_mode = result.stat.mode.zext();
        0
    };
};

fuse_openat :: fn(fd: *FuseFile, path: CStr, flags: i64, mode: i64) i64 = {
    q := fd.q;
    
    name := path.str();
    name.len += 1;
    @assert(name[name.len - 1] == 0);
    in: Fuse.LookupIn = (name = name);
    result := fuse_blocking(q, .LOOKUP, fd.nodeid, in)
        .or(fn(e) => return(e));
    node := result.nodeid;

    in: Fuse.OpenIn = (flags = flags.trunc(), open_flags = 0);
    result := fuse_blocking(q, .OPEN, node, in)
        .or(fn(e) => return(e));
    
    fd := push_file(FuseFile, (q = q, nodeid = node, fh = result.fh));
    fd.fd.intcast()
};

init_fuse :: fn(q: *UQueue) Fd = {
    q.pipe = init(general_allocator(), 128);
    
    in := zeroed Fuse.InitIn;
    in.major = Fuse.MAJOR;
    in.minor = Fuse.MINOR;
    result := fuse_blocking(q, .INIT, 0, in).unwrap();
    
    ::DeriveFmt(Fuse.InitOut);
    ::DeriveFmt(Array(u16, 11));
    ::display_slice(u16);
    @println("%", result&);
    push_file(FuseFile, (q = q, nodeid = 1, fh = 0))
}

Fuse :: import("@/examples/os/drivers/fs/fuse.fr");

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I) Result(FuseOutType(I), i64) #where = {
    _, out_dyn := @run count_bufs(FuseOutType(I));
    @assert(out_dyn == 0, "fuse_blocking: pass extra memory for out buffer");
    fuse_blocking(q, op, node, in, empty())
}

fn fuse_blocking(q: *UQueue, op: Fuse.Opcode, node: u64, in: ~I, e_out: []u8) Result(FuseOutType(I), i64) #where = {
    hi := zeroed Fuse.InHeader;
    hi.opcode = op;
    hi.nodeid = node;
    hi.unique = u64.atomic_inc(fs.next_fuse_request_id&);
    ho := zeroed Fuse.OutHeader;
    out := zeroed FuseOutType(I);
    old := q.pipe.done.committed.bouba;
    // TODO: putting stack memory in the queue relies on blocking
    send(q, hi&, in&, ho&, out&, e_out);
    while => q.pipe.done.committed.bouba == old {
        q'poll(q, 0);
    };
    ::enum(@type op);
    @debug_assert(ho.len != 0 || op == .FORGET);  // no reply, virtio is just returning the buffer. 
    @debug_assert(ho.len == 0 || hi.unique == ho.unique);
    @if(ho.error != 0) return(Err = ho.error.intcast());
    extra := ho.len.zext() - size_of(@type out);
    extra := e_out.slice(0, extra.max(0).min(e_out.len));
    
    out_fixed, out_dyn := @run count_bufs(@type out);
    @debug_assert(out_dyn <= 1, "TODO: multiple output bufs");
    if out_dyn > 0 {
        @debug_assert(ho.len.zext() >= (@run size_of(@type ho)) + out_fixed);
        p := ptr_from_int([]u8, int_from_ptr(@type out, out&) + out_fixed);
        p[] = extra;
    };
    
    (Ok = out)
}

fn send(q: *UQueue, hi: *Fuse.InHeader, in: ~I, ho: *Fuse.OutHeader, out: ~O, eo: []u8) void #where #inline/*semantic*/ = {
    f :: fn(data: ~T) []u8 #where => {
        ::[]@type data[];
        data.slice(1).interpret_as_bytes()
    };
    // TODO: putting stack memory in the queue relies on blocking
    bufs := @uninitialized Array([]u8, 10); bi := 0;
    push_buf :: fn(b: []u8) => { bufs&[bi] = b; bi += 1; };
    
    hi.len = 0;
    ::[]@type hi[];
    push_buf(hi.slice(1).interpret_as_bytes());
    hi.len += size_of(@type hi[]);
    
    in_fixed, in_dyn := @run count_bufs(Deref(I));
    b := in.f().slice(0, in_fixed);
    push_buf(b);
    hi.len += b.len.trunc();
    range(0, in_dyn) { i |
        p := ptr_from_int([]u8, Deref(I).int_from_ptr(in) + in_fixed + i * @run size_of([]u8));
        push_buf(p[]);
        hi.len += p.len.trunc();
    };
    readable := bi;
    
    push_buf(ho.f());
    out_fixed, _ := @run count_bufs(Deref(O));
    b := out.f().slice(0, out_fixed);
    push_buf(b);
    push_buf(eo);
    
    bufs := bufs&.items().slice(0, bi);
    q.pipe.work&.push(bufs = bufs, n = (bufs_readable = readable.intcast()))
}

fn count_bufs(T: Type) Ty(i64, i64) #fold = {
    fields := get_fields(T);
    i := 0;
    direct_field_bytes := 0;
    while => i < fields.len && fields[i].ty != []u8 {
        direct_field_bytes += size_of(fields[i].ty);
        i += 1;
    };
    indirect_field_count := 0;
    while => i < fields.len && fields[i].ty == []u8 {
        indirect_field_count += 1;
        i += 1;
    };
    @assert_eq(i, fields.len, "all #inline fields must be after all normal fields");
    (direct_field_bytes, indirect_field_count)
}

FuseOutType :: fn(In: Type) Type #fold = {
    name := In.typename().str();
    @assert(name.ends_with("In"), "expected In type, found %", name);
    @assert(!name.starts_with("*"));
    name = name.slice(0, name.len - 2);
    name := @tfmt("%Out", name);
    Type.get_constant(Fuse, name.sym())
        || @panic("missing Fuse.%", name)
}

fn get_file(fd: Fd) ?FileHandle = {
    if fd.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd } {
        fd = fs.root_dir;
    };
    fs.mutex&.lock();
    @if(!fd.fd.intcast().ult(fs.fd.len)) return(.None);
    file := fs.fd[fd.fd.zext()];
    fs.mutex&.unlock();
    (Some = file)
}

FuseId :: @struct(nodeid: u64, fh: u64);
FRes :: fn($T: Type) Type = Result(T, i64);

fn follow_path(fd: Fd, path: Str) SysResult(Fd) = {
    if path.starts_with("./") {
        path = path.rest(2);
    };
    
    first := true;
    i := 0;
    buf := temp().alloc_uninit(u8, path.len + 1);
    loop {
        continue :: local_return;
        start := i;
        while => i < path.len && path[i] != PATH_SEP.ascii() {
            i += 1;
        };
        last := i == path.len;
        part := path.slice(start, i);
        buf.slice(0, part.len).copy_from(part);
        buf[part.len] = 0;
        name: CStr = (ptr = buf.ptr);
        
        // TODO: don't allow "foo/bar/file.txt/."
        if part.len == 0 || part == "." {
            @if(last) return(Ok = fd);
            i += 1;
            continue();
        };
        if part == ".." {
            panic("TODO: go up a directory");
        };

        // :SLOW
        out := zeroed Posix.Stat;
        result := Posix'fstatat(fd, name, out&, 0);
        if result&.is_err() {
            err := result.Err;
            if !first {
                _ := Syscall'close(fd);
            };
            return(Err = err)
        };
        
        ifmt := out.st_mode.int().bit_and(Posix.S.IFMT);
        is_dir := ifmt == Posix.S.IFDIR;
        
        @if(!is_dir && !last) return(Err = (_ = 20));
        
        // TODO: opendir flag?
        result := Posix'openat(fd, name, 0, 0);
        if result&.is_err() {
            err := result.Err;
            if !first {
                _ := Syscall'close(fd);
            };
            return(Err = err)
        };
        new_fd := result.Ok;
        
        if !first {
            _ := Syscall'close(fd);
        };
        @if(last) return(Ok = new_fd);
        fd = new_fd;
        first = false;
        i += 1;
    }
}
