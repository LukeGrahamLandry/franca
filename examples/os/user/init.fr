
main :: fn() void = {
    println("init!");
    
    // note: this only affects the main thread
    //       should probably wrap it for the pthread_create part
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(16) * 10);
    buf.set_bytes(0);  // :SLOW force it to commit the pages
    _ := set_signal_handler(callee = handle_signal, stack = buf);
    
    // TODO: real file system. for now just embed the blob of all the files like the web demo does. 
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        (fs, contents.items())
    };
    fs.index = fs_i;
    fs.contents = contents;
    fs.stdin = init(general_allocator(), 1.shift_left(16));
    fs.fd = list(general_allocator());
    range(0, 3) { _ |
        f := zeroed FileHandle;
        f.vtable = stdout_file;
        fs.fd&.push(f);
    };
    fs.fd[0].vtable = stdin_file;
    
    //import("@/examples/toy/reloc.fr")'main();
    if query_current_arch() != .wasm32 {
        redo_relocations_static_linux();
    };
    push_dynamic_context {
        c := context(DefaultContext);
        c.prefer_syscalls = false;
        
        Crash'push_aot_debug_resolver();
        c.panic_hook = fn(s) = {
            c := context(DefaultContext);
            c.prefer_syscalls = true;
            Crash'backtracing_panic_handler(s)
        };
        
        // TODO: this shouldn't be needed but the compiler's dying in get_environment_variable. 
        xxx := zeroed CStr;
        c.environment_variables = xxx&;
        
        c.cli_arguments = empty();
        signal_env[] = c[];
        signal_env.thread_index = -1;  // make handle_signal NOT count as the same thread for reenterant mutex

        // remember to reduce codegen_queue_size to make kaleidoscope work
        //push_dynamic_context { 
        //    import("@/compiler/main.fr")'main2("examples/kaleidoscope.fr", true);
        //};
        //Syscall'exit(0);
        
        buf := u8.list(general_allocator());
        timer := false;
        @println("The system took %ms to boot.", timestamp());
        // TODO: this shell should share some logic with examples/terminal.fr
        loop {
            mark := temp().mark();
            old := fs.strace;  // TODO: not thread safe
            fs.strace = false;
            Term'interactive_read_line(buf&);
            print("\n");
            fs.strace = old;
            
            command := buf.items();
            parts := command.split(" ", temp()).items();
            @switch(parts[0]) {
                @case("exit") => Syscall'exit(0);
                @case("quit") => Syscall'exit(0);
                @case("uptime") => {   
                    @println("%ms", timestamp());
                };
                @case("strace") => {
                    fs.strace = parts[1] == "on" || parts[1] == "true";
                };
                @case("time") => {
                    timer = parts[1] == "on" || parts[1] == "true";
                };
                @case("help") => print(SHELL_HELP.rest(1));
                @default => {
                    break :: local_return;
                    command := parts[0];
                    if command.ends_with(".fr") {
                        if fs.index&.get(command).is_none() {
                            check := @tfmt("examples/%", command);
                            if fs.index&.get(check).is_none() {
                                @println("file not found: %", command);
                                break();
                            } else {
                                command = check;
                            };
                        }
                        
                        println("compiling...");
                        start := timestamp();
                        push_dynamic_context { 
                            c := context(DefaultContext);
                            args := CStr.list(temp());
                            args&.push("franca".as_cstr());
                            for parts { it |
                                args&.push(it.as_cstr());
                            };
                            c.cli_arguments = args.items();
                            
                            import("@/compiler/main.fr")'main2(command, true);
                        };
                        if timer {
                            @print("(%ms)\n", timestamp() - start);
                        };
                        // TODO: don't crash on compile error
                    } else {
                        @print("unknown command: |%|\n", buf.items());
                    };
                };
            };
            buf&.clear();
            temp().reset(mark);
        };
    };
}

fs :: @static(@struct {
    contents: []u8;
    index: RawHashMap(Str, Ty(i64, i64));
    fd: List(FileHandle);
    mutex: Mutex;
    stdin: import("@/lib/collections/deque.fr")'RawDeque(u8);
    strace: bool;
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    contents: []u8;
    pos: i64;
    readable: bool;
};

FileVTable :: @struct {
     read: @FnPtr(self: *FileHandle, buf: []u8) i64;
    write: @FnPtr(self: *FileHandle, buf: []u8) i64;
    lseek: @FnPtr(self: *FileHandle, offset: i64, whence: Whence) i64;
    close: @FnPtr(self: *FileHandle) void = fn(self) = ();
};

signal_env :: @static(DefaultContext);

// note: intid != ctx.intid is legal because an interrupt might have triggered while a different task was running. 
//       ex. uart always goes to the init task. 
handle_signal :: fn(ctx: *MContext, intid: i64, data: i64) i64 = {
    set_dynamic_context(DefaultContext.raw_from_ptr(signal_env));
    // TODO: don't hardcode the 33. get it from device tree. 
    if intid == 33 || intid == 69 || intid == 37 {
        char: u8 = data.trunc();
        if char == 3 {
            println("^c");
            // TODO: this doesn't work reliably. try it in examples/chess/perft.fr and it can get stuck? 
            Syscall'exit(1);  // will stop the whole system if this is the init task (which it always is rn)
        };
        if char == 13 {
            char = 10;
        };
        // TODO: what if interrupted while reading
        fs.stdin&.push_back(char, panicking_allocator);
        
        p := bit_cast_unchecked(*i64, *u32, fs.stdin.len&);
        Futex'wake(p, 1);  // :SLOW. only needed if its not the init process sleeping in the read
        
        return(intid);
    };
    
    ec := ctx.esr.shift_right_logical(26).bit_and(0b111111);
    // TODO: import Gic.null_interrupt_id
    if intid != 1023 || ec != 0b010101 {
        push_emergency_dynamic_environment {
            context(DefaultContext)[].prefer_syscalls = true;
            @println("sp = %; fp = %; lr = %; ip = %;", ctx.gpr&[31], ctx.gpr&[29], ctx.gpr&[30], ctx.elr);
            Crash'backtracing_panic_handler("fatal signal");
        };
    };
    
    // when targeting real linux, (open,fstat)at have a sucky abi so its easier to just do the syscall 
    // instead of trying to use glibc, which makes intercepting them more painful. 
    syscall_number := ctx.gpr&[8];
    @assert_eq(syscall_number, ctx.gpr&[16]);
    // TODO: instead of doing work here, just poke a call to the libc handler into ctx[lr, elr]
    @switch(syscall_number) {
        @case(56) => {  // openat
            path := u8.ptr_from_int(ctx.gpr&[1]);
            path := (@as(CStr) (ptr = path)).str();
            if fs.index&.get(path) { off, len |
                // TODO: this is a dead lock if the thing locking it is the thing that was interrupted
                if !fs.mutex&.try_lock() {
                    panic("fucked: openat with fs.mutex locked");
                };
                fd := fs.fd.len;
                fs.fd&.push(
                    vtable = read_only_mem_file,
                    contents = fs.contents.subslice(off, len),
                    pos = 0,
                    readable = true,
                );
                fs.mutex&.unlock();
                ctx.gpr&[0] = fd;
            } else {
                ctx.gpr&[0] = -1;
            };
            @trace("openat(%) = %", path, ctx.gpr&[0]);
        };
        @case(79) => {  // fstatat
            path := u8.ptr_from_int(ctx.gpr&[1]);
            path := (@as(CStr) (ptr = path)).str();
            @trace("fstatat(%)", path);
            out := Posix.Linux.StatArm64.ptr_from_int(ctx.gpr&[2]);
            ::[]@type out[];
            out.slice(1).set_zeroed();
            if fs.index&.get(path) { off, len |
                out.st_mode = Posix.S.IFREG;
                ctx.gpr&[0] = 0;
            } else {
                ctx.gpr&[0] = -1;
            };
        };
        @default => {
            @panic("invalid syscall %", syscall_number);
        };
    };
    intid
}

redo_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    header := Elf.Header.ptr_from_raw(base);
    @assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    unpacked.strings.ptr = unpacked.strings.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        name: CStr = (ptr = unpacked.strings.index(sym.name.zext()));
        name := name.str();
        
        type := sym.info.shift_right_logical(4);
        if sym.value == 0 {
            temporary_libc_import(name, dest, false);
        }
    };
};

temporary_libc_import :: fn(name: Str, dest: *rawptr, allow_null: bool) void = {
    LIBC_s :: Type.scope_of(LIBC);
    inline_for get_constants(LIBC_s) { $n |
        fid :: get_constant(FuncId, LIBC_s, n[]).unwrap();
        check := @run n[].str();
        if name == check {
            dest[] = fid;
            return();
        };
    };
    
    if !allow_null {
        dest[] = fn() void = panic("called a weak import");
    };
}

MyAttr :: @struct {
    stack: []u8;
};

LIBC :: @struct {
    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 = with_syscalls {
                result := Syscall'mmap(addr, len, prot, flags, fd, offset);
                @trace("mmap(%, %) = %", len, flags, result);
                @assert_ne(result, 0, "some sort of corruption is going on because i over commit and can't null");
                result
    };
    munmap :: fn(addr: rawptr, len: i64) i64 = with_syscalls {
                result := Syscall'munmap(addr, len);
                @trace("mumap(%, %)", addr, len);
                @assert_eq(result.value, 0, "some sort of corruption is going on. munmap(%) can't fail", addr);
                result.value
    };
    mprotect :: fn() = 0;
    read :: fn(f: Fd, buf: *u8, len: i64) i64 = with_file f { fd |
        @trace("read(%, %, %)", f.fd, u8.int_from_ptr(buf), len);
        fd'vtable'read(fd, buf.slice(len))
    };
    close :: fn(f: Fd) i64 = with_file f { fd |
        @trace("close(%)", f.fd);
        fd'vtable'close(fd);
        // TODO: reuse slots of the array
        0
    };
    dlopen :: fn(name: CStr) rawptr = {
        @trace("dlopen(%)", name);
        if name == "libc.so.6" {
            return(123.rawptr_from_int());
        };
        zeroed(rawptr)
    };
    dlsym :: fn(lib: rawptr, name: CStr) rawptr = {
        @assert_eq(lib.int_from_rawptr(), 123);
        dest := zeroed(rawptr);
        temporary_libc_import(name.str(), dest&, true);
        @trace("dlsym(%, %) = %", lib, name, dest);
        dest
    };
    dlclose :: fn() = 0;
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
        Syscall'perform_syscall(args&, 94);  // exit
    };
    write :: fn(f: Fd, buf: *u8, size: i64) i64 = with_file f { fd |
        @trace("write(%, %, %)", f.fd, u8.int_from_ptr(buf), size);
        fd'vtable'write(fd, buf.slice(size))
    };
    lseek :: fn(f: Fd, offset: i64, whence: Whence) i64 = with_file f { fd |
        result := fd'vtable'lseek(fd, offset, whence);
        @trace("lseek(fd = %, %, %) = %", f.fd, offset, @as(i64) whence, result);
        result
    };
    __errno_location :: fn() *i64 = @static(i64);
    sigaction :: fn() i64 = 0;
    memmove :: fn(dest: rawptr, src: rawptr, count: i64) void =
                copy_bytes_static(dest, src, count);
    pthread_attr_init :: fn(out: *ThreadAttr) i64 = {
                out[] = zeroed(@type out[]);
                0
    };
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                ctx := zeroed MContext;
                ctx.elr = bit_cast_unchecked(@type callee, i64, callee);
                ctx.gpr&[0] = bit_cast_unchecked(@type userdata, i64, userdata);
                ctx.gpr&[30] = int_from_rawptr(fn() void = {
                    args: Array(i64, 6) = (0, 0, 0, 0, 0, 0);
                    Syscall'perform_syscall(args&, 94);  // exit
                    unreachable()
                });
                ctx.gpr&[31] = bit_cast_unchecked(*u8, i64, attr.stack.end_pointer());
                
                args: Array(i64, 6) = (MContext.int_from_ptr(ctx&), 0, 0, 0, 0, 0);
                id, _ := Syscall'perform_syscall(args&, 0xFFFF0005);  // spawn_thread
                out[] = bit_cast_unchecked(@type id, pthread_t, id);
                @trace("pthread_create(elr = %, x0 = %, sp = %) = %", ctx.elr, ctx.gpr&[0], ctx.gpr&[31], id);
                0
    };
    pthread_attr_setstack :: fn(attr: *ThreadAttr, ptr: *u8, len: i64) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                attr.stack = ptr.slice(len);
                0
    };
    pthread_getcpuclockid :: fn() = 0;
    // TODO: do something like tid_futex instead of just spam yielding like this
    pthread_join :: fn(thread: pthread_t, value_ptr: *rawptr) i64 = {
                id := bit_cast_unchecked(@type thread, i64, thread);
                args: Array(i64, 6) = (id, 0, 0, 0, 0, 0);
                @trace("pthread_join(%)", id);
                while(=> {
                    done, _ := Syscall'perform_syscall(args&, 0xFFFF0006);  // check_thread
                    done == 0
                }, => {
                    Syscall'perform_syscall(args&, 0xFFFF0002);  // yield
                });
                value_ptr[] = zeroed rawptr; // TODO
                0
    };
    // for mandel.ssa
    putchar :: fn(c: u8) = print(c&.slice(1));
    puts :: fn(s: CStr) i64 = {  // for hello.c
        println(s.str());
        0
    };
    
    tcgetattr :: fn(fd: Fd, it: *Term.Terminos) i64 = with_file fd { fd |
        // TODO
        it[] = zeroed(Term.Terminos);
        0
    };
    tcsetattr :: fn(fd: Fd, optional_actions: i64, it: *Term.Terminos) i64 = with_file fd { fd |
        // TODO
        0
    };
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        // TODO: other clock_id's
        time_spec[] = system_counter_uptime();
        0
    };
    // TODO: do this more efficiently. 
    //       if multiple threads are sleeping, just have one yield like this for the shortest duration and the rest futex wait.
    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        @trace("nanosleep(s = %, ns = %)", duration.seconds, duration.nanoseconds);
        @debug_assert_eq(nullable_remainder_out, 0, "todo: sleep remainder");
        zeroes := zeroed Array(i64, 6);
            now := system_counter_uptime();
            end := now + duration[];
            dowhile {
                _ := Syscall'perform_syscall(zeroes&, 0xFFFF0002);  // yield
                now := system_counter_uptime();
                end.ms() > now.ms()
            };
            0
    };
    
    localtime_r :: fn(time_in: *time_t, time_out: *BigTime) *BigTime = {
        // TODO
        time_out[] = zeroed(BigTime);
        time_out
    };
    // TODO: this is supposed to be calander time not system up time
    time :: fn(out: *time_t) time_t = (seconds = timestamp() * 1000);
};

system_counter_uptime :: fn() TimeSpec = {
    // "From Armv8.6-A and Armv9.1-A, the frequency of the count is fixed at 1GHz. 
    //  Pre-Armv8.6-A, the count frequency was a system design choice, typically 
    //  in the range of 1MHz to 50MHz." -- (Learn the architecture - Generic Timer. v1.4)
    // 2^64 nanoseconds is ~585 years.
    // TODO: ns*S_PER_NS overflows in 5.85 years at 1GHz which is enough that it doesn't matter for me but not infinity
    //       but you have to multiply first so you don't truncate
    
    ticks := u64.sys_get(.CNTVCT_EL0);
    ticks_per_s := u64.sys_get(.CNTFRQ_EL0);
    ns := ticks * NS_PER_S / ticks_per_s;
    s, ns_r := ns.div_mod(NS_PER_S);
    (seconds = s.bitcast(), nanoseconds = ns_r.bitcast())
}

fn with_file(fd: Fd, $body: @Fn(fd: *FileHandle) i64) i64 = {
    fs.mutex&.lock();
    fd := fs.fd.index(fd.fd.zext());
    result := @must_return body(fd);
    fs.mutex&.unlock();
    result
}

fn with_syscalls($body: @Fn() i64) i64 = {
    c := context(DefaultContext);
    c.prefer_syscalls = true;
    result := @must_return body();
    c.prefer_syscalls = false;
    result
}

read_only_mem_file :: @static(FileVTable) (
    read = fn(fd, dest) = {
        @if(!fd.readable) return(-1);
        dest.len = min(dest.len, fd.contents.len - fd.pos).max(0);
        src := fd.contents.subslice(fd.pos, dest.len);
        dest.copy_from(src);
        fd.pos += dest.len;
        dest.len
    },
    write = fn(_self, _src) = -1,
    lseek = fn(fd, offset, whence) = {
        @if(!fd.readable) return(-1);
        ::enum(Whence);
        fd.pos = @match(whence) {
            fn End() => fd.contents.len;
            fn Set() => offset;
            @default => todo();
        };
        fd.pos
    },
    close = fn(fd) = {
        fd.readable = false;
    },
);

stdout_file :: @static(FileVTable) (
    read = fn(_fd, _dest) = 0,
    write = fn(_fd, src) = with_syscalls {
        result := Syscall'write((fd = 1), src.ptr, src.len);
        result.value
    },
    lseek = fn(_fd, _offset, _whence) = -1,
    close = fn(_fd) = (),
);

stdin_file :: @static(FileVTable) (
    read = fn(_fd, dest) = {
        fd := ptr_diff(fs.fd.maybe_uninit.ptr, _fd);
        i := 0;
        while => i < dest.len {
            continue :: local_return;
            // TODO: this is a race with the interrupt handler adding more bytes
            c := fs.stdin&.pop_front()  // :SLOW
                || {
                if i == 0 {
                    // TODO: don't hardcode blocking + MIN=1 + timeout=infinity (which is what interactive_read_line wants)
                    // since send_signal clears Task.futex_wait, this sleeps until we get a byte if its the init process reading. 
                    p := bit_cast_unchecked(*i64, *u32, fs.stdin.len&);
                    fs.mutex&.unlock();
                    Futex'wait(p, 0);
                    fs.mutex&.lock();
                    _fd = fs.fd.index(fd);
                    continue();
                };
                return(i)
            };
            dest[i] = c;
            i += 1;
        };
        i
    },
    write = fn(_fd, _src) = -1,
    lseek = fn(_fd, _offset, _whence) = -1,
    close = fn(_fd) = (),
);

fn trace(arg: FatExpr) FatExpr #macro = @{
    if fs.strace {
        c := context(DefaultContext);
        t := c.temporary_allocator_i;
        old := fs.strace;    // TODO: not thread safe
        fs.strace = false;
        c.temporary_allocator_i = Arena'stack_alloc(1024);
        @[println arg];
        c.temporary_allocator_i = t;
        fs.strace = old;
    };
};

Term :: import("@/lib/sys/terminal.fr");
#use("@/lib/sys/threads.fr");
#use("@/lib/sys/sync/mutex.fr");

// TODO: make this less annoying
DISABLE_IMPORT_FRC :: false;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr"); 

#use("@/examples/os/libkernel.fr");

SHELL_HELP :: """
exit                 (power down the machine)
<path>               (jit and run a .fr program)
strace <on, off>     (toggle libc logging)
time <on, off>       (log runtime after running a program)
uptime               (read the system counter)
""";
