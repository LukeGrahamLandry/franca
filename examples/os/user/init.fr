
main :: fn() void = {
    t := get_current_thread();
    buf := t.allocate_signal_stack();
    _ := set_signal_handler(callee = handle_signal, stack = buf);
    
    if query_current_arch() != .wasm32 {
        redo_relocations_static_linux();
    };
        tls(.prefer_syscalls)[] = false;
        
        t := get_current_thread();
        
        Crash'push_aot_debug_resolver();
        
        #use("@/lib/sys/jump.fr");
        jumpbuf :: @static(JumpBuf);
        throw_panic_hook :: fn(s: Str) Never = {
            fs := shell;
            panicking :: @static(bool);
            old := fs.strace;
            fs.strace = false;
            @if(panicking[]) Crash'backtracing_panic_handler(s);
            panicking[] = true;
            println(s);
            Crash'report_backtrace(fp = Crash'trace_start(), ip = 0.rawptr_from_int());
            panicking[] = false;
            fs.strace = old;
            // TODO: don't leak the compiler, etc.
            @if(tls(.thread_index)[] != 1) {
                @println("child thread % panicked", tls(.thread_index)[]);
                Syscall'exit(1); 
            };
            throw(jumpbuf);
        };
        
        shell.device_tree_bytes = {
            devicetree := tls(.cli_arguments)[0].ptr;
            h := bit_cast_unchecked(*u8, *DT.Header, devicetree)[];
            DT.Header.byte_swap_fields(h&);
            devicetree.slice(h.totalsize.zext())
        };
        
        Vfs'init_vfs();
        buf := u8.list(general_allocator());
        timer := false;
        boottime := timestamp();
        @println("The system took %ms to boot.", boottime);
        @if(boottime > 750) @println("that's really slow, i hope you're not using hardware virtualization");
        
        sync_vaddr();
        run_startup_commands();
        
        // TODO: this shell should share some logic with examples/terminal.fr
        loop {
            mark := temp().mark();
            old := shell.strace;  // TODO: not thread safe
            shell.strace = false;
            Term'interactive_read_line(buf&);
            print("\n");
            shell.strace = old;
            
            push_tls_value(.panic_hook, throw_panic_hook) {
                @match(try(jumpbuf)) {
                    fn Try() => decode_and_run_cmd(buf.items());
                    fn Catch() => println("main thread panicked.");
                };
            };
            // TODO: reset panic_hook even if jumped
            
            buf&.clear();
            temp().reset(mark);
        };
}

Vfs :: import("@/examples/os/user/vfs.fr");

run_startup_commands :: fn() void = {
    fs := Vfs.fs;
    count := 0;
    start := timestamp();
    bootargs := find_boot_args(DT'iter(shell.device_tree_bytes)) || "\0";
    while => bootargs.len > 0 {
        bootargs := bootargs&.pop_cstr();
        init := bootargs.split(";", temp()).items();
        for(init, decode_and_run_cmd);
        count += init.len;
    };
}

decode_and_run_cmd :: fn(full_command: Str) void = {
    fs := Vfs.fs;
    while => full_command.len > 0 && full_command[0].is_ascii_whitespace() {
        full_command = full_command.rest(1);
    };
    @if(full_command == "") return(); 
    
            parts := full_command.split(" ", temp()).items();
            @switch(parts[0]) {
                @case("exit") => Syscall'exit(0);
                @case("quit") => Syscall'exit(0);
                @case("uptime") => {   
                    @println("%ms", timestamp());
                };
                @case("strace") => {
                    shell.strace = parts[1] == "on" || parts[1] == "true";
                };
                @case("time") => {
                    shell.timer = parts[1] == "on" || parts[1] == "true";
                };
                @case("nocache") => {
                    shell.nocache = parts[1] == "on" || parts[1] == "true";
                };
                @case("help") => print(SHELL_HELP.rest(1));
                @case("devicetree") => {
                    out := u8.list(temp());
                    import("@/examples/dump_devicetree.fr")'dump(out&, shell.device_tree_bytes);
                    print(out.items());
                };
                @default => {
                    break :: local_return;
                    spawn := parts[0] == "spawn";
                    if spawn {
                        parts = parts.rest(1);
                    };
                    fs.cwd = fs.root_dir;  // TODO: this is why i need more official processes
                    command := search_path(parts[0]) || {
                        @print("unknown command: |%|\n", full_command);
                        break()
                    };
                    
                    cmd: Command = (command = command, parts = parts);
                    // allocating this is dumb but passing a pointer to the stack would be a race
                    cmd := general_allocator().boxed(Command, cmd);  
                    if spawn {
                        #use("@/lib/sys/threads.fr");
                        start_thread(Command, run_command, cmd);
                    } else {
                        start := timestamp();
                        run_command(cmd);
                        if shell.timer {
                            #use("@/lib/sys/process.fr");
                            @print("(%ms)\n", timestamp() - start);
                        };
                    };
                };
            };
}

DT :: import("@/examples/os/drivers/devicetree.fr");
find_boot_args :: fn(self: DT.Iter) ?Str = {
    self&.consume_root();
    self&.find_node(.BEGIN_NODE, fn(it) => it.name == "chosen")
        || return(.None);
    it := self&.find_node(.PROP, fn(it) => it.name == "bootargs")
        || return(.None);
    (Some = it.data)
};

// this is only used once at startup, everyone else does it through libc. TODO: it would be nice to get rid of this
fn set_signal_handler(new: SignalHandler) SignalHandler = {
    old := zeroed SignalHandler;
    args: Array(i64, 6) = (SignalHandler.int_from_ptr(new&), SignalHandler.int_from_ptr(old&), 0, 0, 0, 0);
    Syscall'perform_syscall(args&, 0xFFFF0003);  // sig_action
    old
}

Command :: @struct(command: Str, parts: []Str);
run_command :: fn(cmd: *Command) void = {
    command, parts := (cmd.command, cmd.parts);
        args := CStr.list(temp());
        args&.push("franca".as_cstr());
        for parts { it |
            args&.push(it.as_cstr());
        };
push_tls_value(.comptime, zeroed(rawptr)) {
    push_tls_value(.cli_arguments, args.items()) { 
        fs := Vfs.fs;
        // TODO: passing nocache here is weaker than FRANCA_NO_CACHE=1 because some user code only checks the envvar
        import("@/compiler/main.fr")'main2(command, shell.nocache);
    };
};
    general_allocator().dealloc_one(Command, cmd);
}

search_path :: fn(command: Str) ?Str = {
    if !command.ends_with(".fr") {
        command = @tfmt("%.fr", command);
    };
    path := @slice("", "examples/", "examples/os/bin/");
    for path { it |
        check := @tfmt("%%", it, command);
        if file_exists(check) {
            return(Some = check);
        };
    };
    .None
}

shell :: @static(@struct {
    strace: bool;
    timer: bool;
    nocache: bool;
    device_tree_bytes: []u8;
});

pl011_int_poll :: fn(q: *UQueue, who: i64) void = {
    fs := Vfs.fs;
    // if polling after work.push, do nothing, wait for an interrupt.
    @if(who == 0) return();  
    // else, polling before done.pop
    work := fs.stdin.pipe.work&;
    
    // handle_signal doesn't done.push, it claims from work without committing. 
    // so instead of being able to wait in done.pop, we need to wait for 
    // a claim in work, commit it, and done.push, then the next call to pop won't block. 
    // need the claim-commit separation becuase handle_signal isn't allowed 
    // to block on work.pop, and it gets bytes one at a time. 
    // it can't block because the interrupt is allowed to be on the same thread as the read. 
    value := work.claimed.kiki;
    while => work.committed.kiki == value {
        Futex'wait(work.claimed.kiki&, value);
        value = work.claimed.kiki;
    };
    entry := work[work.committed.kiki];
    work.committed.kiki += 1;
    @assert(work.claimed.kiki == work.committed.kiki);
    fs.stdin.pipe.done&.push(entry);
}

// note: you can't use a mutex here because it has the same thread_index as the interrupted task
handle_signal :: fn(ctx: *MContext, intid: i64, data: i64) Ty(i64, *MContext) = {
    fs := Vfs.fs;

        thread := get_current_tls();
        if bit_cast_unchecked(@type thread.signal_handler, i64, thread.signal_handler) != 0 {
            result, _ := thread'signal_handler(ctx, intid, data);
            if result == intid {
                return(intid, ctx);
            };
        };
    
    // TODO: don't hardcode the 33. get it from device tree. 
    //       the kernel side now knows the right numbers. just have to use them here. 
    if intid == 33 {
        work := fs.stdin.pipe.work&;
        if work.claimed.kiki == work.committed.kiki {
            work.claimed.kiki += 1;
        };
        entry := work[work.committed.kiki]&;
        i := u32.atomic_inc(entry.n.bytes_written&).zext();
        if i < entry.bufs[0].len {
            entry.bufs[0][i] = data.trunc();
            Futex'wake(work.committed.kiki&, 1);
        };  // else, silently drop the bytes :(
        return(intid, ctx);
    };
    
    ec := ctx.esr.shift_right_logical(26).bit_and(0b111111);
    // TODO: import Gic.null_interrupt_id
    if intid != 1023 || ec != 0b010101 {
        crashing :: @static(bool);
        shell.strace = false;
        if !crashing[] {
            crashing[] = true;
            @println("sp = %; fp = %; lr = %; ip = %;", ctx.gpr&[31], ctx.gpr&[29], ctx.gpr&[30], ctx.elr);
            eprintln("fatal signal");
            report_backtrace(fp = Crash.Frame.ptr_from_int(ctx.gpr&[29]), ip = ctx.elr.rawptr_from_int());
        };
        Syscall'exit(1);
    };
    
    // when targeting real linux, (open,fstat)at have a sucky abi 
    // so its easier to just do the syscall than try to use glibc, 
    // but that makes intercepting them on my os more painful. 
    syscall_number := ctx.gpr&[8];
    msg :: "perform_syscall always has x8==x16\nallowing someone else to call us is sketchy because i return to lr instead of elr";
    @assert_eq(ctx.gpr&[8], ctx.gpr&[16], msg);
    unistd :: import("@/examples/os/user/libc/impl/unistd.fr");
    dirent :: import("@/examples/os/user/libc/impl/dirent.fr");
    // TODO: FuncId->rawptr doesn't work if its a scope access. :compilerbug
    callee := @switch(syscall_number) {
        @case(56) => { x :: unistd.FR_openat; @as(rawptr) x };
        @case(79) => { x :: unistd.fstatat; @as(rawptr) x };
        @case(64) => { x :: unistd.write; @as(rawptr) x };
        @case(61) => { x :: dirent.posix_getdents; @as(rawptr) x };       
        @default => @panic("invalid syscall %", syscall_number);
    };
    
    // this wouldn't work because perform_syscall doesn't save LR 
    // but its fine to return to perform_syscall's caller directly, 
    // because it doesn't do anything useful before returning. 
    // ctx.gpr[30] = ctx.elr;
    
    // redirect the call (keeping the same arguments in x0..<6)
    ctx.elr = callee.int_from_rawptr();
    (intid, ctx)
}

redo_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    header := Elf.Header.ptr_from_raw(base);
    @assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    unpacked.strings.ptr = unpacked.strings.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        name: CStr = (ptr = unpacked.strings.index(sym.name.zext()));
        name := name.str();
        
        type := sym.info.shift_right_logical(4);
        if sym.value == 0 {
            temporary_libc_import(name, dest, false);
        }
    };
};

libc_exports :: @static(RawHashMap(Str, rawptr)) {
        it := ScopeId.list(temp());
        it&.push(Type.scope_of(LIBC));
        dirs := @slice("examples/os/user/libc", "examples/os/user/libc/impl");
        for dirs { dir |
            files := collect_directory_ordered(dir, temp(), temp()).unwrap();
            for files { jt |
                if jt.name.ends_with(".fr") {
                    it&.push(import(@tfmt("@/%/%", dir, jt.name)));
                };
            };
        };
        
        out: RawHashMap(Str, rawptr) = init();
        for it { s |
            collect_from_scope(out&, s, false);
        };
        out
};

fn collect_from_scope(out: *RawHashMap(Str, rawptr), s: ScopeId, allow_stomp: bool) void = {
    fr := current_compiler_context();
    for get_constants(s) { n |
        continue :: local_return;
        val, ty := get_constant(s, n) || continue();
        @if(ty != FuncId) continue();
        fid := FuncId.ptr_from_raw(val)[];
        old := out.insert(n.str(), fr.get_jitted(fid), fr.get_alloc());
        @assert(allow_stomp || old.is_none(), "duplicate libc export: %", n.str());
    };
}

temporary_libc_import :: fn(name: Str, dest: *rawptr, allow_null: bool) void = {
    if libc_exports.get(name) { it |
        dest[] = it;
        return()
    };
    if !allow_null {
        dest[] = fn() void = panic("called a weak import");
    };
}

// if you do `build.fr -smp 1 -no_preempt` this gives a better chance of getting the same pointers 
// between runs so you can print them and diff exactly what happens if one of qemu/vzf doesn't work. 
// this avoids differences in vaddr caused by different startup code depending which devices are available.  
sync_vaddr :: fn() void = {
    prefix := "page_size=";
    s := cli_args()[1].str();
    @assert(s.starts_with(prefix));
    page_size := s.rest(prefix.len).parse_int();
    next_vaddr := u8.int_from_ptr(page_allocator.alloc_uninit(u8, 1).as_ptr()) + page_size;
    waste := next_vaddr.align_to(1.shift_left(34)) - next_vaddr;
    _ := page_allocator.alloc_uninit(u8, waste);
}

MyAttr :: @struct {
    stack: []u8;
};

LIBC :: @struct {
    // TODO: this needs to be threadlocal
    __errno_location :: fn() *i64 = @static(i64);
    
    FR_set_signal_handler :: fn(callee: SignalHandler.F) SignalHandler.F = {
        thread := get_current_tls();
        old := thread.signal_handler;
        thread.signal_handler = callee;
        old
    }
    
    FR_debug_write :: fn(ptr: *u8, len: i64) void = 
        sys_debug_write(ptr.slice(len));
};

fn get_current_tls() *ThreadData = {
    thread := Thread.ptr_from_raw(tls(.thread)[]);
    @run @assert_eq(size_of(@type thread.runtime_data), size_of(ThreadData));
    ::ptr_utils(Thread);
    @assert(!thread.is_null(), "missing env.thread");
    thread := bit_cast_unchecked(@type thread.runtime_data&, *ThreadData, thread.runtime_data&);
    thread
}

system_counter_uptime :: fn() TimeSpec = {
    // "From Armv8.6-A and Armv9.1-A, the frequency of the count is fixed at 1GHz. 
    //  Pre-Armv8.6-A, the count frequency was a system design choice, typically 
    //  in the range of 1MHz to 50MHz." -- (Learn the architecture - Generic Timer. v1.4)
    // 2^64 nanoseconds is ~585 years.
    // TODO: ns*S_PER_NS overflows in 5.85 years at 1GHz which is enough that it doesn't matter for me but not infinity
    //       but you have to multiply first so you don't truncate
    
    ticks := u64.sys_get(.CNTVCT_EL0);
    ticks_per_s := u64.sys_get(.CNTFRQ_EL0);
    ns := ticks * NS_PER_S / ticks_per_s;
    s, ns_r := ns.div_mod(NS_PER_S);
    (seconds = s.bitcast(), nanoseconds = ns_r.bitcast())
}

fn with_syscalls($body: @Fn() i64) i64 = {
    old := tls(.prefer_syscalls)[];
    tls(.prefer_syscalls)[] = true;
    result := @must_return body();
    tls(.prefer_syscalls)[] = old;
    result
}

fn trace(arg: FatExpr) FatExpr #macro = @{
    if shell.strace {
        t := tls(.temporary_allocator_i)[];
        old := shell.strace;    // TODO: not thread safe
        old_sys := tls(.prefer_syscalls)[];
        tls(.prefer_syscalls)[] = false;
        shell.strace = false;
        tls(.temporary_allocator_i)[] = Arena'stack_alloc(1024);
        @print("%) ", tls(.thread_index)[]);
        @[println arg];
        tls(.temporary_allocator_i)[] = t;
        shell.strace = old;
        tls(.prefer_syscalls)[] = old_sys;
    };
};

ThreadData :: @struct {
    signal_handler: SignalHandler.F; 
    known_wasm_jit_event: i64;
    _: Array(i64, 3);
};

// signal stack must be in the same franca_required_stack_bits aligned chunk for tls to work. 
// see threads/allocate_stack.
fn allocate_signal_stack(t: *Thread) []u8 = {
    signal_stack_size := 1.shift_left(16) * 10;
    buf := t.stack.usable.subslice(t.stack_reserved_size, signal_stack_size);
    t.stack_reserved_size += signal_stack_size;
    buf
}

Term :: import("@/lib/sys/terminal.fr");
#use("@/lib/sys/threads.fr");
#use("@/lib/sys/sync/mutex.fr");

// TODO: make this less annoying
DISABLE_IMPORT_FRC :: false;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr"); 

#use("@/examples/os/libkernel.fr");

SHELL_HELP :: """
exit                 (power down the machine)
<path>               (jit and run a .fr program)
spawn <path>         (new thread won't block the shell)
strace <on, off>     (toggle libc logging)
time <on, off>       (log runtime after running a program)
nocache <on, off>    (recompile every time instead of saving .frc)
uptime               (read the system counter)
devicetree           (show hardware info from the boot loader)

example programs:
test_fuse
test_faults
spawn test_screen
spawn doom

""";
