
main :: fn() void = {
    println("init!");
    
    // note: this only affects the main thread
    //       should probably wrap it for the pthread_create part
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(16) * 10);
    buf.set_bytes(0);  // :SLOW force it to commit the pages
    _ := set_signal_handler(callee = handle_signal, stack = buf);
    
    init_vfs();

    if query_current_arch() != .wasm32 {
        redo_relocations_static_linux();
    };
    push_dynamic_context {
        c := context(DefaultContext);
        c.prefer_syscalls = false;
        
        Crash'push_aot_debug_resolver();
        c.panic_hook = fn(s) = {
            c := context(DefaultContext);
            c.prefer_syscalls = true;
            Crash'backtracing_panic_handler(s)
        };
        
        // TODO: this shouldn't be needed but the compiler's dying in get_environment_variable. 
        xxx := zeroed CStr;
        c.environment_variables = xxx&;
        
        c.cli_arguments = empty();
        signal_env[] = c[];
        signal_env.thread_index = -1;  // make handle_signal NOT count as the same thread for reenterant mutex

        q := zeroed UQueue; q := q&;
        ok := virtq_create(q, "Host.fs", 1);
        @println("virtq_create? ok=%", ok);
        q: ?*UQueue = @if(ok, (Some = q), .None);
        
        Fs :: import("@/examples/os/user/fs.fr");
        fs.fuse_q = q;
        if q { q |
            fuse_root := init_fuse(q);
            cwd := get_file(fs.root_dir).unwrap();
            cwd := MemDir.ptr_from_raw(cwd.data);
            child := get_file(fuse_root).unwrap();
            child := FuseFile.ptr_from_raw(child.data)[];
            create_child(cwd, "Host", FuseFile, child);
            
            bytes := read_entire_file_or_crash(temp(), "Host/a.txt");
            @println("ALL: %", bytes);
            
            fd := Posix'openat(fuse_root, "a.txt".as_cstr(), Posix'O'RDWR, 0)
                || @panic("failed to open");
            
            _ := Syscall'lseek(fd, 0, .Set) 
                || @panic("failed lseek");
                
            buf := @tfmt("Goodbye World %!", timestamp());
            writen_len := Syscall'write(fd, buf.ptr, buf.len)
                || @panic("failed write");
            @println("WRITE: %/%", writen_len, buf.len);
            
            pos := Syscall'lseek(fd, 10, .Set) 
                || @panic("failed lseek");
            @println("seek to %", pos);
            
            out := u8.list(1000, temp());
            read_len := Syscall'read(fd, out.items().end_pointer(), out.maybe_uninit.len - out.len) 
                || @panic("failed read");
            out.len += read_len;
            @println("READ(%): %", read_len, out.items());
            
            Syscall'close(fd);
            
            bytes := read_entire_file_or_crash(temp(), "Host/foo/bar.txt");
            @println("foo/bar.txt: %", bytes);
        };
        
        buf := u8.list(general_allocator());
        timer := false;
        @println("The system took %ms to boot.", timestamp());
        // TODO: this shell should share some logic with examples/terminal.fr
        loop {
            mark := temp().mark();
            old := fs.strace;  // TODO: not thread safe
            fs.strace = false;
            Term'interactive_read_line(buf&);
            print("\n");
            fs.strace = old;
            
            command := buf.items();
            parts := command.split(" ", temp()).items();
            @switch(parts[0]) {
                @case("exit") => Syscall'exit(0);
                @case("quit") => Syscall'exit(0);
                @case("uptime") => {   
                    @println("%ms", timestamp());
                };
                @case("strace") => {
                    fs.strace = parts[1] == "on" || parts[1] == "true";
                };
                @case("time") => {
                    timer = parts[1] == "on" || parts[1] == "true";
                };
                @case("help") => print(SHELL_HELP.rest(1));
                @default => {
                    break :: local_return;
                    command := parts[0];
                    if command.ends_with(".fr") {
                        if !file_exists(command) {
                            check := @tfmt("examples/%", command);
                            if !file_exists(check) {
                                @println("file not found: %", command);
                                break();
                            } else {
                                command = check;
                            };
                        }
                        
                        println("compiling...");
                        start := timestamp();
                        push_dynamic_context { 
                            c := context(DefaultContext);
                            args := CStr.list(temp());
                            args&.push("franca".as_cstr());
                            for parts { it |
                                args&.push(it.as_cstr());
                            };
                            c.cli_arguments = args.items();
                            
                            import("@/compiler/main.fr")'main2(command, true);
                        };
                        if timer {
                            @print("(%ms)\n", timestamp() - start);
                        };
                        // TODO: don't crash on compile error
                    } else {
                        @print("unknown command: |%|\n", buf.items());
                    };
                };
            };
            buf&.clear();
            temp().reset(mark);
        };
    };
}

#use("@/examples/os/user/vfs.fr");

signal_env :: @static(DefaultContext);

// note: intid != ctx.intid is legal because an interrupt might have triggered while a different task was running. 
//       ex. uart always goes to the init task. 
handle_signal :: fn(ctx: *MContext, intid: i64, data: i64) i64 = {
    set_dynamic_context(DefaultContext.raw_from_ptr(signal_env));
    // TODO: don't hardcode the 33. get it from device tree. 
    //       the kernel side now knows the right numbers. just have to use them here. 
    if intid == 33 || intid == 69 || intid == 37 {
        char: u8 = data.trunc();
        if char == 3 {
            println("^c");
            // TODO: this doesn't work reliably. try it in examples/chess/perft.fr and it can get stuck? 
            Syscall'exit(1);  // will stop the whole system if this is the init task (which it always is rn)
        };
        if char == 13 {
            char = 10;
        };
        todo();
        // translate to the UQueue
        
        // TODO: what if interrupted while reading
        fs.stdin&.push_back(char, panicking_allocator);
        
        p := bit_cast_unchecked(*i64, *u32, fs.stdin.len&);
        Futex'wake(p, 1);  // :SLOW. only needed if its not the init process sleeping in the read
        
        return(intid);
    };
    
    ec := ctx.esr.shift_right_logical(26).bit_and(0b111111);
    // TODO: import Gic.null_interrupt_id
    if intid != 1023 || ec != 0b010101 {
        push_emergency_dynamic_environment {
            context(DefaultContext)[].prefer_syscalls = true;
            @println("sp = %; fp = %; lr = %; ip = %;", ctx.gpr&[31], ctx.gpr&[29], ctx.gpr&[30], ctx.elr);
            eprintln("fatal signal");
            report_backtrace(fp = ctx.gpr&[29].rawptr_from_int(), ip = ctx.elr.rawptr_from_int());
            Syscall'exit(1);
        };
    };
    
    // when targeting real linux, (open,fstat)at have a sucky abi 
    // so its easier to just do the syscall than try to use glibc, 
    // but that makes intercepting them on my os more painful. 
    syscall_number := ctx.gpr&[8];
    msg :: "perform_syscall always has x8==x16\nallowing someone else to call us is sketchy because i return to lr instead of elr";
    @assert_eq(ctx.gpr&[8], ctx.gpr&[16], msg);
    // TODO: FuncId->rawptr doesn't work if its a scope access. :compilerbug
    callee := @switch(syscall_number) {
        @case(56) => { x :: LIBC.FR_openat; @as(rawptr) x };
        @case(79) => { x :: LIBC.FR_fstatat; @as(rawptr) x };
        @default => @panic("invalid syscall %", syscall_number);
    };
    
    // this wouldn't work because perform_syscall doesn't save LR 
    // but its fine to return to perform_syscall's caller directly, 
    // because it doesn't do anything useful before returning. 
    // ctx.gpr[30] = ctx.elr;
    
    // redirect the call (keeping the same arguments in x0..<6)
    ctx.elr = callee.int_from_rawptr();
    
    intid
}

redo_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    header := Elf.Header.ptr_from_raw(base);
    @assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    unpacked.strings.ptr = unpacked.strings.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        name: CStr = (ptr = unpacked.strings.index(sym.name.zext()));
        name := name.str();
        
        type := sym.info.shift_right_logical(4);
        if sym.value == 0 {
            temporary_libc_import(name, dest, false);
        }
    };
};

temporary_libc_import :: fn(name: Str, dest: *rawptr, allow_null: bool) void = {
    LIBC_s :: Type.scope_of(LIBC);
    inline_for get_constants(LIBC_s) { $n |
        fid :: get_constant(FuncId, LIBC_s, n[]).unwrap();
        check := @run n[].str();
        if name == check {
            dest[] = fid;
            return();
        };
    };
    
    if !allow_null {
        dest[] = fn() void = panic("called a weak import");
    };
}

MyAttr :: @struct {
    stack: []u8;
};

LIBC :: @struct {
    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 = with_syscalls {
                result := Syscall'mmap(addr, len, prot, flags, fd, offset);
                @trace("mmap(%, %) = %", len, flags, result);
                @assert_ne(result, 0, "some sort of corruption is going on because i over commit and can't null");
                result
    };
    munmap :: fn(addr: rawptr, len: i64) i64 = with_syscalls {
                result := Syscall'munmap(addr, len);
                @trace("mumap(%, %)", addr, len);
                @assert_eq(result.value, 0, "some sort of corruption is going on. munmap(%) can't fail", addr);
                result.value
    };
    mprotect :: fn() = 0;
    read :: fn(f: Fd, buf: *u8, len: i64) i64 = {
        fd := get_file(f) || return(-1);
        @trace("read(%, %, %)", f.fd, u8.int_from_ptr(buf), len);
        fd'vtable'read(fd.data, buf.slice(len))
    };
    close :: fn(f: Fd) i64 = {
        @if(f.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd }) return(-1);
        fd := get_file(f) || return(-1);
        ::ptr_utils(@type fd.vtable[]);
        @if(identical(fd.vtable, closed_file_vtable)) return(-1);
        @trace("close(%)", f.fd);
        fd'vtable'close(fd.data);
        fs.mutex&.lock();
        // default impl for everything to just error
        closed_file_vtable :: @static(FileVTable) { () };
        fs.fd[f.fd.intcast()] = (vtable = closed_file_vtable, data = zeroed(rawptr));
        fs.mutex&.unlock();
        // TODO: reuse slots of the array
        // note: not freeing fd.data because it's owned by the directory.
        0
    };
    dlopen :: fn(name: CStr) rawptr = {
        @trace("dlopen(%)", name);
        if name == "libc.so.6" {
            return(123.rawptr_from_int());
        };
        zeroed(rawptr)
    };
    dlsym :: fn(lib: rawptr, name: CStr) rawptr = {
        @assert_eq(lib.int_from_rawptr(), 123);
        dest := zeroed(rawptr);
        temporary_libc_import(name.str(), dest&, true);
        @trace("dlsym(%, %) = %", lib, name, dest);
        dest
    };
    dlclose :: fn() = 0;
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
        Syscall'perform_syscall(args&, 94);  // exit
    };
    write :: fn(f: Fd, buf: *u8, size: i64) i64 = {
        fd := get_file(f) || return(-1);
        @trace("write(%, %, %)", f.fd, u8.int_from_ptr(buf), size);
        fd'vtable'write(fd.data, buf.slice(size))
    };
    lseek :: fn(f: Fd, offset: i64, whence: Whence) i64 = {
        fd := get_file(f) || return(-1);
        result := fd'vtable'lseek(fd.data, offset, whence);
        @trace("lseek(fd = %, %, %) = %", f.fd, offset, @as(i64) whence, result);
        result
    };
    FR_fstat :: fn(f: Fd, out: *Posix.Linux.StatArm64) i64 = {
        out[] = zeroed(@type out[]);
        fd := get_file(f) || return(-1);
        result := fd'vtable'fstat(fd.data, out);
        @trace("fstat(%) = %", f.fd, result);
        result
    };
    readlinkat :: fn(parent: Fd, path: CStr, ptr: *u8, len: i64) i64 = 
        -1;
    opendir :: fn(path: CStr) i64 = {
        __errno_location()[] = 1;
        0
    };
    mkdirat :: fn(parent: Fd, path: CStr, mode: i64) i64 = 
        -1;
    
    __errno_location :: fn() *i64 = @static(i64);
    sigaction :: fn() i64 = 0;
    memmove :: fn(dest: rawptr, src: rawptr, count: i64) void =
                copy_bytes_static(dest, src, count);
    pthread_attr_init :: fn(out: *ThreadAttr) i64 = {
                out[] = zeroed(@type out[]);
                0
    };
    // note: this requires that userdata be a *Thread (as called by raw_create_thread)
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                ctx := zeroed MContext;
                ctx.elr = bit_cast_unchecked(@type callee, i64, callee);
                ctx.gpr&[0] = bit_cast_unchecked(@type userdata, i64, userdata);
                ctx.gpr&[30] = int_from_rawptr(fn() void = {
                    args: Array(i64, 6) = (0, 0, 0, 0, 0, 0);
                    Syscall'perform_syscall(args&, 94);  // exit
                    unreachable()
                });
                ctx.gpr&[31] = bit_cast_unchecked(*u8, i64, attr.stack.end_pointer());
                
                thread := Thread.ptr_from_raw(userdata);
                @assert_eq(thread.tid_futex, MAX_u32);
                exit_futex := u32.int_from_ptr(thread.tid_futex&);
                args: Array(i64, 6) = (MContext.int_from_ptr(ctx&), exit_futex, 0, 0, 0, 0);
                id, _ := Syscall'perform_syscall(args&, 0xFFFF0005);  // spawn_thread
                @if(id < 0) panic("failed to create thread");
                thread.tid = id.intcast();
                out.opaque = userdata;
                @trace("pthread_create(elr = %, x0 = %, sp = %) = %", ctx.elr, ctx.gpr&[0], ctx.gpr&[31], id);
                0
    };
    pthread_attr_setstack :: fn(attr: *ThreadAttr, ptr: *u8, len: i64) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                attr.stack = ptr.slice(len);
                0
    };
    pthread_getcpuclockid :: fn() = 0;
    pthread_join :: fn(thread: pthread_t, value_ptr: *rawptr) i64 = {
        t := Thread.ptr_from_raw(thread.opaque);
        // not the same as `with_syscalls { t.join(); 0 };` because that would free the stack twice
        t.sys_join();
        value_ptr[] = zeroed rawptr; // TODO
        0
    };
    // for mandel.ssa
    putchar :: fn(c: u8) = print(c&.slice(1));
    puts :: fn(s: CStr) i64 = {  // for hello.c
        println(s.str());
        0
    };
    
    tcgetattr :: fn(fd: Fd, it: *Term.Terminos) i64 = {
        // TODO
        it[] = zeroed(Term.Terminos);
        0
    };
    tcsetattr :: fn(fd: Fd, optional_actions: i64, it: *Term.Terminos) i64 = {
        // TODO
        0
    };
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        // TODO: other clock_id's
        time_spec[] = system_counter_uptime();
        0
    };
    // TODO: do this more efficiently. 
    //       if multiple threads are sleeping, just have one yield like this for the shortest duration and the rest futex wait.
    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        @trace("nanosleep(s = %, ns = %)", duration.seconds, duration.nanoseconds);
        @debug_assert_eq(nullable_remainder_out, 0, "todo: sleep remainder");
        zeroes := zeroed Array(i64, 6);
            now := system_counter_uptime();
            end := now + duration[];
            dowhile {
                _ := Syscall'perform_syscall(zeroes&, 0xFFFF0002);  // yield
                now := system_counter_uptime();
                end.ms() > now.ms()
            };
            0
    };
    
    localtime_r :: fn(time_in: *time_t, time_out: *BigTime) *BigTime = {
        // TODO
        time_out[] = zeroed(BigTime);
        time_out
    };
    // TODO: this is supposed to be calander time not system up time
    time :: fn(out: *time_t) time_t = (seconds = timestamp() * 1000);
    
    // note: this is the linux syscall abi, not the libc abi
    FR_openat :: fn(f: Fd, path: CStr, flags: i64, mode: i64) i64 = {
        path := path.str();
        if path.starts_with("./") {
            path = path.rest(2);
        };
        if path.contains("/") {  // :SLOW
            result := follow_path(f, path);
            @if(result&.is_err()) return(-result.Err._);
            return result.Ok.fd.intcast();
        };
        fd := get_file(f) || return(-1);
        result := fd'vtable'openat(fd.data, (ptr = path.ptr), flags, mode);
        @trace("openat(fd = %, %, %, %) = %", f.fd, path, flags, mode, result);
        result
    }
    
    // note: this is the linux syscall abi, not the libc abi
    FR_fstatat :: fn(fd: Fd, path: CStr, out: *Posix.Linux.StatArm64) i64 = {
        fd_in := fd.fd;
        fd := FR_openat(fd, path, 0, 0);
        @if(fd < 0) return(fd);
        fd: Fd = (fd = fd.intcast());
        result := FR_fstat(fd, out);
        Syscall'close(fd);
        result
    }
};

system_counter_uptime :: fn() TimeSpec = {
    // "From Armv8.6-A and Armv9.1-A, the frequency of the count is fixed at 1GHz. 
    //  Pre-Armv8.6-A, the count frequency was a system design choice, typically 
    //  in the range of 1MHz to 50MHz." -- (Learn the architecture - Generic Timer. v1.4)
    // 2^64 nanoseconds is ~585 years.
    // TODO: ns*S_PER_NS overflows in 5.85 years at 1GHz which is enough that it doesn't matter for me but not infinity
    //       but you have to multiply first so you don't truncate
    
    ticks := u64.sys_get(.CNTVCT_EL0);
    ticks_per_s := u64.sys_get(.CNTFRQ_EL0);
    ns := ticks * NS_PER_S / ticks_per_s;
    s, ns_r := ns.div_mod(NS_PER_S);
    (seconds = s.bitcast(), nanoseconds = ns_r.bitcast())
}

fn with_syscalls($body: @Fn() i64) i64 = {
    c := context(DefaultContext);
    c.prefer_syscalls = true;
    result := @must_return body();
    c.prefer_syscalls = false;
    result
}

fn trace(arg: FatExpr) FatExpr #macro = @{
    if fs.strace {
        c := context(DefaultContext);
        t := c.temporary_allocator_i;
        old := fs.strace;    // TODO: not thread safe
        fs.strace = false;
        c.temporary_allocator_i = Arena'stack_alloc(1024);
        @[println arg];
        c.temporary_allocator_i = t;
        fs.strace = old;
    };
};

Term :: import("@/lib/sys/terminal.fr");
#use("@/lib/sys/threads.fr");
#use("@/lib/sys/sync/mutex.fr");

// TODO: make this less annoying
DISABLE_IMPORT_FRC :: false;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr"); 

#use("@/examples/os/libkernel.fr");

SHELL_HELP :: """
exit                 (power down the machine)
<path>               (jit and run a .fr program)
strace <on, off>     (toggle libc logging)
time <on, off>       (log runtime after running a program)
uptime               (read the system counter)
""";
