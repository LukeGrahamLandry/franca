
main :: fn() void = {
    // note: this only affects the main thread
    //       should probably wrap it for the pthread_create part
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(16) * 10);
    _ := set_signal_handler(callee = handle_signal, stack = buf);
    
    if query_current_arch() != .wasm32 {
        redo_relocations_static_linux();
    };
    push_dynamic_context {
        c := context(DefaultContext);
        c.prefer_syscalls = false;
        
        Crash'push_aot_debug_resolver();
        c.panic_hook = fn(s) = {
            c := context(DefaultContext);
            fs.strace = false;
            Crash'backtracing_panic_handler(s)
        };
        
        // TODO: this shouldn't be needed but the compiler's dying in get_environment_variable. 
        xxx := zeroed CStr;
        c.environment_variables = xxx&;
        
        c.cli_arguments = empty();
        signal_env[] = c[];
        signal_env.thread_index = -1;  // make handle_signal NOT count as the same thread for reenterant mutex

        init_vfs();
        buf := u8.list(fs.allocator);
        timer := false;
        @println("The system took %ms to boot.", timestamp());
        
        // TODO: this shell should share some logic with examples/terminal.fr
        loop {
            mark := temp().mark();
            old := fs.strace;  // TODO: not thread safe
            fs.strace = false;
            Term'interactive_read_line(buf&);
            print("\n");
            fs.strace = old;
            
            command := buf.items();
            parts := command.split(" ", temp()).items();
            @switch(parts[0]) {
                @case("exit") => Syscall'exit(0);
                @case("quit") => Syscall'exit(0);
                @case("uptime") => {   
                    @println("%ms", timestamp());
                };
                @case("strace") => {
                    fs.strace = parts[1] == "on" || parts[1] == "true";
                };
                @case("time") => {
                    timer = parts[1] == "on" || parts[1] == "true";
                };
                @case("help") => print(SHELL_HELP.rest(1));
                @default => {
                    break :: local_return;
                    spawn := parts[0] == "spawn";
                    if spawn {
                        parts = parts.rest(1);
                    };
                    command := search_path(parts[0]) || {
                        @print("unknown command: |%|\n", buf.items());
                        break()
                    };
                    
                    cmd: Command = (command = command, parts = parts);
                    if spawn {
                        #use("@/lib/sys/threads.fr");
                        start_thread(Command, fn(cmd) = {
                            buf := page_allocator.alloc_uninit(u8, 1.shift_left(16) * 10);
                            _ := set_signal_handler(callee = handle_signal, stack = buf);
                            run_command(cmd);
                        }, cmd&);
                        usleep(5000); // HACK
                    } else {
                        start := timestamp();
                        println("compiling...");
                        run_command(cmd&);
                        if timer {
                            #use("@/lib/sys/process.fr");
                            @print("(%ms)\n", timestamp() - start);
                        };
                    };
                };
            };
            buf&.clear();
            temp().reset(mark);
        };
    };
}

Command :: @struct(command: Str, parts: []Str);
run_command :: fn(cmd: *Command) void = {
    command, parts := (cmd.command, cmd.parts);
    push_dynamic_context { 
        c := context(DefaultContext);
        args := CStr.list(temp());
        args&.push("franca".as_cstr());
        for parts { it |
            args&.push(it.as_cstr());
        };
        c.cli_arguments = args.items();
        import("@/compiler/main.fr")'main2(command, true);
    };
}

search_path :: fn(command: Str) ?Str = {
    if !command.ends_with(".fr") {
        command = @tfmt("%.fr", command);
    };
    path := @slice("", "examples/", "examples/os/bin/");
    for path { it |
        check := @tfmt("%%", it, command);
        if file_exists(check) {
            return(Some = check);
        };
    };
    .None
}

#use("@/examples/os/user/vfs.fr");

signal_env :: @static(DefaultContext);

pl011_int_poll :: fn(q: *UQueue, who: i64) void = {
    // if polling after work.push, do nothing, wait for an interrupt.
    @if(who == 0) return();  
    // else, polling before done.pop
    work := fs.stdin.pipe.work&;
    
    // handle_signal doesn't done.push, it claims from work without committing. 
    // so instead of being able to wait in done.pop, we need to wait for 
    // a claim in work, commit it, and done.push, then the next call to pop won't block. 
    // need the claim-commit separation becuase handle_signal isn't allowed 
    // to block on work.pop, and it gets bytes one at a time. 
    // it can't block because the interrupt is allowed to be on the same thread as the read. 
    value := work.claimed.kiki;
    while => work.committed.kiki == value {
        Futex'wait(work.claimed.kiki&, value);
        value = work.claimed.kiki;
    };
    entry := work[work.committed.kiki];
    work.committed.kiki += 1;
    @assert(work.claimed.kiki == work.committed.kiki);
    bytes := entry.bufs[0].slice(0, entry.n.bytes_written.zext());
    fs.stdin.pipe.done&.push(entry);
}

handle_signal :: fn(ctx: *MContext, intid: i64, data: i64) Ty(i64, *MContext) = {
    set_dynamic_context(DefaultContext.raw_from_ptr(signal_env));
    // TODO: don't hardcode the 33. get it from device tree. 
    //       the kernel side now knows the right numbers. just have to use them here. 
    if intid == 33 {
        work := fs.stdin.pipe.work&;
        if work.claimed.kiki == work.committed.kiki {
            work.claimed.kiki += 1;
        };
        entry := work[work.committed.kiki]&;
        i := u32.atomic_inc(entry.n.bytes_written&).zext();
        if i < entry.bufs[0].len {
            entry.bufs[0][i] = data.trunc();
            Futex'wake(work.committed.kiki&, 1);
        };  // else, silently drop the bytes :(
        return(intid, ctx);
    };
    
    ec := ctx.esr.shift_right_logical(26).bit_and(0b111111);
    // TODO: import Gic.null_interrupt_id
    if intid != 1023 || ec != 0b010101 {
        crashing :: @static(bool);
        fs.strace = false;
        if !crashing[] {
            crashing[] = true;
            fs.strace = false;
            @println("sp = %; fp = %; lr = %; ip = %;", ctx.gpr&[31], ctx.gpr&[29], ctx.gpr&[30], ctx.elr);
            eprintln("fatal signal");
            report_backtrace(fp = ctx.gpr&[29].rawptr_from_int(), ip = ctx.elr.rawptr_from_int());
        };
        Syscall'exit(1);
    };
    
    // when targeting real linux, (open,fstat)at have a sucky abi 
    // so its easier to just do the syscall than try to use glibc, 
    // but that makes intercepting them on my os more painful. 
    syscall_number := ctx.gpr&[8];
    msg :: "perform_syscall always has x8==x16\nallowing someone else to call us is sketchy because i return to lr instead of elr";
    @assert_eq(ctx.gpr&[8], ctx.gpr&[16], msg);
    // TODO: FuncId->rawptr doesn't work if its a scope access. :compilerbug
    callee := @switch(syscall_number) {
        @case(56) => { x :: LIBC.FR_openat; @as(rawptr) x };
        @case(79) => { x :: LIBC.FR_fstatat; @as(rawptr) x };
        @case(64) => { x :: LIBC.write; @as(rawptr) x };
        @default => @panic("invalid syscall %", syscall_number);
    };
    
    // this wouldn't work because perform_syscall doesn't save LR 
    // but its fine to return to perform_syscall's caller directly, 
    // because it doesn't do anything useful before returning. 
    // ctx.gpr[30] = ctx.elr;
    
    // redirect the call (keeping the same arguments in x0..<6)
    ctx.elr = callee.int_from_rawptr();
    (intid, ctx)
}

redo_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    header := Elf.Header.ptr_from_raw(base);
    @assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    unpacked.strings.ptr = unpacked.strings.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        name: CStr = (ptr = unpacked.strings.index(sym.name.zext()));
        name := name.str();
        
        type := sym.info.shift_right_logical(4);
        if sym.value == 0 {
            temporary_libc_import(name, dest, false);
        }
    };
};

temporary_libc_import :: fn(name: Str, dest: *rawptr, allow_null: bool) void = {
    LIBC_s :: Type.scope_of(LIBC);
    inline_for get_constants(LIBC_s) { $n |
        fid :: get_constant(FuncId, LIBC_s, n[]).unwrap();
        check := @run n[].str();
        if name == check {
            dest[] = fid;
            return();
        };
    };
    
    if !allow_null {
        dest[] = fn() void = panic("called a weak import");
    };
}

MyAttr :: @struct {
    stack: []u8;
};

LIBC :: @struct {
    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 = with_syscalls {
                result := Syscall'mmap(addr, len, prot, flags, fd, offset);
                @trace("mmap(%, %) = %", len, flags, result);
                @assert_ne(result, 0, "some sort of corruption is going on because i over commit and can't null");
                result
    };
    munmap :: fn(addr: rawptr, len: i64) i64 = with_syscalls {
                result := Syscall'munmap(addr, len);
                @trace("mumap(%, %)", addr, len);
                @assert_eq(result.value, 0, "some sort of corruption is going on. munmap(%) can't fail", addr);
                result.value
    };
    mprotect :: fn() = 0;
    read :: fn(f: Fd, buf: *u8, len: i64) i64 = {
        fd := get_file(f) || return(-1);
        @trace("read(%, %, %)", f.fd, u8.int_from_ptr(buf), len);
        fd'vtable'read(fd.data, buf.slice(len))
    };
    close :: fn(f: Fd) i64 = {
        @if(f.fd == { xxx := LinuxLibc.AT_FDCWD; xxx.fd }) return(-1);
        fd := get_file(f) || return(-1);
        ::ptr_utils(@type fd.vtable[]);
        @if(identical(fd.vtable, closed_file_vtable)) return(-1);
        @trace("close(%)", f.fd);
        fd'vtable'close(fd.data);
        fs.mutex&.lock();
        // default impl for everything to just error
        closed_file_vtable :: @static(FileVTable) { () };
        fs.fd[f.fd.intcast()] = (vtable = closed_file_vtable, data = zeroed(rawptr));
        fs.free&.push_back(f, fs.allocator);
        fs.mutex&.unlock();
        // note: not freeing fd.data because it's owned by the directory.
        0
    };
    dlopen :: fn(name: CStr) rawptr = {
        @trace("dlopen(%)", name);
        if name == "libc.so.6" {
            return(123.rawptr_from_int());
        };
        zeroed(rawptr)
    };
    dlsym :: fn(lib: rawptr, name: CStr) rawptr = {
        @assert_eq(lib.int_from_rawptr(), 123);
        dest := zeroed(rawptr);
        temporary_libc_import(name.str(), dest&, true);
        @trace("dlsym(%, %) = %", lib, name, dest);
        dest
    };
    dlclose :: fn() = 0;
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
        Syscall'perform_syscall(args&, 94);  // exit
    };
    write :: fn(f: Fd, buf: *u8, size: i64) i64 = {
        fd := get_file(f) || return(-1);
        @trace("write(%, %, %)", f.fd, u8.int_from_ptr(buf), size);
        fd'vtable'write(fd.data, buf.slice(size))
    };
    lseek :: fn(f: Fd, offset: i64, whence: Whence) i64 = {
        fd := get_file(f) || return(-1);
        result := fd'vtable'lseek(fd.data, offset, whence);
        @trace("lseek(fd = %, %, %) = %", f.fd, offset, @as(i64) whence, result);
        result
    };
    FR_fstat :: fn(f: Fd, out: *Posix.Linux.StatArm64) i64 = {
        out[] = zeroed(@type out[]);
        fd := get_file(f) || return(-1);
        result := fd'vtable'fstat(fd.data, out);
        @trace("fstat(%) = %; %", f.fd, result, @if(result == 0, {
            ifmt := out.st_mode.int().bit_and(Posix.S.IFMT);
            @if(ifmt == Posix.S.IFDIR, "DIR", "REG")
        }, "-"));
        result
    };
    readlinkat :: fn(parent: Fd, path: CStr, ptr: *u8, len: i64) i64 = 
        -1;
    opendir :: fn(path: CStr) i64 = {
        __errno_location()[] = 1;
        0
    };
    __errno_location :: fn() *i64 = @static(i64);
    sigaction :: fn() i64 = 0;
    memmove :: fn(dest: rawptr, src: rawptr, count: i64) void =
                copy_bytes_static(dest, src, count);
    pthread_attr_init :: fn(out: *ThreadAttr) i64 = {
                out[] = zeroed(@type out[]);
                0
    };
    // note: this requires that userdata be a *Thread (as called by raw_create_thread)
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                ctx := zeroed MContext;
                ctx.elr = bit_cast_unchecked(@type callee, i64, callee);
                ctx.gpr&[0] = bit_cast_unchecked(@type userdata, i64, userdata);
                ctx.gpr&[30] = int_from_rawptr(fn() void = {
                    args: Array(i64, 6) = (0, 0, 0, 0, 0, 0);
                    Syscall'perform_syscall(args&, 94);  // exit
                    unreachable()
                });
                ctx.gpr&[31] = bit_cast_unchecked(*u8, i64, attr.stack.end_pointer());
                
                thread := Thread.ptr_from_raw(userdata);
                @assert_eq(thread.tid_futex, MAX_u32);
                exit_futex := u32.int_from_ptr(thread.tid_futex&);
                args: Array(i64, 6) = (MContext.int_from_ptr(ctx&), exit_futex, 0, 0, 0, 0);
                id, _ := Syscall'perform_syscall(args&, 0xFFFF0005);  // spawn_thread
                @if(id < 0) panic("failed to create thread");
                thread.tid = id.intcast();
                out.opaque = userdata;
                @trace("pthread_create(elr = %, x0 = %, sp = %) = %", ctx.elr, ctx.gpr&[0], ctx.gpr&[31], id);
                0
    };
    pthread_attr_setstack :: fn(attr: *ThreadAttr, ptr: *u8, len: i64) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                attr.stack = ptr.slice(len);
                0
    };
    pthread_getcpuclockid :: fn() = 0;
    pthread_join :: fn(thread: pthread_t, value_ptr: *rawptr) i64 = {
        t := Thread.ptr_from_raw(thread.opaque);
        // not the same as `with_syscalls { t.join(); 0 };` because that would free the stack twice
        t.sys_join();
        value_ptr[] = zeroed rawptr; // TODO
        0
    };
    // for mandel.ssa
    putchar :: fn(c: u8) = print(c&.slice(1));
    puts :: fn(s: CStr) i64 = {  // for hello.c
        println(s.str());
        0
    };
    
    tcgetattr :: fn(fd: Fd, it: *Term.Terminos) i64 = {
        // TODO
        it[] = zeroed(Term.Terminos);
        0
    };
    tcsetattr :: fn(fd: Fd, optional_actions: i64, it: *Term.Terminos) i64 = {
        // TODO
        0
    };
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        // TODO: other clock_id's
        time_spec[] = system_counter_uptime();
        0
    };
    // TODO: do this more efficiently. 
    //       if multiple threads are sleeping, just have one yield like this for the shortest duration and the rest futex wait.
    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        @trace("nanosleep(s = %, ns = %)", duration.seconds, duration.nanoseconds);
        @debug_assert_eq(nullable_remainder_out, 0, "todo: sleep remainder");
        zeroes := zeroed Array(i64, 6);
            now := system_counter_uptime();
            end := now + duration[];
            dowhile {
                _ := Syscall'perform_syscall(zeroes&, 0xFFFF0002);  // yield
                now := system_counter_uptime();
                end.ms() > now.ms()
            };
            0
    };
    
    localtime_r :: fn(time_in: *time_t, time_out: *BigTime) *BigTime = {
        // TODO
        time_out[] = zeroed(BigTime);
        time_out
    };
    // TODO: this is supposed to be calander time not system up time
    time :: fn(out: *time_t) time_t = (seconds = timestamp() * 1000);
    
    // note: this is the linux syscall abi, not the libc abi
    FR_openat :: fn(f: Fd, path: CStr, flags: i64, mode: i64) i64 = {
        path := path.str();
        need_close := false;
        if path.contains("/") {  // :SLOW
            parent, file := or follow_path_prefix(f, path) { e |
                return(-e.abs());
            };
            f = parent;
            need_close = true;
            path = @tfmt("%\0", file);
        };
        fd := get_file(f) || return(-1);
        result := fd'vtable'openat(fd.data, (ptr = path.ptr), flags, mode);
        @trace("openat(fd = %, %, %, %) = %", f.fd, path, flags, mode, result);
        @assert(f.fd.intcast() != result, "openat must return new fd");
        if need_close {
            close(f);
        };
        result
    }
    
    // note: this is the linux syscall abi, not the libc abi
    FR_fstatat :: fn(fd: Fd, path: CStr, out: *Posix.Linux.StatArm64) i64 = {
        fd := FR_openat(fd, path, 0, 0);
        @if(fd < 0) return(fd);
        fd: Fd = (fd = fd.intcast());
        result := FR_fstat(fd, out);
        close(fd);
        result
    }
    
    mkdirat :: fn(parent: Fd, path: CStr, mode: i64) i64 = {
        @assert(!path.str().contains("/"), "TODO: mkdirat(%) flow_path but start early", path);
        f := get_file(parent) || return(-1);
        result := f'vtable'mkdir(f'data, path, mode);
        result
    }
    
    access :: fn(path: CStr, mode: i64) i64 = {
        fd := FR_openat(Posix'AT'FDCWD(), path, 0, 0);
        @if(fd < 0) return(fd);
        fd: Fd = (fd = fd.intcast());
        f := get_file(fd) || return(-1);
        result := f'vtable'access(f'data, mode);
        close(fd);
        result
    }
    
    malloc :: fn(size: i64) *u8 = 
        general_allocator().alloc_uninit(u8, size).as_ptr();
    free :: fn(p: rawptr) i64 = {
        // TODO: need to track size
        0
    }
    system :: fn(command: CStr) i64 = {
        @eprintln("TODO: implment LIBC.system(%)", command);
        -1
    };
    
    vsnprintf :: fn() void = @panic("TODO: libc.vsnprintf");
    
    strtod :: fn(s: *u8, end_out: **u8) f64 = {
        // TODO: this one doesn't support all the syntax. 1e-2
        s: CStr = (ptr = s);
        n, rest := parse_float(s.str());
        ::ptr_utils(*u8);
        if !end_out.is_null() {
            end_out[] = rest.ptr;
        };
        n
    }
};

system_counter_uptime :: fn() TimeSpec = {
    // "From Armv8.6-A and Armv9.1-A, the frequency of the count is fixed at 1GHz. 
    //  Pre-Armv8.6-A, the count frequency was a system design choice, typically 
    //  in the range of 1MHz to 50MHz." -- (Learn the architecture - Generic Timer. v1.4)
    // 2^64 nanoseconds is ~585 years.
    // TODO: ns*S_PER_NS overflows in 5.85 years at 1GHz which is enough that it doesn't matter for me but not infinity
    //       but you have to multiply first so you don't truncate
    
    ticks := u64.sys_get(.CNTVCT_EL0);
    ticks_per_s := u64.sys_get(.CNTFRQ_EL0);
    ns := ticks * NS_PER_S / ticks_per_s;
    s, ns_r := ns.div_mod(NS_PER_S);
    (seconds = s.bitcast(), nanoseconds = ns_r.bitcast())
}

fn with_syscalls($body: @Fn() i64) i64 = {
    c := context(DefaultContext);
    old := c.prefer_syscalls;
    c.prefer_syscalls = true;
    result := @must_return body();
    c.prefer_syscalls = old;
    result
}

fn trace(arg: FatExpr) FatExpr #macro = @{
    if fs.strace {
        c := context(DefaultContext);
        t := c.temporary_allocator_i;
        old := fs.strace;    // TODO: not thread safe
        old_sys := c.prefer_syscalls;
        c.prefer_syscalls = false;
        fs.strace = false;
        c.temporary_allocator_i = Arena'stack_alloc(1024);
        @[println arg];
        c.temporary_allocator_i = t;
        fs.strace = old;
        c.prefer_syscalls = old_sys;
    };
};

Term :: import("@/lib/sys/terminal.fr");
#use("@/lib/sys/threads.fr");
#use("@/lib/sys/sync/mutex.fr");

// TODO: make this less annoying
DISABLE_IMPORT_FRC :: false;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr"); 

#use("@/examples/os/libkernel.fr");

SHELL_HELP :: """
exit                 (power down the machine)
<path>               (jit and run a .fr program)
spawn <path>         (new thread won't block the shell)
strace <on, off>     (toggle libc logging)
time <on, off>       (log runtime after running a program)
uptime               (read the system counter)

example programs:
test_fuse
test_faults
spawn test_screen
""";
