
DBG :: false;

main :: fn() void = {
    println("init!");
    
    // note: this only affects the main thread
    buf := page_allocator.alloc_uninit(u8, 1.shift_left(16) * 10);
    range(0, 10) { i |
        buf[1.shift_left(16) * i] = 0;  // commit the page
    };
    args: Array(i64, 6) = (int_from_rawptr(handle_signal), u8.int_from_ptr(buf.ptr), buf.len, 0, 0, 0);
    Syscall'perform_syscall(args&, 0xFFFF0003);  // sig_action
    
    // TODO: real file system. for now just embed the blob of all the files like the web demo does. 
    fs_i, contents := @run {
        fs, contents := import("@/examples/web/build.fr")'collect_fs(ast_alloc());
        (fs, contents.items())
    };
    fs.index = fs_i;
    fs.contents = contents;
    fs.stdin = init(general_allocator(), 1.shift_left(16));
    fs.fd = list(general_allocator());
    range(0, 3) { _ |
        f := zeroed FileHandle;
        f.vtable = stdout_file;
        fs.fd&.push(f);
    };
    fs.fd[0].vtable = stdin_file;
    
    //import("@/examples/toy/reloc.fr")'main();
    if query_current_arch() != .wasm32 {
        redo_relocations_static_linux();
    };
    push_dynamic_context {
        c := context(DefaultContext);
        c.prefer_syscalls = false;
        
        Crash'push_aot_debug_resolver();
        c.panic_hook = fn(s) = {
            c := context(DefaultContext);
            c.prefer_syscalls = true;
            Crash'backtracing_panic_handler(s)
        };
        
        // TODO: this shouldn't be needed but the compiler's dying in get_environment_variable. 
        xxx := zeroed CStr;
        context(DefaultContext)[].environment_variables = xxx&;
        
        c.cli_arguments = empty();
        signal_env[] = c[];
        //import("@/examples/kaleidoscope.fr")'main();
        //import("@/examples/sudoku.fr")'main();
        //import("@/compiler/main.fr")'main2("examples/sudoku.fr", true);
        
        //range(0, 100) { i |
        //    println(i);
        //    context(DefaultContext)[].comptime = zeroed rawptr;
        //    import("@/compiler/main.fr")'main2("examples/sudoku.fr", true);
        //};
        import("@/compiler/main.fr")'main2("examples/kaleidoscope.fr", true);
        
        // doesn't work because it imports putchar 
        // (and i don't have dlopen yet, and putting it in temporary_libc_import 
        //  wouldn't help because qbe_frontend doesn't check that)
        //c.cli_arguments = @slice(@as(CStr) "", @as(CStr) "backend/test/mandel.ssa", "-r");
        //import("@/backend/meta/qbe_frontend.fr")'main();
    };
}

fs :: @static(@struct {
    contents: []u8;
    index: RawHashMap(Str, Ty(i64, i64));
    fd: List(FileHandle);
    mutex: Mutex;
    stdin: import("@/lib/collections/deque.fr")'RawDeque(u8);
});

FileHandle :: @rec @struct {
    vtable: *FileVTable;
    contents: []u8;
    pos: i64;
    readable: bool;
};

FileVTable :: @struct {
     read: @FnPtr(self: *FileHandle, buf: []u8) i64;
    write: @FnPtr(self: *FileHandle, buf: []u8) i64;
    lseek: @FnPtr(self: *FileHandle, offset: i64, whence: Whence) i64;
    close: @FnPtr(self: *FileHandle) void = fn(self) = ();
};

MContext :: @struct {
    gpr: Array(i64, 32);
    esr: i64;
    far: i64;
    elr: i64;
    spsr: i64;
    intid: i64;
    _: i64;
    fpr: Array(i64, 64);
};

signal_env :: @static(DefaultContext);

// note: intid != ctx.intid is legal because an interrupt might have triggered while a different task was running. 
//       ex. uart always goes to the init task. 
handle_signal :: fn(ctx: *MContext, intid: i64, data: i64) i64 = {
    set_dynamic_context(DefaultContext.raw_from_ptr(signal_env));
    if intid == 33 {
        char: u8 = data.trunc();
        if char == 3 {
            println("^C");
            Syscall'exit(1);  // will stop the whole system if this is the init task (which it always is rn)
        };
        // TODO: what if interrupted while reading
        fs.stdin&.push_back(char, panicking_allocator);
        @println("INPUT: %", data);
        return(intid);
    };
    
    ec := ctx.esr.shift_right_logical(26).bit_and(0b111111);
    if intid != 1023 || ec != 0b010101 {
        push_emergency_dynamic_environment {
            context(DefaultContext)[].prefer_syscalls = true;
            @println("sp = %; fp = %; lr = %; ip = %;", ctx.gpr&[31], ctx.gpr&[29], ctx.gpr&[30], ctx.elr);
            Crash'backtracing_panic_handler("fatal signal");
        };
    };
    
    // when targeting real linux, (open,fstat)at have a sucky abi so its easier to just do the syscall 
    // instead of trying to use glibc, which makes intercepting them more painful. 
    syscall_number := ctx.gpr&[8];
    @assert_eq(syscall_number, ctx.gpr&[16]);
    @switch(syscall_number) {
        @case(56) => {  // openat
            path := u8.ptr_from_int(ctx.gpr&[1]);
            path := (@as(CStr) (ptr = path)).str();
            @if(DBG) @println("openat(%)", path);
            if fs.index&.get(path) { off, len |
                fs.mutex&.lock();
                fd := fs.fd.len;
                fs.fd&.push(
                    vtable = read_only_mem_file,
                    contents = fs.contents.subslice(off, len),
                    pos = 0,
                    readable = true,
                );
                fs.mutex&.unlock();
                ctx.gpr&[0] = fd;
            } else {
                ctx.gpr&[0] = -1;
            };
        };
        @case(79) => {  // fstatat
            path := u8.ptr_from_int(ctx.gpr&[1]);
            path := (@as(CStr) (ptr = path)).str();
            out := Posix.Linux.StatArm64.ptr_from_int(ctx.gpr&[2]);
            ::[]@type out[];
            out.slice(1).set_zeroed();
            if fs.index&.get(path) { off, len |
                out.st_mode = Posix.S.IFREG;
                ctx.gpr&[0] = 0;
            } else {
                ctx.gpr&[0] = -1;
            };
        };
        @default => {
            @panic("invalid syscall %", syscall_number);
        };
    };
    intid
}

redo_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    header := Elf.Header.ptr_from_raw(base);
    @assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    unpacked.strings.ptr = unpacked.strings.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        name: CStr = (ptr = unpacked.strings.index(sym.name.zext()));
        name := name.str();
        
        type := sym.info.shift_right_logical(4);
        if sym.value == 0 {
            temporary_libc_import(name, dest, false);
        }
    };
};

temporary_libc_import :: fn(name: Str, dest: *rawptr, allow_null: bool) void = {
    LIBC_s :: Type.scope_of(LIBC);
    inline_for get_constants(LIBC_s) { $n |
        fid :: get_constant(FuncId, LIBC_s, n[]).unwrap();
        check := @run n[].str();
        if name == check {
            dest[] = fid;
            return();
        };
    };
    
    if !allow_null {
        @if(DBG) println(name);
        dest[] = fn() void = panic("called a weak import");
    };
}

MyAttr :: @struct {
    stack: []u8;
};

LIBC :: @struct {
    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 = {
                c := context(DefaultContext);
                c.prefer_syscalls = true;
                result := Syscall'mmap(addr, len, prot, flags, fd, offset);
                @if(DBG) @println("mmap(%) -> %", len, result);
                @assert_ne(result, 0, "some sort of corruption is going on because i over commit and can't null");
                c.prefer_syscalls = false;
                result
    };
    munmap :: fn(addr: rawptr, len: i64) voidResult = {
                c := context(DefaultContext);
                c.prefer_syscalls = true;
                result := Syscall'munmap(addr, len);
                @assert_eq(result.value, 0, "some sort of corruption is going on. munmap(%) can't fail", addr);
                c.prefer_syscalls = false;
                result
    };
    mprotect :: fn() = 0;
    read :: fn(fd: Fd, buf: *u8, len: i64) i64 = {
        fs.mutex&.lock();
        fd := fs.fd.index(fd.fd.zext());
        result := fd'vtable'read(fd, buf.slice(len));
        fs.mutex&.unlock();
        result
    };
    close :: fn(fd: Fd) i64 = {
        fs.mutex&.lock();
        fd := fs.fd.index(fd.fd.zext());
        fd'vtable'close(fd);
        // TODO: reuse slots of the array
        fs.mutex&.unlock();
        0
    };
    dlopen :: fn(name: CStr) rawptr = {
        if name == "libc.so.6" {
            return(123.rawptr_from_int());
        };
        zeroed(rawptr)
    };
    dlsym :: fn(lib: rawptr, name: CStr) rawptr = {
        @assert_eq(lib.int_from_rawptr(), 123);
        dest := zeroed(rawptr);
        temporary_libc_import(name.str(), dest&, true);
        dest
    };
    dlclose :: fn() = 0;
    exit :: fn(status: i64) void = {
        args: Array(i64, 6) = (status, 0, 0, 0, 0, 0);
        Syscall'perform_syscall(args&, 94);  // exit
    };
    write :: fn(fd: Fd, buf: *u8, size: i64) i64 = {
        fs.mutex&.lock();
        fd := fs.fd.index(fd.fd.zext());
        result := fd'vtable'write(fd, buf.slice(size));
        fs.mutex&.unlock();
        result
    };
    lseek :: fn(fd: Fd, offset: i64, whence: Whence) i64 = {
        fs.mutex&.lock();
        fd := fs.fd.index(fd.fd.zext());
        result := fd'vtable'lseek(fd, offset, whence);
        fs.mutex&.unlock();
        result
    };
    __errno_location :: fn() *i64 = @static(i64);
    sigaction :: fn() i64 = 0;
    clock_gettime :: fn() i64 = 0;
    memmove :: fn(dest: rawptr, src: rawptr, count: i64) void =
                copy_bytes_static(dest, src, count);
    pthread_attr_init :: fn(out: *ThreadAttr) i64 = {
                out[] = zeroed(@type out[]);
                0
    };
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                ctx := zeroed MContext;
                ctx.elr = bit_cast_unchecked(@type callee, i64, callee);
                ctx.gpr&[0] = bit_cast_unchecked(@type userdata, i64, userdata);
                ctx.gpr&[30] = int_from_rawptr(fn() void = {
                    args: Array(i64, 6) = (0, 0, 0, 0, 0, 0);
                    Syscall'perform_syscall(args&, 94);  // exit
                    unreachable()
                });
                ctx.gpr&[31] = bit_cast_unchecked(*u8, i64, attr.stack.end_pointer());
                
                args: Array(i64, 6) = (MContext.int_from_ptr(ctx&), 0, 0, 0, 0, 0);
                id, _ := Syscall'perform_syscall(args&, 0xFFFF0005);  // spawn_thread
                out[] = bit_cast_unchecked(@type id, pthread_t, id);
                
                0
    };
    pthread_attr_setstack :: fn(attr: *ThreadAttr, ptr: *u8, len: i64) i64 = {
                attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
                attr.stack = ptr.slice(len);
                0
    };
    pthread_getcpuclockid :: fn() = 0;
    pthread_join :: fn(thread: pthread_t, value_ptr: *rawptr) i64 = {
                id := bit_cast_unchecked(@type thread, i64, thread);
                args: Array(i64, 6) = (id, 0, 0, 0, 0, 0);
                dowhile {
                    done, _ := Syscall'perform_syscall(args&, 0xFFFF0006);  // check_thread
                    done == 0
                };
                value_ptr[] = zeroed rawptr; // TODO
                0
    };
    // for mandel.ssa
    putchar :: fn(c: u8) = print(c&.slice(1));
};

read_only_mem_file :: @static(FileVTable) (
    read = fn(fd, dest) = {
        @if(!fd.readable) return(-1);
        dest.len = min(dest.len, fd.contents.len - fd.pos).max(0);
        src := fd.contents.subslice(fd.pos, dest.len);
        dest.copy_from(src);
        fd.pos += dest.len;
        dest.len
    },
    write = fn(_self, _src) = -1,
    lseek = fn(fd, offset, whence) = {
        @if(!fd.readable) return(-1);
        ::enum(Whence);
        fd.pos = @match(whence) {
            fn End() => fd.contents.len;
            fn Set() => offset;
            @default => todo();
        };
        fd.pos
    },
    close = fn(fd) = {
        fd.readable = false;
    },
);

stdout_file :: @static(FileVTable) (
    read = fn(_fd, _dest) = 0,
    write = fn(_fd, src) = {
        c := context(DefaultContext);
        c.prefer_syscalls = true;
        result := Syscall'write((fd = 1), src.ptr, src.len);
        c.prefer_syscalls = false;
        result.value
    },
    lseek = fn(_fd, _offset, _whence) = -1,
    close = fn(_fd) = (),
);

stdin_file :: @static(FileVTable) (
    read = fn(_fd, dest) = {
        i := 0;
        while => i < dest.len {
            c := fs.stdin&.pop_front()  // :SLOW
                || return(i);
            dest[i] = c;
            i += 1;
        };
        i
    },
    write = fn(_fd, _src) = -1,
    lseek = fn(_fd, _offset, _whence) = -1,
    close = fn(_fd) = (),
);

#use("@/lib/sys/threads.fr");
#use("@/lib/sys/sync/mutex.fr");

// TODO: make this less annoying
DISABLE_IMPORT_FRC :: false;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr"); 
