
driver :: fn(vtable: *ImportVTable) void = {
    start := timestamp();
    bytes := compile(vtable);
    #use("@/examples/testing.fr");
    link_image_base: i64 = 0x40100000;
    mem_size := flat_link(bytes, link_image_base);
    // before stomping the elf header, save it as something objdump understands
    write_entire_file_or_crash("target/kernel.elf", bytes);
    output := "target/kernel.out";
    link_linux_boot(bytes, link_image_base, mem_size);
    write_entire_file_or_crash(output, bytes);
    
    if !cli_args().contains(fn(it) => it[] == "-qemu") {
        @println(">>> wrote to %; (run with -qemu to run the os as well)", output);
        @println("    (follows linux boot protocol)");
        return();
    };
    @eprintln(">>> compiled in %ms;", timestamp() - start);
    println("running...   (to turn it off, ctrl-a then press x)");
    // TODO: use `-accel hvf` on macos
    sh(@slice(
        "qemu-system-aarch64", "-machine", "virt,gic-version=3", 
        "-cpu", "cortex-a76", "-kernel", output, "-nographic", 
        "-m", "512M",
        "-device", "virtio-serial-pci,id=virtio-serial0",
        "-device", "virtconsole,chardev=vc02",
        "-chardev", "file,path=target/qemuconsoleoutput.txt,id=vc02",
    ));
    console := read_entire_file_or_crash(temp(), "target/qemuconsoleoutput.txt");
    print(console);
    _ := Syscall'remove("target/qemuconsoleoutput.txt");
}

compile :: fn(vtable: *ImportVTable) []u8 = {
    env: TargetEnv = (arch = .aarch64, os = .linux);
    src := "#include_std(\"lib/core.fr\");#include_std(\"examples/os/kernel/start.fr\");";
    build_options := vtable.default_build_options();
    build_options.retain_function_names = true;
    build_options.use_raw_syscalls = true;
    it := build_options.safety_checks&;
    it.insert(.Bounds, false);
    it.insert(.DebugAssertions, false);
    it.insert(.InvalidTag, false);
    comp := vtable.new_with_src(src, "examples/os/kernel/start.fr", build_options);
    fr := vtable.with(comp);
    
    entry := ProgramEntry.GiveMeTheCodeAndGiveItToMeRaw;
    fid := or fr.get_unique_named("main") {
        panic("expected exactly one function called 'main'")
    };
    fns := @slice(fid);
    
    m := @uninitialized Qbe.Module;
    init_default_module_dyn(m&, fr.vtable, (
        os = .linux, 
        arch = .aarch64, 
        type = .Relocatable,
        link_libc = false,
    ));
    m.goal.have_entry_point = true;  // TODO: why isn't this enough to replace `ENTRY(_start)`
    
    // HACK: shouldn't be relying on name mangling like this 
    // TODO: i don't have a way to ask for sane names without franca_runtime_init or making a dynamic library
    emit_entry(m&, @tfmt("main__%", @as(u32) fid));
    chunks := {fr.vtable.emit_qbe_included}(Qbe.Module.raw_from_ptr(m&), fr&, fns, entry);
    concat(chunks&, temp())
}

// TODO: should make an api for this that isn't so painful
emit_entry :: fn(m: *Qbe.Module, main: Str) void = {
    #use("@/backend/arm64/bits.fr");
    start := m.intern("_start");
    main := m.intern(main);
    m.goal.entry_point = "_start";

    code := zeroed Qbe.MultiArchAsm;
    // linux boot protocol: x0 = device tree
    code&[.aarch64] = interpret_as_bytes(@const_slice(
        arm_nop,  // adr fp, stack_top
        arm_nop,  // ^
        0xd50041bf, // msr SPSel, #0x1; probably already the case but just make sure. 
        movn(.X64, x1, 0b1111, .Left0),
        and_sr(.X64, fp, fp, x1, .LSL, 0b0),
        add_im(.X64, sp, fp, @as(u12) 0, 0b0),
        sub_im(.X64, x2, lr, 4, 0),  // base address if loaded as linux image
        arm_nop,  // bl main
        b(0, 0),
        arm_nop,
        arm_nop,
    ));
    m.add_code_bytes(start, code&);  
    m.maybe_add_export(start, true);
    m.emit_data(
        id = m.intern("stack_end"),
        template = (Zeroes = 0x100000),
        relocations = empty(),
    );
    stack_top := m.intern("stack_top");
    m.emit_data(
        id = stack_top,
        template = (Zeroes = 0),
        relocations = empty(),
    );
    // +4 becuase i insert bti. :(
    use_symbol(m, start) { s_start |
        use_symbol(m, stack_top) { s_stack_top |
            push_fixup(m, s_stack_top, (
                patch_at = u8.raw_from_ptr(m.segments&[.Code].mmapped.index(s_start.offset + 0 + 4)),
                type = (InReg = (r = fp, increment = 0)),
            ));
        };
        
        use_symbol(m, main) { s_main |
            s_main.strong = true;
            push_fixup(m, s_main, (
                patch_at = u8.raw_from_ptr(m.segments&[.Code].mmapped.index(s_start.offset + 7*4 + 4)),
                type = .Call,
            ));
        };
    };
}

// this is a bit overkill, maybe the sane thing would be to refactor elf/emit.fr
// such that there's a nice api that looks like a linker script for doing this sort of thing. 
// it would certainly be less fucking around to do this without making the intermediate elf file. 
// for now i thinks its cute that this works so i'll deal with it later. 
// whatever i decide with that, the important thing is not to depend on the gnu linker 
// because i disagree with their whole mental model of how toolchains for cross compiling should work. 
//
// this takes a relocatable elf file and does the relocations to make it loadable 
// at ram_base and with only one load command (i.e. no virtual memory holes). 
// it ignores section.addr_align
// (which is eventually going to get annoying enough that i replace this function with something sane)
flat_link :: fn(in: []u8, ram_base: i64) i64 = {
    Elf :: import("@/backend/elf/bits.fr");
    Arm :: import("@/backend/arm64/bits.fr");
    
    h := in.peek_type(Elf.Header);
    sh := in.rest(h.section_header_off).peek_type(Elf.SectionHeader);
    sh: []Elf.SectionHeader = sh.slice(h.section_header_num.zext());
    
    is_alloc :: fn(it) => it.flags.bit_and(1.shift_left(@as(i64) Elf.SectionFlag.Alloc)) != 0;
    section_bytes :: fn(it) => in.subslice(it.offset, it.size);
    section_array :: fn(it, $T) => {
        bytes := section_bytes(it);
        @as([]T) (ptr = ptr_cast_unchecked(u8, T, bytes.ptr), len = bytes.len / T.size_of())
    };
    
    voff := ram_base;
    found_entry := false;
    file_high := 0;
    entry_file_off := 0;
    enumerate sh { i, it |
        if is_alloc(it) {
            if h.entry >= it.addr && h.entry < it.addr + it.size {
                @assert(!found_entry);
                entry_file_off = h.entry - it.addr + it.offset;
                h.entry -= it.addr;
                h.entry += voff;
                found_entry = true;
            };
            ::enum(@type it.type);
            if it.type == .ProgramBits {
                end := it.offset + it.size;
                file_high = max(file_high, end);
            };
        
            it.addr = voff;
            voff += it.size;
        };
    };
    mem_size := voff - ram_base;
    @eprintln(">>> file size = %, mem size = %;", in.len, mem_size);
    @assert(file_high > 0);
    
    enumerate sh { mem_section_i, mem_section |
        if is_alloc(mem_section) {
            mem_bytes := section_bytes(mem_section);
            each sh { rel_section |
                ::enum(Elf.SectionType);
                @debug_assert_ne(rel_section.type, .RelocNoAddend, "todo: link no addend");
                if rel_section.info.zext() == mem_section_i && rel_section.type == .RelocAddend {
                    symbols := section_array(sh[rel_section.link.zext()]&, Elf.Symbol);
                    relocs := section_array(rel_section, Elf.RelA);
                    each relocs { it |
                        continue :: local_return;
                        sym := symbols[it.sym.zext()]&;
                        sym_type := sym.info.shift_right_logical(4);
                        
                        dest_vaddr := sh[sym.section_header_index.zext()].addr + sym.value;
                        src_vaddr := mem_section.addr + it.offset + it.addend;
                        inst := bit_cast_unchecked(*u8, *u32, mem_bytes.index(it.offset));
                        
                        // TODO: ehhh, using this with imports that expect a GOT slot doesn't really make sense. 
                        @if_else {
                            @if(it.type == Elf.R_AARCH64_ABS64) => {
                                // TODO: get rid of these so base address doesn't matter!
                                // TODO: what are the 137 data relocations that clearly don't matter that much?
                                @assert(mem_section.type != .Bss, "TODO: reloc in bss");
                                dest_vaddr = 0;  // TODO: redo at runtime. don't want fixed base address so can't do it here, but it seems fine without
                                bit_cast_unchecked(*u8, *i64, mem_bytes.index(it.offset))[] = dest_vaddr;
                            };
                            @if(it.type == Elf.R_AARCH64_CALL26 || it.type == Elf.R_AARCH64_JUMP26) => {
                                set_link := inst[].bit_and(1.shift_left(31)) != 0;
                                distance := dest_vaddr - src_vaddr;
                                inst[] = Arm'b(distance / 4, @as(u1) @as(i64) set_link.int());
                            };
                            @if(it.type == Elf.R_AARCH64_ADR_PREL_PG_HI21 || it.type == Elf.R_AARCH64_ADR_GOT_PAGE) => {
                                reg := inst[].bit_and(0b11111).zext();
                                i, _ := Arm'encode_adrp_off(dest_vaddr, src_vaddr, @as(u5) reg, false);
                                inst[] = i;
                            };
                            @if(it.type == Elf.R_AARCH64_ADD_ABS_LO12_NC || it.type == Elf.R_AARCH64_LD64_GOT_LO12_NC) => {
                                is_add := inst[].shift_right_logical(32-9) == 0b100100010;
                                is_load := inst[].shift_right_logical(32-10) == 0b1111100101;
                                @assert(is_add || is_load);
                                if dest_vaddr == 0 {
                                    @assert(sym_type == Elf.STB_WEAK);
                                    is_load = false;
                                };
                                // note: this assumes load's dest & addr are the same
                                reg := inst[].bit_and(0b11111).zext();
                                _, i := Arm'encode_adrp_off(dest_vaddr, src_vaddr, @as(u5) reg, is_load);
                                inst[] = i;
                            };
                            @else => unreachable();
                        };
                        if it.type != Elf.R_AARCH64_ABS64 {
                            it.type = 0;
                        }
                    };
                    
                    relocs&.unordered_retain(fn(it) => it.type != 0);
                    rel_section.size = relocs.len * size_of(Elf.RelA);
                }
            };
        };
    };
    
    //h.type = .Executable;  // leaving this as Relocatable makes objdump look for symbols in the right place
    h.program_header_entsize = size_of(Elf.ProgramHeader);
    available := in.slice(size_of(Elf.Header), h.section_header_off);
    @assert(available.len > size_of(Elf.ProgramHeader));
    h.program_header_num = 1;
    h.program_header_off = size_of(Elf.Header);
    ph := available&.pop_type(Elf.ProgramHeader);
    ph[] = (
        type = .Load,
        prot = 0b111,
        offset = 0,
        vaddr = ram_base, 
        paddr = ram_base,
        file_size = in.len,
        mem_size = in.len,
        align = 65536,
    );
    
    mem_size
}

// TODO: the constant R_AARCH64_ABS64 are wrong now because don't know where it will be loaded in ram.
//       but theres only two left and it seems to work
// note: ram_base won't be the address its loaded at runtime, it's just used to offset constant addresses. 
link_linux_boot :: fn(in: []u8, ram_base: i64, mem_size: i64) void = {
    Elf :: import("@/backend/elf/bits.fr");
    Arm :: import("@/backend/arm64/bits.fr");
    
    elf_h := in.peek_type(Elf.Header)[];
    lin_h := in.peek_type(LinuxBootHeader);
    distance := (elf_h.entry - ram_base) / 4;
    lin_h[] = (
        code = (Arm'b(distance, 1), 0),
        text_offset = 0,
        image_size = mem_size,
        flags = 0b0_11_0,
    );
}

// https://www.kernel.org/doc/Documentation/arm64/booting.txt
LinuxBootHeader :: @struct {
    code: Array(u32, 2);
    text_offset: i64;
    image_size: i64;
    flags: i64;
    res := zeroed Array(i64, 3);
    magic: u32 = 0x644d5241;
    res5: u32 = 0;
};

Qbe :: import("@/backend/lib.fr");
#use("@/lib/sys/fs.fr");
