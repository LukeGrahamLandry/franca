//
// this program starts a vm, loads a kernel image with the linux boot protocol,
// and gives it access to various virtio devices. 
// it only supports macos (because it uses Virtualization.Framework)
// but it means i can produce an executable, that runs my operating system 
// as though it were a normal program, and doesn't depend on qemu. 
// also i can compile that executable without installing xcode,
// the duel of which is that it can't be broken by updating xcode. 
// of course, my os doesn't depend on vzf, it runs just fine in qemu, 
// if you can figure out the right incantation. 
//

Cfg :: @struct {
    kernel: Str;
    bootargs: Str;
    shared_folders: []Ty(Str, Str);
    graphics: bool;
    width: f64;
    height: f64;
    cores: i64;
};

// TODO: an option to bake in the bytes of kernel.out
main :: fn() void = {
    run_vm(parse(cli_args()));
};

run_vm :: fn(args: Cfg) Never #use(apple) = {
    if args.graphics {
        app := NSApplication'sharedApplication();
        window: NSWindow = (_ = @objc cls("NSWindow").alloc());
        
        state: State = (
            env = get_dynamic_context(),
            window = window,
            cfg = args,
        );
        register_objc_class(FrancaVmAppDelegate);
        del := new "FrancaVmAppDelegate";
        // TODO: HACK: this name shouldn't be hardcoded in register_objc_class
        object_setInstanceVariable(del, "franca_sapp", State.raw_from_ptr(state&));
        @objc app.setDelegate(del);
        
        style: i64 = 0b1111;  // NSWindowStyleMask Tiled|Closable|Miniaturizable|Resizable
        rect: CGRect = (origin = (x = 0, y = 0), size = (width = args.width, height = args.height));
        window.initWithContentRect(rect, style, 2 /*NSBackingStoreBuffered*/, false);
        
        @objc window.makeKeyAndOrderFront(ObjCId.zeroed());
        app.run();
    } else {
        start_vm(args, .None);
        loop := NSRunLoop'mainRunLoop();
        loop.run();
    };
    unreachable();
}

// note: can't jit this program because the compiler executable doesn't have the entitlement for virtualization
start_vm :: fn(args: Cfg, view: ?FuncId.scope_of(apple).VZVirtualMachineView) void #use(apple) = {
    @assert_eq(query_current_os(), .macos, "this program requires Virtualization.Framework");

    console := new "VZVirtioConsoleDeviceSerialPortConfiguration";
    import("@/lib/sys/terminal.fr")'start_raw(STD_IN, false);
    at := VZFileHandleSerialPortAttachment'alloc();
    at := at.initWithFileHandleForReading(NSFileHandle'fileHandleWithStandardInput(), NSFileHandle'fileHandleWithStandardOutput());
    @objc console.setAttachment(at);
    serialPorts := @objc cls("NSArray").arrayWithObject(console);
    
    // TODO: there's also VZMultipleDirectoryShare, is it better to have one device? 
    shared_folders := new "NSMutableArray";
    for args.shared_folders { tag, path |
        tag := NSString'stringWithUTF8String(tag.as_cstr());
        path := NSString'stringWithUTF8String(path.as_cstr());
        path := NSURL'fileURLWithPath(path);
        
        dir: VZSharedDirectory = (_ = new "VZSharedDirectory");
        dir.initWithURL(path, false);
        
        share: VZSingleDirectoryShare = (_ = new "VZSingleDirectoryShare");
        share.initWithDirectory(dir);
        
        virtfs: VZVirtioFileSystemDeviceConfiguration = (_ = new "VZVirtioFileSystemDeviceConfiguration");
        virtfs.initWithTag(tag);
        @objc virtfs.setShare(share);
        
        @objc shared_folders.addObject(virtfs);
    };
    
    screens := new "NSMutableArray";
    if args.graphics {
        gfx := new "VZVirtioGraphicsDeviceConfiguration";
        gfx_cfg := new "VZVirtioGraphicsScanoutConfiguration";
        @objc gfx_cfg.initWithWidthInPixels(args.width.int(), heightInPixels = args.height.int());
        s := @objc cls("NSArray").arrayWithObject(gfx_cfg);
        @objc gfx.setScanouts(s);
        @objc screens.addObject(gfx);
    };
    
    cfg: VZVirtualMachineConfiguration = (_ = new "VZVirtualMachineConfiguration");
    
    @objc_set(cfg) (
        CPUCount = args.cores,
        memorySize = 6 * 1024 * 1024 * 1024,
        serialPorts = serialPorts,
        directorySharingDevices = shared_folders,
        graphicsDevices = screens,
    );
    
    kernel := NSString'stringWithUTF8String(args.kernel.as_cstr());
    boot := VZLinuxBootLoader'alloc();
    boot := boot.initWithKernelURL(NSURL'fileURLWithPath(kernel));
    bootargs := NSString'stringWithUTF8String(args.bootargs.as_cstr());
    boot.setCommandLine(bootargs);
    cfg.setBootLoader(boot);
    
    vm := VZVirtualMachine'alloc();
    vm := vm.initWithConfiguration(cfg);
    
    register_objc_class(FrancaVmDelegate);
    del := new "FrancaVmDelegate";
    // TODO: HACK: this name shouldn't be hardcoded in register_objc_class
    object_setInstanceVariable(del, "franca_sapp", get_dynamic_context());
    @objc vm.setDelegate(del);
    
    blk := new_global_block(general_allocator(), get_dynamic_context(), fn(self: *Block_literal_1, err: ObjCId) void = {
        set_dynamic_context(self.userdata);
        @assert(err.is_nil(), "failed to start vm");
    });
    
    @assert_eq(args.graphics, view.is_some(), "-graphics vs args.view");
    if view { view |
        view.setVirtualMachine(vm);
    };
    
    vm.startWithCompletionHandler(blk);
};

FrancaVmDelegate :: @struct {
    EXTENDS :: "NSObject";
    //IMPLEMENTS :: "VZVirtualMachineDelegate";
    
    #use(apple);
    guestDidStopVirtualMachine :: fn(self: ObjCId, _: VZVirtualMachine) void = {
        out := zeroed(rawptr);
        object_getInstanceVariable(self, "franca_sapp", out&);
        set_dynamic_context(out);
        
        Syscall'exit(0);
    }
}

State :: @struct {
    env: rawptr;
    window: FuncId.scope_of(apple).NSWindow;
    cfg: Cfg;
};

FrancaVmAppDelegate :: @struct {
    EXTENDS :: "NSObject";
    //IMPLEMENTS :: @const_slice("NSApplicationDelegate");
    
    #use(apple);
    applicationDidFinishLaunching :: fn(self: ObjCId, _: id"NSNotification") void = {
        state := zeroed(rawptr);
        object_getInstanceVariable(self, "franca_sapp", state&);
        state := State.ptr_from_raw(state);
        set_dynamic_context(state.env);
    
        app := NSApplication'sharedApplication();
        @objc app.activateIgnoringOtherApps(true);
        
        view: VZVirtualMachineView = (_ = new "VZVirtualMachineView");
        // TODO: the vm side needs to be aware. rn it just makes it super blurry for a bit and it still doesn't resize
        // @objc view.setAutomaticallyReconfiguresDisplay(true);
        @objc state.window.setContentView(view);
        start_vm(state.cfg, (Some = view));
    }

    applicationShouldTerminateAfterLastWindowClosed :: fn(self: ObjCId, sender: ObjCId) bool =
        true;
}

parse :: fn(args: []CStr) Cfg = {
    kernel: ?Str = .None;
    bootargs := u8.list(temp());
    shared_folders := Ty(Str, Str).list(temp());
    graphics := false;
    cores := 1;
    i := 1;
    while => i < args.len {
        c := args[i].str(); i += 1;
        @switch(c) {
            @case("-kernel") => {
                kernel = (Some = args[i].str()); i += 1;
            };
            @case("-append") => {
                bootargs&.push_all(args[i].str()); i += 1;
            };
            @case("-share") => {
                s := args[i].str(); i += 1;
                i := s.index_of("=".ascii()) 
                    || @panic("expected -share <tag>=<path>");
                push(shared_folders&, (s.slice(0, i), s.rest(i + 1)));
            };
            @case("-graphics") => {
                graphics = true;
            };
            @case("-smp") => {
                cores = args[i].str().parse_int(); i += 1;
            };
            @default => {
                @eprintln("unknown argument %", c);
            };
        }
    };
    (
        kernel = kernel || @panic("expected -kernel <path>"),
        bootargs = bootargs.items(),
        shared_folders = shared_folders.items(),
        graphics = graphics,
        width = 1280/2, 
        height = 800/2,
        cores = cores,
    )
}

driver :: fn(vtable: *ImportVTable) void = {
    opts := vtable.default_build_options();
    opts.retain_function_names = true;
    
    #use("@/lib/args.fr");
    Args :: @struct {
        unsafe := false;
        o := "a.out";
        arch := "";
    };
    arg := parse_args(Args);
    
    ::?Os;::?Arch;
    #use("@/lib/sys/process.fr");
    arch := @if(arg.arch == "", query_current_arch(), Arch.from_name(arg.arch) || @panic("invalid -arch %", arg.arch));
    
    if arg.unsafe {
        s := opts.safety_checks&;
        s.insert(.Bounds, false);
        s.insert(.DebugAssertions, false);
        s.insert(.InvalidTag, false);
    };
    
    input_path := "examples/os/vzf.fr";
    src := @tfmt("""#include_std("lib/core.fr");#include_std("%");""", input_path);
    
    comp := vtable.new_with_src(src, input_path, opts);
    ctx := vtable.with(comp);
    
    Dyn :: import("@/lib/dynamic_lib.fr");
    
    libs :: @const_slice("objc", "Virtualization", "CoreGraphics", "Metal", "QuartzCore", "AppKit", "MetalKit", "Cocoa", "CoreFoundation", "CoreVideo", "Foundation");

    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    
    Qbe :: import("@/backend/ir.fr");
    m := Qbe.Module.zeroed();
    init_default_module_dyn(m&, vtable, (
        arch = arch, 
        os = .macos, 
        type = .Exe,
        exe_debug_symbol_table = true,
    ));
    m.macho_entitlements = entitlements;
    for libs { it |
        m&.new_library(it);
    };
    bytes := emit_qbe_included_dyn(m&, ctx&, @slice(main_f), .WrapMain); 
    #use("@/lib/sys/fs.fr");
    write_chunks_or_crash(arg.o, bytes&);
    ctx'vtable'drop_qbe_module(Qbe.Module.raw_from_ptr(m&));
    ctx'vtable'destroy_compiler(ctx.data);
}

entitlements :: """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.virtualization</key>
	<true/>
</dict>
</plist>""";

//
// The rest of this file is bindings to Apple's Virtualization.Framework
//

apple :: fn() = {
#use("@/graphics/macos/objective_c.fr");
#reexport("@/graphics/macos/objective_c.fr");
#reexport("@/graphics/macos/frameworks.fr");

@class(VZVirtualMachine) {
    alloc :: fn() VZVirtualMachine #static;
    initWithConfiguration :: fn(self, _: VZVirtualMachineConfiguration) VZVirtualMachine;
    startWithCompletionHandler :: fn(self, _: *Block_literal_1) void;
};

@class(VZVirtualMachineConfiguration) {
    CPUCount: i64;
    memorySize: i64;
    serialPorts: NSArray_of(VZSerialPortConfiguration);
    bootLoader: VZLinuxBootLoader;
    directorySharingDevices: NSArray_of(VZVirtioFileSystemDevice);
};

@class(VZVirtualMachineView) {
    virtualMachine: VZVirtualMachine;
};

@class(VZSerialPortConfiguration) {
    
};

@class(VZVirtioConsoleDeviceSerialPortConfiguration) {
    attachment: VZFileHandleSerialPortAttachment;
};

@class(VZFileHandleSerialPortAttachment) {
    alloc :: fn() VZFileHandleSerialPortAttachment #static;
    initWithFileHandleForReading :: fn(self, _: NSFileHandle, fileHandleForWriting: NSFileHandle) VZFileHandleSerialPortAttachment;
};

@class(VZLinuxBootLoader) {
    alloc :: fn() VZLinuxBootLoader #static;
    initWithKernelURL :: fn(self, _: NSURL) VZLinuxBootLoader;
    commandLine: NSString;
};

@class(VZSingleDirectoryShare) {
    alloc :: fn() VZSingleDirectoryShare #static;
    initWithDirectory :: fn(self, _: VZSharedDirectory) VZSingleDirectoryShare;
};

@class(VZSharedDirectory) {
    alloc :: fn() VZSharedDirectory #static;
    initWithURL :: fn(self, _: NSURL, readOnly: bool) VZSharedDirectory;
};

@class(VZVirtioFileSystemDeviceConfiguration) {
    share: VZSingleDirectoryShare;
    alloc :: fn() VZVirtioFileSystemDeviceConfiguration #static;
    initWithTag :: fn(self, _: NSString) VZVirtioFileSystemDeviceConfiguration; 
};

@class(NSRunLoop) {
    mainRunLoop: NSRunLoop #readonly #static;
    run :: fn(self) void;
};

@class(NSFileHandle) {
    initWithFileDescriptor :: fn(_: Fd) NSFileHandle #static;
    fileHandleWithStandardInput: NSFileHandle #static #readonly;
    fileHandleWithStandardOutput: NSFileHandle #static #readonly;
};

};
