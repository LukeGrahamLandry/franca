
main :: fn() void = {
    globals[] = init(general_allocator());
    a, b, c := ("target/a.txt", "target/b.txt", "target/c.txt");
    dir, file := (@symbol dir, @symbol file);
    
    ()
    .push("target")
    .open(O = "r")
        .named(dir)
        .open(child = "a.txt", O = "rwtc")
            .named(file)
            .write("12AAAA")
            .write("789")
            .seek(to = 2)
            .write("3456")
            .seek(to = 0)
            .read().assert_eq("123456789")
            .var(file, Fd)
            .close()
        .var(dir, Fd)
        .close();
    
    msg1 := "This is the new contents of b.txt";
    msg2 := "something else!";
    msg3 := "Stomp with something else";
    
    ()
    .push(msg1)
        .write(to = b)
        .read().assert_eq(msg1)
    .push(msg2)
        .write(to = c)
        .read().assert_eq(msg2)
    .push(b)
        .rename(to = c)
            .read().assert_eq(msg1)
    .push(msg3)
        .write_tmp(to = c)
        .read().assert_eq(msg3)
    .push(msg3)
        .write_tmp(to = b)
        .read().assert_eq(msg3);
    
    d2 := "target/a/b/c";
    d := @tfmt("%/d.txt", d2);
    make_dirs_or_crash(d2);
    msg4 := "in my new directory";
    msg4.write(to = d)
        .read().assert_eq(msg4);
    
    d2.ls().assert_eq("d.txt\0");
    d2 := d2.slice(0, d2.len - 2);
    d2.open(O = "r")
        .named(dir)
        .open(child = "c.txt", O = "wct")
            .write("Hello World")
            .close()
        .var(dir, Fd)
        .close();
    d2.ls().assert_eq("c\0c.txt\0");
    
    println("ok");
}

fn read(path: Str) []u8 =
    read_entire_file_or_crash(temp(), path);

fn close(fd: Fd) void = {
    Syscall'close(fd);
}

fn open(path: Str, it: @struct(O: Str)) Fd = 
    Posix'AT'FDCWD().open(child = path, O = it.O);

fn open(fd: Fd, it: @struct(child: Str, O: Str)) Fd = {
    r, w, t, c := (it.O.contains("r"), it.O.contains("w"), it.O.contains("t"), it.O.contains("c"));
    flags := @if_else {
        @if(r && w) => Posix.O.RDWR;
        @if(r) => Posix.O.RDONLY;
        @if(w) => Posix.O.WRONLY;
        @else => @panic("open(%): O(%) must contain r or w", it.child, it.O);
    };
    if(t) {| flags = flags.bit_or(Posix.O.TRUNC); };
    if(c) {| flags = flags.bit_or(Posix.O.CREAT); };

    Posix'openat(fd, it.child.as_cstr(), flags, Posix'S'IRWXU)
        || @panic("failed to open (parent = %)|%|", fd.fd, it.child)
}

fn write(buf: Str, it: @struct(to: Str)) Str = {
    it.to.open(O = "wtc").write(buf).close();
    it.to
}

fn write_tmp(buf: Str, it: @struct(to: Str)) Str = {
    write_entire_file_or_crash(it.to, buf);
    it.to
}

fn write(fd: Fd, buf: Str) Fd = {
    len := Syscall'write(fd, buf.ptr, buf.len)
        || @panic("failed write % bytes", buf.len);
    @assert_eq(len, buf.len, "incomplete write");
    fd
}

fn read(fd: Fd) []u8 = {
    buf := temp().alloc_uninit(u8, fd.size());
    len := Syscall'read(fd, buf.ptr, buf.len)
        || @panic("failed read % bytes", buf.len);
    @assert_eq(len, buf.len, "incomplete read");
    buf
}

fn seek(fd: Fd, it: @struct(to: i64)) Fd = {
    _ := Syscall'lseek(fd, it.to, .Set) 
        || @panic("failed lseek to %", it.to);
    fd
}

fn cur(fd: Fd) i64 = 
    Syscall'lseek(fd, 0, .Cur) 
        || @panic("failed seek(Cur)");

fn size(fd: Fd) i64 = {
    cur := fd.cur();
    size := Syscall'lseek(fd, 0, .End) 
        || @panic("failed seek(End)");
    fd.seek(to = cur);
    size
}

fn rename(old: Str, it: @struct(to: Str)) Str = {
    rename(old.as_cstr(), it.to.as_cstr()) 
        || @panic("failed rename % -> %", old, it.to);
    it.to
}

fn ls(path: Str) Str = {
    files := collect_directory_ordered(path, temp(), temp())
        || @panic("failed to walk_dir %", path);
    out := u8.list(temp());
    for files { it |
        out&.push_all(it.name);
        out&.push(0);
    };
    out.items()
}

#use("@/lib/collections/map.fr");
globals :: @static(HashMap(Symbol, @union(Fd: Fd, Str: Str)));

fn named(value: Fd, key: Symbol) Fd = {
    globals.insert(key, (Fd = value));
    value
}
fn named(value: Str, key: Symbol) Str = {
    globals.insert(key, (Str = value));
    value
}
fn var(_: void, key: Symbol, $T: Type) T #generic = {
    value := globals.get(key) || @panic("missing global %", key);
    bit_cast_unchecked(@type value, T, value)
}

fn push(_: void, value: Str) Str = value;

#use("@/lib/sys/fs.fr");
