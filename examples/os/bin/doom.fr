// this program uses my c compiler to compile doom and then runs it, rendering to the framebuffer on my os

// input doesn't work yet
// relies on shared target directory from host because i don't have my own writable file system 
// need to pre-fetch the code+iwad because i don't have networking so run build.fr with -fetch-doom

// TODO: change the resolution so it doesn't have the green boarder around the gameplay? 

main :: fn() void = {
    println("doom.fr running");
    argv := list(CStr, temp());
    argv&.push("doom.fr".as_cstr());
    argv&.push("-iwad".as_cstr());
    argv&.push(IWAD[].rest("target/".len()).as_cstr());
    argv&.push(zeroed CStr);
    Syscall'chdir("target");
    
    doom'run(argv.len.intcast() - 1, bit_cast_unchecked(*CStr, **i8, argv.maybe_uninit.ptr));
}

fetch :: fn() Ty(Str, Str) = {
    #use("@/examples/testing.fr");
    // TODO: use https://github.com/id-Software/DOOM instead
    root := fetch_or_crash("https://github.com/maximevince/fbDOOM/archive/72b0675c10f51ba5844df5669991c3ab7038fd1f.zip", 604498, "5dec861e2821301ce992b98872220c2acab08ac894bbb3c0a9c8424cc49890e2", "fbDOOM-72b0675c10f51ba5844df5669991c3ab7038fd1f");
    iwad := fetch_or_crash("https://www.doomworld.com/3ddownloads/ports/shareware_doom_iwad.zip", 1782482, "845f4f3a449343b068a4e178f9cb018cb1f5b7d5ef09db292864ed554f612276", "doomdata");
    (root, @tfmt("%/DOOM1.WAD", iwad))
}

IWAD :: @static(Str);  // TODO: const destructure. `a, b :: foo()`
doom :: (fn() ScopeId = {
    #use("@/examples/import_c/ffi.fr");
    Qbe :: import("@/backend/ir.fr");
    root, iwad := fetch();
    IWAD[] = iwad.shallow_copy(ast_alloc());
    fr := current_compiler_context();
    c := import_c'init_fr(fr);
    src_path := @tfmt("%/fbdoom", root);
    c.include_paths&.push(src_path);
    write_entire_file_or_crash(@tfmt("%/strings.h", src_path), SRC_strings_h);
    make_dirs(@tfmt("%/linux", src_path));
    write_entire_file_or_crash(@tfmt("%/linux/fb.h", src_path), """
        struct fb_var_screeninfo {
            struct { int offset; int length; } red;
            struct { int offset; int length; } green;
            struct { int offset; int length; } blue;
            struct { int offset; int length; } transp;
            int bits_per_pixel;
            int grayscale;
            int xres;
            int yres;
            int xres_virtual;
            int yres_virtual;
        };
        #define FBIOGET_VSCREENINFO 1234
    """);
    make_dirs(@tfmt("%/sys", src_path));
    write_entire_file_or_crash(@tfmt("%/sys/socket.h", src_path), "");
    
    root_scope := list(Ty(Str, *import_c'C'Compile'VarScope), temp());
    for source_files { it |
        println(it);
        src := read_entire_file_or_crash(c.arena, @tfmt("%/%", src_path, it));
        or import_c'compile_c(c, it, src) { err |
            @panic("%", err);
        };
        
        retain c.scope.vars.raw& { name, v |
            ::ptr_utils(@type v.var[]);
            keep := v.var.is_null() || !v.var.is_static;
            if !keep {
                push(root_scope&, (name[], v[]));
            };
            keep
        };
    };
    for root_scope { name, value |
        c.scope.vars&.insert(name, value);
    };
    
    bytes := import_c'compile_fr(fr, SRC, c, "doom");
    fr'vtable'drop_qbe_module(Qbe.Module.raw_from_ptr(c.m));
    c.arena_storage&.deinit();
    result := fr'vtable'import_frc(fr.data, bytes);
    or result { err |
        fr.report_error(err)
    }
})();

source_files :: @const_slice(
    "wi_stuff.c", // TODO: order shouldn't matter
    "am_map.c", "d_event.c", "d_items.c", "d_iwad.c", "d_loop.c", 
    "d_main.c", "d_mode.c", "d_net.c", "doomdef.c", 
    "doomstat.c", "dstrings.c", "dummy.c", "f_finale.c", "f_wipe.c",
    "g_game.c", "gusconf.c", "hu_lib.c", "hu_stuff.c", "i_cdmus.c", 
    "i_endoom.c", "i_joystick.c", "i_scale.c", "i_sound.c", 
    "i_system.c", "i_timer.c", "i_video_fbdev.c", "icon.c", "info.c", "m_argv.c", 
    "m_bbox.c", "m_cheat.c", "m_config.c", "m_controls.c", "m_fixed.c", 
    "m_menu.c", "m_misc.c", "m_random.c", "memio.c", "p_ceilng.c",
    "p_doors.c", "p_enemy.c", "p_floor.c", "p_inter.c", "p_lights.c", "p_map.c",
    "p_maputl.c", "p_mobj.c", "p_plats.c", "p_pspr.c", "p_saveg.c", "p_setup.c",
    "p_sight.c", "p_spec.c", "p_switch.c", "p_telept.c", "p_tick.c", "p_user.c", 
    "r_bsp.c", "r_data.c", "r_draw.c", "r_main.c", "r_plane.c", "r_segs.c", "r_sky.c", 
    "r_things.c", "s_sound.c", "sha1.c", "sounds.c", "st_lib.c", "st_stuff.c", 
    "statdump.c", "tables.c", "v_video.c", "w_checksum.c", "w_file_stdc.c", 
    "w_file.c", "w_main.c", "w_wad.c", "z_zone.c"
);

SRC :: """
void run(int argc, char **argv) {
    myargc = argc;
    myargv = argv;
    M_FindResponseFile();
    D_DoomMain();
}
""";

SRC_strings_h :: """
int strcasecmp(const char *s1, const char *s2);
char *strdup(char *s);
int strncasecmp(const char *s1, const char *s2, long n);
""";
