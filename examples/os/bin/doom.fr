// input doesn't work yet

main :: fn() void = {
    println("doom.fr running");
    argv := list(CStr, temp());
    argv&.push("doom.fr".as_cstr());
    argv&.push("-iwad".as_cstr());
    argv&.push(IWAD[].rest("target/".len()).as_cstr());
    argv&.push(zeroed CStr);
    Syscall'chdir("target");
    
    #use("@/lib/sys/threads.fr");
    start_thread_nodata {
        import("@/examples/os/bin/test_screen.fr")'run_loop() { fb, r |
            frame := doom.DG_ScreenBuffer[].slice(640*400);
            if !frame.ptr.is_null() {
                fb.copy_from(frame);
            };
        };
    };
    
    doom'run(argv.len.intcast() - 1, bit_cast_unchecked(*CStr, **i8, argv.maybe_uninit.ptr), vtable);
}

vtable :: @static(doom.VTable) (
    DG_Init = fn() = {
        println("DG_Init");
        // TODO
    },
    DG_DrawFrame = fn() = {
        // TODO
    },
    DG_GetKey = fn(pressed, doomKey) = {
        // TODO
        0
    },
    DG_SleepMs = fn(ms) = {
        usleep(ms * US_PER_MS);
    },
    DG_GetTicksMs = fn() = timestamp().trunc(),
    DG_SetWindowTitle = fn(title: *i8) = {
        title := bit_cast_unchecked(@type title, CStr, title);
        println(title.str());  // TODO
    },
);

fetch :: fn() Ty(Str, Str) = {
    #use("@/examples/testing.fr");
    // TODO: use https://github.com/id-Software/DOOM instead
    root := fetch_or_crash("https://github.com/ozkl/doomgeneric/archive/fc601639494e089702a1ada082eb51aaafc03722.zip", 3237906, "ce728978d1d63a038890306dc7da05e0e2093d2f4c4d37eb111b7f6a5a3bc4db", "doomgeneric-fc601639494e089702a1ada082eb51aaafc03722");
    iwad := fetch_or_crash("https://www.doomworld.com/3ddownloads/ports/shareware_doom_iwad.zip", 1782482, "845f4f3a449343b068a4e178f9cb018cb1f5b7d5ef09db292864ed554f612276", "doomdata");
    (root, @tfmt("%/DOOM1.WAD", iwad))
}

IWAD :: @static(Str);
doom :: (fn() ScopeId = {
    #use("@/examples/import_c/ffi.fr");
    Qbe :: import("@/backend/ir.fr");
    root, iwad := fetch();
    IWAD[] = iwad.shallow_copy(ast_alloc());
    fr := current_compiler_context();
    c := import_c'init_fr(fr);
    src_path := @tfmt("%/doomgeneric", root);
    c.include_paths&.push(src_path);
    write_entire_file_or_crash(@tfmt("%/strings.h", src_path), SRC_strings_h);
    root_scope := list(Ty(Str, *import_c'C'Compile'VarScope), temp());
    for source_files { it |
        println(it);
        src := read_entire_file_or_crash(c.arena, @tfmt("%/%", src_path, it));
        or import_c'compile_c(c, it, src) { err |
            @panic("%", err);
        };
        
        retain c.scope.vars.raw& { name, v |
            ::ptr_utils(@type v.var[]);
            keep := v.var.is_null() || !v.var.is_static;
            if !keep {
                push(root_scope&, (name[], v[]));
            };
            keep
        };
    };
    for root_scope { name, value |
        c.scope.vars&.insert(name, value);
    };
    
    bytes := import_c'compile_fr(fr.get_alloc(), SRC, c);
    fr'vtable'drop_qbe_module(Qbe.Module.raw_from_ptr(c.m));
    c.arena_storage&.deinit();
    result := fr'vtable'import_frc(fr.data, bytes);
    or result { err |
        fr.report_error(err)
    }
})();

source_files :: @const_slice(
    "wi_stuff.c", // TODO: order shouldn't matter
    "am_map.c", "d_event.c", "d_items.c", "d_iwad.c", "d_loop.c", 
    "d_main.c", "d_mode.c", "d_net.c", "doomdef.c", "doomgeneric.c",
    "doomstat.c", "dstrings.c", "dummy.c", "f_finale.c", "f_wipe.c",
    "g_game.c", "gusconf.c", "hu_lib.c", "hu_stuff.c", "i_cdmus.c", 
    "i_endoom.c", "i_input.c", "i_joystick.c", "i_scale.c", "i_sound.c", 
    "i_system.c", "i_timer.c", "i_video.c", "icon.c", "info.c", "m_argv.c", 
    "m_bbox.c", "m_cheat.c", "m_config.c", "m_controls.c", "m_fixed.c", 
    "m_menu.c", "m_misc.c", "m_random.c", "memio.c", "mus2mid.c", "p_ceilng.c",
    "p_doors.c", "p_enemy.c", "p_floor.c", "p_inter.c", "p_lights.c", "p_map.c",
    "p_maputl.c", "p_mobj.c", "p_plats.c", "p_pspr.c", "p_saveg.c", "p_setup.c",
    "p_sight.c", "p_spec.c", "p_switch.c", "p_telept.c", "p_tick.c", "p_user.c", 
    "r_bsp.c", "r_data.c", "r_draw.c", "r_main.c", "r_plane.c", "r_segs.c", "r_sky.c", 
    "r_things.c", "s_sound.c", "sha1.c", "sounds.c", "st_lib.c", "st_stuff.c", 
    "statdump.c", "tables.c", "v_video.c", "w_checksum.c", "w_file_stdc.c", 
    "w_file.c", "w_main.c", "w_wad.c", "z_zone.c"
);

SRC :: """
typedef struct VTable {
    void (*DG_Init)(void);
    void (*DG_DrawFrame)(void);
    void (*DG_SleepMs)(unsigned int);
    unsigned int (*DG_GetTicksMs)(void);
    int (*DG_GetKey)(int *pressed, char *doomKey);
    void (*DG_SetWindowTitle)(char *title);
} VTable;

VTable vtable = { 0 };

void run(int argc, char **argv, VTable *v) {
    vtable = v[0];
    doomgeneric_Create(argc, argv);
    while (1) doomgeneric_Tick();
}

void DG_Init(void) {
    vtable.DG_Init();
}

void DG_DrawFrame(void) {
    vtable.DG_DrawFrame();
}

void DG_SleepMs(uint32_t ms) {
  vtable.DG_SleepMs(ms);
}

uint32_t DG_GetTicksMs(void) {
    return(vtable.DG_GetTicksMs());
}

int DG_GetKey(int *pressed, char *doomKey) {
    return(vtable.DG_GetKey(pressed, doomKey));
}

void DG_SetWindowTitle(char *title) {
    vtable.DG_SetWindowTitle(title);
}
""";

SRC_strings_h :: """
int strcasecmp(const char *s1, const char *s2);
char *strdup(char *s);
int strncasecmp(const char *s1, const char *s2, long n);
""";
