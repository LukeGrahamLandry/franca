// this allows compiling the userspace part of my os to wasm and running it in a web browser. 
// the core syscalls that would normally be provided by the kernel map quite directly to browser apis:
// thread -> WebWorker, mmap -> memory.grow, futex -> memory.atomics.(wait, notify), virtio-gpu -> webgpu. 
// there's an example of the js side in examples/web/(main.js, worker.js). 

#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
#use("@/graphics/lib.fr");
SOKOL_BACKEND :: RenderBackend.WGPU;
GRAPHICS_TARGET_WEB :: true;
::Sapp.Wgpu;

#use("@/examples/os/libkernel.fr");

// this is what the browser calls when compiled with -dynamiclib
// it just sees the ones marked #export
#export
fn main(argc: i64, argv: *CStr, envp: *CStr, sp: i64) void = {
    init_the_memory();
    
    // this is done twice so mmap works in allocate_stack
    for_wasm_imports { i, name |
        if wasm_libc_exports.get(name) { addr |
            Jit'impl'run(Assign = (dest = i, src = addr.int_from_rawptr()));
        };
    };
    
    // TODO: don't waste the memory of the original stack
    
    franca_runtime_init(argc, argv, main2, envp, sp);
}

// static data needs to be in a passive segment instead of an active segment 
// so it doesn't get reset when you spawn a new thread. 
// this is called from the main entry point but not wasm_init_thread. 
init_the_memory :: AsmFunctionWasmOnly(fn() void = (), 
    fn(out) = out.push_all(Jit.impl.init_the_memory_code));

// TODO: #use should probably be illegal since it also declares a `main` 
//       which should conflict with ours, but it's very convient that it works (tho order dependent)
#use("@/examples/os/user/init.fr");

main2 :: fn() void = {
    globals.jit_events = list(4096, general_allocator());
    redo_relocations_wasm();  // do it again to record 
    globals.free = list(4096, general_allocator());
    Vfs'init_vfs();
    xxx := Vfs.fs;  // :compilerbug ?? Type Error: field 'fs' does not exist
    xxx.stdin.poll = fn(a, b) = ();
    
    // the reverse: anything we imported from js and didn't override should still be accessible with dlopen 
    _ := reach_webgpu_imports();
    for_wasm_imports { i, name |
        if libc_exports.get(name).is_none() {
            libc_exports.insert(name, i.rawptr_from_int(), general_allocator());
        };
    };

    shell.strace = cli_args().contains(fn(it) => it[] == "-strace");
    globals.ready = true;
    tls(.prefer_syscalls)[] = false;
    import("@/examples/web/demo.fr")'main();
}

reach_webgpu_imports :: fn() []rawptr #noinline = @run {
    force_reachable := rawptr.list(ast_alloc());
    WGPU :: import("@/target/franca/webgpu.g.fr");
    fr := current_compiler_context();
    fid := get_constant(FuncId, Sapp.Wgpu, @symbol francaRequestState).unwrap();
    addr := fr.get_jitted(fid);
    force_reachable&.push(addr);
    for WGPU.get_constants() { n |
        name := n.str();
        if name.starts_with("wgpu") {
            fid := get_constant(FuncId, WGPU, n).unwrap();
            addr := fr.get_jitted(fid);
            force_reachable&.push(addr);
        };
    };
    fmodf :: fn() void #libc;
    fmod :: fn() void #libc;
    sinf :: fn() void #libc;
    cosf :: fn() void #libc;
    sqrt :: fn() void #libc;
    pow :: fn() void #libc;
    acos :: fn() void #libc;
    cos :: fn() void #libc;
    fabs :: fn() void #libc;
    floor :: fn() void #libc;
    ceil :: fn() void #libc;
    
    for (@slice(fmodf, fmod, sinf, cosf, sqrt, pow, acos, cos, fabs, floor, ceil)) { fid |
        addr := fr.get_jitted(fid);
        force_reachable&.push(addr);
    };
    
    force_reachable.items()
};

redo_relocations_wasm :: fn() void #inline = {
    for_wasm_imports { i, name |
        if wasm_libc_exports.get(name) { addr |
            Overrides'FR_wasm_jit_event(Assign = (dest = i, src = addr.int_from_rawptr()));
        };
    };
};

wasm_libc_exports :: {  // note: evaluating this mutates libc_exports as well
    @run collect_from_scope(libc_exports, Type.scope_of(Overrides), true);
    libc_exports
};

for_wasm_imports :: fn($body: @Fn(i: i64, name: Str) void) void = {
    import_names_raw := @import_symbol("__franca_wasm_import_names");
    import_names_raw := u8.ptr_from_raw(import_names_raw).slice(1.shift_left(16));
    i := 0;
    dowhile {
        name := import_names_raw&.pop_cstr();
        @if(name.len > 0) body(i, name);
        i += 1;
        name.len > 0
    };
}

Host :: @struct {
    jit_instantiate_module :: fn(address: *u8, length: i64, table_start: i64, table_index: u32) void #weak #import("libc");
    js_performace_now :: fn() f64 #weak #import("libc");
    js_write :: fn(id: i64, ptr: *u8, len: i64) i64 #weak #import("libc");
    js_worker_spawn :: fn(userdata: rawptr, stack: *u8, exit_futex: *u32) void #weak #import("libc");
    js_worker_stop :: fn(status: i64) void #weak #import("libc");
};

#use("@/lib/sys/sync/mutex.fr");
#use("@/lib/sys/threads.fr");
globals :: @static(@struct {
    free: List([]u8);  // sorted by address
    grow: Mutex;
    ready: bool;
    
    // TODO: make this less chunky. also merge all the Grow
    //       and when you drop the Qbe.Module, drop the corrisponding Event.Module. 
    jit_events: List(Jit.Event);
    jit: Mutex;
});

wasm_page_size :: 65536;

// don't need to preserve callee because it's always franca_runtime_init_thread
fn wasm_init_thread(franca_userdata: rawptr, known_wasm_jit_event: i64) i64 #export = {
    get_current_tls()[].known_wasm_jit_event = known_wasm_jit_event;
    tls(.panic_hook)[] = fn(msg) = {
        Overrides'FR_debug_write(msg.ptr, msg.len);
        Overrides'exit(123);
        unreachable()
    };
    Overrides'FR_wasm_jit_event(.Sync);
    franca_runtime_init_thread(franca_userdata);
    get_current_tls()[].known_wasm_jit_event
}

fn close_modules(events: []i64) void = {
    @debug_assert(globals.jit&.locked_by_me());
    indices: HashMap(i64, void) = init(temp());
    event_i := 0;
    range(events[0], globals.jit_events.len) { i |
        event := globals.jit_events.index(i);
        @match(event) {
            // to start with, all the functions creating by this module are now dead
            fn Module(it) => if event_i < events.len && events[event_i] == i {
                Vfs.fs.allocator.dealloc(u8, it.wasm);
                @trace("jit_close(%, %..+%)", i, it.table_start, it.count);
                range(it.table_start, it.table_start+it.count) { i |
                    indices&.insert(i, ());
                };
                event[] = .Sync;
                event_i += 1;
            }
            // now follow through all the assignments to get the final set of dead slots
            fn Assign(it) => {
                if indices&.get(it.src).is_some() {
                    // src is dead so dest is dead too. 
                    indices&.insert(it.dest, ());
                    // when a new thread grows the table, entry start off as null, so its fine to do nothing
                    event[] = .Sync;
                    // TODO: i think that's still wrong for threads that are only partially synced
                } else {
                    // src is live so dest is no longer dead.
                    indices&.remove(it.dest);
                }
            }
            @default => ();
        }
    };
    @assert_eq(event_i, events.len, "closed multiple times or unordered events");
    // for threads that have already seen the functions we're removing, 
    // tell them to move null into that slot so it crashes if they try to call it. 
    // also my hope is this lets the module be gc-ed. 
    each indices& { i, _ |
        event: Jit.Event = (Assign = (dest = i, src = 0));
        Jit'impl'run(event);
        globals.jit_events&.push(event);
    };
}

Jit :: import("@/backend/wasm/jit.fr");
Overrides :: @struct {
    FR_wasm_jit_event :: fn(event: Jit.Event) i64 = {
        @match(event&) {
            fn Assign(it) => @if(it.src == it.dest) return(0);
            fn Grow(it) => @assert(it.delta != 0, "can't check the size like that because i don't store results");
            fn Module(it) => {
                it.wasm = it.wasm.shallow_copy(Vfs.fs.allocator);
            }
            fn Sync() => ();
            fn Close() => ();
        };
        
        result := 0;
        with globals.jit& {
            // replay all the events done by other threads first. 
            i := get_current_tls()[].known_wasm_jit_event&;
            to_sync := globals.jit_events.items().rest(i[]);
            for to_sync { it |
                Jit'impl'run(it);
            };
            @if(to_sync.len != 0) @trace("jit_sync(%..+%)", i[], to_sync.len);
            
            if !@is(event&, .Sync, .Close) {
                globals.jit_events&.push(event);
            };
            
            result = Jit'impl'run(event);
            @match(event&) {
                fn Module(it) => {
                    result = globals.jit_events.len - 1;   // return the handle for closing
                    @trace("jit_open(size = %) = %, %..+%", it.wasm.len, result, it.table_start, it.count);
                }
                fn Close(it) => close_modules(it.events);
                @default => ();
            };
            i[] = globals.jit_events.len;

        };
        result
    }
    
    yield_file :: fn(ptr: *u8, len: i64) void = {
        r := Host'js_write(0xBBBB0001, ptr, len);
        @assert_eq(r, len, "failed yield_file");
    }
    
    FR_debug_write :: fn(ptr: *u8, len: i64) void = {
        Host'js_write(0xBBBB0000, ptr, len);
    };

    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, off: i64) rawptr = {
        if !globals.ready {
            len := len.ualign_to(wasm_page_size);
            prev := memory_grow(len.udiv(wasm_page_size).intcast()).intcast();
            @assert(prev != -1, "oom");
            return rawptr_from_int(prev * wasm_page_size);
        };
        
        result := zeroed(rawptr);
        with globals.grow& {
            break :: local_return;
            len := len.ualign_to(wasm_page_size);
            
            enumerate_rev globals.free.items() { i, buf |
                if buf.len >= len {
                    result = u8.raw_from_ptr(buf.ptr);
                    buf[].slice(0, len).set_zeroed();  // this is kinda unfortunate
                    buf[] = buf[].rest(len);
                    check_merges(i);
                    break();
                };
            };
            
            prev := memory_grow(len.udiv(wasm_page_size).intcast()).intcast();
            @assert(prev != -1, "oom");
            result = rawptr_from_int(prev * wasm_page_size);
        };
        @trace("mmap(%) = %", len, result);
        result
    };
    
    munmap :: fn(addr: rawptr, len: i64) i64 = {
        @if(globals.ready) with globals.grow& {
            break :: local_return;
            buf := u8.ptr_from_raw(addr).slice(len.ualign_to(wasm_page_size));
            
            i := 0;  // TODO: binary search
            while => i < globals.free.len && buf.ptr.in_memory_after(globals.free[i].ptr) {
                i += 1;
            };
            globals.free&.insert(i, buf);
            check_merges(i);
        };
        @trace("munmap(%, %)", addr, len);
        0
    };
    
    mprotect :: fn(addr: i64, len: i64, prot: i64) i64 = {
        0
    };
    
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        ms := Host'js_performace_now();
        s := int(ms) / 1000;
        xxx := (ms - float(s*MS_PER_S));
        time_spec[] = (seconds = s, nanoseconds = int(xxx * NS_PER_MS));
        0
    };
    
    abort :: fn() void = exit(1);  // TODO: signal or whatever
    
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        Host'js_worker_stop(status);
    };

    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        ns := duration.seconds * NS_PER_S + duration.nanoseconds;
        zero: u32 = 0;
        _ := import("@/lib/sys/sync/futex.fr")'wasm_atomic_wait(zero&, zero, ns);
        0
    };
    
    #use("@/lib/sys/threads.fr");
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
        attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
        thread := Thread.ptr_from_raw(userdata);
        id: i32 = thread.first_environment.thread_index.intcast();
        @debug_assert_gt(id, 0, "too many threads");
        thread.tid_futex = id.bitcast();
        thread.tid = id;
        Host'js_worker_spawn(userdata, attr.stack.end_pointer(), thread.tid_futex&);
        out.opaque = userdata;
        @trace("pthread_create(%) = %", userdata, id);
        0
    };
};

check_merges :: fn(i: i64) void = {
    free := globals.free&;
    range(i-1, i+1) { i |
        while => i > 0 && i < free.len - 1 && free[i].end_pointer().identical(free[i + 1].ptr) {
            free[i].len += free[i + 1].len;
            free.ordered_remove(i + 1);
        }
    };
};

// returns old size
memory_grow :: AsmFunctionWasmOnly(fn(page_delta: i32) i32 = (), fn(out) = {
    out.push(0x00);  // 0 locals
    out.push(0x20);  // local.get(0)
    out.push(0x00);  // ^
    out.push(0x40);  // memory.grow()
    out.push(0x00);  // ^
    out.push(0x0B);  // end
});
