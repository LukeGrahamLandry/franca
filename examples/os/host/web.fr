#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
#include_std("graphics/lib.fr");
SOKOL_BACKEND :: RenderBackend.WGPU;
GRAPHICS_TARGET_WEB :: true;
::Sapp.Wgpu;

#use("@/examples/os/libkernel.fr");

// this is what the browser calls when compiled with -dynamiclib
// it just sees the ones marked #export
#export
fn main(argc: i64, argv: *CStr, envp: *CStr, sp: i64) void = {
    init_the_memory();
    franca_runtime_init(argc, argv, main2, envp, sp);
}

// this is what you get if you compile without -dynamiclib
// because get_unique_named looks for void->void overload. 
// used for testing as an exe with import_wasm. 
fn main() void = {
    init_the_memory();
    main2();
}

// static data needs to be in a passive segment instead of an active segment 
// so it doesn't get reset when you spawn a new thread. 
// this is called from the main entry point but not wasm_init_thread. 
init_the_memory :: AsmFunctionWasmOnly(fn() void = (), 
    fn(out) = out.push_all(Jit.impl.init_the_memory_code));

// TODO: #use should probably be illegal since it also declares a `main` 
//       which should conflict with ours, but it's very convient that it works (tho order dependent)
#use("@/examples/os/user/init.fr");

main2 :: fn() void = {
    context(DefaultContext)[].thread = Thread.raw_from_ptr(@static(Thread));
    globals.jit_events = list(128, Arena'stack_alloc(2048));
    redo_relocations_wasm();
    globals.jit_events = globals.jit_events.items().clone(general_allocator());
    Vfs'init_vfs();
    xxx := Vfs.fs;  // :compilerbug ?? Type Error: field 'fs' does not exist
    xxx.stdin.poll = fn(a, b) = ();
    
    // the reverse: anything we imported from js and didn't override should still be accessible with dlopen 
    _ := reach_webgpu_imports();
    for_wasm_imports { i, name |
        if libc_exports.get(name).is_none() {
            libc_exports.insert(name, i.rawptr_from_int(), general_allocator());
        };
    };

    shell.strace = cli_args().contains(fn(it) => it[] == "-strace");
    context(DefaultContext)[].prefer_syscalls = false;
    import("@/examples/web/demo.fr")'main();
}

reach_webgpu_imports :: fn() []rawptr #noinline = @run {
    force_reachable := rawptr.list(ast_alloc());
    WGPU :: import("@/target/franca/webgpu.g.fr");
    fr := current_compiler_context();
    fid := get_constant(FuncId, Sapp.Wgpu, @symbol francaRequestState).unwrap();
    addr := fr.get_jitted(fid);
    force_reachable&.push(addr);
    for WGPU.get_constants() { n |
        name := n.str();
        if name.starts_with("wgpu") {
            fid := get_constant(FuncId, WGPU, n).unwrap();
            addr := fr.get_jitted(fid);
            force_reachable&.push(addr);
        };
    };
    fmodf :: fn() void #libc;
    fmod :: fn() void #libc;
    sinf :: fn() void #libc;
    cosf :: fn() void #libc;
    for (@slice(fmodf, fmod, sinf, cosf)) { fid |
        addr := fr.get_jitted(fid);
        force_reachable&.push(addr);
    };
    
    force_reachable.items()
};

redo_relocations_wasm :: fn() void #inline = {
    @run {
        collect_from_scope(libc_exports, Type.scope_of(Overrides), true);
    };

    globals.heap_next = memory_grow(0).intcast().mul(wasm_page_size);
    globals.heap_end = globals.heap_next;
    
    for_wasm_imports { i, name |
        if libc_exports.get(name) { addr |
            Overrides'FR_wasm_jit_event(Assign = (dest = i, src = addr.int_from_rawptr()));
        };
    };
};

for_wasm_imports :: fn($body: @Fn(i: i64, name: Str) void) void = {
    import_names_raw := @import_symbol("__franca_wasm_import_names");
    import_names_raw := u8.ptr_from_raw(import_names_raw).slice(1.shift_left(16));
    i := 0;
    dowhile {
        name := import_names_raw&.pop_cstr();
        @if(name.len > 0) body(i, name);
        i += 1;
        name.len > 0
    };
}

Host :: @struct {
    jit_instantiate_module :: fn(address: *u8, length: i64, table_start: i64, table_index: u32) void #weak #import("libc");
    js_performace_now :: fn() f64 #weak #import("libc");
    js_write :: fn(id: i64, ptr: *u8, len: i64) i64 #weak #import("libc");
    js_worker_spawn :: fn(userdata: rawptr, stack: *u8, exit_futex: *u32) void #weak #import("libc");
    js_worker_stop :: fn(status: i64) void #weak #import("libc");
    
    // TODO: spawn worker
    // TODO: sleep worker
};

#use("@/lib/sys/sync/mutex.fr");
#use("@/lib/sys/threads.fr");
globals :: @static(@struct{
    heap_next: i64;
    heap_end: i64;
    grow: Mutex;
    
    // TODO: make this less chunky. also merge all the Grow
    //       and when you drop the Qbe.Module, drop the corrisponding Event.Module. 
    jit_events: List(Jit.Event);
    jit: Mutex;
});

wasm_page_size :: 65536;

// don't need to preserve callee because it's always franca_runtime_init_thread
fn wasm_init_thread(franca_userdata: rawptr) void #export = {
    thread := Thread.ptr_from_raw(franca_userdata);
    set_dynamic_context(DefaultContext.raw_from_ptr(thread.first_environment&));
    thread.first_environment.panic_hook = fn(msg) = {
        Overrides'FR_debug_write(msg.ptr, msg.len);
        Overrides'exit(123);
        unreachable()
    };
    Overrides'FR_wasm_jit_event(.Sync);
    franca_runtime_init_thread(franca_userdata);
}

Jit :: import("@/backend/wasm/jit.fr");
Overrides :: @struct {
    FR_wasm_jit_event :: fn(event: Jit.Event) i64 = {
        @match(event&) {
            fn Assign(it) => @if(it.src == it.dest) return(0);
            fn Grow(it) => @assert(it.delta != 0, "can't check the size like that because i don't store results");
            fn Module(it) => {
                @trace("jit(size = %)", it.wasm.len);
                it.wasm = it.wasm.shallow_copy(general_allocator());
            }
            fn Sync() => ();
        };
        
        result := 0;
        with globals.jit& {
            // replay all the events done by other threads first. 
            i := get_current_tls()[].known_wasm_jit_event&;
            to_sync := globals.jit_events.items().rest(i[]);
            for to_sync { it |
                Jit'impl'run(it);
            };
            @if(to_sync.len != 0) @trace("jit_sync(%..+%)", i[], to_sync.len);
            
            if !event&.is(.Sync) {
                globals.jit_events&.push(event);
                result = Jit'impl'run(event);
            };

            i[] = globals.jit_events.len;
        };
        result
    }
    
    yield_file :: fn(ptr: *u8, len: i64) void = {
        r := Host'js_write(0xBBBB0001, ptr, len);
        @assert_eq(r, len, "failed yield_file");
    }
    
    FR_debug_write :: fn(ptr: *u8, len: i64) void = {
        Host'js_write(0xBBBB0000, ptr, len);
    };

    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, off: i64) rawptr = {
        len := len.ualign_to(wasm_page_size);
        start := i64.atomic_add(globals.heap_next&, len);
        if start + len > globals.heap_end {
            with globals.grow& {
                len := len * 2;
                prev := memory_grow(len.udiv(wasm_page_size).intcast()).intcast().mul(wasm_page_size);
                @assert(prev != -1, "oom");
                @assert_eq(prev, globals.heap_end, "TODO: someone else is growing the memory");
                old := i64.atomic_add(globals.heap_end&, len);
                @assert_eq(prev, old, "TODO: someone else is growing the memory");
            };
        };
        @trace("mmap(%) = %", len, start);
        start.rawptr_from_int()
    };
    
    munmap :: fn(addr: rawptr, len: i64) i64 = {
        @trace("munmap(%, %)", addr, len);
        0
    };
    
    mprotect :: fn() = 0;
    
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        ms := Host'js_performace_now();
        s := int(ms) / 1000;
        time_spec[] = (seconds = s, nanoseconds = int((ms - float(s*MS_PER_S)) * NS_PER_MS));
        0
    };
    
    abort :: fn() void = exit(1);  // TODO: signal or whatever
    
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        Host'js_worker_stop(status);
    };

    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        eprintln("TODO: nanosleep");
        0
    };
    
    #use("@/lib/sys/threads.fr");
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
        attr := bit_cast_unchecked(*ThreadAttr, *MyAttr, attr);
        thread := Thread.ptr_from_raw(userdata);
        id: i32 = thread.first_environment.thread_index.intcast();
        @debug_assert_gt(id, 0, "too many threads");
        thread.tid_futex = id.bitcast();
        thread.tid = id;
        Host'js_worker_spawn(userdata, attr.stack.end_pointer(), thread.tid_futex&);
        out.opaque = userdata;
        @trace("pthread_create(%) = %", userdata, id);
        0
    };
};

// returns old size
memory_grow :: AsmFunctionWasmOnly(fn(page_delta: i32) i32 = (), fn(out) = {
    out.push(0x00);  // 0 locals
    out.push(0x20);  // local.get(0)
    out.push(0x00);  // ^
    out.push(0x40);  // memory.grow()
    out.push(0x00);  // ^
    out.push(0x0B);  // end
});

// TODO
// record all calls to table_assign and jit_instantiate_module so i can replay them when spawning a thread
// 
