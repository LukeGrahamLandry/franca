#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
#include_std("graphics/lib.fr");
SOKOL_BACKEND :: RenderBackend.WGPU;
GRAPHICS_TARGET_WEB :: true;
::Sapp.Wgpu;

#use("@/examples/os/libkernel.fr");

// this is what the browser calls when compiled with -dynamiclib
// it just sees the ones marked #export
#export
fn main(argc: i64, argv: *CStr, envp: *CStr, sp: i64) void = {
    franca_runtime_init(argc, argv, main2, envp, sp);
}

// this is what you get if you compile without -dynamiclib
// because get_unique_named looks for void->void overload. 
// used for testing as an exe with import_wasm. 
fn main() void = {
    main2();
}

// TODO: #use should probably be illegal since it also declares a `main` 
//       which should conflict with ours, but it's very convient that it works (tho order dependent)
#use("@/examples/os/user/init.fr");

main2 :: fn() void = {
    redo_relocations_wasm();
    Vfs'init_vfs();
    xxx := Vfs.fs;  // :compilerbug ?? Type Error: field 'fs' does not exist
    xxx.stdin.poll = fn(a, b) = ();
    
    // the reverse: anything we imported from js and didn't override should still be accessible with dlopen 
    _ := reach_webgpu_imports();
    for_wasm_imports { i, name |
        if libc_exports.get(name).is_none() {
            libc_exports.insert(name, i.rawptr_from_int(), general_allocator());
        };
    };

    shell.strace = cli_args().contains(fn(it) => it[] == "-strace");
    context(DefaultContext)[].prefer_syscalls = false;
    import("@/examples/web/demo.fr")'main();
}

reach_webgpu_imports :: fn() []rawptr #noinline = @run {
    force_reachable := rawptr.list(ast_alloc());
    WGPU :: import("@/target/franca/webgpu.g.fr");
    fr := current_compiler_context();
    fid := get_constant(FuncId, Sapp.Wgpu, @symbol francaRequestState).unwrap();
    addr := fr.get_jitted(fid);
    force_reachable&.push(addr);
    for WGPU.get_constants() { n |
        name := n.str();
        if name.starts_with("wgpu") {
            fid := get_constant(FuncId, WGPU, n).unwrap();
            addr := fr.get_jitted(fid);
            force_reachable&.push(addr);
        };
    };
    fmodf :: fn() void #libc;
    fmod :: fn() void #libc;
    sinf :: fn() void #libc;
    cosf :: fn() void #libc;
    for (@slice(fmodf, fmod, sinf, cosf)) { fid |
        addr := fr.get_jitted(fid);
        force_reachable&.push(addr);
    };
    
    force_reachable.items()
};

redo_relocations_wasm :: fn() void #inline = {
    @run {
        collect_from_scope(libc_exports, Type.scope_of(Overrides), true);
    };

    globals.heap_next = memory_grow(0).intcast().mul(wasm_page_size).rawptr_from_int();
    globals.heap_end = globals.heap_next;
    
    for_wasm_imports { i, name |
        if libc_exports.get(name) { addr |
            table_assign :: import("@/backend/wasm/emit.fr").table_assign;
            table_assign(i.intcast(), addr.int_from_rawptr().intcast());
        };
    };
};

for_wasm_imports :: fn($body: @Fn(i: i64, name: Str) void) void = {
    import_names_raw := @import_symbol("__franca_wasm_import_names");
    import_names_raw := u8.ptr_from_raw(import_names_raw).slice(1.shift_left(16));
    i := 0;
    dowhile {
        name := import_names_raw&.pop_cstr();
        @if(name.len > 0) body(i, name);
        i += 1;
        name.len > 0
    };
}

Host :: @struct {
    jit_instantiate_module :: fn(address: *u8, length: i64, table_start: i64, table_index: u32) void #weak #import("libc");
    js_performace_now :: fn() f64 #weak #import("libc");
    js_write :: fn(id: i64, ptr: *u8, len: i64) i64 #weak #import("libc");
    js_worker_stop :: fn(status: i64) void #weak #import("libc");
    
    // TODO: spawn worker
    // TODO: sleep worker
};

globals :: @static(@struct{
    heap_next: rawptr;
    heap_end: rawptr;
});

wasm_page_size :: 65536;

Overrides :: @struct {
    yield_file :: fn(ptr: *u8, len: i64) void = {
        r := Host'js_write(0xBBBB0001, ptr, len);
        @assert_eq(r, len, "failed yield_file");
    }
    
    FR_debug_write :: fn(ptr: *u8, len: i64) void = {
        Host'js_write(0xBBBB0000, ptr, len);
    };

    mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, off: i64) rawptr = {
        len := len.ualign_to(wasm_page_size);
        start := globals.heap_next;
        globals.heap_next = globals.heap_next.offset(len);
        if ptr_diff(globals.heap_next, globals.heap_end) < 0 {
            len *= 2;
            prev := memory_grow(len.udiv(wasm_page_size).intcast()).intcast().mul(wasm_page_size);
            @assert(prev != -1, "oom");
            @assert_eq(prev, globals.heap_end.int_from_rawptr(), "TODO: someone else is growing the memory");
            globals.heap_end = globals.heap_end.offset(len);
        };
        start
    };
    
    munmap :: fn(addr: rawptr, len: i64) i64 = {
        0
    };
    
    mprotect :: fn() = 0;
    
    clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) i64 = {
        ms := Host'js_performace_now();
        s := int(ms) / 1000;
        time_spec[] = (seconds = s, nanoseconds = int((ms - float(s*MS_PER_S)) * NS_PER_MS));
        0
    };
    
    abort :: fn() void = exit(1);  // TODO: signal or whatever
    
    exit :: fn(status: i64) void = {
        @trace("exit(%)", status);
        Host'js_worker_stop(status);
    };

    nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: i64) i64 = {
        eprintln("TODO: nanosleep");
        0
    };
    
    #use("@/lib/sys/threads.fr");
    pthread_create :: fn(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) i64 = {
        panic("TODO: pthread_create");
    };
};

// returns old size
memory_grow :: AsmFunctionWasmOnly(fn(page_delta: i32) i32 = (), fn(out) = {
    out.push(0x00);  // 0 locals
    out.push(0x20);  // local.get(0)
    out.push(0x00);  // ^
    out.push(0x40);  // memory.grow()
    out.push(0x00);  // ^
    out.push(0x0B);  // end
});

// TODO
// record all calls to table_assign and jit_instantiate_module so i can replay them when spawning a thread
// 
