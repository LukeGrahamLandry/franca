
Header :: @struct {
    vendor_id: u16;  //  0xffff means non-existant device
    device_id: u16;
    command: u16;
    status: u16;
    revision: u8;
    prog_if: u8;
    subclass: u8;
    class_code: u8;
    _: u16;
    header_type: u8;
    bist: u8;
    // tag is header_type. 0 = end point, 1 = bridge
    body: @union(
        _0: @struct {
            bar: Array(u32, 6);
            _: Array(u32, 3);
            cap: u8;  // same place in both _0 and _1
            __: Array(u8, 3);
            ___: Array(u32, 2);
        },
        _1: @struct {
            _: Array(u32, 12);
        },
    );
}

// TODO: this is just the only one i have for now
CapNode :: import("@/examples/os/drivers/virtio.fr").PciCap;  
fn for_cap(h: *Header, $body: @Fn(it: *CapNode) void) void = {
    base := Header.int_from_ptr(h);
    it := CapNode.ptr_from_int(base + h.body._0.cap&.vol().zext());
    dowhile {
        body(it);
        off := it.cap_next&.vol();
        it = CapNode.ptr_from_int(base + off.zext());
        off != 0
    };
}

// 
// Base Address Registers:
// low 4 bits are flags. high bits will read zero at the beginning. 
// the driver chooses where in the valid pci range that bar should be allocated 
// (and writes that address to the bar). its always aligned to the size and
// low bits that make it unaligned are masked out (so writing all ones 
// lets you check the size by seeing which bits stick)
// 64 bit addresses just used two consecutive slots. 
// 
BarResult :: @struct {
    old_address: i64;
    size: i64;
    flags: u8;
    mem: []u8;
};
// TODO: is this different for body._1?
// TODO: error if address not in size_mask so caller can try again with something aligned?
// address must be a valid mmio address from the pci.reg node of the device tree
set_bar64 :: fn(h: *Header, bar: u8, address: i64, stomp: bool) BarResult = {
    bar := h.body._0.bar&[bar.zext()]&;
    initial := vol_2x32(bar);
    old_address := initial.bit_and(bit_not(0xF));
    vol_2x32(bar, -1);
    size_mask := vol_2x32(bar).bit_and(bit_not(0xF));
    size := size_mask.bit_not().add(1);
    if old_address != 0 && !stomp {
        address = old_address;
    };
    vol_2x32(bar, address);
    flags: u8 = initial.bit_and(0xF).trunc();
    (old_address = old_address, size = size, flags = flags, mem = u8.ptr_from_int(address).slice(size))
}

// TODO: nicer api for device tree
read_device_tree :: fn(self: DT.Iter) ?MemoryRegion = {
    self&.consume_root();
    self&.find_node(.BEGIN_NODE, fn(it) => it.name.starts_with("pci")) 
        || return(.None);
    depth := self.depth;
    
    // read its childen
    // annoying: vol_2x32 is just for avoiding unaligned read so it works without mmu, not because its actually volatile.
    config: []u8 = empty();
    bar: []u8 = empty();
    dowhile {
        it := self&.next();
        // device tree pci.reg replaces ACPI 'MCFG' table and lets you find the config space. 
        // "The PCI Express bus extends the Configuration Space from 256 bytes to 4096 bytes."
        //    so maybe i need prev.starts_with("pcie") or else step by 256?
        if it.name == "reg" {
            addr := it.read_2x32(0);
            size := it.read_2x32(2);
            config = (ptr = u8.ptr_from_int(addr), len = size);
            @if(bar.len != 0) return(Some = (config = config, bar = bar));
        };
        
        // TODO: use #address-cells, #size-cells, #interrupt-cells
        if it.name == "ranges" {
            while => it.data.len >= 7 * size_of(u32) {
                flags: i64 = it.read_32(0).zext();
                pci_addr := it.read_2x32(1);
                cpu_addr := it.read_2x32(3);
                pci_size := it.read_2x32(5);
                it.data = it.data.rest(7 * size_of(u32));
                if pci_addr == cpu_addr {
                    bar = (ptr = u8.ptr_from_int(pci_addr), len = pci_size);
                    @if(config.len != 0) return(Some = (config = config, bar = bar));
                }
            };
        };
        
        if it.name == "interrupt-map-mask" {
            // TODO
        }
        if it.name == "interrupt-map" {
            // TODO
        };
        
        self.depth >= depth
    };
    .None
}

MemoryRegion :: @struct {
    config: []u8;  // array of Headers (but spaced out by 4096 bytes)
    bar: []u8;     // memory that can be allocated to the bars for specific devices
};
