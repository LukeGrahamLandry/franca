
Self :: @struct {
    device: Virt.Device #use;
    dropped_write: i64 = 0;
};

RECEIVE :: 0;
TRANSMIT :: 1;

// TODO: seperate find and init
// TODO: use VIRTIO_F_EVENT_IDX to not get an interrupt until a whole chunk of work is done
// this working with mmu relies on it being before ram start and setup_virtual_memory mapping all that as device
find :: fn(pci: *Pci.MemoryRegion) ?Self = {
    it := Virt'find(pci, 3) 
        || return(.None);
    feat := 1.shift_left(32);  // VIRTIO_F_VERSION_1
    agree := it.cfg.init_features(feat);
    @if(agree != feat) kpanic("didn't agree on device features");
    
    buf := kernel.physical&.map_contiguous(1.shift_left(16), 1);
    each buf { it |
        it[] = 0;
    };
    
    qs := buf&.pop_slice(Virt.Queue, 2);
    self: Self = (device = (queues = qs, interrupt_status = it.status, intid = it.intid));
    init_queue(it.cfg, qs.index(TRANSMIT), TRANSMIT, buf&, 128, it.note);
    init_queue(it.cfg, qs.index(RECEIVE), RECEIVE, buf&, 128, it.note);
    it.cfg.publish_queues();
    (Some = self)
}

// note: this is only used for kernel logging (before setting up the UQueue)
fn write(self: *Self, virtual: []u8) void = {
    @if(virtual.len == 0) return();
    q := self.queues.index(TRANSMIT);
    if q.device_idx != q.driver_idx {
        // TODO: its kinda fucked to drop writes. 
        //       but without this, if you try to log while its being used by UQueue.poll,
        //       you hang everything. 
        self.dropped_write += 1;
        return();
    };
    q.push_virt(virtual, 0);
    
    // TODO: this needs to be nonblocking eventually but then the lifetime of the message gets complicated
    q.publish_chain();
    i := q.driver_idx;
    while => q.device.head.idx&.vol() != i {
        barrier();  // spin
    };
    q.device_idx = i;
    
    // TODO: sketchy
    if q.user { user |
        user.pipe.work&.set_all(q.device_idx.zext());
        user.pipe.done&.set_all(q.driver_idx.zext());
    };
    
    if self.dropped_write > 0 {
        self.dropped_write = MIN_i64;
        write(self, "\nWARNING: DROPPED A LOG MESSAGE\n");
        self.dropped_write = 0;
    }
}

