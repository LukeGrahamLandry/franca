
Self :: @struct {
    device: Virt.Device #use;
};

RECEIVE :: 0;
TRANSMIT :: 1;

// TODO: seperate find and init
// TODO: use VIRTIO_F_EVENT_IDX to not get an interrupt until a whole chunk of work is done
// this working with mmu relies on it being before ram start and setup_virtual_memory mapping all that as device
find :: fn(pci: *Pci.MemoryRegion) ?Self = {
    it := Virt'find(pci, 3) 
        || return(.None);
    feat := 1.shift_left(32);  // VIRTIO_F_VERSION_1
    agree := it.cfg.init_features(feat);
    @if(agree != feat) kpanic("didn't agree on device features");
    
    buf := kernel.physical&.map_contiguous(1.shift_left(16), 1);
    each buf { it |
        it[] = 0;
    };
    
    qs := buf&.pop_slice(Virt.Queue, 2);
    self: Self = (device = (queues = qs, interrupt_status = it.status, intid = it.intid));
    init_queue(it.cfg, qs.index(TRANSMIT), TRANSMIT, buf&, 128, it.note);
    init_queue(it.cfg, qs.index(RECEIVE), RECEIVE, buf&, 128, it.note);
    it.cfg.publish_queues();
    (Some = self)
}

fn check_interrupt(self: *Self, intid: i64) void = {
    @if(intid != self.device.intid) return();
    @if(self.device.interrupt_status.is_null()) return();
    @if(self.device.interrupt_status.vol().bit_and(1) == 0) return();
    
        each self.queues { q |
            i := q.device.head.idx&.vol();  // this read resets it to zero
            if q.this_queue_index == RECEIVE {
                if i != q.device_idx {
                    // TODO: do the right thing when it gives me more than one (which is what happens when you paste)
                    byte: u8 = 0;
                    
                    while => q.device_idx != i {
                        i := q.device_idx.zext().mod(q.device.ring.len);
                        q.device_idx += 1;
                        used := q.device.ring[i];
                        desc := q.desc[used.id.zext()];
                        @if(desc.flags.bit_and(Virt.DESC_F_NEXT) != 0) kpanic("TODO: restore multiple descriptors");
                        capacity := desc.addr.slice(desc.len.zext());
                        bytes := capacity.slice(0, used.len.zext());
                        byte = bytes[0];
                        // TODO: just reuse the one desc
                        // TODO: don't chain them
                        q.push_phys(capacity, Virt.DESC_F_WRITE);
                    };

                    q.publish_chain();
                    
                    // HACK?
                    init := kernel.tasks&[0]&;
                    @if(init.signal_handler == 0) kpanic("got input before init signal handler");
                    push_signal_context(init);
                    init.mcontext.gpr&[1] = intid;
                    init.mcontext.gpr&[2] = byte.zext();  // HACK
                    return_to_user(init);
                };
            };
        };
}

fn write(self: *Self, virtual: []u8) void = {
    @if(virtual.len == 0) return();
    q := self.queues.index(TRANSMIT);
    q.push_virt(virtual, 0);
    
    // TODO: this needs to be nonblocking eventually but then the lifetime of the message gets complicated
    q.publish_chain();
    i := q.driver_idx;
    while => q.device.head.idx&.vol() != i {
        barrier();  // spin
    };
}
