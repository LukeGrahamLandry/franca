
Self :: @struct {
    device: Virt.Device #use;
};

RECEIVE :: 0;
TRANSMIT :: 1;

// TODO: seperate find and init
// TODO: use VIRTIO_F_EVENT_IDX to not get an interrupt until a whole chunk of work is done
// this working with mmu relies on it being before ram start and setup_virtual_memory mapping all that as device
find :: fn(pci: *Pci.MemoryRegion) ?Self = {
    it := Virt'find(pci, 3) 
        || return(.None);
    feat := 1.shift_left(32);  // VIRTIO_F_VERSION_1
    agree := it.cfg.init_features(feat);
    @if(agree != feat) kpanic("didn't agree on device features");
    
    buf := kernel.physical&.map_contiguous(1.shift_left(16), 1);
    each buf { it |
        it[] = 0;
    };
    
    qs := buf&.pop_slice(Virt.Queue, 2);
    self: Self = (device = (queues = qs, interrupt_status = it.status, intid = it.intid));
    init_queue(it.cfg, qs.index(TRANSMIT), TRANSMIT, buf&, 128, it.note);
    init_queue(it.cfg, qs.index(RECEIVE), RECEIVE, buf&, 128, it.note);
    it.cfg.publish_queues();
    (Some = self)
}

fn check_interrupt(self: *Virt.Device, intid: i64) void = {
    @if(intid != self.intid) return();
    @if(self.interrupt_status.is_null()) return();
    @if(self.interrupt_status.vol().bit_and(1) == 0) return();
    // interrupt_status is reset to zero by reading it
    
    each self.queues { q |
        if q.user { user |
            if q.device.head.idx&.vol() != q.device_idx {
                #use("@/examples/os/kernel/syscalls.fr");
                virtq_poll(UQueue.int_from_ptr(user));
            };
        };
    };
}

fn write(self: *Self, virtual: []u8) void = {
    @if(virtual.len == 0) return();
    q := self.queues.index(TRANSMIT);
    q.push_virt(virtual, 0);
    
    // TODO: this needs to be nonblocking eventually but then the lifetime of the message gets complicated
    q.publish_chain();
    i := q.driver_idx;
    while => q.device.head.idx&.vol() != i {
        barrier();  // spin
    };
}
