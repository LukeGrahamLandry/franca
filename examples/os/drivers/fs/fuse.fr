// virtio-fs uses the same abi as linux's FUSE. 
// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/include/uapi/linux/fuse.h?id=3f29d59e92a96d843c2ff10ebfed92ac26878658
// > ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)
// > Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>

MAJOR :: 7;
MINOR :: 45;
Attr :: @struct(
    ino: u64,
    size: u64,
    blocks: u64,
    atime: u64,
    mtime: u64,
    ctime: u64,
    atimensec: u32,
    mtimensec: u32,
    ctimensec: u32,
    mode: u32,
    nlink: u32,
    uid: u32,
    gid: u32,
    rdev: u32,
    blksize: u32,
    flags: u32,
);
SxTime :: @struct(
    tv_sec: i64,
    tv_nsec: u32,
    __reserved: i32,
);
Statx :: @struct(
    mask: u32,
    blksize: u32,
    attributes: u64,
    nlink: u32,
    uid: u32,
    gid: u32,
    mode: u16,
    __spare0: Array(u16, 1),
    ino: u64,
    size: u64,
    blocks: u64,
    attributes_mask: u64,
    atime: SxTime,
    btime: SxTime,
    ctime: SxTime,
    mtime: SxTime,
    rdev_major: u32,
    rdev_minor: u32,
    dev_major: u32,
    dev_minor: u32,
    __spare2: Array(u64, 14),
);
Kstatfs :: @struct(
    blocks: u64,
    bfree: u64,
    bavail: u64,
    files: u64,
    ffree: u64,
    bsize: u32,
    namelen: u32,
    frsize: u32,
    padding: u32,
    spare: Array(u32, 6),
);
Opcode :: @enum(i32) (
    LOOKUP = 1,
    FORGET = 2,
    GETATTR = 3,
    SETATTR = 4,
    READLINK = 5,
    SYMLINK = 6,
    MKDIR = 9,
    UNLINK = 10,
    RMDIR = 11,
    RENAME = 12,
    LINK = 13,
    OPEN = 14,
    READ = 15,
    WRITE = 16,
    STATFS = 17,
    RELEASE = 18,
    FSYNC = 20,
    FLUSH = 25,
    INIT = 26,
    OPENDIR = 27,
    READDIR = 28,
    RELEASEDIR = 29,
    FSYNCDIR = 30,
    ACCESS = 34,
    CREATE = 35,
    INTERRUPT = 36,
    DESTROY = 38,
    POLL = 40,
    BATCH_FORGET = 42,
    FALLOCATE = 43,
    READDIRPLUS = 44,
    LSEEK = 46,
    SYNCFS = 50,
    TMPFILE = 51,
    STATX = 52,
    INIT_BSWAP_RESERVED = 436207616,
);
EntryOut :: @struct(
    nodeid: u64,
    generation: u64,
    entry_valid: u64,
    attr_valid: u64,
    entry_valid_nsec: u32,
    attr_valid_nsec: u32,
    attr: Attr,
);
ForgetIn :: @struct(
    nlookup: u64,
);
ForgetOne :: @struct(
    nodeid: u64,
    nlookup: u64,
);
BatchForgetIn :: @struct(
    count: u32,
    dummy: u32,
);
StatxIn :: @struct(
    getattr_flags: u32,
    reserved: u32,
    fh: u64,
    sx_flags: u32,
    sx_mask: u32,
);
StatxOut :: @struct(
    attr_valid: u64,
    attr_valid_nsec: u32,
    flags: u32,
    spare: Array(u64, 2),
    stat: Statx,
);
MkdirIn :: @struct(
    mode: u32,
    umask: u32,
    name: []u8 #inline,  // null terminated
);
MkdirOut :: @struct();
RenameIn :: @struct(
    newdir: u64,
    name: []u8 #inline,  // null terminated
    newname: []u8 #inline,  // null terminated
);
RenameOut :: @struct();
LinkIn :: @struct(
    oldnodeid: u64,
);
SetattrIn :: @struct(
    valid: u32,
    padding: u32,
    fh: u64,
    size: u64,
    lock_owner: u64,
    atime: u64,
    mtime: u64,
    ctime: u64,
    atimensec: u32,
    mtimensec: u32,
    ctimensec: u32,
    mode: u32,
    unused4: u32,
    uid: u32,
    gid: u32,
    unused5: u32,
);
OpenIn :: @struct(
    flags: u32,
    open_flags: u32,
);
CreateIn :: @struct(
    flags: u32,
    mode: u32,
    umask: u32,
    open_flags: u32,
    name: []u8 #inline,  // null terminated
);
CreateOut :: @struct {
    lookup: LookupOut;
    open: OpenOut;
};
OpenOut :: @struct(
    fh: u64,
    open_flags: u32,
    backing_id: i32,
);
ReleaseIn :: @struct(
    fh: u64,
    flags: u32,
    release_flags: u32,
    lock_owner: u64,
);
FlushIn :: @struct(
    fh: u64,
    unused: u32,
    padding: u32,
    lock_owner: u64,
);
ReadIn :: @struct(
    fh: u64,
    offset: u64,
    size: u32,
    read_flags: u32,
    lock_owner: u64,
    flags: u32,
    padding: u32,
);
WriteIn :: @struct(
    fh: u64,
    offset: u64,
    size: u32,
    write_flags: u32,
    lock_owner: u64,
    flags: u32,
    padding: u32,
    data: []u8 #inline,
);
WriteOut :: @struct(
    size: u32,
    padding: u32,
);
StatfsOut :: @struct(
    st: Kstatfs,
);
FsyncIn :: @struct(
    fh: u64,
    fsync_flags: u32,
    padding: u32,
);
AccessIn :: @struct(
    mask: u32,
    padding: u32,
);
InitIn :: @struct(
    major: u32,
    minor: u32,
    max_readahead: u32,
    flags: u32,
    flags2: u32,
    unused: Array(u32, 11),
);
InitOut :: @struct(
    major: u32,
    minor: u32,
    max_readahead: u32,
    flags: u32,
    max_background: u16,
    congestion_threshold: u16,
    max_write: u32,
    time_gran: u32,
    max_pages: u16,
    map_alignment: u16,
    flags2: u32,
    max_stack_depth: u32,
    request_timeout: u16,
    unused: Array(u16, 11),
);
InterruptIn :: @struct(
    unique: u64,
);
PollIn :: @struct(
    fh: u64,
    kh: u64,
    flags: u32,
    events: u32,
);
PollOut :: @struct(
    revents: u32,
    padding: u32,
);
FallocateIn :: @struct(
    fh: u64,
    offset: u64,
    length: u64,
    mode: u32,
    padding: u32,
);
InHeader :: @struct(
    len: u32,
    opcode: Opcode,
    unique: u64,
    nodeid: u64,
    uid: u32,
    gid: u32,
    pid: u32,
    total_extlen: u16,
    padding: u16,
);
OutHeader :: @struct(
    len: u32,
    error: i32,
    unique: u64,
);
Dirent :: @struct(
    ino: u64,
    off: u64,
    namelen: u32,
    type: u32,
    // name: Array(i8, ),
);
Direntplus :: @struct(
    entry_out: EntryOut,
    dirent: Dirent,
);
LseekIn :: @struct(
    fh: u64,
    offset: u64,
    whence: u32,
    padding: u32 = 0,
);
LseekOut :: @struct(
    offset: u64,
);
SyncfsIn :: @struct(
    padding: u64,
);

// The bytes for `[]u8 #inline` fields are passed directly after the struct (not as pointers to other memory). 

LookupIn :: @struct {
    name: []u8 #inline;  // null terminated
};
LookupOut :: EntryOut;
ReadOut :: @struct {
    data: []u8 #inline;
};
ReleaseOut :: @struct();
ForgetOut :: @struct();
FlushOut :: @struct();
FsyncOut :: @struct();
