// lists the contents of various archive formats (but does not unpack them). 
// supports: .tar, .tar.gz

main :: fn() void = {
    in := read_file_from_last_arg();
    out := u8.list(temp());
    dump(in, out&);
    print(out.items());
}

dump :: fn(in: []u8, out: *List(u8)) void = {
    ::if_opt(i64, []u8);
    decompressed := if GZip'header_size(in) { (skip: i64) |
        compressed := in.rest(skip);
        decompressed := u8.list(temp());
        consumed, error := Deflate'decompress(compressed, decompressed&);
        ::enum(Deflate.Error);
        @fmt(out, " gzip header size = %\n", skip);
        @fmt(out, "  compressed size = %\n", compressed.len);
        if error != .Ok {
            @fmt(out, "error: % after % input bytes and % output bytes\n", error, consumed, decompressed.len);
            return();
        };
        @fmt(out, "decompressed size = %\n", decompressed.len);
        // if FHCRC is set, should be 8, (4 byte checksum and 4 byte size)
        @fmt(out, "remaining bytes after compressed blob: %\n", compressed.len - consumed);
        decompressed.items()
    } else {
        @fmt(out, "not gzipped\n");
        in
    };
    
    result := Tar'iter(decompressed) { h, contents |
        @fmt(out, "%|%|%| size=% type=% magic=%\n", 
            h.size&.items(), h.prefix&.items(), h.name&.items(), contents.len, h.typeflag - "0".ascii(), h.magic&.items());
    };
    i := result.or(fn(e) => {
        ::enum(@type e);
        @fmt(out, "error! invalid tar file. %", e);
        return()
    });
    @fmt(out, "that's all folks!\nremaining bytes: %\n", decompressed.len - i);
}

GZip :: import("@/lib/encoding/gzip.fr");
Tar :: import("@/lib/encoding/tar.fr");
Deflate :: import("@/lib/encoding/deflate.fr");
#use("@/lib/sys/fs.fr");
