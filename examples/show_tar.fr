// lists the contents of various archive formats (but does not unpack them). 
// supports: .tar, .tar.gz, .zip

main :: fn() void = {
    in := read_file_from_last_arg();
    out := u8.list(temp());
    dump(in, out&);
    print(out.items());
}

dump :: fn(in: []u8, out: *List(u8)) void = {
    ::if_opt(i64, []u8);
    
    if Pkzip'find(in) { ecd |
        @fmt(out, "looks like a pkzip file!\n");
        Pkzip'iter(in, ecd) { it |
            @fmt(out, "% ", it.name);
            if it.h.compressed_size == it.h.uncompressed_size {
                @fmt(out, "(size: %)\n", it.h.uncompressed_size);
            } else {
                @fmt(out, "(size: % -> %)\n", it.h.compressed_size, it.h.uncompressed_size);
            };
        };
        return();
    };
    
    decompressed := if GZip'header_size(in) { (skip: i64) |
        compressed := in.rest(skip);
        decompressed := u8.list(temp());
        consumed, error := Deflate'decompress(compressed, decompressed&);
        @fmt(out, " gzip header size = %\n", skip);
        @fmt(out, "  compressed size = %\n", compressed.len);
        if error != .Ok {
            @fmt(out, "error: % after % input bytes and % output bytes\n", error, consumed, decompressed.len);
            return();
        };
        @fmt(out, "decompressed size = %\n", decompressed.len);
        // if FHCRC is set, should be 8, (4 byte checksum and 4 byte size)
        @fmt(out, "remaining bytes after compressed blob: %\n", compressed.len - consumed);
        decompressed.items()
    } else {
        @fmt(out, "not gzipped\n");
        in
    };
    
    result := Tar'iter(decompressed) { h, contents |
        prefix := h.prefix&.items().peek_cstr();
        name := h.name&.items().peek_cstr();
        size := h.size&.items().peek_cstr();
        @fmt(out, "%|%|%| size=% type=% magic=%\n", 
            size, prefix, name, contents.len, h.typeflag - "0".ascii(), h.magic&.items());
    };
    i := result.or(fn(e) => {
        @fmt(out, "error! invalid tar file. %", e);
        return()
    });
    @fmt(out, "that's all folks!\nremaining bytes: %\n", decompressed.len - i);
}

GZip :: import("@/lib/encoding/gzip.fr");
Tar :: import("@/lib/encoding/tar.fr");
Deflate :: import("@/lib/encoding/deflate.fr");
Pkzip :: import("@/lib/encoding/pkzip.fr");
#use("@/lib/sys/fs.fr");
