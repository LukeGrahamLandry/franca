
// These are shorthand for being generic over common types of indirection. 
// It's nice to be able to write types that don't care if they own or borrow data. 
// It still ends up inferring some statically known type. There's no runtime type checking. 
// I just don't like being forced to write the generic all the time. 
// Makes it easy to write libraries that support many memory management models. 

// - ?T: Option(T)
// - &T: Ptr(T)
// - []T: Slice(T)
// - {}(K, V): Map(K, V)
// - !(R, E): Result(R, E)
// - ^T: Future(T)
// - *T

// You might think trying all the combinations of pointer types would be slow but,
// - it remembers what worked for a module last time. 
// - you can always give it a hint. 
// - there's generally a clear flow of restrictions on the type. 
//   it doesn't just guess a combination and check, it's like
//   "hey you mutated that pointer I guess it must not be const, lets see if that works" or whatever. 
// - its done lazily. it doesnt bother determining all possible types in a child modules, 
//   it just checks if the ones you pass in work and then remembers. 
