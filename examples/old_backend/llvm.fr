//! https://llvm.org/docs/LangRef.html
//! This converts the legacy bytecode into llvm ir text.
//
// TODO: have a way of marking ones that should be imported instead of emitted so the driver program could do incremental compilation stuff. 
// TODO: move the top level loop to walk_bc because its probably the same on all backends. 
// TODO: not reserving enough
// TODO: only specfiy ccc if you take a pointer to the function? you want to use one that allows tail calls otherwise. 
// TODO: use the arch passed in instead of buildoptions.wasm32

// https://llvm.org/docs/SourceLevelDebugging.html#dbg-declare
// they say the debug info intrinsics are deprecated and you should use records now... 
// but records don't seem to work, "expecte instruction opcode", and clang generates the intrinsics, and rustc generates the intrinsics...
// so i guess they're just lying out of spite???? 
// oh maybe its just super recent and doesn't exist yet and they don't bother to put dates on the docs? 
// this are like ~a month ago
// https://github.com/llvm/llvm-project/pulls?q=is%3Apr+RemoveDIs 
// yeah it looks like 18 exists now and they want to slowly make it possible to do the new thing during 19
// https://discourse.llvm.org/t/rfc-instruction-api-changes-needed-to-eliminate-debug-intrinsics-from-ir/68939/11
// tho this implies they should be able to parse it
// https://github.com/llvm/llvm-project/pull/79818

// TODO: better error mwssage if you use @enum instead of @tagged. -- Jun 14
LlvmVal :: @struct(
    ty: Prim,
    id: i64
);

EmitLlvm :: @struct(
    comp: CompCtx,
    out: BucketArray(u8),
    current: BbId,
    next_var: i64 = 0,
    next_debug_info: i64 = 0,
    current_debug_info := 0,
    debug_info: List(u8),
    debug_unit: i64 = 0,
    debug_file: i64 = 0,
    debug_func_type: i64 = 0,
    debug_addr_type: i64 = 0,
    arch: Arch,
    os: Os,
    debug_file_scopes: HashMap(Str, i64),
    context_slot: ?LlvmVal = .None,
    $Val := LlvmVal, // TODO: const can't be first (doesn't parse).  -- Jun 14
);

emit_llvm_impl :: { T :: CodeGen(EmitLlvm); T.emit };

// :TooManyArgsX64
// TODO: hah, since then ive fixed 8 arg functions on x64 but this has grown and my arm can't do >8 args. 
fn emit_llvm(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry, arch: Arch, os: Os) BucketArray(u8) #inline = {
    _ := alloc;  // TODO
    target: TargetEnv = (arch = arch, os = os);
    emit_llvm_impl(comp, fns, entry, target&, rawptr.zeroed()) // you can use this to not use the precompiled verison but then its really slow.
}

// TODO: dependency problem so can't call this `init`
fn new(comp: CompCtx, alloc: Alloc, arch: Arch, os: Os, _: rawptr) EmitLlvm #inline = {
    s: EmitLlvm = (
        comp = comp,
        out = init(12, alloc), 
        current = BbId.zeroed(), 
        debug_info = list(alloc), 
        arch = arch, 
        os = os,
        debug_file_scopes = init(alloc),
    );
    
    // TODO: how the hell am i supposed to know these numbers without just compiling a c program with clang. 
    //       its not a big deal tho cause passing -target to clang overrides this. 
    s.out&.push_all("""
    target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
    target triple = "arm64-apple-macosx13.0.0"
    """);
    if arch == .x86_64 {
        s.out&.push_all("module asm \".intel_syntax noprefix\"\n");
    };
    
    if s.comp.get_build_options()[].debug_info {
        s.debug_unit = s&.next_debug();
        s.debug_file = s&.next_debug();
        s.debug_func_type = s&.next_debug();
        s.debug_addr_type = s&.next_debug();
        debug_ident := s&.next_debug();
        // you can say language: 0, but then opt removes it and if you try to run it through again it complains theres no language
        template :: "!% = distinct !DICompileUnit(language: 0, producer: \"Franca\", emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None, file: !%, isOptimized: false, runtimeVersion: 0)\n";
        @fmt(s.debug_info&, template, s.debug_unit, s.debug_file);
        @fmt(s.debug_info&, "!% = !DIFile(filename: \"mandelbrot.fr\", directory: \"examples\")\n", s.debug_file);
        @fmt(s.debug_info&, "!llvm.dbg.cu = !{!%}\n", s.debug_unit);        
        @fmt(s.debug_info&, "!llvm.ident = !{!%}\n", debug_ident);        
        @fmt(s.debug_info&, "!% = !DISubroutineType(types: !{null})\n", s.debug_func_type);
        @fmt(s.debug_info&, "!% = !DIBasicType(name: \"ptr\", size: 64, align: 64, encoding: DW_ATE_address)\n", s.debug_addr_type);
        @fmt(s.debug_info&, "!% = !{!\"franca\"}\n", debug_ident);
    };
    s
}

fn next_debug(self: *EmitLlvm) i64 = {
    self.next_debug_info += 1;
    self.next_debug_info - 1
}

fn debug_scope_for_file(self: *EmitLlvm, filename: Str) i64 = {
    if self.debug_file_scopes&.get(filename) { id | 
        return(id);
    };
    id := self.next_debug();
    self.debug_file_scopes&.insert(filename, id);
    // TODO: check no \n or " in filenames? its just whatever shit you passed to codemap for now. 
    directory := filename.pop_path_segment();
    file := filename.slice(directory.len, filename.len);
    if directory.len > 0 {
        // TODO: do i need to do this? 
        directory.len -= 1; // trailing /
    };
    @fmt(self.debug_info&, "!% = !DIFile(filename: \"%\", directory: \"%\")\n", id, file, directory);
    id
}

// TODO: my impression is unnamed_addr doesn't help size (even with -no-deduplication) so maybe take it out -- Aug 13
fn emit_function_husk(self: *EmitLlvm, fid: FuncId, signeture: PrimSig, $emit_body: @Fn() void) void = {
    start_bucket_index := self.out.i;
    start_index := self.out&.current().len();
    func := self.comp.get_function(fid);
    name: List(u8) = list(temp());
    self.fmt_fn_name(fid, name&);
    
    // this has to happen before emit_body because that calls setup which wants to emit debug info for variables. 
    if self.comp.get_build_options()[].debug_info {
        self.current_debug_info = self.next_debug();
        place := self.comp.get_whole_line(func.loc);
        file_scope := self.debug_scope_for_file(place.filename);
        source_name := self.comp.get_string(func.name); 
        // lldb says <stdin> instead of the filename if you don't have the `file` field. so whats the scope field for then???
        template :: "!% = distinct !DISubprogram(name: \"%\", linkageName: \"%\", unit: !%, scope: !%, file: !%, type: !%, spFlags: DISPFlagDefinition)\n";
        @fmt(self.out&.current(), template, self.current_debug_info, source_name, name.items(), self.debug_unit, file_scope, file_scope, self.debug_func_type);
    };
    
    if self.comp.get_build_options()[].retain_function_names {
        self.out&.push_all("define ccc ");
    } else {
        self.out&.push_all("define private ccc ");
    };
    self.write_header(signeture, name.items()) {arg_index|
        @tfmt("%arg%", "%", arg_index)
    };
    self.out&.current().push_all(" unnamed_addr ");
    if func.get_flag(.Cold) {
        // Note: this doesn't do anything on -Os unless you also pass `-mllvm -hot-cold-split=true`
        self.out&.current().push_all(" cold optsize noinline ");
    } else {
        if func.get_flag(.NoInline) {
            self.out&.current().push_all(" noinline ");
        };
    };
    // sanitize_address only does anything if you also pass -fsanitize=address to clang. 
    self.out&.current().push_all(" \"frame-pointer\"=\"all\" sanitize_address "); // must be before debug info!
    if self.comp.get_build_options()[].debug_info {
        @fmt(self.out&.current(), "!dbg !%", self.current_debug_info);
    };
   
    self.out&.current().push_all("{\n");
    emit_body();
    self.out&.current().push_all("}\n");
    
    if func.get_flag(.LogIr) {
        @println("[#log_ir % %]", fid, self.comp.get_string(func.name));
        end_bucket_index := self.out.i;
        end_index := self.out&.current().len();
        
        if start_bucket_index == end_bucket_index {
            print(self.out&.current().items().slice(start_index, end_index));
        } else {
            println("TODO: log_ir llvm split bucket");
        };
    };
};

fn emit_entry_points_and_debug_info(gen: *CodeGen(EmitLlvm), comp: CompCtx, fns: []FuncId, entry: ProgramEntry) void = {
    gen.loop_emit_constants();
    @match(entry) {
        fn TestRunnerMain() => {
            gen.backend.out&.push_all("define ccc i64 @test_runner_main(){\n");
            
            i := 1;
            // TODO: warn if fns has duplicates
            for fns { f |
                gen.backend.out&.reserve(100);
                f = comp.follow_redirects(f);
                func := comp.get_function(f);
                // note: this only works because void has a fixed typeid value
                if func.finished_arg.unwrap() == void {
                    @fmt(gen.backend.out&.current(), "   call void @\"%\"()\n", (gen.backend&, f));
                } else {
                    @fmt(gen.backend.out&.current(), "   %% = call i64 @\"%\"(i64 0)\n", "%", i, (gen.backend&, f));
                    i += 1;
                };
            };
            gen.backend.out&.push_all("ret i64 0\n}\n");
            
            env := comp.get_comptime_env();
            runtime_init := env.runtime_init.expect("declaration of franca_runtime_init (forgot to include lib/core.fr?)");
            
            gen.backend.out&.push_all("define ccc i64 @main(i64 %argc, i64 %argv) {\n");
            @fmt(gen.backend.out&.current(), "call void @\"%\"(i64 %argc, i64 %argv, ptr @test_runner_main)\n", (gen.backend&, runtime_init), "%", "%");
            gen.backend.out&.push_all("ret i64 0\n}\n");
        };
        fn GiveMeTheCodeAndGiveItToMeRaw() => ();
        fn ExportWithNames() => {
            // TODO: warn if fns has duplicates
            for fns { fid |
                gen.backend&.write_export_bounce(fid);
            };
        };
        fn WrapMain() => {
            @assert(fns.len == 1, ".WrapMain expected a single entry point");
            env := comp.get_comptime_env();
            runtime_init := env.runtime_init.expect("declaration of franca_runtime_init (forgot to include lib/core.fr?)");
            
            gen.backend.out&.push_all("define ccc i64 @main(i64 %argc, i64 %argv) {\n");
            @fmt(gen.backend.out&.current(), "call void @\"%\"(i64 %argc, i64 %argv, ptr @\"%\")\n", (gen.backend&, runtime_init), "%", "%", (gen.backend&, fns[0]));
            gen.backend.out&.push_all("ret i64 0\n}\n");
        };
    };

    self := gen.backend&;
    if self.comp.get_build_options()[].debug_info {
        version := self.next_debug();
        d_version := self.next_debug();
        level := self.next_debug();
        
        @fmt(self.out&.current(), "!% = !{i32 8, !\"PIC Level\", i32 2}\n", level); // no idea what that means, its what rustc does
        @fmt(self.out&.current(), "!% = !{i32 2, !\"Debug Info Version\", i32 3}\n", version);
        @fmt(self.out&.current(), "!% = !{i32 2, !\"Dwarf Version\", i32 4}\n", d_version);
        self.out&.push_bucket(self.debug_info);
        self.debug_info = List(u8).zeroed();
        @fmt(self.out&.current(), "!llvm.module.flags = !{!%, !%, !%}", version, d_version, level);
    };
}

fn finished(self: *EmitLlvm, fid: FuncId) void = ();

fn emit_bounce_fn(self: *EmitLlvm, impl_name_callee: Str, fake_decl_name: Str, signeture: PrimSig, private: bool) void = {
    self.current_debug_info = 0;
    spec := if(private, => "define private ccc ", => "define ccc ");
    self.out&.push_all(spec);
    values: List(LlvmVal) = list(temp());
    self.next_var = 0;
    self.write_header(signeture, fake_decl_name) {arg_index|
        ::if(Prim);
        // TODO: format this better. 
        ty: Prim = if(signeture.first_arg_is_indirect_return){
            // TODO: only sokol tests this 
            if arg_index.eq(0) {
                Prim.P64
            }{
                signeture.args[arg_index.sub(1)]
            }
        }{
            signeture.args[arg_index]
        };
        values&.push((ty = ty, id = arg_index));
        self.next_var += 1;
        @tfmt("%v%", "%", arg_index)
    };
    self.out&.reserve(50);
    self.out&.current().push_all("{\n");
    ret := self.inst_call(values.items(), signeture, .None) {
        @fmt(self.out&.current(), "@\"%\"", impl_name_callee);
    };
    self.inst_return(ret);
    self.out&.current().push_all("}\n");
}

// TODO: copy-paste from DynamicImport but reversed so its a pain. 
fn write_export_bounce(self: *EmitLlvm, fid: FuncId) void = {
    self.current_debug_info = 0;
    func := self.comp.get_function(fid);
    export_name := self.comp.get_string(func.name);
    internal_name: List(u8) = list(temp()); 
    self.fmt_fn_name(fid, internal_name&);
    
    sig := self.comp.prim_sig(func).unwrap();
    self.emit_bounce_fn(internal_name.items(), export_name, sig, false);
}

fn emit_constant(self: *EmitLlvm, id: BakedVarId) void = {
    self.out&.reserve(100);
    value := self.comp.get_baked(id);
    idx: i64 = id.id.zext();
    
    // :build_options_wasm
    // The front end always treats pointers as 64bit when calculating struct sizes and offsets.
    // However, llvm's ptr type uses the correct size for the target architecture. 
    // Generally this doesn't matter, inttoptr/ptrtoint work fine (leave the extra as zero?) and we just use twice as much memory as we should.
    // However, this means on 32bit targets, constants can't be arrays of type ptr because then the offsets would be wrong. 
    // So we just lie and say they're i64 and maunually fill in zeros. 
    // One extra disadvantage is that the host JavaScript code gets pointer arguments as BigNum instead of Number becuase a double doesn't fit an i64. 
    // Note that constexpr zext doesn't exist anymore so we do a weird dance with bitcasting a vector. 
    // -- Aug 19
    wasm32 := self.comp.get_build_options()[].wasm32;
    
    if value.relocations.len == 0 {
        @match(value.template) {
            (fn Zeroes(len) => {
                @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i8] zeroinitializer\n", idx, len);
            });
            (fn Bytes(bytes) => {
                // TODO: emit string as characters if they're in a sane range. 
                
                @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i8] c\"", idx, bytes.len);
                for(bytes) {b|
                    if b != "\\".ascii() &&  b != "\"".ascii() && b >= 32 && b <= 126 {
                        self.out&.current().push(b);
                    } else {
                        self.out&.current().push("\\".ascii());
                        push_hex_byte(self.out&.current(), b, true);
                    };
                };
                //self.out&.push_all("\\00\"\n"); // TODO: hack cause im to lazy to ask for debug names as cstr
                self.out&.push_all("\"\n"); // TODO: hack cause im to lazy to ask for debug names as cstr
                
                //@fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i8] [", idx, bytes.len + 1);
                //for(bytes[].items()) {b|
                //    @fmt(self.out&.current(), " i8 %,", @as(i64) b.zext());
                //};
                //// self.pop_trailing_comma(); // add back when remove below
                //self.out&.push_all("i8 0]\n"); // TODO: hack cause im to lazy to ask for debug names as cstr
            });
        };
        return();
    };

    @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i64] [", idx, value.len() / 8);
    bake_iter_legacy value { inner |
        self.out&.reserve(20);
        @match(inner) {
            (fn FnPtr(f) => {
                f = self.comp.follow_redirects(f);  // TODO: hack because of new deduplication
                if wasm32 {
                    @fmt(self.out&.current(), "i64 bitcast (<2 x i32> <i32 ptrtoint (ptr @\"%\" to i32), i32 0> to i64),", (self, f));
                } else {
                    @fmt(self.out&.current(), "i64 ptrtoint (ptr @\"%\" to i64),", (self, f));
                };
                // TODO: make sure we emitted the function. 
            });
            (fn AddrOf(id) => {
                if wasm32 {
                    @fmt(self.out&.current(), "i64 bitcast (<2 x i32> <i32 ptrtoint (ptr @g% to i32), i32 0> to i64),", @as(i64) id.id.zext());
                } else {
                    @fmt(self.out&.current(), "i64 ptrtoint (ptr @g% to i64),", @as(i64) id.id.zext());
                };
            });
            (fn Num(v) => {
                // TODO: small prims
                @fmt(self.out&.current(), "i64 %,", v.value);
            });
        };
    };
    self.pop_trailing_comma();
    self.out&.push_all("]\n");
}

fn emit_special(self: *EmitLlvm, f_id: FuncId, body: *FuncImpl, func: *Func, bc: *FnBody, pending: *List(FuncId)) bool = {
    self.current_debug_info = 0;
    @match(body) {
        fn Normal(_) => { panic("ICE: empty body but expr"); };
        fn Redirect(f) => {
            pending.push(f[]);
            
            // :sema_regression :ExtraRedirectShims
            // you should be able to choose an order to compile stuff so emit_bc just happens to already know when things are redirects.
            // you didn't need to do this before. but it shouldn't matter that much i guess -- Aug 24
            // without this, when you sema emit_special_body on a redirect you can check if the target is special too and emit it early,
            // but that only helps a bit and breaks dedup test so this is preferable for now. 
            assert(f[] != f_id, "redirect to yourself");
            new_name := @tfmt("%", (self, f[]));
            old_name := @tfmt("%", (self, f_id));
            self.emit_bounce_fn(new_name, old_name, bc.signeture, true);
            return(true);
        }
        fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special(f_id, check, func, bc, pending), => return(true));
            };
        }
        fn DynamicImport(name) => { 
            // TODO: do i need to hackily do the same for ComptimeAddr and hope for the best? ideally the forntend would handle that instead. 

            // :link_rename
            import_name := check_link_rename(self.comp, name[], func, (arch = self.arch, os = self.os));
            self.forward_declare(bc.signeture, false, import_name);
            name := @tfmt("%", (self, bc.func));
            self.emit_bounce_fn(import_name, name, bc.signeture, true);
            return(true);
        }
        fn LlvmIr(code) => { 
            self.next_var = 0;
            ir := self.comp.get_string(code[]);
            self.out&.push_all("define private ccc ");
            name := @tfmt("%", (self, bc.func));
            self.write_header(bc.signeture, name) {arg_index|
                args := func.arg.bindings.items();
                arg := args[arg_index].name.Var.name;
                arg := self.comp.get_string(arg);
                arg := @format("%%", "%", arg) temp();
                self.next_var += 1;
                arg.items()
            };
            @fmt(self.out&.current(), "{\n%}\n", ir);
            return(true);
        }
        fn TargetOsSplit(it) => {
            if it.os == self.os {
                // TODO: :copy-paste from emit_special:redirect
                pending.push(it.fid);
                assert(it.fid != f_id, "redirect to yourself");
                new_name := @tfmt("%", (self, it.fid));
                old_name := @tfmt("%", (self, f_id));
                self.emit_bounce_fn(new_name, old_name, bc.signeture, true);
                return(true);
            };
        }
        @default fn() void => return(false);
    };
    false
}

fn forward_declare(self: *EmitLlvm, sig: PrimSig, private: bool, name: Str) void = {
    self.current_debug_info = 0;
    self.out&.push_all("declare ccc ");
    if private {
        self.out&.push_all("private ");
    };
    self.write_header(sig, name) {arg_index| @tfmt("%v%", "%", arg_index) };
    self.out&.push_all(";\n");
}

fn emit_special_asm(self: *EmitLlvm, body: *FuncImpl, func: *Func, bc: *FnBody, target: *TargetEnv) bool = {
    self.current_debug_info = 0;
    @match(body) {
        fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special_asm(check, func, bc, target), => return(true));
            };
        }
        fn JittedAarch64(code) => { 
            if target.arch != .aarch64 { 
                return(false); 
            };
            name := @format("%", (self, bc.func)) temp();
            self.forward_declare(bc.signeture, false, name.items());
            
            prefix := if(self.os == .linux, => "", => "_");
            @fmt(self.out&.current(), "module asm \"%%:\"\n", prefix, (self, bc.func));
            for code { inst |
                v := @as(i64) inst.zext();
                @fmt(self.out&.current(), "module asm \".word %\"\n", v);
            };
            
            return(true);
        }
        fn X86AsmText(code) => {
            if target.arch != .x86_64 { 
                return(false); 
            };
            name := @format("%", (self, bc.func)) temp();
            self.forward_declare(bc.signeture, false, name.items());
            
            prefix := if(self.os == .linux, => "", => "_");
            @fmt(self.out&.current(), "module asm \"%%:\"\n", prefix, (self, bc.func));
            code := self.comp.get_string(code[]);
            code := code.split_lines(temp());
            for code { inst |
                @fmt(self.out&.current(), "module asm \"%\"\n", inst);
            };
            return(true);
        }
        fn X86AsmBytes(code) => { // :copy-paste
            if target.arch != .x86_64 { 
                return(false); 
            };
            name := @format("%", (self, bc.func)) temp();
            self.forward_declare(bc.signeture, false, name.items());
            
            prefix := if(self.os == .linux, => "", => "_");
            @fmt(self.out&.current(), "module asm \"%%:\"\n", prefix, (self, bc.func));
            for code { inst |
                v := @as(i64) inst.zext();
                @fmt(self.out&.current(), "module asm \".byte %\"\n", v);
            };
            
            return(true);
        }
        @default => return(false);
    };
    false
}

fn write_header(self: *EmitLlvm, sig: PrimSig, name: Str, $get_arg_name: @Fn(idx: i64) Str) void = {
    self.out&.reserve(50);
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            @fmt(self.out&.current(), "%", llvm_pair_type(fst, snd));
        }{| // one
            @fmt(self.out&.current(), "%", fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("void");
    };
    @fmt(self.out&.current(), " @\"%\"(", name);
    
    // TODO: don't have two callsites for get_arg_name
    shift := if(sig.first_arg_is_indirect_return) {
        size: i64 = sig.return_value_bytes.zext();
        // note: when calling through function pointers, you need to put the sret attribute there as well (large_struct_ret_return tests this).
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, get_arg_name(0));
        1
    }{| 0 };
    
    enumerate(sig.args) {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        @fmt(self.out&.current(), "% %,", ty[].llvm_type(), get_arg_name(i)); 
    };
    self.pop_trailing_comma();
    self.out&.current().push_all(")");
}

fn setup(self: *EmitLlvm, body: *FnBody, vars_out: *List(EmitLlvm.Val)) void = {
    self.out&.push_all("entry:\n");
    self.next_var = 0;
    // TODO: waste for ssa vars, they just get set to the value. -- Jun 14
    vars := body.vars.items();
    do_debug := self.comp.get_build_options()[].debug_info;
    
    file_scope := 0;
    if do_debug {
        func := self.comp.get_function(body.func);
        place := self.comp.get_whole_line(func.loc);
        file_scope = self.debug_scope_for_file(place.filename);
    };
    enumerate(vars) {i, ty|
        v := self.get_var(.P64);
        vars_out.push(v);
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   % = alloca i8, i32 %, align %\n", v, @as(i64) ty.size.zext(), @as(i64) ty.align.zext()); // uhg % was a bad choice. 
        if do_debug && body.var_names.len > i {
            name := body.var_names[i];
            if !(name.raw() == 0) {
                name := self.comp.get_string(name);
                local := self.next_debug();
                location := self.next_debug();
                scope := self.current_debug_info;
                @fmt(self.debug_info&, "!% = !DILocalVariable(name: \"%\", scope: !%, file: !%, type: !%)\n",
                    local, name, scope, file_scope, self.debug_addr_type);
                @fmt(self.debug_info&, "!% = !DILocation(line: 1, column: 1, scope: !%)\n", location, scope);
                // because the hardest part of compilers is how few times you need to write the word "metadata" apparently 
                template :: "    call void @llvm.dbg.declare(metadata ptr %, metadata !%, metadata !DIExpression()), !dbg !%\n";
                @fmt(self.out&.current(), template, v, local, location);
            };
        };
    };
    // TODO: use phi nodes cause this is stupid but that's such a pain in the ass. 
    // I use these for block arguments. 
    max_args := 0;
    each(body.blocks.items()){b|
        max_args = max_args.max(b.arg_prims.len);
    };
    range(0, max_args) {i|
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   %a% = alloca i64\n", "%", i); // uhg % was a bad choice. 
    };
    shift := if body.signeture.first_arg_is_indirect_return {
        @fmt(self.out&.current(), " store ptr %arg0, ptr %a0\n", "%", "%");
        1
    }{| 0 };
    enumerate body.signeture.args {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        // TODO: ty.llvm_type() error says it wants the raw type but found enum ptr when it should say wants the enum type
        @fmt(self.out&.current(), "   store % %arg% , ptr %a%\n", ty[].llvm_type(), "%", i, "%", i); 
    };
    self.out&.push_all("   br label %b0\n"); 
}

fn raw(a: Symbol) u32 #unsafe_noop_cast;

fn fmt_fn_name(self: *EmitLlvm, f: FuncId, out: *List(u8)) void = 
    out.push_all(self.comp.fmt_fn_name(f));

fn display(self: Ty(*EmitLlvm, FuncId), out: *List(u8)) void = {
    self._0.fmt_fn_name(self._1, out)
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, f: FuncId, tail: bool, loc: ?Span, _context: bool) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig, loc) {
        self.out&.current().push_all("@\"");
        self.fmt_fn_name(f, self.out&.current());
        self.out&.current().push_all("\"");
    }
}

// For float cmp, 
// - o=ordered: false if either is nan
// - u=unordered: true if either is nan
// Which is interesting because it means the NaN != NaN thing isn't real, they just all choose that for some reason. 
fn inst_intrinsic(self: *EmitLlvm, args: Slice(LlvmVal), op: Intrinsic) Slice(EmitLlvm.Val) = {
    bin :: fn(self: *EmitLlvm, args: Slice(LlvmVal), op: Str) Slice(EmitLlvm.Val) = {
        out := self.get_var(args[0].ty);
        @fmt(self.out&.current(), "   % = % %, %\n", out, op, args[0], args[1]);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    bin_cmp :: fn(self: *EmitLlvm, args: Slice(LlvmVal), op: Str) Slice(EmitLlvm.Val) = {
        temp_bool := self.get_var(.I8);
        out := self.get_var(.I8);
        @fmt(self.out&.current(), "   % = % %, %\n", temp_bool, op, args[0], args[1]);
        @fmt(self.out&.current(), "   % = zext i1 % to i8\n", out, temp_bool);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    cast :: fn(self: *EmitLlvm, args: Slice(LlvmVal), out: Prim, pre: Str, post: Str) Slice(EmitLlvm.Val) = {
        out := self.get_var(out);
        @fmt(self.out&.current(), "   % = % % %\n", out, pre, args[0], post);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    
    @match(op) {
        fn Add() => self.bin(args, "add i64");
        fn Sub() => self.bin(args, "sub i64");
        fn Mul() => self.bin(args, "mul i64");
        fn Div() => self.bin(args, "sdiv i64");
        fn Eq() => self.bin_cmp(args, "icmp eq i64");
        fn Ne() => self.bin_cmp(args, "icmp ne i64");
        fn Le() => self.bin_cmp(args, "icmp sle i64");
        fn Ge() => self.bin_cmp(args, "icmp sge i64");
        fn Lt() => self.bin_cmp(args, "icmp slt i64");
        fn Gt() => self.bin_cmp(args, "icmp sgt i64");
        fn PtrToInt() => self.cast(args, .I64, "ptrtoint ptr", "to i64"); 
        fn IntToPtr() => self.cast(args, .P64, "inttoptr i64", "to ptr"); 
        fn ShiftLeft()            => self.bin(args, "shl i64");
        fn ShiftRightLogical()    => self.bin(args, "lshr i64");
        fn ShiftRightArithmetic() => self.bin(args, "ashr i64");
        fn BitOr()  => self.bin(args, "or i64");
        fn BitAnd() => self.bin(args, "and i64");
        fn BitXor() => self.bin(args, "xor i64");
        fn FAdd() => self.bin(args, "fadd double");
        fn FSub() => self.bin(args, "fsub double");
        fn FMul() => self.bin(args, "fmul double");
        fn FDiv() => self.bin(args, "fdiv double");
        fn FEq() => self.bin_cmp(args, "fcmp oeq double");
        fn FNe() => self.bin_cmp(args, "fcmp une double");  // NaN != NaN. so this one returns true if either is NaN. 
        fn FLe() => self.bin_cmp(args, "fcmp ole double");
        fn FGe() => self.bin_cmp(args, "fcmp oge double");
        fn FLt() => self.bin_cmp(args, "fcmp olt double");
        fn FGt() => self.bin_cmp(args, "fcmp ogt double");
        fn Trunc64To32() => self.cast(args, .I32, "trunc i64", "to i32"); 
        fn Trunc64To16() => self.cast(args, .I16, "trunc i64", "to i16"); 
        fn Trunc64To8()  => self.cast(args,  .I8, "trunc i64", "to i8"); 
        fn Trunc32To16() => self.cast(args, .I16, "trunc i32", "to i16"); 
        fn Trunc32To8()  => self.cast(args,  .I8, "trunc i32", "to i8"); 
        fn Trunc16To8()  => self.cast(args,  .I8, "trunc i16", "to i8"); 
        fn SignExtend32To64() => self.cast(args,  .I64, "sext i32", "to i64"); 
        fn ZeroExtend32To64() => self.cast(args,  .I64, "zext i32", "to i64"); 
        fn ZeroExtend16To64() => self.cast(args,  .I64, "zext i16", "to i64"); 
        fn ZeroExtend8To64()  => self.cast(args,  .I64, "zext i8", "to i64"); 
        fn ZeroExtend16To32() => self.cast(args,  .I32, "zext i16", "to i32"); 
        fn ZeroExtend8To32()  => self.cast(args,  .I32, "zext i8", "to i32"); 
        fn ZeroExtend8To16()  => self.cast(args,  .I16, "zext i8", "to i16"); 
        fn IntToFloatValue()  => self.cast(args,  .F64, "sitofp i64", "to double"); 
        fn FloatToIntValue()  => self.cast(args,  .I64, "fptosi double", "to i64"); 
        fn IntToFloatBits()   => self.cast(args,  .F64, "bitcast i64", "to double"); 
        fn FloatToIntBits()   => self.cast(args,  .I64, "bitcast double", "to i64"); 
        fn ShrinkFloat()      => self.cast(args,  .F32, "fptrunc double", "to float"); 
        fn GrowFloat()        => self.cast(args,  .F64, "fpext float", "to double"); 
        fn BitNot()           => self.cast(args,  .I64, "xor i64", ", -1"); 
        fn GetContext()       => {
            panic("TODO: llvm implicit context")
        }
        fn SetContext()       => {
            panic("TODO: llvm implicit context")
        }
        @default => @panic("ICE: unhandled LLVM inst_intrinsic");
    }
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, loc: ?Span, $do_call: @Fn() void) Slice(EmitLlvm.Val) = {
    self.out&.reserve(30);
    
    out_vals: List(LlvmVal) = list(temp());
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            out_vals&.push(self.get_var(fst));
            out_vals&.push(self.get_var(snd));
            @fmt(self.out&.current(), "   %v% = call % ", "%", self.next_var, llvm_pair_type(fst, snd));
            self.next_var += 1;
        }{| // one
            v := self.get_var(fst);
            out_vals&.push(v);
            @fmt(self.out&.current(), "   % = call % ", v, fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("   call void ");
    };
    maybe_struct_out := self.next_var.sub(1);
    
    do_call();
    
    self.out&.push_all("(");
    shift := if(sig.first_arg_is_indirect_return) {
        size: i64 = sig.return_value_bytes.zext();
        // note: the sret must match the declaration! not doing this breaks large_struct_ret_return and compiler driver dylib ffi. 
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, args[0]);
        1
    }{| 0 };
    @debug_assert_eq(args.len, sig.args.len.add(shift));
    
    range(0, sig.args.len) {i|
        ty := sig.args[i];
        v := args[i.add(shift)];
        self.out&.reserve(30);
        ::assert_eq(Prim);
        //assert_eq(ty, v.ty); // TODO
        @fmt(self.out&.current(), " % %,", ty.llvm_type(), v);
    };
    self.pop_trailing_comma();
    
    self.out&.current().push_all(")");
    
    if self.current_debug_info != 0 {
        // we know self.comp.get_build_options()[].debug_info is true. 
        // Fixes "inlinable function call in a function with debug info must have a !dbg location"
        location := self.next_debug();
        line := 1;
        column := 1;
        if loc { loc |
            // TODO: we should track line numbers instead of byte indexes if that's always what we want. -- Sep 24
            place := self.comp.get_whole_line(loc); // :SLOW
            line = place.line;
            column = place.col;
            // TODO: if this is from a macro / inlined something the location could be wrong because current_debug_info uses the file containing the outer function, 
            //       but this code might not be in that file and then the line we report is junk. 
        };
        @fmt(self.debug_info&, "!% = !DILocation(line: %, column: %, scope: !%)\n", location, line, column, self.current_debug_info);
        @fmt(self.out&.current(), ", !dbg !%", location);
    };
    
    self.out&.current().push_all("\n");
    if(sig.ret2) {_| // two
        v1 := out_vals[0];
        v2 := out_vals[1];
        self.out&.reserve(30);
        p := llvm_pair_type(v1.ty, v2.ty);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 0\n", v1, p, "%", maybe_struct_out);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 1\n", v2, p, "%", maybe_struct_out);
    };
    
    out_vals.items()
}

fn pop_trailing_comma(self: *EmitLlvm) void = {
    // they don't allow trailing comma because they hate us personally 
    if(self.out&.current().items().ends_with(",")) {
        // TODO: access fields on lvalues. `self.out&.current().len += 1` should work
        l := self.out&.current();
        l.len -= 1;
    };
}

fn inst_trap(self: *EmitLlvm) void = {
    // i think trap makes it crash instead of ub and it seems you need unreachable for it to believe the block is finished. 
    self.out&.push_all("   call void @llvm.trap()\n   unreachable\n");
}

fn inst_call_ptr(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, ptr: EmitLlvm.Val, loc: ?Span, _context: bool) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig, loc) {
        @fmt(self.out&.current(), "%", ptr);
    }
}

HATEFUL_GEP :: false; // doesn't work

fn inst_offset(self: *EmitLlvm, ptr: EmitLlvm.Val, bytes: i64) EmitLlvm.Val = {
    self.out&.reserve(30);
    done := self.get_var(.P64);
    if HATEFUL_GEP {
        @fmt(self.out&.current(), "   % = getelementptr i8, ptr %, i64 %\n", done, ptr, bytes); 
    } else {
        temp := self.get_var(.I64);
        new := self.get_var(.I64);
        @fmt(self.out&.current(), "   % = ptrtoint ptr % to i64\n", temp, ptr); 
        @fmt(self.out&.current(), "   % = add i64 %, %\n", new, temp, bytes); 
        @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", done, new); 
    };
    done
}

MAX_I32 :: 1.shift_left(32).sub(1);

fn inst_literal(self: *EmitLlvm, value: i64, ty: Prim) EmitLlvm.Val = {
    v := self.get_var(ty);
    self.out&.reserve(100);
    @match(ty) {
        fn F64() => {
            // for f64, llvm wants the bits as hex. 
            h := fmt_hex(value);
            @fmt(self.out&.current(), "   % = fadd double %, 0.0\n", v, h); 
        }
        fn F32() => {
            // for f32, llvm wants an f64 as hex that happens to be exactly representable as f32. 
            // but we store it as an f32 on the bottom with the high bits zeroed. 
            assert(value.lt(MAX_I32), "ICE: too many bits for f32");
            value: u32 = value.trunc();    // the bits we want to load
            value: f32 = value.bitcast();  // the number we want to load
            value: f64 = value.cast();     // the same numerical value
            value: i64 = value.bitcast();  // the bits we need to give llvm
            // TODO: does it change if you try to print here??????
            h := fmt_hex(value);
            @fmt(self.out&.current(), "   % = fadd float %, 0.0\n", v, h); 
        }
        fn P64() => {
            @assert_eq(value, 0); // a literal pointer that isn't null doesn't make sense for AOT.
            @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, value); 
        }
        @default => {
            // TODO: better error message if you forget an argument
            // TODO: just track constants myself in Val? you can't just assign to a constsant int. 
            @fmt(self.out&.current(), "   % = add % %, 0\n", v, ty.llvm_type(), value); 
        };
    };
    v
}

// TODO: need to sign extend sometimes. 
fn inst_load(self: *EmitLlvm, addr: EmitLlvm.Val, ty: Prim) EmitLlvm.Val = {
    value := self.get_var(ty);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = load %, ptr %\n", value, ty.llvm_type(), addr); 
    value
}

fn inst_store(self: *EmitLlvm, addr: EmitLlvm.Val, value: EmitLlvm.Val, ty: Prim) void = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   store % %, ptr %\n", ty.llvm_type(), value, addr); 
}

fn inst_copy(self: *EmitLlvm, from: EmitLlvm.Val, to: EmitLlvm.Val, bytes: u16) void = {
    if(from.id == to.id, => return());
    self.out&.reserve(30);
    //@fmt(self.out&.current(), "   call void @llvm.memcpy.p0.p0.i32(ptr %, ptr %, i32 %, i1 false)\n", to, from, @as(i64) bytes.zext()); 
    @fmt(self.out&.current(), "   call void @llvm.memmove.p0.p0.i32(ptr %, ptr %, i32 %, i1 false)\n", to, from, @as(i64) bytes.zext()); 
}

fn inst_func_ref(self: *EmitLlvm, fid: FuncId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @\"%\" to i64\n", temp, (self, fid));
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_global(self: *EmitLlvm, id: BakedVarId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @g% to i64\n", temp, @as(i64) id.id.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_jump_if(self: *EmitLlvm, cond: EmitLlvm.Val, true: BbId, false: BbId, args: Slice(EmitLlvm.Val)) void = {
    assert(args.len.eq(0), "i dont use this yet");
    self.out&.reserve(40);
    c := self.get_var(.I8);
    @fmt(self.out&.current(), "   % = trunc i8 % to i1\n", c, cond); 
    @fmt(self.out&.current(), "   br i1 %, label %b%, label %b%\n", c, "%", @as(i64) true.id.zext(), "%", @as(i64) false.id.zext()); 
}

fn inst_jump(self: *EmitLlvm, always: BbId, args: Slice(EmitLlvm.Val)) void = {
    enumerate(args){i, arg|
        self.out&.reserve(50);
        @fmt(self.out&.current(), "   store % %, ptr %a%\n", arg.ty.llvm_type(), arg[], "%", i); 
    };
    self.out&.reserve(20);
    @fmt(self.out&.current(), "   br label %b%\n", "%", @as(i64) always.id.zext()); 
}

fn inst_switch(self: *EmitLlvm, info: *RawList(SwitchPayload), inspected: LlvmVal, _uid: i64) void = {
    normal_branches, default := info.decode_switch();
    type := inspected.ty.llvm_type();
    @fmt(self.out&.current(), "   switch % %, label ", type, inspected); 
    
    assert(default.is_some(), "TODO: allow match with no default, no safety check?");
    if default { default_block |
        @fmt(self.out&.current(), "%b%", "%", @as(i64) default_block.id.zext()); 
    };
    
    self.out&.current().push_all("[");
    for normal_branches { case | 
        self.out&.reserve(20);
        @fmt(self.out&.current(), "i64 %, label %b%\n", case.value, "%", @as(i64) case.block.id.zext()); 
    };
    self.out&.current().push_all("]");
}
            
fn inst_return(self: *EmitLlvm, args: Slice(EmitLlvm.Val)) void = {
    self.out&.reserve(100);
    @switch(args.len){
        @case(0) => {
            self.out&.current().push_all("   ret void\n");
        };
        @case(1) => {
            @fmt(self.out&.current(), "   ret % %\n", args[0].ty.llvm_type(), args[0]); 
        };
        @case(2) => {
            self.next_var += 2;
            pair := llvm_pair_type(args[0].ty, args[1].ty);
            @fmt(self.out&.current(), "   %v% = insertvalue % undef, % %, 0\n", "%", self.next_var.sub(2), pair, args[0].ty.llvm_type(), args[0]); 
            @fmt(self.out&.current(), "   %v% = insertvalue % %v%, % %, 1\n", "%", self.next_var.sub(1), pair, "%", self.next_var.sub(2), args[1].ty.llvm_type(), args[1]); 
            @fmt(self.out&.current(), "   ret % %v%\n", pair, "%", self.next_var.sub(1)); 
        };
        @default fn() => unreachable();
    };
}

fn move_to_block(self: *EmitLlvm, block: *BasicBlock, ip: BbId) Slice(EmitLlvm.Val) = {
    self.out&.reserve(100);
    @fmt(self.out&.current(), "b%:\n", @as(i64) ip.id.zext()); 
        
    self.current = ip;
    args: List(EmitLlvm.Val) = list(block.arg_prims.len, temp());
    
    enumerate(block.arg_prims) {i, ty| 
        self.out&.reserve(20);
        v := self.get_var(ty[]);
        args&.push(v);
        @fmt(self.out&.current(), "   % = load %, ptr %a%\n", v, ty[].llvm_type(), "%", i); 
    };
    args.items()
}

fn get_var(self: *EmitLlvm, ty: Prim) LlvmVal = {
    v: LlvmVal = (ty = ty, id = self.next_var);
    self.next_var += 1;
    v
}

fn display(self: LlvmVal, out: *List(u8)) void = {
    @fmt(out, "%v%", "%", self.id);
}
::enum(Prim);

// TODO: these are super clunky, you want to have 'or' in switch cases. 
fn llvm_type(ty: Prim) Str = @match(ty) {
    fn I8() => "i8";
    fn I16() => "i16";
    fn I32() => "i32";
    fn I64() => "i64";
    fn F64() => "double";
    fn F32() => "float";
    fn P64() => "ptr";
};

fn llvm_pair_type(a: Prim, b: Prim) Str = {
    s := @format("{ %, % }", a.llvm_type(), b.llvm_type()) temp();
    s.items()
}
