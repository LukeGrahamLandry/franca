Vm :: @struct(
    chunk: *Chunk,
    ip: *u8,
    stack: List$Value, // TODO: inline fixed size array
    stack_top: *Value,
    last_return: Value
);

fun init() Vm = {
    var self: Vm = ()!uninitialized; // TODO: no uninit
    self.stack = list(stack_max);  // EXTRA: grow stack
    self&.reset_stack();
    self
}

fun drop(self: *Vm) Unit = {
    // self.chunk.drop(); // TODO: but for now its always on the stack. 
    self.stack&.drop();
}

InterpretResult :: @enum(Ok, CompileError, RuntimeError);

fun interpret(self: *Vm, source: Str) InterpretResult = {
    chunk: Chunk = init();
    ::if(InterpretResult);
    result := if(compile(source, chunk&)) {|
       self.interpret(chunk&)
    } {| InterpretResult.CompileError };
    chunk&.drop();
    result
}

fun interpret(self: *Vm, chunk: *Chunk) InterpretResult = {
    self.chunk = chunk;
    self.ip = chunk.code&.as_ptr();
    self.run()
}

fn run(self: *Vm) InterpretResult = {
    return :: __return; // Note: outside the loop call
    
    out := InterpretResult.RuntimeError;
    debug: List$u8 = list();
    
    // TODO: this should work without type hint
    loop {()Unit|
        if(::debug_trace_execution){|
            debug&.clear();
            @fmt(debug&, "         %", ""); // TODO: fix 'no trivial tuples'
            for(self.stack&.as_ptr(), self.stack_top) {(slot: *Value)|
                @fmt(debug&, "[ % ]", slot);
            };
            println(debug&.items());
        
            p := self.chunk[].code&.as_ptr();
            i := p.ptr_diff(self.ip);
            println(i);  // TODO: do these into the buffer as well 
            self.chunk.dis_inst(i);
        };
        
        instruction := self.read_byte();
        
        // TODO: switch over incomplete enum like is is awkward because you can't use contextual field. 
        @switch(instruction) {
            @case(OpCode.Constant) => {
                constant := self.read_constant();
                self.push(constant);
            };
            @case(OpCode.Return) => {
                value := self.pop();
                self.last_return = value;
                @println("RET: %", value);
                return(.Ok);
            };
            @case(OpCode.Negate) => {
                val := self.pop();
                if(val.is_number().not()){|
                    self.runtime_error("Operand must be a number.");
                    return(.RuntimeError);
                };
                self.push(val.to_number().neg().to_value());
            };
            // TODO: without the ret type annotation you get err walkwip, but only when it couldn't find the function to call? so just need better error message. 
            @case(OpCode.Add)      => binary_op(add); 
            @case(OpCode.Subtract) => binary_op(sub); 
            @case(OpCode.Multiply) => binary_op(mul); 
            @case(OpCode.Divide)   => binary_op(div);  
            @case(OpCode.Greater)  => binary_op(gt);  
            @case(OpCode.Less)     => binary_op(lt);  
            @case(OpCode.True)     => self.push(true_value);  
            @case(OpCode.False)    => self.push(false_value);  
            @case(OpCode.Nil)      => self.push(nil_value);  
            @case(OpCode.Not) => {
                val := self.pop();
                is_falsy :: fn(v: Value) bool = v.is_bool().and(=> v.to_bool().not()).or(v.is_nil()); 
                self.push(val.is_falsy().to_value());
            };
            @case(OpCode.Equal) => {
                rhs := self.pop();
                lhs := self.pop();
                self.push(lhs.eq(rhs).to_value());  // Don't care about NaN != NaN for now. 
            };
            @default() fn(_: u8) => {
                println("bad opcode");
                return(.RuntimeError);
            };
        }
    };
    
    binary_op :: fn(const op: OverloadSet) Unit => {
        // TODO: you can't put `Fn(Ty(f64, f64), f64)` as the argument type because it wont find the overload because it thinks the arg is a OverloadSet. 
        rhs := self.pop();
        lhs := self.pop();
        if(rhs.is_number().and(lhs.is_number()).not()){|
            self.runtime_error("Operands must be numbers.");
            return(.RuntimeError); // non-local returns baby~
        };
        result := op(lhs.to_number(), rhs.to_number()).to_value();
        self.push(result);
    };
    
    out
}

// TODO: I could expose the dereference and increment instruction but presumably if you want it to be fast you'd just use llvm anyway. 
#inline fn read_byte(self: *Vm) u8 = {
    let b = self.ip[];
    self.ip = self.ip.offset(1);
    b
}

#inline fn read_constant(self: *Vm) Value = {
    // TODO: you can't put the type annotation that does the cast on the var or the call because then it changes the overload resolution. 
    let index = self.read_byte();
    self.chunk.constants&.get(@as(i64) index)
}

fun push(self: *Vm, value: Value) Unit = {
    self.stack_top[] = value;
    self.stack_top = self.stack_top.offset(1);
}

fun pop(self: *Vm) Value = {
    self.stack_top = self.stack_top.offset(1.neg());
    self.stack_top[]
}

fn reset_stack(self: *Vm) Unit = {
    self.stack_top = self.stack&.as_ptr();
}

fn runtime_error(self: *Vm, msg: Str) Unit = {
    p := self.chunk.code&.as_ptr();
    i := p.ptr_diff(self.ip);
    line := self.chunk.lines[i];
}

::ptr_utils(u8);
::ptr_utils(Value);
