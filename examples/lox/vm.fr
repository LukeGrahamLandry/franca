debug_trace_execution :: false;
debug_print_code :: false;
stack_max :: 256;

Vm :: @struct(
    stack: List(Value), // TODO: inline fixed size array
    stack_top: *Value,
    last_return: Value,
    gc: Alloc,
    objects: *Obj,
    strings: Table,
    globals: Table,
    errors: List(u8),
    frames: List(CallFrame),
);

CallFrame :: @struct {
    function: *ObjFunction;
    ip: *u8;
    first_local: i64;
};

Table :: RawHashMap(*ObjString, Value);

fn init_vm() Vm = {
    self := zeroed Vm;
    self.gc = general_allocator();
    self.stack = list(stack_max, general_allocator());  // EXTRA: grow stack
    self.objects = Obj.ptr_from_int(0); // EVIL
    self.strings = init(); 
    self.globals = init(); 
    self&.reset_stack();
    self.errors = list(self.gc);
    self.frames = list(self.gc);
    self&.define_native("clock", fn(_) = {
        timestamp_s().to_value()
    });
    self
}

fn define_native(self: *Vm, name: Str, callee: ObjNative.F) void = {
    name := self.copy_string(name);
    obj := self.allocate_obj(ObjNative);
    obj.function = callee;
    self.globals&.insert(name, obj.obj&.to_value(), self.gc);
}

fn drop(self: *Vm) void = {
    self.stack&.drop();
    self.globals&.drop(self.gc);
    self.strings&.drop(self.gc);
    self.errors&.drop();
    self.frames&.drop();
    self.free_objects();
}

InterpretResult :: @enum(i64) (Ok, CompileError, RuntimeError, SuspendPrint);

fn interpret(self: *Vm, source: Str, collect_errors: bool, $print: Fn(Value, void) #duplicated) InterpretResult = {
    ::if(InterpretResult);
    function := self.compile(source) || {
        print(self.errors.items());
        return(.CompileError);
    };
    result := self.interpret(function, collect_errors, print);
    if !collect_errors && self.errors.len > 0 {
        print(self.errors.items());
    }
    result
}

fn interpret(self: *Vm, source: Str) InterpretResult = {
    self.interpret(source, false) { value |
        @println("%", value);
    }
}

fn interpret(self: *Vm, function: *ObjFunction, collect_errors: bool, $print: Fn(Value, void) #duplicated) InterpretResult = {
    self.stack_top = self.stack.maybe_uninit.ptr;
    self.stack&.clear();
    
    self.frames&.push(
        function = function, ip = 
        function.chunk.code.index(0), 
        first_local = ptr_diff(self.stack.maybe_uninit.ptr, self.stack_top),
    );
    self.push(function.to_value());
    
    loop {
        result := self.run();
        if result == .SuspendPrint {
            print(self.last_return);
        } else {
            self.frames&.pop();
            return(result);
        };
    }
}

is_falsy :: fn(v: Value) bool = v.is_bool().and(=> v.to_bool().not()).or(v.is_nil()); 
                
fn run(self: *Vm) InterpretResult = {
    out := InterpretResult.RuntimeError;
    debug: List(u8) = list(temp());  // :LEAK someone needs to reset temp in this program
    frame := self.frames&.last().unwrap();
    ip := frame.ip&;
    loop {
        continue :: local_return;
        @debug_assert(ptr_diff(frame.function.chunk.code.maybe_uninit.ptr, ip[]) < frame.function.chunk.code.len, "fell off the end of function");
        
        if debug_trace_execution {
            debug&.clear();
            @fmt(debug&, "       stack:");
            for(self.stack&.as_ptr(), self.stack_top) {slot|
                @fmt(debug&, "[ % ]", slot);
            };
            @fmt(debug&, "\n      global:"); 
            each self.globals& { k, v |
                @fmt(debug&, "[ % = % ]", k.data, v);
            };
        
            @fmt(debug&, "\n"); 
            p := frame.function.chunk.code&.as_ptr();
            i := p.ptr_diff(ip[]);
            frame.function.chunk&.dis_inst(debug&, i);
            
            print(debug&.items());
        };
        
        instruction := self.read_byte();
        
        // TODO: switch over incomplete enum like is is awkward because you can't use contextual field. 
        @switch(instruction) {
            @case(OpCode.Constant) => {
                constant := self.read_constant();
                self.push(constant);
            };
            @case(OpCode.Call) => {
                arg_count: i64 = self.read_byte().zext();
                if !self.call_value(self.peek(arg_count), arg_count) {
                    return(.RuntimeError);
                };
                frame = self.frames&.last().unwrap();
                ip = frame.ip&;
            };
            @case(OpCode.Return) => {
                value := self.pop();
                self.frames&.pop().unwrap();
                if self.frames.len == 0 {
                    self.last_return = value;
                    return(.Ok);
                }
                self.stack_top = self.stack.index_unchecked(frame.first_local);
                self.stack.len = frame.first_local; // redundant [...] safety check
                frame = self.frames&.last().unwrap();
                ip = frame.ip&;
                self.push(value);
            };
            @case(OpCode.Negate) => {
                val := self.pop();
                if(val.is_number().not()){
                    self.runtime_error("Operand must be a number.");
                    return(.RuntimeError);
                };
                self.push(val.to_number().neg().to_value());
            };
            @case(OpCode.Add) => {
                rhs := self.pop();
                lhs := self.pop();
                if rhs.is_number() {
                    if !lhs.is_number() {
                        self.runtime_error("Second operand must be a number.");
                        return(.RuntimeError);
                    };
                    result := add(lhs.to_number(), rhs.to_number()).to_value();
                    self.push(result);
                    continue();
                };
                
                if rhs.is_obj(ObjType.String) {
                    if !lhs.is_obj(ObjType.String) {
                        self.runtime_error("Second operand must be a string.");
                        return(.RuntimeError);
                    };
                    lhs := lhs.to_string();
                    rhs := rhs.to_string();
                    new := self.gc.alloc_uninit(u8, lhs.data.len + rhs.data.len);
                    new.slice(0, lhs.data.len).copy_from(lhs.data);
                    new.slice(lhs.data.len, new.len).copy_from(rhs.data);
                    o := self.take_string(new);
                    self.push(o.to_value());
                    continue();
                };
                
                self.runtime_error("Operands must be numbers or strings.");
                return(.RuntimeError);
            };
            @case(OpCode.Subtract) => binary_op(sub); 
            @case(OpCode.Multiply) => binary_op(mul); 
            @case(OpCode.Divide)   => binary_op(div);  
            @case(OpCode.Greater)  => binary_op(gt);  
            @case(OpCode.Less)     => binary_op(lt);  
            @case(OpCode.True)     => self.push(true_value);  
            @case(OpCode.False)    => self.push(false_value);  
            @case(OpCode.Nil)      => self.push(nil_value);  
            @case(OpCode.Not) => {
                val := self.pop();
                self.push(val.is_falsy().to_value());
            };
            @case(OpCode.Equal) => {
                rhs := self.pop();
                lhs := self.pop();
                result := @if(rhs.is_number() && lhs.is_number(), rhs.to_number() == lhs.to_number(), lhs == rhs);
                self.push(result.to_value());
            };
            @case(OpCode.Print) => {
                value := self.pop();
                self.last_return = value;
                return(.SuspendPrint);
            };
            @case(OpCode.Pop) => {
                _ := self.pop();
            };
            @case(OpCode.DefineGlobal) => {
                value := self.pop();
                name := self.read_constant();
                @debug_assert(name.is_obj(.String), "LOX_ICE: DefineGlobal expected string name.");
                self.globals&.insert(name.to_string(), value, self.gc);
            };
            @case(OpCode.GetGlobal) => {
                name := self.read_constant();
                @debug_assert(name.is_obj(.String), "LOX_ICE: GetGlobal expected string name.");
                @match(self.globals&.get(name.to_string())) {
                    fn Some(value) => self.push(value);
                    fn None() => {
                        self.runtime_error(@tfmt("Accessed undeclared global variable: %", name.to_string()[].data));
                        return(.RuntimeError);
                    }
                };
            };
            @case(OpCode.SetGlobal) => {
                name := self.read_constant();
                @debug_assert(name.is_obj(.String), "LOX_ICE: SetGlobal expected string name.");
                @match(self.globals&.get_ptr(name.to_string())) {
                    fn Some(slot) => {
                        slot[] = self.peek();
                    }
                    fn None() => {
                        self.runtime_error("Accessed undeclared global variable.");
                        return(.RuntimeError);
                    }
                };
            };
            @case(OpCode.SetLocal) => {
                idx: i64 = self.read_byte().zext();
                self.stack[frame.first_local + idx] = self.peek();
            };
            @case(OpCode.GetLocal) => {
                idx: i64 = self.read_byte().zext();
                self.push(self.stack[frame.first_local + idx]);
            };
            @case(OpCode.JumpIfFalse) => {
                distance := self.read_u16();
                if self.peek().is_falsy() {
                    ip[] = ip[].offset(distance);
                };
            };
            @case(OpCode.Jump) => {
                distance := self.read_u16();
                ip[] = ip[].offset(distance);
            };
            @case(OpCode.Loop) => {
                distance := -self.read_u16();
                ip[] = ip[].offset(distance);
            };
            @default => {
                println("bad opcode");
                return(.RuntimeError);
            };
        };
    };
    
    binary_op :: fn($op: OverloadSet) void => {
        rhs := self.pop();
        lhs := self.pop();
        if !(rhs.is_number() && lhs.is_number()) {
            self.runtime_error("Operands must be numbers.");
            return(.RuntimeError); // non-local returns baby~
        };
        result := op(lhs.to_number(), rhs.to_number()).to_value();
        self.push(result);
    };
    
    out
}

fn call_value(self: *Vm, callee: Value, arg_count: i64) bool = {
    if !callee.is_obj() {
        self.runtime_error("tried to call non-function");
        return false;
    }
    f := @match(callee.to_obj()[].type) {
        fn Function() => callee.to_function();
        fn Native() => {
            callee := ObjNative.to_obj_subtype(callee);
            args := self.stack_top.offset(-arg_count).slice(arg_count);
            result := callee'function(args);
            self.stack_top = self.stack_top.offset(-arg_count - 1);
            self.stack.len -= arg_count + 1;  // [...]
            self.push(result);
            return(true)
        }
        @default => {
            self.runtime_error("tried to call non-function");
            return(false)
        };
    };
    if arg_count != f.arity {
        self.runtime_error(@tfmt("expected % arguments but got %", f.arity, arg_count));
        return false;
    }
    s := ptr_diff(self.stack.maybe_uninit.ptr, self.stack_top);
    self.frames&.push(function = f, ip = f.chunk.code.index(0), first_local = s - arg_count - 1);
    true
}

#inline fn read_byte(self: *Vm) u8 = {
    ip := self.frames&[self.frames.len - 1].ip&;
    b := ip[][];
    ip[] = ip[].offset(1);
    b
}

#inline fn read_u16(self: *Vm) i64 = {
    ip := self.frames&[self.frames.len - 1].ip&;
    a: i64 = ip[][].zext();
    b: i64 = ip[].offset(1)[].zext();
    ip[] = ip[].offset(2);
    a.bit_or(b.shift_left(8))
}

#inline fn read_constant(self: *Vm) Value = {
    // TODO: you can't put the type annotation that does the cast on the var or the call because then it changes the overload resolution. 
    index := self.read_byte();
    chunk := self.frames.last().unwrap()[].function.chunk&;
    chunk.constants&.get(@as(i64) index.zext())
}

fn push(self: *Vm, value: Value) void = {
    @debug_assert(self.stack.len < self.stack.maybe_uninit.len);
    self.stack_top[] = value;
    self.stack_top = self.stack_top.offset(1);
    self.stack.len += 1; // redundant. but fixes safety check using locals
}

fn pop(self: *Vm) Value = {
    @debug_assert(self.stack.len >= 1);
    self.stack_top = self.stack_top.offset(1.neg());
    self.stack.len -= 1; // redundant. but fixes safety check using locals
    self.stack_top[]
}

fn peek(self: *Vm) Value = {
    self.peek(0)
}
fn peek(self: *Vm, n: i64) Value = {
    self.stack_top.offset(-1 - n)[]
}

fn reset_stack(self: *Vm) void = {
    self.stack_top = self.stack&.as_ptr();
}

fn runtime_error(self: *Vm, msg: Str) void = {
    @fmt(self.errors&, "Runtime Error: %", msg);
    each_rev self.frames& { frame |
        chunk := frame.function.chunk&;
        p := chunk.code&.as_ptr();
        i := p.ptr_diff(frame.ip);
        line := chunk.lines[i];
        @fmt(self.errors&, "\n[line %] in %", line, frame.function.name);
    };
}

::ptr_utils(u8);
::ptr_utils(Value);
