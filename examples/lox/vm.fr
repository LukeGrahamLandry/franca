Vm :: @struct(
    chunk: *Chunk,
    ip: *u8,
    stack: List(Value), // TODO: inline fixed size array
    stack_top: *Value,
    last_return: Value,
    gc: Alloc,
    objects: Value, // TODO: compiler bug make this *Obj
);

lox_alloc :: libc_allocator;
fn init_vm() Vm = {
    self := Vm.uninitialized(); // TODO: no uninit
    self.gc = lox_alloc;
    self.stack = list(stack_max, lox_alloc);  // EXTRA: grow stack
    self.objects.bits = null_object;
    self&.reset_stack();
    self
}

fn drop(self: *Vm) void = {
    // self.chunk.drop(); // TODO: but for now its always on the stack. 
    self.stack&.drop();
    self.free_objects();
}

InterpretResult :: @enum(Ok, CompileError, RuntimeError);

fn interpret(self: *Vm, source: Str) InterpretResult = {
    chunk: Chunk = init();
    ::if(InterpretResult);
    result := if(compile(self, source, chunk&)) {|
       self.interpret(chunk&)
    } {| InterpretResult.CompileError };
    chunk&.drop();
    result
}

fn interpret(self: *Vm, chunk: *Chunk) InterpretResult = {
    self.chunk = chunk;
    self.ip = chunk.code&.as_ptr();
    self.run()
}

fn run(self: *Vm) InterpretResult = {
    out := InterpretResult.RuntimeError;
    debug: List(u8) = list(lox_alloc);
    
    loop {|
        continue :: local_return;
        @if(::debug_trace_execution, {
            debug&.clear();
            @fmt(debug&, "         %", ""); // TODO: fix 'no trivial tuples'
            for(self.stack&.as_ptr(), self.stack_top) {slot|
                @fmt(debug&, "[ % ]", slot);
            };
            println(debug&.items());
        
            p := self.chunk[].code&.as_ptr();
            i := p.ptr_diff(self.ip);
            println(i);  // TODO: do these into the buffer as well 
            self.chunk.dis_inst(i);
        }, ());
        
        instruction := self.read_byte();
        
        // TODO: switch over incomplete enum like is is awkward because you can't use contextual field. 
        @switch(instruction) {
            @case(OpCode.Constant) => {
                constant := self.read_constant();
                self.push(constant);
            };
            @case(OpCode.Return) => {
                value := self.pop();
                self.last_return = value;
                @println("RET: %", value);
                return(.Ok);
            };
            @case(OpCode.Negate) => {
                val := self.pop();
                if(val.is_number().not()){|
                    self.runtime_error("Operand must be a number.");
                    return(.RuntimeError);
                };
                self.push(val.to_number().neg().to_value());
            };
            // TODO: without the ret type annotation you get err walkwip, but only when it couldn't find the function to call? so just need better error message. 
            @case(OpCode.Add) => {
                rhs := self.pop();
                lhs := self.pop();
                if rhs.is_number() {|
                    if !lhs.is_number() {|
                        self.runtime_error("Second operand must be a number.");
                        return(.RuntimeError);
                    };
                    result := add(lhs.to_number(), rhs.to_number()).to_value();
                    self.push(result);
                    continue();
                };
                
                if rhs.is_obj(ObjType.String) {|
                    if !lhs.is_obj(ObjType.String) {|
                        self.runtime_error("Second operand must be a string.");
                        return(.RuntimeError);
                    };
                    lhs := lhs.to_string();
                    rhs := rhs.to_string();
                    o := self.allocate_obj(ObjString, ObjType.String);
                    new := self.gc.alloc(u8, lhs.data.len + rhs.data.len);
                    new.slice(0, lhs.data.len).copy_from(lhs.data);
                    new.slice(lhs.data.len, new.len).copy_from(rhs.data);
                    o.data = new;
                    self.push(o.to_value());
                    continue();
                };
                
                self.runtime_error("Operands must be numbers or strings.");
                return(.RuntimeError);
            };
            @case(OpCode.Subtract) => binary_op(sub); 
            @case(OpCode.Multiply) => binary_op(mul); 
            @case(OpCode.Divide)   => binary_op(div);  
            @case(OpCode.Greater)  => binary_op(gt);  
            @case(OpCode.Less)     => binary_op(lt);  
            @case(OpCode.True)     => self.push(true_value);  
            @case(OpCode.False)    => self.push(false_value);  
            @case(OpCode.Nil)      => self.push(nil_value);  
            @case(OpCode.Not) => {
                val := self.pop();
                is_falsy :: fn(v: Value) bool = v.is_bool().and(=> v.to_bool().not()).or(v.is_nil()); 
                self.push(val.is_falsy().to_value());
            };
            @case(OpCode.Equal) => {
                rhs := self.pop();
                lhs := self.pop();
                self.push(lhs.eq(rhs).to_value());  // Don't care about NaN != NaN for now. 
            };
            @default => {
                println("bad opcode");
                return(.RuntimeError);
            };
        };
    };
    
    binary_op :: fn($op: OverloadSet) void => {
        // TODO: you can't put `Fn(Ty(f64, f64), f64)` as the argument type because it wont find the overload because it thinks the arg is a OverloadSet. 
        rhs := self.pop();
        lhs := self.pop();
        if(rhs.is_number().and(lhs.is_number()).not()){|
            self.runtime_error("Operands must be numbers.");
            return(.RuntimeError); // non-local returns baby~
        };
        result := op(lhs.to_number(), rhs.to_number()).to_value();
        self.push(result);
    };
    
    out
}

// TODO: I could expose the dereference and increment instruction but presumably if you want it to be fast you'd just use llvm anyway. 
#inline fn read_byte(self: *Vm) u8 = {
    b := self.ip[];
    self.ip = self.ip.offset(1);
    b
}

#inline fn read_constant(self: *Vm) Value = {
    // TODO: you can't put the type annotation that does the cast on the var or the call because then it changes the overload resolution. 
    index := self.read_byte();
    self.chunk.constants&.get(@as(i64) index.zext())
}

fn push(self: *Vm, value: Value) void = {
    self.stack_top[] = value;
    self.stack_top = self.stack_top.offset(1);
}

fn pop(self: *Vm) Value = {
    self.stack_top = self.stack_top.offset(1.neg());
    self.stack_top[]
}

fn reset_stack(self: *Vm) void = {
    self.stack_top = self.stack&.as_ptr();
}

fn runtime_error(self: *Vm, msg: Str) void = {
    p := self.chunk.code&.as_ptr();
    i := p.ptr_diff(self.ip);
    line := self.chunk.lines[i];
}

// TODO: EXTRA: store the data contiguously with the ObjString header
// TODO: EXTRA: track which strings are constant-ish so don't free them
fn copy_string(self: *Vm, s: Str) *ObjString = {
    o := self.allocate_obj(ObjString, ObjType.String);
    new := self.gc.alloc(u8, s.len);
    new.copy_from(s);
    o.data = new;
    o
}

::ptr_utils(u8);
::ptr_utils(Value);
