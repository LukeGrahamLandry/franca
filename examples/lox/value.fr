Value :: Unique(i64);

// TODO: better error message if you forget the format string in @fmt
// TODO: higher prevision float rendering 
fn display(self: *Value, out: *List(u8)) Unit = self[].display(out);
fn display(self: Value, out: *List(u8)) Unit = {
    if(self.is_nil(), => "nil".display(out)) {|
        if(self.is_bool(), => self.to_bool().display(out)) {|
            if(self.is_number(), => self.to_number().display(out)) {|
                "~~BAD_VALUE~~".display(out)
            }
        }
    }
}

qnan        : i64   : 0x7ffc000000000000;
nil_value   : Value : @as(i64) 1.bit_or(qnan);
false_value : Value : @as(i64) 2.bit_or(qnan);
true_value  : Value : @as(i64) 3.bit_or(qnan);

#inline fn to_value(self: f64) Value = @as(Value) @as(i64) self.bitcast();
#inline fn to_value(self: bool) Value = if(self, => true_value, => false_value);

#inline fn is_number(self: Value) bool = (@as(i64) self).bit_and(qnan).ne(qnan);
#inline fn is_bool(self: Value) bool = self.eq(true_value).or(self.eq(false_value));
#inline fn is_nil(self: Value) bool = self.eq(nil_value);

#inline fn to_bool(self: Value) bool = self.eq(true_value);
#inline fn to_number(self: Value) f64 = (@as(i64) self).bitcast();

#redirect(Ty(i64, i64), bool) fn eq(lhs: Value, rhs: Value) bool;

ObjType :: @enum(String, _temp);
Obj :: @struct(
    type: ObjType,
    next: *Obj, // TODO: i can't do this yet...
);

ObjString :: @struct(
    obj: Obj,
    s: Str,
);

::if(Value);
