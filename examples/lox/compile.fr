
Parser :: @struct(scanner: Scanner, current: Token, previous: Token, had_error: bool);

fun compile(source: Str, chunk: *Chunk) bool = {
    self: Parser = (scanner = init(source), current = ()!uninitialized, previous = ()!uninitialized, had_error = false);
    self&.advance();
    self.had_error = true; // TODO: temp! just need to make it not try to run the chunk before ive put anything in it. 
    self.had_error
}

fn advance(self: *Parser) Unit = {
    self.previous = self.current;
    (=> {
        // TODO: wraping the loop in a lambda like this looks really dumb. 
        //       have an overload that passes you break. but then need type inference on closure args 
        //       so it isn't super painful. 
        break :: __return;
        loop {()Unit|
            self.current = self.scanner&.next();
            println(self.current.lexeme);
            if(self.current.type.eqq(TokenType.Error).not(), => { break(); });
            self.error_at(self.current, "");
        };
    })();
}

fn error(self: *Parser, msg: Str) Unit = self.error_at(self.previous, msg);
fn error_at(self: *Parser, token: Token, msg: Str) Unit = {
    self.had_error = true;
    // TODO: render lex err vs eof vs normal token differently
    @println("[line %] Error: % at %", token.line, msg, token.lexeme);
}

fn unreachable() Never = panic("Entered unreachable code.");
