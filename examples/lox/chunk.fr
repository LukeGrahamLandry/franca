Chunk  :: @struct(
    code: List(u8),
    constants: List(Value),
    lines: List(i64),
);

// TODO: auto inc with specific type. 
// TODO: EXTRA: seperate ne/le/ge opcodes. 
OpCode :: @enum(u8) (
    Return = 0,
    Constant = 1,
    Negate = 2,
    Add = 3,
    Subtract = 4,
    Multiply = 5,
    Divide = 6,
    True = 7,
    False = 8, 
    Nil = 9,
    Not = 10,
    Equal = 11,
    Less = 12,
    Greater = 13,
);

lox_alloc :: libc_allocator;
fn init() Chunk = (code = list(lox_alloc), constants = list(lox_alloc), lines = list(lox_alloc));
fn push(self: *Chunk, b: OpCode, line: i64) void = self.push((@as(u8) b).zext(), line); // TODO: .as_raw() on enums
fn push(self: *Chunk, b: i64, line: i64) void = {
    self.code&.push(@as(u8) b.trunc()); // TODO: real u8 type and auto convert literals
    self.lines&.push(line);
}

fn push(self: *Chunk, b: Value) i64 = {
    self[].constants&.push(b);
    // EXTRA(1): add OP_CONSTANT_LONG that uses two byte index when len > 256. 
    self[].constants.len.sub(1)
}

fn drop(self: *Chunk) void = {
    self[].code&.drop(); 
    self[].constants&.drop(); 
    self[].lines&.drop();
}

fn disassemble(self: *Chunk, name: Str) void = {
    @println("=== % ===", name);
    offset := 0;
    dowhile {|
        offset = offset.add(self.dis_inst(offset));
        offset.lt(self[].code.len)
    };   
    println("===");
}

// TODO: buffer this. need to make it easier to @fmt new line. do escape codes. 
fn dis_inst(self: *Chunk, i: i64) i64 = {
    // TODO: why doesn't this work as a closure that captures 'i'
    //       probably cause its through a macro and result doesnt work out? 
    simple :: fn(i: i64, n: Str) i64 => {
        @println("  - %: %", i, n);  // TODO: format with align like printf can. 
        1
    };
    
    line := self[].lines.get(i); // TODO: print line info and leave blank if it didn't change from the last time. 
    changed := i.gt(0).and(fn() bool => self[].lines.get(i.sub(1)).ne(line));
    
    @switch(self.code.get(i)) {
        @case(OpCode.Return)   => simple(i, "Return");
        @case(OpCode.Negate)   => simple(i, "Negate");
        @case(OpCode.Add)      => simple(i, "Add");
        @case(OpCode.Subtract) => simple(i, "Subtract");
        @case(OpCode.Multiply) => simple(i, "Multiply");
        @case(OpCode.Divide)   => simple(i, "Divide");
        @case(OpCode.Constant) => {
            val_i := self.code.get(i.add(1));
            val := self.constants.get(val_i.zext());
            @println("  - %: % %         %", i, "Constant", val_i, val&);
            2
        };
        @case(OpCode.True)    => simple(i, "True");
        @case(OpCode.False)   => simple(i, "False");
        @case(OpCode.Nil)     => simple(i, "Nil");
        @case(OpCode.Not)     => simple(i, "Not");
        @case(OpCode.Equal)   => simple(i, "Equal");
        @case(OpCode.Less)    => simple(i, "Less");
        @case(OpCode.Greater) => simple(i, "Greater");
        @default              => simple(i, "???");
    }
}

fn display(self: u8, out: *List(u8)) void = display(@as(i64) self.zext(), out);
