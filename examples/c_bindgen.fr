CDecl :: @tagged(
    Struct: @struct(name: Str, fields: List(CField)),
    Enum: @struct(name: ?Str, items: List(CEnumItem)),
    Func: @struct(name: Str, type: Str, args: List(CField)),
);

CField :: @struct(name: Str, type: Str);
CEnumItem :: @struct(name: Str, value: Str);

#include_std("lib/x/json.fr");
#include_std("lib/core.fr");

fn main() void = {
    // clang -Xclang -ast-dump=json bindings/sokol/sokol_app.h > target/ast.json
    // TODO: only show message if file not there. 
    println("Don't forget to create 'target/ast.json' (dump from clang)");
    ast := temp().read_to_string("target/ast.json");  
    //ast := temp().read_to_string("target/sokol.json");  
    json: JsonParser = new_json(ast.items(), temp());
    :: Result(JsonPart, Str);
    :: tagged(JsonPart);
    
    // Get to the good bit
    (fn() => {
        break :: local_return;
        loop {|
            part := json&.next().unwrap();
            if part&.is(.Key) && (part.Key == "inner") {|
                break();
            };
        };
    })();
    
    loop {|
        continue :: local_return;
        part := json&.next().unwrap();
        //@println("%", part&.tag());
        //println(json.cursor);
        @match(part) {
            fn Eof() => exit(0);
            fn Key(name) => {
                skip_to_tag :: fn(key: Str, tag: JsonPart.Tag()) JsonPart => {
                    res := json&.skip_until_key(key);
                    if(res&.is_err(), => panic(res.Err));
                    value := json&.next().unwrap();
                    @assert(value&.is(tag), "expected % '%'", tag, key);
                    value
                };
                
                skip_to_string :: fn(key: Str) Str => {
                    value := skip_to_tag(key, .StringValue);
                    value.StringValue
                };
                
                if name == "kind" {|
                    value := json&.next().unwrap();
                    assert(value&.is(.StringValue), "expected tag");
                    @switch(value.StringValue) {
                        @case("RecordDecl") => {
                            res := json&.skip_until_key("name");
                            if(res&.is_err(), => continue()); // some stuff doesn't have a name... idk bro. 
                            value := json&.next().unwrap();
                            assert(value&.is(.StringValue), "expected name string");
                            @println("Struct named %", value.StringValue);
                            
                            skip_to_tag("inner", .StartList);
                            
                            dowhile {|
                                value := json&.next().unwrap();
                                if value&.is(.StartDict) {|
                                    kind := skip_to_string("kind");
                                    @assert_eq(kind, "FieldDecl");
                                    name := skip_to_string("name");
                                    skip_to_tag("type", .StartDict);
                                    type := skip_to_string("qualType");
                                    res := json&.skip_current_value();
                                    res.unwrap();
                                    @println("- field %: %", name, type);
                                    value := json&.next().unwrap();
                                    assert(value&.is(.End), "// TODO: skip_current_value should probably eat the End too?");
                                    true
                                } else {|
                                    false
                                }
                            }
                        };
                        @case("EnumDecl") => {
                        
                        };
                        @case("FunctionDecl") => {
                            name := skip_to_string("name");
                            skip_to_tag("type", .StartDict);
                            type := skip_to_string("qualType");
                            @println("Function named '%' with type '%'", name, type);
                        };
                        @default => {
                            json&.skip_current_value().unwrap();
                            continue();
                        };
                    };
                };
            }
            @default => ();  
        };
    };
}

// TODO: This is a copy paste from the one farm_game uses for sokol. 
//       I need a more declaritive way of describing how to build a c library. 
fn driver(vtable: *ImportVTable) void = {
    src := temp().read_to_string("examples/c_bindgen.fr");  // TODO: don't depend on cwd.
    comp := vtable.new_with_src(src.items(), default_build_options());
    ctx := vtable.with(comp);
    
    libs := ctx.empty_libs();
    libs&.intercept_imports();
    libs&.add_lib(wuffs_lib);
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    {vtable.compile_func}(comp, main_f, .Jit).unwrap();

    v := should_jit();
    if v {|
        ptr := {vtable.get_jitted_ptr}(comp, main_f).unwrap();
        {vtable.make_jitted_exec}(comp);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
        exit(0);
    };
    
    ir_text := {vtable.emit_llvm}((data = comp, vtable = vtable), temp(), @slice (main_f), .ExportWithNames);
    out := open_temp_file();
    for(ir_text&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());
    // TODO: this includes all the wuffs functions (like png, etc that i don't use) figure out how to make -flto work. :BLOAT
    args := libs&.get_aot_objects();
    args&.push_all(@slice ("-x", "ir", out&.s_name(), "-o", "bind.out", "-Os"));  
    @println("building aot exe: %", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "clang failed");
    out.remove(); // TODO: defer 
}

::display_slice(Str);

// TODO: compiler bug! if you try to just return(true/false) in those branches, 
//       it always returns the first branch. same if you use two ifs instead of switch. same either if you have blocks or just => return.
//        -- Jul 4 :FUCKED
fn should_jit() bool = {
    args := cli_args();
    for args { arg |
        s := arg.str();
        a: ?bool = .None;
        @switch(s) {
            @case("-aot") => {
                a = (Some = false);
            };
            @case("-jit") => {
                a = (Some = true);
            };
            @default => ();
        };
        if a {a|
            return(a);
        };
    };
    panic("Please pass -jit or -aot as an argument. (aot runs ~10x faster, dont forget to run the exe tho")
}
