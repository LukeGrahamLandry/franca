CDecl :: @tagged(
    Struct: @struct(name: Str, fields: List(CField)),
    Enum: @struct(name: ?Str, items: List(CEnumItem)),
    Func: @struct(name: Str, type: Str, args: List(CField)),
);

CField :: @struct(name: Str, type: Str);
CEnumItem :: @struct(name: Str, value: Str);

#include_std("lib/x/json.fr");
#include_std("lib/core.fr");

fn main() void = {
    // clang -Xclang -ast-dump=json bindings/sokol/sokol_app.h > target/ast.json
    // TODO: only show message if file not there. 
    println("Don't forget to create 'target/ast.json' (dump from clang)");
    ast := temp().read_to_string("target/ast.json");  
    //ast := temp().read_to_string("target/sokol.json");  
    json: JsonParser = new_json(ast.items(), temp());
    :: Result(JsonPart, Str);
    :: tagged(JsonPart);
    
    // Get to the good bit
    (fn() => {
        break :: local_return;
        loop {|
            part := json&.next().unwrap();
            if part&.is(.Key) && (part.Key == "inner") {|
                break();
            };
        };
    })();
    
    loop {|
        continue :: local_return;
        part := json&.next().unwrap();
        //@println("%", part&.tag());
        //println(json.cursor);
        @match(part) {
            (fn Eof() => {
                exit(0);
            }); //return());
            (fn Key(name) => {
                if name.eq("range").or(=> name == "loc").or(=> name == "id") {|
                    res := json&.skip_next_value();
                    res.unwrap();
                    continue();
                };
                if name == "kind" {|
                    value := json&.next().unwrap();
                    assert(value&.is(.StringValue), "expected tag");
                    @switch(value.StringValue) {
                        @case("RecordDecl") => {
                        
                        };
                        @case("EnumDecl") => {
                        
                        };
                        @case("FunctionDecl") => {
                        
                        };
                        @default => {
                            json&.skip_current_value().unwrap();
                            continue();
                        };
                    };
                    //@println("=== % ===", value.StringValue);
                } else {|
                    //@println("%: ", name);
                };
            });
            (fn StringValue(value) => {
                println(value);
            });
            @default => ();  
        };
    };
}

// TODO: This is a copy paste from the one farm_game uses for sokol. 
//       I need a more declaritive way of describing how to build a c library. 
fn driver(vtable: *ImportVTable) void = {
    src := temp().read_to_string("examples/c_bindgen.fr");  // TODO: don't depend on cwd.
    comp := vtable.new_with_src(src.items(), .Aarch64);
    ctx := vtable.with(comp);
    
    libs := ctx.empty_libs();
    libs&.intercept_imports();
    libs&.add_lib(wuffs_lib);
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    {vtable.compile_func}(comp, main_f, .Jit).unwrap();

    v := should_jit();
    if v {|
        ptr := {vtable.get_jitted_ptr}(comp, main_f).unwrap();
        {vtable.make_jitted_exec}(comp);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
        exit(0);
    };
    
    ir_text := {vtable.emit_llvm}((data = comp, vtable = vtable), temp(), @slice (main_f), .ExportWithNames);
    out := open_temp_file();
    for(ir_text&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());
    // TODO: this includes all the wuffs functions (like png, etc that i don't use) figure out how to make -flto work. :BLOAT
    args := libs&.get_aot_objects();
    args&.push_all(@slice ("-x", "ir", out&.s_name(), "-o", "bind.out", "-Os"));  
    @println("building aot exe: %", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "clang failed");
    out.remove(); // TODO: defer 
}

::display_slice(Str);

// TODO: compiler bug! if you try to just return(true/false) in those branches, 
//       it always returns the first branch. same if you use two ifs instead of switch. same either if you have blocks or just => return.
//        -- Jul 4 :FUCKED
fn should_jit() bool = {
    args := cli_args();
    for args { arg |
        s := arg.str();
        a: ?bool = .None;
        @switch(s) {
            @case("-aot") => {
                a = (Some = false);
            };
            @case("-jit") => {
                a = (Some = true);
            };
            @default => ();
        };
        if a {a|
            return(a);
        };
    };
    panic("Please pass -jit or -aot as an argument. (aot runs ~10x faster, dont forget to run the exe tho")
}
