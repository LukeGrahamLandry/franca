// this is an interpreter for a subset of the jinja templating language. 
// jinja spec: https://jinja.palletsprojects.com/en/stable/templates/
// i expect this will be :SLOW but i enjoy experimenting with different styles.
//
// see the end of the file for an example program. 
// implemented: 
// - with name=value %} body
// - if cond %} body
// - for it in items if cond %} body
// - "string".upper(), loop.index
// - obj.field, obj[field], field in obj, obj[field] is defined
// - +, ==, and
// - 123, "", {{ expr }}
// - include "file.jinja"
// parsed but unfinished: {-, else, macro, call, filter. 
// also there's no operator precedence.

::tagged_derive(KExpr);  // HACK: @rec
KExpr :: @rec @tagged(
    If: @struct(cond: *KExpr, then: *KExpr, else: *KExpr),
    With: @struct(var: Str, value: *KExpr, body: *KExpr),
    Call: @struct(callee: *KExpr, args: []Arg),
    Binary: @struct(op: Binary, lhs: *KExpr, rhs: *KExpr),
    Include: @struct(path: *KExpr),
    For: @struct(var: Str, list: *KExpr, cond: *KExpr, body: *KExpr),
    Filter: @struct(call: *KExpr, body: *KExpr),
    Concat: []*KExpr,
    Value: Value,
    IsDefined: *KExpr,
    GetVar: Str,
    Code: @struct(src: Str, kind: CodeKind),
    DeclareMacro: @struct(call: *KExpr, body: *KExpr),
    Tag: @struct(tag: Str, src: Str, body: []*KExpr),
    Method: @struct(receiver: *KExpr, call: *KExpr),
);
Arg :: @struct(name: Str, value: *KExpr);
::tagged_derive(Value);  // HACK: @rec
Value :: @rec @tagged(
    String: Str, 
    Number: i64, 
    Undefined, 
    Map: RawHashMap(Str, Value),
    List: RawList(Value),
    Macro: *Macro, 
);
Binary :: @enum(Plus, And, Index, Equal, In);
Macro :: @struct(args: Arg, body: *KExpr);
CodeKind :: @enum(Text, Tag, Expr, String);

Ctx :: @struct {
    variables: RawHashMap(Str, Value);
    arena: Alloc;
    sources: RawHashMap(Str, Str);
};

fn eval(c: *Ctx, e: *KExpr) Value = {
    @match(e) {
        fn Include(it) => {
            path := c.eval(it.path);
            @assert(path&.is(.String), "include %", path&);
            src := c.sources&.get(path.String)
                || @panic("bad include %", path&);
            e = c.expr(Code = (src = src, kind = .Text));
            c.eval(e)
        }
        fn Code(it) => {
            s := it.src;
            e := @match(it.kind) {
                fn Text() => {
                    parts := parse_top_level(it.src, c.arena);
                    parts := c.arena.alloc_init(*KExpr, parts.len, fn(i) => c.expr(Code = parts[i]));
                    c.expr(Concat = parts)
                }
                fn String() => c.expr(Value = (String = it.src));
                fn Expr() => {
                    e := c.parse_expr(s&);
                    @assert_eq(s.len, 0, "Expr didn't consume all: %", s);
                    e
                }
                fn Tag() => @panic("unreachable: tag wasn't consumed: %", it.src);
            };
            c.eval(e)
        };
        fn Tag(it) => {
            ee, body := c.parse_tag(it);
            c.eval(ee)
        }
        fn DeclareMacro(it) => {
            (String = "/*TODO:DeclareMacro*/\n")
        }
        fn Concat(parts) => {
            parts := parts.items().shallow_copy(c.arena);
            out := @ref u8.list(c.arena);
            enumerate parts { i, it |
                @if_let(it[]) fn Code(code) => if code.kind == .Tag {
                    eat_until_ending_tag(c, code.src, parts.rest(i));
                };
                
                it := c.eval(it[]);
                @match(it) {
                    fn String(it) => out.push_all(it);
                    fn Number(it) => @fmt(out, "%", it);
                    @default => @panic("concat %", it&);
                };
            };
            (String = out.items())
        };
        fn Value(it) => it[];
        fn With(it) => {
            value := c.eval(it.value);
            prev := c.variables&.insert(it.var, value, c.arena);
            result := c.eval(it.body);
            if prev { prev |
                c.variables&.insert(it.var, prev, c.arena);
            };
            result
        }
        fn For(it) => {  // :SLOW
            collection := c.eval(it.list);
            @assert(collection&.is(.List), "For %", collection&.tag());
            collection := collection.List;
            out := @ref list(*KExpr, c.arena);
            enumerate collection { i, item |
                loop: HashMap(Str, Value) = init(c.arena);
                loop&.insert("index", (Number = i + 1));
                body := c.expr(If = (cond = it.cond, then = it.body, else = c.expr(Value = (String = ""))));
                body := c.expr(With = (var = it.var, value = c.expr(Value = item[]), body = body));
                body := c.expr(With = (var = "loop", value = c.expr(Value = (Map = loop.raw)), body = body));
                out.push(body);
            };
            e := c.expr(Concat = out.items());
            c.eval(e)
        }
        fn If(it) => {
            cond := c.eval(it.cond);
            @assert(cond&.is(.Number), "If cond %", cond&.tag());
            e := @if(cond.Number != 0, it.then, it.else);
            c.eval(e)
        }
        fn GetVar(it) => {
            value := c.variables&.get(it);
            value || Value.Undefined
        }
        fn IsDefined(it) => {
            it := c.eval(it[]);
            (Number = int(!it&.is(.Undefined)))
        }
        fn Binary(it) => {
            lhs := c.eval(it.lhs);
            @match(it.op) {
                fn Index() => {
                    obj := lhs;
                    index := c.eval(it.rhs);
                    @match(obj) {
                        fn List(it) => {
                            @assert_eq(index&.tag(), .Number, "tried to index list");
                            list := obj.List;
                            @assert(index.Number.ult(list.len), "index oob %/%", index.Number, list.len);
                            list[index.Number]
                        }
                        fn Map(it) => {
                            @assert_eq(index&.tag(), .String, "tried to index map");
                            value := it&.get(index.String);
                            value || Value.Undefined
                        }
                        @default => @panic("% is not indexable", obj&.tag());
                    }
                }
                fn Equal() => {
                    rhs := c.eval(it.rhs);
                    @assert(!lhs&.is(.Undefined) && !rhs&.is(.Undefined), "undefined ==");
                    value := equal(lhs&, rhs&);
                    (Number = int(value))
                }
                fn And() => {
                    @assert(lhs&.is(.Number), "and %", lhs&);
                    @if(lhs.Number == 0) return(lhs);
                    c.eval(it.rhs)
                }
                fn Plus() => {
                    rhs := c.eval(it.rhs);
                    @assert_eq(lhs&.tag(), rhs&.tag(), "polymorphic plus");
                    @match(lhs) {
                        fn Number(lhs) => (Number = lhs + rhs.Number);
                        fn String(lhs) => (String = items(@format("%%", lhs, rhs.String) c.arena));
                        @default => @panic("TODO: % + %", lhs&, rhs&);
                    }
                }
                fn In() => {
                    index := lhs;
                    obj := c.eval(it.rhs);
                    
                    value := @match(obj) {
                        fn List(it) => it.contains(fn(it) => equal(it, index&));
                        fn Map(it) => {
                            @assert_eq(index&.tag(), .String, "tried to index map");
                            it&.get(index.String).is_some()
                        }
                        @default => @panic("% is not indexable", obj&.tag());
                    };
                    (Number = int(value))
                }
            }
        }
        fn Method(it) => {
            @assert(it.call.is(.Call), "method call %", it.call.tag());
            @assert(it.call.Call.callee.is(.GetVar), "method var");
            method_name := it.call.Call.callee.GetVar;
            receiver := c.eval(it.receiver);
            @assert(method_name == "upper" && receiver&.is(.String), "method upper");
            s := receiver.String;
            out := c.arena.alloc_init(u8, s.len, fn(i) => s[i].ascii_to_upper());
            (String = out)
        }
        fn Filter(it) => (String = "/*TODO:filter*/");
        fn Call(it) => (String = "/*TODO:call*/");
    }
}

fn equal(lhs: *Value, rhs: *Value) bool = {
    @assert(!lhs.is(.Undefined) && !rhs.is(.Undefined), "undefined ==");
    @if(lhs.tag() != rhs.tag()) return(false);
    @match(lhs) {
        fn String(lhs) => lhs[] == rhs.String;
        fn Number(lhs) => lhs[] == rhs.Number;
        @default => @panic("TODO: eq %", lhs.tag());
    }
}

fn eat_until_ending_tag(c: *Ctx, src: Str, parts: []*KExpr) void = {
    root := parts[0]&;
    parts := parts.rest(1);

    start_tag, start_expr_i := eat_tag(src);
    @switch(start_tag) {
        @case("include") => {
            src := src.rest(start_expr_i);
            path := c.parse_expr(src&);
            root[] = c.expr(Include = (path = path));
            return();
        }
        @case("else") => {
            root[] = c.expr(Value = (String = "/*TODO:else*/"));
            return();
        }
        @default => ();
    };

    enumerate parts { i, it |
        it := it[];
        @if_let(it) fn Code(code) => if code.kind == .Tag {
            end_tag, _ := eat_tag(code.src);
            if end_tag.starts_with("end") {
                @assert_eq(end_tag.rest(3), start_tag, "malformed input: bad nesting");
                old_body := parts.slice(0, i);
                body := old_body.shallow_copy(c.arena);
                old_body.len += 1;  // include ending tag in range to remove.
                each old_body { it |
                    it[] = c.expr(Value = (String = ""));
                };
                root[] = c.expr(Tag = (tag = start_tag, src = src.rest(start_expr_i), body = body));
                return();
            } else {
                c.eat_until_ending_tag(code.src, parts.rest(i));
            };
        };
    };
    @panic("unclosed tag %", start_tag);
}

fn parse_tag(c: *Ctx, it: *get_variant_type(KExpr, .Tag)) Ty(*KExpr, *KExpr) = {
    body := c.expr(Concat = it.body);
    src := it.src;
    e := @switch(it.tag) {
        @case("if") => {
            cond := c.parse_expr(src&);
            c.expr(If = (
                cond = cond, 
                then = body, 
                else = c.expr(Concat = empty()),
            ))
        };
        @case("for") => {
            name := token(src&);
            @assert_eq(name.type, .Ident, "for var");
            in := token(src&);
            @assert(in.type == .Ident && in.s == "in", "expected 'in' after 'for %'", name.s);
            list := c.parse_expr(src&);
            cond := @if(src.starts_with("if"), {
                _ := token(src&);
                c.parse_expr(src&)
            }, c.expr(Value = (Number = 1)));
            c.expr(For = (
                var = name.s,
                cond = cond, 
                list = list, 
                body = body,
            ))
        };
        @case("macro") => {
            call := c.parse_expr(src&);
            c.expr(DeclareMacro = (
                call = call,
                body = body,
            ))
        };
        @case("filter") => {
            c.expr(Filter = (
                call = c.parse_expr(src&), 
                body = body,
            ))
        };
        @case("with") => {
            name := token(src&);
            @assert_eq(name.type, .Ident, "with var");
            in := token(src&);
            @assert(in.type == .Punct && in.s == "=", "expected '=' after 'with %'", name.s);
            c.expr(With = (
                var = name.s,
                value = c.parse_expr(src&),
                body = body,
            ))
        };
        @default => @panic("invalid tag: %", it.tag);
    };
    t := token(src&);
    @assert(t.s == "-" || t.s == "+" || t.s == "", "tag not fully consumed: % %", t.s, src);
    @assert(src.len == 0, "tag not fully consumed: % %", t.s, src);
    (e, body)
}

fn parse_expr(c: *Ctx, src: *Str) *KExpr = {
    t := token(src);
    e := @match(t.type) {
        fn Ident() => c.expr(GetVar = t.s);
        fn Int() => c.expr(Value = (Number = t.s.parse_int()));
        fn String() => c.expr(Value = (String = t.s));
        fn Punct() => {
            @assert_eq(t.s, "(", "expected prefix operator");
            e := c.parse_expr(src);
            t := token(src);
            @assert_eq(t.s, ")", "closing");
            e
        }
        @default => @panic("TODO: parse % %", t.type, t.s);
    };
    loop {
        @if(src.len == 0) return(e);
        @switch(src[0]) {
            @case("=".ascii()) => {
                @if(!src[].starts_with("==")) return(e);
                src[] = src[].rest(2);
                e = c.expr(Binary = (op = .Equal, lhs = e, rhs = c.parse_expr(src)));
            };
            @case("+".ascii()) => {
                _ := token(src);
                e = c.expr(Binary = (op = .Plus, lhs = e, rhs = c.parse_expr(src)));
            };
            @case("|".ascii()) => {
                _ := token(src);
                e = c.expr(Filter = (call = c.parse_expr(src), body = e));
            };
            @case("[".ascii()) => {
                _ := token(src);
                index := c.parse_expr(src);
                t := token(src);
                @assert_eq(t.s, "]", "close index");
                e = c.expr(Binary = (op = .Index, lhs = e, rhs = index));
            };
            @case(".".ascii()) => {
                _ := token(src);
                old_src := src[];
                t := token(src);
                @assert_eq(t.type, .Ident, "field name");
                if src.len > 0 && src[0] == "(".ascii() {
                    call := c.parse_expr(old_src&);
                    src[] = old_src;
                    e = c.expr(Method = (receiver = e, call = call));
                } else {
                    e = c.expr(Binary = (op = .Index, lhs = e, rhs = c.expr(Value = (String = t.s))));
                }
            };
            @case("(".ascii()) => {
                _ := token(src);
                args := @ref Arg.list(c.arena);
                while => !src[].starts_with(")") {
                    name := c.parse_expr(src);
                    if name.tag() == .GetVar && src[0] == "=".ascii() {
                        _ := token(src);
                        value := c.parse_expr(src);
                        args.push(name = name.GetVar, value = value);
                    } else{
                        args.push(name = "", value = name);
                    };
                    if src[0] == ",".ascii() {
                        _ := token(src);
                    };
                };
                _ := token(src);
                e = c.expr(Call = (callee = e, args = args.items()));
            };
            @case("i".ascii()) => @if_else {
                @if(src[].starts_with("is defined")) => {
                    _ := token(src);
                    _ := token(src);
                    e = c.expr(IsDefined = e);
                };
                @if(src[].starts_with("in")) => {
                    _ := token(src);
                    list := c.parse_expr(src);
                    e = c.expr(Binary = (op = .In, lhs = e, rhs = list));
                };
                @else => return(e);
            };
            @case("a".ascii()) => {
                if !src[].starts_with("and") {
                    return e;
                };
                _ := token(src);
                e = c.expr(Binary = (op = .And, lhs = e, rhs = c.parse_expr(src)));
            };
            @default => return(e);
        };
    }
}

eat_tag :: fn(src: Str) Ty(Str, i64) = {
    step := int("-=".contains(src[0]));
    src := src.rest(step);
    s, i := eat_ident(src);
    (s, i + step)
}

eat_ident :: fn(src: Str) Ty(Str, i64) = {
    i := 0;
    while => i < src.len && src[i].is_ascii_whitespace() {
        i += 1;
    };
    start := i;
    while => i < src.len && (src[i].is_ascii_alpha() || src[i] == "_".ascii()) {
        i += 1;
    };
    (src.slice(start, i), i)
}

fn parse_top_level(src: Str, a: Alloc) []get_variant_type(KExpr, .Code) = {
    parts := @ref list(get_variant_type(KExpr, .Code), a);
    i := 0;
    start_string := 0;
    while => i < src.len {
        paired_code("{%", "%}", .Tag);
        paired_code("{{", "}}", .Expr);
        if paired("{#", "#}") { string, _ |
            parts.push(src = string, kind = .String);
        };
        
        paired :: fn(a: Str, b: Str) ?Ty(Str, Str) => {
            yield :: local_return;
            if src.rest(i).starts_with(a) {
                string := src.slice(start_string, i);
                i += a.len;
                start := i;
                while => !src.rest(i).starts_with(b) {
                    i += 1;
                };
                code := src.slice(start, i);
                i += b.len;
                start_string = i;
                yield(Some = (string, code));
            };
            .None
        };
        
        paired_code :: fn(a: Str, b: Str, kind: CodeKind) => if paired(a, b) { string, code |
            parts.push(src = string, kind = .String);
            parts.push(src = code, kind = kind);
        };
        i += 1;
    };
    string := src.slice(start_string, i);
    parts.push(src = string, kind = .String);
    parts.items()
}

token :: fn(src: *Str) Tok = {
    t, s := eat_token(src[]);
    while => s.len > 0 && s[0].is_ascii_whitespace() {
        s = s.rest(1);
    };
    src[] = s;
    t
};

eat_token :: fn(src: Str) Ty(Tok, Str) = {
    i := 0;
    while => i < src.len && src[i].is_ascii_whitespace() {
        i += 1;
    };
    if i == src.len {
        return((type = .Eof, s = ""), "");
    };
    c := src[i];
    if ".-+=()[],|".contains(c) {
        i += 1;
        return((type = .Punct, s = src.slice(i-1, i)), src.rest(i));
    };
    if c.is_ascii_alpha() || c == "_".ascii() {
        s, i2 := eat_ident(src.rest(i));
        return((type = .Ident, s = s), src.rest(i+i2));
    };
    if "\"'".contains(c) {
        i += 1;
        start := i;
        while => i < src.len && src[i] != c {
            i += 1;
        };
        return((type = .String, s = src.slice(start, i)), src.rest(i+1));
    };
    if c.is_ascii_digit() {
        start := i;
        while => i < src.len && src[i].is_ascii_digit() {
            i += 1;
        };
        return((type = .Int, s = src.slice(start, i)), src.rest(i));
    };
    @panic("TODO: unexpected char %", src.slice(i, i+1));
}

Tok :: @struct {
    type: @enum(Ident, String, Punct, Int, Equals, Eof);
    s: Str;
};

fn expr(c: *Ctx, e: KExpr) *KExpr = 
    c.arena.boxed(KExpr, e);

load_json :: fn(src: Str, a: Alloc) Value = {
    #use("@/lib/encoding/json.fr");
    json: JsonParser = new_json(src, a);
    part := json&.next().unwrap();
    value := load(json&, part, a);
    part := json&.next().unwrap();
    @assert(part&.is(.Eof), "more after json");
    return value;
    
    load :: fn(json: *JsonParser, part: JsonPart, a: Alloc) Value = {
        @match(part) {
            fn StartDict() => {
                out: HashMap(Str, Value) = init(a);
                part := json.next().unwrap();
                while => !part&.is(.End) {
                    @assert(part&.is(.Key), "expected key in json");
                    key := part.Key;
                    part = json.next().unwrap();
                    value := load(json, part, a);
                    out&.insert(key, value);
                    part = json.next().unwrap();
                };
                (Map = out.raw)
            }
            fn StartList() => {
                out := Value.list(a);
                part := json.next().unwrap();
                while => !part&.is(.End) {
                    value := load(json, part, a);
                    out&.push(value);
                    part = json.next().unwrap();
                };
                (List = out.as_raw())
            }
            fn Null() => (.Undefined);
            fn Float(it) => (Number = it.int());
            fn BoolValue(it) => (Number = it.int());
            fn StringValue(it) => return(String = it);
            @default => @panic("invalid json %", part&.tag());
        }
    };
}

fn display(value: *Value, out: *List(u8)) void = {
    @match(value) {
        fn Number(it) => @fmt(out, "%", it[]);
        fn String(it) => @fmt(out, "\"%\"", it[]);
        fn Undefined() => @fmt(out, "undefined");
        fn Macro() => @fmt(out, "<macro>");
        fn List(it) => {
            @fmt(out, "[");
            each it { it |
                display(it, out);
                @fmt(out, ", ");
            };
            @fmt(out, "]");
        }
        fn Map(it) => {
            @fmt(out, "{");
            each it { key, it |
                @fmt(out, "%: ", key);
                display(it, out);
                @fmt(out, ", ");
            };
            @fmt(out, "}");
        }
    }
}

#use("@/lib/collections/map.fr");

main :: fn() void = {
    a := temp();
    start := "input.jinja";
    sources: HashMap(Str, Str) = init(a);
    sources&.insert(start, SRC);
    arg := load_json(ARG, a);
    c: Ctx = (
        variables = init(),
        arena = a,
        sources = sources.raw,
    ); c := c&;
    arg := c.expr(Value = arg);
    e := c.expr(Value = (String = start));
    e := c.expr(Include = (path = e));
    e := c.expr(With = (var = "args", value = arg, body = e));
    s := c.eval(e);
    @assert(s&.is(.String));
    @assert_eq(s.String, EXPECT);
    @print("[ok] SRC(ARG) == EXPECT\n");
}

// example input
ARG :: """{
    "foo": [2, 3], 
    "bar": { "N": 3 },
    "t": true,
}""";
SRC :: """
1
{% for it in args.foo if (args.foo[1] == 3) and (loop.index is defined) and args.t %}
{{ it }}
{% endfor %}
{% with two=2 %}
{% if (two in args.foo) and (("n".upper()) in args.bar) and (args["f" + "oo"][0] is defined) %}
{{ args.bar.N + 1 }}
{% endif %}
{% endwith %}
""";
EXPECT :: "\n1\n\n2\n\n3\n\n\n\n4\n\n\n";
