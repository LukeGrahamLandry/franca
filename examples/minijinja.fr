// this is an interpreter for a subset of the jinja templating language. 
// jinja spec: https://jinja.palletsprojects.com/en/stable/templates/
// i want to compile curl from source without depending on a python interpreter.
// curl uses mbedtls which uses tf-psa-crypto which uses jinja to generate c code.
// my goal for this program is to be shorter than the real jinja's uv.lock file (1244 lines). 
// i expect this will be :SLOW but i enjoy experimenting with different styles.

main :: fn() void = {
    paths := @slice(
        "/Users/luke/Downloads/mbedtls-7294fc1c1a3c5e0641fdc7dcdc7c9d9c716a4c4e/tf-psa-crypto/scripts/data_files/driver_templates/psa_crypto_driver_wrappers.h.jinja",
        "/Users/luke/Downloads/mbedtls-7294fc1c1a3c5e0641fdc7dcdc7c9d9c716a4c4e/tf-psa-crypto/scripts/data_files/driver_templates/psa_crypto_driver_wrappers_no_static.c.jinja",
        "/Users/luke/Downloads/mbedtls-7294fc1c1a3c5e0641fdc7dcdc7c9d9c716a4c4e/tf-psa-crypto/scripts/data_files/driver_templates/OS-template-opaque.jinja",
        "/Users/luke/Downloads/mbedtls-7294fc1c1a3c5e0641fdc7dcdc7c9d9c716a4c4e/tf-psa-crypto/scripts/data_files/driver_templates/OS-template-transparent.jinja",
    );
    a: Arena.Allocator = init(general_allocator(), 4096);
    for paths { path |
        c: Ctx = (
            variables = init(),
            arena = a&.borrow(),
        );
        println(path);
        src := read_entire_file_or_crash(temp(), path);
        e := c&.expr(Code = (src = src, kind = .Text));
        s := c&.eval(e);
        @assert(s&.is(.String));
        println(s.String);
        a&.reset_retaining_capacity();
    };
    a&.deinit();
}

::tagged_derive(KExpr);  // HACK: @rec
KExpr :: @rec @tagged(
    If: @struct(cond: *KExpr, then: *KExpr, else: *KExpr),
    With: @struct(var: Str, value: *KExpr, body: *KExpr),
    Call: @struct(callee: *KExpr, args: []Arg),
    Binary: @struct(op: Binary, lhs: *KExpr, rhs: *KExpr),
    Include: @struct(path: Str),
    For: @struct(var: Str, list: *KExpr, cond: *KExpr, body: *KExpr),
    Filter: @struct(call: *KExpr, body: *KExpr),
    Concat: []*KExpr,
    Value: Value,
    IsDefined: *KExpr,
    GetVar: Str,
    Code: @struct(src: Str, kind: CodeKind),
    DeclareMacro: @struct(call: *KExpr, body: *KExpr),
    Tag: @struct(tag: Str, src: Str, body: []*KExpr, depth: i64 /*temporary*/),
    Method: @struct(receiver: *KExpr, call: *KExpr),
);
Arg :: @struct(name: Str, value: *KExpr);
::tagged_derive(Value);  // HACK: @rec
Value :: @rec @tagged(
    String: Str, 
    Number: i64, 
    Undefined, 
    Map: RawHashMap(Str, Value),
    List: RawList(Value),
    Macro: *Macro, 
    RealString: Str, /*temporary for debugging. eventually just String*/
);
Binary :: @enum(Plus, And, Index, Equal);
Macro :: @struct(args: Arg, body: *KExpr);
CodeKind :: @enum(Text, Tag, Expr);

Ctx :: @struct {
    variables: RawHashMap(Str, Value);
    arena: Alloc;
    depth := 0;
};

fn eval(c: *Ctx, e: *KExpr) Value = {
    @match(e) {
        fn Code(it) => {
            s := it.src;
            e := @match(it.kind) {
                fn Text() => c.parse_top_level(it.src);
                fn Expr() => {
                    _ := c.parse_expr(s&);
                    @assert_eq(s.len, 0, "Expr didn't consume all: %", s);
                    return(String = @tfmt("$%$\n", it.src))
                }
                fn Tag() => @panic("unreachable: tag wasn't consumed: %", it.src);
            };
            c.eval(e)
        };
        fn Tag(it) => {
            ee, body := c.parse_tag(it);
            e := c.arena.alloc_uninit(*KExpr, 3);
            pad := temp().alloc_init(u8, it.depth, fn(_) => " ".ascii());
            e[0] = c.expr(Value = (String = @tfmt("%begin % %\n", pad, it.tag, it.src)));
            e[1] = body;
            e[2] = c.expr(Value = (String = @tfmt("%end %\n", pad, it.tag)));
            e := c.expr(Concat = e);
            c.eval(e)
        }
        fn Concat(parts) => {
            parts := parts.items().shallow_copy(c.arena);
            out := @ref u8.list(c.arena);
            enumerate parts { i, it |
                @if_let(it[]) fn Code(code) => if code.kind == .Tag {
                    eat_until_ending_tag(c, code.src, parts.rest(i));
                };
                
                it := c.eval(it[]);
                @assert(it&.is(.String));
                out.push_all(it.String);
            };
            (String = out.items())
        };
        fn Value(it) => {
            @if_let(it) fn RealString(s) => {
                return(String = @tfmt("S(%)\n", s.len));
            }
            it[]
        };
        @default => @panic("TODO: eval(%)", e.tag());
    }
}

fn eat_until_ending_tag(c: *Ctx, src: Str, parts: []*KExpr) void = {
    root := parts[0]&;
    parts := parts.rest(1);

    start_tag, start_expr_i := eat_tag(src);
    single_tags := @const_slice("else", "include");
    if single_tags.contains(start_tag) {
        root[] = c.expr(Value = (String = @tfmt("KW(%)\n", src)));
        return();
    };

    c.depth += 1;
    enumerate parts { i, it |
        it := it[];
        @if_let(it) fn Code(code) => if code.kind == .Tag {
            end_tag, _ := eat_tag(code.src);
            if end_tag.starts_with("end") {
                @assert_eq(end_tag.rest(3), start_tag, "malformed input: bad nesting");
                old_body := parts.slice(0, i);
                body := old_body.shallow_copy(c.arena);
                old_body.len += 1;  // include ending tag in range to remove.
                each old_body { it |
                    it[] = c.expr(Value = (String = ""));
                };
                root[] = c.expr(Tag = (tag = start_tag, src = src.rest(start_expr_i), body = body, depth = c.depth));
                c.depth -= 1;
                return();
            } else {
                c.eat_until_ending_tag(code.src, parts.rest(i));
            };
        };
    };
    @panic("unclosed tag %", start_tag);
}

fn parse_tag(c: *Ctx, it: *get_variant_type(KExpr, .Tag)) Ty(*KExpr, *KExpr) = {
    body := c.expr(Concat = it.body);
    src := it.src;
    @println("TAG[%][%]", it.tag, src);
    e := @switch(it.tag) {
        @case("if") => {
            cond := c.parse_expr(src&);
            c.expr(If = (
                cond = cond, 
                then = body, 
                else = c.expr(Concat = empty()),
            ))
        };
        @case("for") => {
            name := token(src&);
            @assert_eq(name.type, .Ident, "for var");
            in := token(src&);
            @assert(in.type == .Ident && in.s == "in", "expected 'in' after 'for %'", name.s);
            list := c.parse_expr(src&);
            cond := @if(src.starts_with("if"), {
                _ := token(src&);
                c.parse_expr(src&)
            }, c.expr(Value = (Number = 1)));
            c.expr(For = (
                var = name.s,
                cond = cond, 
                list = list, 
                body = body,
            ))
        };
        @case("macro") => {
            call := c.parse_expr(src&);
            c.expr(DeclareMacro = (
                call = call,
                body = body,
            ))
        };
        @case("filter") => {
            c.expr(Filter = (
                call = c.parse_expr(src&), 
                body = body,
            ))
        };
        @case("with") => {
            name := token(src&);
            @assert_eq(name.type, .Ident, "with var");
            in := token(src&);
            @assert(in.type == .Punct && in.s == "=", "expected '=' after 'with %'", name.s);
            c.expr(With = (
                var = name.s,
                value = c.parse_expr(src&),
                body = body,
            ))
        };
        @default => @panic("invalid tag: %", it.tag);
    };
    t := token(src&);
    @assert(t.s == "-" || t.s == "+" || t.s == "", "tag not fully consumed: % %", t.s, src);
    @assert(src.len == 0, "tag not fully consumed: % %", t.s, src);
    (e, body)
}

fn parse_expr(c: *Ctx, src: *Str) *KExpr = {
    @println("PARSE(%)", src[]);
    t := token(src);
    e := @match(t.type) {
        fn Ident() => c.expr(GetVar = t.s);
        fn Int() => c.expr(Value = (Number = t.s.parse_int()));
        fn String() => c.expr(Value = (String = t.s));
        fn Punct() => {
            @assert_eq(t.s, "(", "expected prefix operator");
            e := c.parse_expr(src);
            t := token(src);
            @assert_eq(t.s, ")", "closing");
            e
        }
        @default => @panic("TODO: parse % %", t.type, t.s);
    };
    loop {
        @println("LOOP(%)", src[]);
        @if(src.len == 0) return(e);
        @switch(src[0]) {
            @case("=".ascii()) => {
                @if(!src[].starts_with("==")) return(e);
                src[] = src[].rest(2);
                e = c.expr(Binary = (op = .Equal, lhs = e, rhs = c.parse_expr(src)));
            };
            @case("+".ascii()) => {
                _ := token(src);
                e = c.expr(Binary = (op = .Plus, lhs = e, rhs = c.parse_expr(src)));
            };
            @case("|".ascii()) => {
                _ := token(src);
                e = c.expr(Filter = (call = c.parse_expr(src), body = e));
            };
            @case("[".ascii()) => {
                _ := token(src);
                index := c.parse_expr(src);
                t := token(src);
                @assert_eq(t.s, "]", "close index");
                e = c.expr(Binary = (op = .Index, lhs = e, rhs = index));
            };
            @case(".".ascii()) => {
                _ := token(src);
                old_src := src[];
                t := token(src);
                @assert_eq(t.type, .Ident, "field name");
                if src.len > 0 && src[0] == "(".ascii() {
                    call := c.parse_expr(old_src&);
                    src[] = old_src;
                    e = c.expr(Method = (receiver = e, call = call));
                } else {
                    e = c.expr(Binary = (op = .Index, lhs = e, rhs = c.expr(Value = (String = t.s))));
                }
            };
            @case("(".ascii()) => {
                _ := token(src);
                args := @ref Arg.list(c.arena);
                while => !src[].starts_with(")") {
                    name := c.parse_expr(src);
                    if name.tag() == .GetVar && src[0] == "=".ascii() {
                        _ := token(src);
                        value := c.parse_expr(src);
                        args.push(name = name.GetVar, value = value);
                    } else{
                        args.push(name = "", value = name);
                    };
                    if src[0] == ",".ascii() {
                        _ := token(src);
                    };
                };
                _ := token(src);
                e = c.expr(Call = (callee = e, args = args.items()));
            };
            @case("i".ascii()) => @if_else {
                @if(src[].starts_with("is defined")) => {
                    _ := token(src);
                    _ := token(src);
                    e = c.expr(IsDefined = e);
                };
                @if(src[].starts_with("in")) => {
                    _ := token(src);
                    list := c.parse_expr(src);
                    e = c.expr(Binary = (op = .Index, lhs = list, rhs = e));
                    e = c.expr(IsDefined = e);
                };
                @else => return(e);
            };
            @case("a".ascii()) => {
                if !src[].starts_with("and") {
                    return e;
                };
                _ := token(src);
                e = c.expr(Binary = (op = .And, lhs = e, rhs = c.parse_expr(src)));
            };
            @default => return(e);
        };
    }
}

fn is_ending_tag(start_tag: Str, check: *KExpr) bool = {
    code := @match(check) {
        fn Code(it) => it;
        @default => return(false);
    };
    @if(code.kind != .Tag || code.src.len < 3) return(false);
    src := code.src;
    tag, i := eat_tag(src);
    @if(!tag.starts_with("end")) return(false);
    tag = tag.rest(3);
    tag == start_tag
}

eat_tag :: fn(src: Str) Ty(Str, i64) = {
    step := int("-=".contains(src[0]));
    src := src.rest(step);
    s, i := eat_ident(src);
    (s, i + step)
}

eat_ident :: fn(src: Str) Ty(Str, i64) = {
    i := 0;
    while => i < src.len && src[i].is_ascii_whitespace() {
        i += 1;
    };
    start := i;
    while => i < src.len && (src[i].is_ascii_alpha() || src[i] == "_".ascii()) {
        i += 1;
    };
    (src.slice(start, i), i)
}

fn parse_top_level(c: *Ctx, src: Str) *KExpr = {
    parts := @ref list(*KExpr, c.arena);
    i := 0;
    start_string := 0;
    while => i < src.len {
        paired_code("{%", "%}", .Tag);
        paired_code("{{", "}}", .Expr);
        if paired("{#", "#}") { string, _ |
            parts.push(c.expr(Value = (RealString = string)));
        };
        
        paired :: fn(a: Str, b: Str) ?Ty(Str, Str) => {
            yield :: local_return;
            if src.rest(i).starts_with(a) {
                string := src.slice(start_string, i);
                i += a.len;
                start := i;
                while => !src.rest(i).starts_with(b) {
                    i += 1;
                };
                code := src.slice(start, i);
                i += b.len;
                start_string = i;
                yield(Some = (string, code));
            };
            .None
        };
        
        paired_code :: fn(a: Str, b: Str, kind: CodeKind) => if paired(a, b) { string, code |
            parts.push(c.expr(Value = (RealString = string)));
            parts.push(c.expr(Code = (src = code, kind = kind)));
        };
        i += 1;
    };
    string := src.slice(start_string, i);
    parts.push(c.expr(Value = (RealString = string)));
    c.expr(Concat = parts.items())
}

token :: fn(src: *Str) Tok = {
    t, s := eat_token(src[]);
    while => s.len > 0 && s[0].is_ascii_whitespace() {
        s = s.rest(1);
    };
    src[] = s;
    t
};

eat_token :: fn(src: Str) Ty(Tok, Str) = {
    println(src);
    i := 0;
    while => i < src.len && src[i].is_ascii_whitespace() {
        i += 1;
    };
    if i == src.len {
        return((type = .Eof, s = ""), "");
    };
    c := src[i];
    if ".-+=()[],|".contains(c) {
        i += 1;
        return((type = .Punct, s = src.slice(i-1, i)), src.rest(i));
    };
    if c.is_ascii_alpha() || c == "_".ascii() {
        s, i2 := eat_ident(src.rest(i));
        return((type = .Ident, s = s), src.rest(i+i2));
    };
    if "\"'".contains(c) {
        i += 1;
        start := i;
        while => i < src.len && src[i] != c {
            i += 1;
        };
        return((type = .String, s = src.slice(start, i)), src.rest(i+1));
    };
    if c.is_ascii_digit() {
        start := i;
        while => i < src.len && src[i].is_ascii_digit() {
            i += 1;
        };
        return((type = .Int, s = src.slice(start, i)), src.rest(i));
    };
    @panic("TODO: unexpected char %", src.slice(i, i+1));
}

Tok :: @struct {
    type: @enum(Ident, String, Punct, Int, Equals, Eof);
    s: Str;
};

fn expr(c: *Ctx, e: KExpr) *KExpr = 
    c.arena.boxed(KExpr, e);

#use("@/lib/sys/fs.fr");
#use("@/lib/collections/map.fr");
