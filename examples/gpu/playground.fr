// shadertoy for masochists. 
// the original implementation of this language is: https://c50.fingswotidun.com and https://fingswotidun.com/stackie
// esoteric stack based expression language that maps (x, y, z, t, u, v) -> _ -> (r, g, b). 
// the expression is compiled into my shader ir, then to msl or wgsl, and evaulated on your gpu.
// each command is one character, here's the starting example.
example_program :: "txp";
// programs output 1 value but we need 3 colour channels. another program defines the colour palette. 
// the palette is invoked 3 times with (x = output of first program, y = (0, 0.5, 1) for (r, g, b) respectively).
// if the program contains a '|', the characters after it replace this default palette. 
default_palette :: "xy2*1-*C";
// CONTROLS: 
//     type to edit the program (backspace to delete a char. copy/paste affect the whole program). 
//     it auto recompiles. press enter to reset t=0. hold control to show ir.

// each line is a program. 
// you can find a bunch at https://c50.fingswotidun.com/api/?top=200
// (cycle with left/right arrow)
optional_examples_path :: "target/c50.txt";

// images won't exactly match the original:
// - i use f32, they use f64. 
//   example: "y99^*s" (should have lines on whole screen but mine only does the top before running out of precision)
// - mine is higher resolution so the random index increments faster
// - TODO: i print floats in a dumb way so my pi is only 5 digits

// TODO: cli mode where you pass program+t and it outputs a png
// TODO: generate random programs
// TODO: test this somehow
// TODO: ui for changing resolution
// TODO: circular ones have a discontinuity on mine. is it just a resolution difference? 

valid_commands :: "xyztuvXYZTUV0123456789pwWeE%o!?Pd:;*/-+sc!<>$ql#^aC|r";
compile_c50 :: fn(m: *ShaderModule, src: Str, name: Ty(Symbol, Str)) Result(*Function, Str) = {
    f := m.init_shader_function(.NONE);
    vars := "xyztuv";
    stack := @ref u32.list(temp());
    // HACK: has to be the same as rest of fragment. rn i do that by preinterning in module init
    ty_f32 := f.type_lookup&.get(f32).unwrap();  
    f.ret = ty_f32;
    f.body&.push(op = .Nop);  // 0=placeholder TODO: do this in init?
    
    // TODO: have a sane api for linking imports
    f.name = name._0;
    f.strings&.insert(f.name, name._1);  // TODO: do this in init?
    
    range(0, vars.len) { _ |
        f.body&.push(op = .Nop);  // TODO: par
        f.input&.push(type = ty_f32, name = zeroed(Symbol));
    };
    // starting rand index for this pixel
    rand_i: u32 = 1 + vars.len.trunc();
    f.body&.push(op = .Nop);  // TODO: par
    f.input&.push(type = ty_f32, name = zeroed(Symbol));
    
    zero: u32 = f.body.len.trunc();
    f.body&.push(op = .Constant, type = ty_f32, a = 0.0.cast().bitcast());
    one: u32 = f.body.len.trunc();
    f.body&.push(op = .Constant, type = ty_f32, a = 1.0.cast().bitcast());
    pi: u32 = f.body.len.trunc();
    f.body&.push(op = .Constant, type = ty_f32, a = PI.cast().bitcast());
    
    enumerate src { i, it |
        continue :: local_return;
        it := it[];
        ::display_slice(u32);
        get :: fn() => stack.pop() 
            || return(Err = @tfmt("stack underflow at operation[%]=%", i, src.subslice(i, 1)));
        
        range(0, vars.len) { i |
            if vars[i] == it {  // get
                stack.push(i.trunc() + 1);
                continue();
            };
            if vars[i] == it.ascii_to_lower() {  // set
                v := get();
                f.body&.push(op = .SetVar, a = i.trunc() + 1, b = v);
                continue();
            };
        };
        
        if it.is_ascii_digit() {
            it: i64 = it.zext() - "0".char();
            it: f64 = it.float();
            stack.push(f.body.len.trunc());
            f.body&.push(op = .Constant, type = ty_f32, a = it.cast().bitcast());
            continue();
        };
        
        if true {
            break :: local_return;
            mangle :: fn($fid: FuncId) Ty(FuncId, Symbol, Str, i64) = {
                arity := get_function_ast(fid, false, false, false, false)[].arg.bindings.len;
                s, n := mangle_name(fid);
                (fid, s, n, arity)
            };
            func := @switch(it) {
                @case("p".ascii()) => mangle(Stolen.perlin2);
                @case("w".ascii()) => mangle(Stolen.wrapPerlin3);
                @case("W".ascii()) => mangle(Stolen.wrapPerlin);
                @case("e".ascii()) => mangle(Stolen.smoothStep1);
                @case("E".ascii()) => mangle(Stolen.ss);
                @case("%".ascii()) => mangle(Stolen.positiveMod);
                @case("o".ascii()) => mangle(Stolen.xorScaled);
                @case("r".ascii()) => {
                    new: u32 = f.body.len.trunc();
                    f.body&.push(op = .add, type = ty_f32, a = rand_i, b = one);
                    f.body&.push(op = .SetVar, a = rand_i, b = new);
                    stack.push(new);
                    mangle(Stolen.random)
                }
                @default => break();
            };
            arity := func._3;

            args := zeroed(Array(u32, 4));
            range_rev(0, arity) { i |
                args&[i] = get();
            };
            range(0, arity) { i |
                f.body&.push(op = .Arg, type = ty_f32, a = args&[i]);
            };
            f.functions&.insert(func._0, func._2);
            stack.push(f.body.len.trunc());
            f.body&.push(op = .Call, type = ty_f32, a = func._0.as_index().trunc());
            continue();
        };
        if true {
            break :: local_return;
            @switch(it) {
                @case("!".ascii()) => {
                    a := get();
                    stack.push(f.body.len.trunc());
                    f.body&.push(op = .sub, type = ty_f32, a = one, b = a);
                };
                @case("?".ascii()) => {
                    a := get();
                    cond: u32 = f.body.len.trunc();
                    f.body&.push(op = .le, type = ty_f32, a = a, b = zero);  // TODO: type should be bool
                    stack.push(f.body.len.trunc());
                    f.body&.push(op = .Select, type = ty_f32, a = cond, b = zero, c = one);
                };  
                @case("P".ascii()) => stack.push(pi);
                @case("d".ascii()) => {
                    @if(stack.len < 1) return(Err = "underflow 'd'");
                    stack.push(stack[stack.len - 1]);
                };
                @case(":".ascii()) => {
                    @if(stack.len < 2) return(Err = "underflow ':'");
                    stack.items().swap(stack.len - 1, stack.len - 2);
                };
                @case(";".ascii()) => {
                    @if(stack.len < 3) return(Err = "underflow ';'");
                    stack.items().swap(stack.len - 1, stack.len - 3);
                };
                @default => break();
            };
            continue();
        };
      
        //      vvv TODO: this type should be optional :compilerbug
        (arity: i64, op: AstOp) := @switch(it) {
            @case("*".ascii()) => (2, .mul);
            @case("/".ascii()) => (2, .div);
            @case("-".ascii()) => (2, .sub);
            @case("+".ascii()) => (2, .add);
            @case("s".ascii()) => (1, .sin);
            @case("c".ascii()) => (1, .cos);
            @case("~".ascii()) => (1, .abs);
            @case("<".ascii()) => (2, .min);
            @case(">".ascii()) => (2, .max);
            @case("$".ascii()) => (1, .floor);
            @case("q".ascii()) => (1, .sqrt);
            @case("l".ascii()) => (1, .log);
            @case("#".ascii()) => (1, .round);
            @case("^".ascii()) => (2, .pow);
            @case("a".ascii()) => (2, .atan2);
            @case("C".ascii()) => {
                stack.push(zero);
                stack.push(one);
                (3, .clamp)
            }
            @default => return(Err = @tfmt("TODO: unknown operation %", it));
        };
        args := zeroed(Array(u32, 3));
        range_rev(0, arity) { i |
            args&[i] = get();
        };
        stack.push(f.body.len.trunc());
        f.body&.push(op = op, type = ty_f32, a = args&[0], b = args&[1], c = args&[2]);
    };
    v := stack.pop() || return(Err = "stack underflow for return value");
    f.body&.push(op = .Return, a = v);
    f.body&.push(op = .End);
    
    (Ok = f)
}

Shaders :: @struct {
    OutV :: @struct(pos: Vec4 #position);
    // TODO: move this out because i keep wanting it?
    vs   :: fn(i: u32 #vertex_id) OutV = {
        xy := @if(i == 0, @vec(-1.0, 1.0),
              @if(i == 1, @vec(-1.0, -1.0),
              @if(i == 2, @vec(1.0, -1.0),
              @if(i == 3, @vec(1.0, 1.0),
              @if(i == 4, @vec(1.0, -1.0),
              @if(i == 5, @vec(-1.0, 1.0),
              @vec(0.0, 0.0)))))));
        (pos = @vec(xy, 0.0, 1.0))
    }
    OutF :: @struct(frag_color: Vec4 #colour);
    UniF :: @struct {
        // pixel coordinate -> normalized
        scale: Vec2;
        time: f32;
        // moves forward by total number of rand calls each frame. 
        rand_index: f32;
        // number of rand calls per pixel for (program, palette)
        rand_calls: Vec2;
        // the random kinda looks worse with high resolution (like a colour instead of a pattern)
        // so allow controling that seperately. so you can have smooth lines with a blocky pattern. 
        rand_scale: Vec2;
    };
    // TODO: my @swizzle syntax is super ugly
    fs   :: fn(in: OutV #input, uni: UniF #uniform(0)) Shaders.OutF = {
        // the random function is indexed. compute the position of this pixel 
        // so each pixel gets new random numbers. since the programs don't have 
        // loops, the number of rand calls required is known statically. 
        // each random() call's argument is as though it were a global counter. 
        step := (@swizzle uni.rand_calls.x) + (@swizzle uni.rand_calls.y) * 3;
        width := 1.0.cast() / @swizzle uni.scale.y;
        rand_xy := (@swizzle in.pos.xy) * uni.rand_scale;
        pixel_index := floor((@swizzle rand_xy.y) * width) + floor((@swizzle rand_xy.x));
        rand_i := uni.rand_index + (step * pixel_index) - 1/* because compiled "r" increments first */;
    
        palette :: fn(value: f32, component: f32, z: f32, t: f32, u: f32, v: f32, i: f32) f32;
        program :: fn(x: f32, y: f32, z: f32, t: f32, u: f32, v: f32, i: f32) f32;
        C :: fn(x, y: f32) => {
            u, v := (x*2 - 1, y*2 - 1);
            z := sqrt(u*u + v*v);
            c := palette(x, y, z, t, u, v, rand_i);
            rand_i += @swizzle uni.rand_calls.y;
            clamp(c, 0, 1)  // matters if custom palette misbehaves
        };
        
        // TODO: can't factor out `uvz :: fn(x, y) Ty(f32, f32, f32) => {};`
        //       because my shader compiler can't deal with nontrivial destructuring assignment yet. 
        xy := (@swizzle in.pos.xy) * uni.scale;
        x, y := (@swizzle xy.x, @swizzle xy.y);
        t := fmod(uni.time, 256);
        u, v := (x*2 - 1, y*2 - 1);
        z := sqrt(u*u + v*v);
        o := program(x, y, z, t, u, v, rand_i);
        rand_i += @swizzle uni.rand_calls.x;
        r := C(o, 0.0);
        g := C(o, 0.5);
        b := C(o, 1.0);
        
        (frag_color = @vec(r, g, b, 1.0))
    }
};
// TODO: i32 literal with high bit set shouldn't be this painful :compiler

// https://github.com/Lerc/stackie/blob/93fc42770059b192e65f3baf0b42ccf5b69e42d2/stackie.js
// i want exactly their magic numbers so the pretty pictures look the same as the website. 
// crimes because no license but the readme implies they wouldn't sad if people to use it. 
// also they've commented that someone else can use it https://news.ycombinator.com/item?id=42039296 
// so maybe it's socially acceptable to steal. 
Stolen :: @struct {
    intHash :: fn(x: i32) i32 = {
        x *= @run 0xed5ad4bb.bitcast();
        x = x.bit_xor(x.shift_right_arithmetic(11));
        x *= @run 0xac4c1b51.bitcast();
        x = x.bit_xor(x.shift_right_arithmetic(15));
        x *= @run 0x31848bab.bitcast();
        x = x.bit_xor(x.shift_right_arithmetic(14));
        x
    };
    
    random :: fn(x: f32) f32 = {
        seed: i32 = 42;
        x := x.f32_to_i32();
        h :: fn(it: i32) i32 => intHash((x + it).bit_and(0x7fffffff));
        pattern := h(seed);
        intValue := h(pattern);
        intValue.i32_to_f32() / 0x7fffffff.i32_to_f32()
    };
    
    ss :: fn(v: f32, a: f32, b: f32) f32 = {
        w := v*v*v*(v*(v*6-15)+10);
        (1.0-w)*a+(w*b)
    }
    
    positiveMod :: fn(v: f32, size: f32) f32 = {
        q := fmod(v, size);
        @if(q < 0, size - q, q)
    }
    
    perlin :: fn(x: f32, y: f32, wrapX: f32, wrapY: f32) f32 = {
        dg :: fn(ix: f32, iy: f32) f32 => {
            pi: f32 = PI;
            gi := random(positiveMod(iy,wrapY)*wrapX+positiveMod(ix,wrapX)*2)*pi*2;
            ((x-ix)*sin(gi)) + ((y-iy)*cos(gi))
        };
        
        u, v := (x.ftrunc(), y.ftrunc());
        sx, sy := (x-u, y-v);
        u1, v1 := (u+1, v+1);
        ss(sy,ss(sx,dg(u,v),dg(u1,v)),ss(sx,dg(u,v1),dg(u1,v1)))
    }

    wrapPerlin :: fn(x: f32, y: f32, wrapX: f32, wrapY: f32) f32 = 
        perlin(x*wrapX,y*wrapY,wrapX,wrapY);
        
    perlin2 :: fn(x: f32, y: f32) f32 = 
        perlin(x, y, 256, 256);
    wrapPerlin3 :: fn(x: f32, y: f32, wrapX: f32) f32 = 
        wrapPerlin(x, y, wrapX, wrapX);
    smoothStep1 :: fn(v: f32) f32 = 
        ss(v, 0, 1);
    xorScaled :: fn(a: f32, b: f32, c: f32) f32 = {
        c := pow(2, c);
        result := bit_xor(f32_to_i32(a*c), f32_to_i32(b*c));
        i32_to_f32(result) / c
    }
};

// TODO: wrong place for these
// TODO: cpu impl as well
ftrunc :: fn(x: f32) f32 #builtin(.trunc);
i32_to_f32 :: fn(x: i32) f32 #builtin(.i32_to_f32);
f32_to_i32 :: fn(x: f32) i32 #builtin(.f32_to_i32);
fmod :: fn(a: f32, b: f32) f32 #builtin(.fmod);
fn pow(a: f32, b: f32) f32 #builtin(.pow);
fn sqrt(x: f32) f32 #builtin(.sqrt);
fn floor(a: f32) f32 #builtin(.floor);

main :: fn() void = 
    Easy'start(State);

State :: @struct {
    WIDTH :: 500; HEIGHT :: 500;
    pipe: Sg.Pipeline;
    shd: ?Sg.Shader;
    uni: Shaders.UniF;
    dirty: bool;
    program_contains_t: bool;
    start_time: f64;
    text: Sdtx.Self;
    src: List(u8);
    error: List(u8);
    need_recompile: bool;
    input_dirty: bool;
    code: List(u8);
    show_generate_code: bool;
    rand_index: i64;
    i: i64;
    examples: []Str;
};

fn on_init(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    src := example_program;
    state.shd = .None;
    sapp.clipboard.enabled = true;
    a := general_allocator();
    state.src = list(a);
    state.error = list(a);
    state.code = list(a);
    state.src&.push_all(src);
    state.need_recompile = true;
    state.input_dirty = true;
    state.dirty = true;
    state.uni.rand_scale.v = (0.2, 0.2);
    fix_scale(state, sapp);
    
    p := optional_examples_path;
    if import("@/lib/sys/fs.fr")'read_entire_file(a, p) { it |
        it.len -= int(it.ends_with("\n"));
        it := it.split("\n", a);
        it&.shrink_to_fit();
        state.examples = it.items();
        @println("loaded % examples from %", it.len, p);
    } else {
        @eprintln("missing examples file %", p);
    };
    
    state.text&.setup(
        sg = sg,
        allocator = general_allocator(),
        fonts = @slice(Sdtx.font.cpc),
    );
}

recompile :: fn(state: *State, sg: *Sg.Self) void = {
    state.need_recompile = false;
    state.dirty = true;
    state.start_time = timestamp_s();
    state.rand_index = 0;
    @if(!state.input_dirty) return();  // pressed enter just to reset the time. keep the same shader. 
    state.input_dirty = false;

    fid1 :: FuncId.scope_of(Shaders.fs).program;  // SKEAK
    fid2 :: FuncId.scope_of(Shaders.fs).palette;  // SKEAK
    m := init_shader_module(temp());
    state.error&.clear();
    src := state.src.items();
    program_src, palette_src := (src, default_palette);
    if src.index_of("|".ascii()) { i |
        program_src = src.slice(0, i);
        palette_src = src.rest(i + 1);
    };
    program_f := or compile_c50(m&, program_src, @run mangle_name(fid1)) { msg |
        state.error&.push_all(msg);
        return()
    };
    palette_f := or compile_c50(m&, palette_src, @run mangle_name(fid2)) { msg |
        state.error&.push_all(msg);
        return()
    };
    state.uni.rand_calls.v = (0, 0);
    for program_src { c |
        state.uni.rand_calls&[0] += int(c == "r".ascii()).float().cast();
    };
    for palette_src { c |
        state.uni.rand_calls&[1] += int(c == "r".ascii()).float().cast();
    };
    @println("run: %", src);

    vertex, fragment := base_shaders();
    state.input_dirty = false;
    state.code&.clear();
    f := @slice(program_f, palette_f);
    out := @ref u8.list(temp());
    out.push_all(fragment);
    ::reach_overloads();
    for f { f |
        @fmt(state.code&, "%", f);
        c :: fn($s) => { S :: import(s); S'emit_function(f, out, @ref zeroed(S.Counters)); };
        @match(SOKOL_BACKEND) {
            fn METAL_MACOS() => c("@/graphics/macos/shaders.fr");
            fn WGPU() => c("@/graphics/web/shaders.fr");
            @default => @panic("TODO: gpu/playground.fr new target");
        };
    };
    shader := out.items();
    
    // if it's not animated, don't bother redrawing the screen every frame. 
    state.program_contains_t = src.contains("t") || src.contains("r");
    
    base_shaders :: fn() Ty(Str, Str) = @run {
        backend := SOKOL_BACKEND;
        vertex := {
            m := init_shader_module(ast_alloc());
            self := translate_to_shader(m&, Shaders.vs, backend, .VERTEX);
            emit_all(m&, backend)
        };
        
        m := init_shader_module(general_allocator());
        translate_to_shader(m&, Shaders.fs, backend, .FRAGMENT);
        
        s := Type.scope_of(Stolen);
        src := @ref u8.list(ast_alloc());
        for get_constants(s) { name |
            fid := get_constant(FuncId, s, name).unwrap();
            func := get_function_ast(fid, true, true, true, true);
            translate_to_shader(m&, fid, backend, .NONE);
        };
        
        fragment := emit_all(m&, backend);
        (vertex, fragment)
    };
    
    // TODO: more direct way of it handling linking stuff together
    // TODO: don't reallocate just to null terminate :SLOW
    shd_desc := Sg.ShaderDesc.zeroed();
    shd_desc.vertex_func.source = vertex.as_cstr();
    shd_desc.fragment_func.source = out.items().as_cstr();
    @if(is_metal(SOKOL_BACKEND)) {
        shd_desc.vertex_func.entry = "main0";
        shd_desc.fragment_func.entry = "main0";
    };
    
    shd_desc.uniform_blocks&[0] = (
        stage = .FRAGMENT,
        size = size_of(Shaders.UniF),
        msl_buffer_n = 0,
        wgsl_group0_binding_n = 0,
    );

    if state.shd { shd |
        state.shd = .None;
        sg.destroy(shd);
        // TODO: let you change shader of a pipeline without destroying and recreating it?
        sg.destroy(state.pipe);
    };
    // TODO: don't crash if the gpu abi doesn't like the code i generated 
    //       (this should never generate invalid ir but should show internal error if there's a bug)
    shd := sg.make(shd_desc);
    state.shd = (Some = shd);
    state.pipe = sg.make(shader = shd);
}

// #position is in pixels, rescale 
fix_scale :: fn(state: *State, sapp: *Sapp.Self) void = {
    state.uni.scale.v = (
        1.0 / sapp.width().float().cast(),
        1.0 / sapp.height().float().cast(),
    );
}

fn on_event(state: *State, sapp: *Sapp.Self, event: *Sapp.Event) void = {
    state.show_generate_code = event.modifiers.get(.control) != 0;
    @match(event.type) {
        fn RESIZED() => fix_scale(state, sapp);
        fn KEY_DOWN() => @match(event.key_code) {
            fn LEFT() => state.next_example(-1);
            fn RIGHT() => state.next_example(1);
            fn ENTER() => {
                state.need_recompile = true;
            }
            fn BACKSPACE() => if state.src.len > 0 {
                state.src.len -= 1;
                state.need_recompile = true;
                state.input_dirty = true;
            };
            fn C() => if event.modifiers.get(.super) != 0 {
                sapp.set_clipboard_string(state.src.items().as_cstr()); 
            };
            // need to still mark dirty if it's CTRL and program_contains_t=false
            // TODO: the thing where modifiers is still set on the event where you release the key
            @default => ();
        };
        fn CLIPBOARD_PASTED() => {
            state.set_src(sapp.get_clipboard_string().items());
        }
        fn CHAR() => if event.modifiers.get(.super) == 0 {
            c: u8 = event.char_code.trunc();
            if event.char_code < 128 && valid_commands.contains(c) {
                state.src&.push(c);
                state.need_recompile = true;
                state.input_dirty = true;
            };
        }
        @default => return();
    };
    state.dirty = true;
}

fn next_example(state: *State, delta: i64) void = {
    @if(state.examples.len == 0) return();
    state.i += delta;
    state.i += state.examples.len * int(state.i < 0);
    state.i -= state.examples.len * int(state.i >= state.examples.len);
    state.set_src(state.examples[state.i]);
}

fn set_src(state: *State, src: Str) void = {
    state.src&.clear();
    state.src&.push_all(src);
    state.need_recompile = true;
    state.input_dirty = true;
    state.dirty = true;
}

fn on_render(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    if state.need_recompile {
        recompile(state, sg);
    };
    w, h := (sapp.width().float().cast(), sapp.height().float().cast());
    uni := state.uni&;
    if state.program_contains_t {
        state.dirty = true;
        time := timestamp_s() - state.start_time;
        uni.time = time.cast();
        
        step := int(cast(uni.rand_calls.x + uni.rand_calls.y * 3));
        rand_i := state.rand_index&;
        rand_i[] += step * int(cast(w * h));
        // wrap when out of mantissa bits
        rand_i[] -= int(rand_i[] > 1.shift_left(23)) * 1.shift_left(23);
        uni.rand_index = rand_i[].float().cast();
    };
    @if(Easy'should_skip_frame(sapp, state.dirty&)) return();
    
    sdtx := state.text.default_context&;
    sdtx.canvas(w.div(1.75), h.div(1.75));
    sdtx.color = 0xFF005555;
    sdtx.put(state.src.items());
    sdtx.pos.y += 2;
    sdtx.pos.x = 0;
    // toggle colour so it's more likely to be visible (unless the last shader happens to toggle at the same rate)
    // (meh: only if the last shader had program_contains_t)
    sdtx.color = @if(state.uni.time.mul(3).cast().int().mod(2) == 0, 0xFFFFFFFF, 0xFF000000);
    sdtx.put(state.error.items());
    
    if state.show_generate_code {
        scale := 1.2;
        sdtx.canvas(sapp.width().float().div(scale).cast(), sapp.height().float().div(scale).cast());
        sdtx.pos.y += cast(2 * scale * 1.75);
        sdtx.color = 0xFFFFFFFF;
        sdtx.put(@tfmt("// t=%.%\n", uni.time, uni.time.mul(10).cast().int().mod(10)));
        sdtx.put(state.code.items());
    };
    
    Easy'glue_begin_pass(sapp, sg, zeroed Sg.PassAction);
    ::[]Shaders.UniF;

    if state.shd { _ |
        sg.apply_pipeline(state.pipe);
        sg.apply_uniforms(0, state.uni&.slice(1).interpret_as_bytes());
        draw(sg = sg, base = 0, elements = 6, instances = 1);
    };
    sdtx.draw_layer(0);
    sg.end_pass();
    sg.commit();
};

mangle_name :: fn(fid: FuncId) Ty(Symbol, Str) #fold = {
    name := get_function_ast(fid, false, false, false, false)[].name;
    name := sym(@tfmt("%__F%", name.str(), fid.as_index())); // TODO: mangle in a consistant place
    (name, name.str())
}

#include_std("graphics/lib.fr");

driver :: fn(vtable: *ImportVTable) void = 
    Easy'build_for_graphics(vtable, @source_file_name());
