
Emit :: @struct(
    program: *SelfHosted,
    var_lookup: HashMap(VarId, Str),
    inlined_return_addr: HashMap(LabelId, ReturnTarget),
    use: *HashSet(ItemKey),
    next_var := 0,
    next_blk := 0,
    indent := 0,
    out: *List(u8),
    last_statement_start := 0,
);

ReturnTarget :: @struct(
    blk: Str,
    p: Placement,
    used: bool,
);

Placement :: @tagged(Assign: Str, Declare: Str, NewMemory, Discard);

fn init(comp: *SelfHosted, use: *HashSet(ItemKey), out: *List(u8)) Emit #inline = (
    program = comp,
    var_lookup = init(temp()),
    inlined_return_addr = init(temp()),
    use = use,
    out = out,
);

fn emit_body(self: *Emit, f: FuncId) void #once = {
    func := self.program.get_function(f);
    arg_ty := func.finished_arg.unwrap();
    
    ret := func.finished_ret.unwrap();
    @fmt(self.out, "% %(", self.type_name(ret), self.fmt_fn_name(f));
    
    args := @ref Str.list(temp());
    if func.finished_arg.unwrap() != void {
        each func.arg.bindings { b |
            v := b.var().unwrap();
            name := self.var_name(v);
            @fmt(self.out, "% %, ", self.type_name(b.ty.Finished), name);
            args.push(name);
        };
        self.out.len -= 2*int(self.out.items().ends_with(", "));
    }
    @fmt(self.out, ")");
    
    body: *FatExpr = @match(func.body&) {
        fn Normal(body) => body;
        fn NewIntrinsic(op) => {
            @fmt(self.out, "{\n");
            indented self {
                self.statement();
                result := self.emit_intrinsic(.NewMemory, op, ret, args.items());
                self.statement();
                @fmt(self.out, "return %;\n}\n", result);
            };
            return()
        };
        fn Redirect(fid) => {
            @fmt(self.out, "#define % %\n", self.fmt_fn_name(f), self.fmt_fn_name(fid[]));
            self.use.insert(FuncId = fid[]);
            return()
        } 
        fn DynamicImport(info) => {
            @fmt(self.out, "{\n");
            @fmt(self.out, "\treturn %(", self.program.get_string(info.name));
            for args { it |
                @fmt(self.out, "%, ", it);
            };
            self.out.len -= 2*int(self.out.items().ends_with(", "));
            @fmt(self.out, ");\n}\n");
            return()
        }
        fn Asm(it) => {
            @fmt(self.out, "{\n");
            it := bit_cast_unchecked(@type it, *EnumMap(Arch, []u8), it);
            for_enum Arch { arch |
                self.statement();
                @fmt(self.out, "#ifdef __%__\n", arch);
                @fmt(self.out, "asm(\"");
                for it[arch] { byte |
                    @fmt(self.out, ".byte %\\n", byte);
                };
                @fmt(self.out, "\");\n");
                self.statement("#endif\n");
            };
            @fmt(self.out, "}\n");
            return()
        }
        @default => @panic("no acceptable impl %", self.program.log(func));
    };
    
    @fmt(self.out, " {\n");
    indented self {
        result := self.compile_expr(body, .NewMemory);
        self.statement();
        @fmt(self.out, "return %;\n", result);
    };
    self.statement();
    @fmt(self.out, "}\n");
}

fn new_tmp_name(self: *Emit) Str = {
    self.next_var += 1;
    @tfmt("v%", self.next_var)
}

fn var_name(self: *Emit, v: Var) Str = {
    s := self.program.get_string(v.name);
    for s { c |
        if !(c.is_ascii_alpha() || c.is_ascii_digit() || c == "_".ascii()) {
            s = "v";
        };
    };
    self.next_var += 1;
    name := @tfmt("%__v%", s, self.next_var);
    _ := self.var_lookup&.insert(v.id, name);
    name
}

fn compile_stmt(self: *Emit, stmt: *FatStmt) void = {
    @match(stmt.stmt&) {
        fn Eval(expr) => {
            self.compile_expr(expr, .Discard);
        }
        fn Decl(f) => self.decl(f[].var().unwrap(), f.default&);
        fn Set(f) => {
            src := self.compile_expr(f.value&, .NewMemory);
            dest := @match(f.place.expr&) {
                fn GetVar(it) => self.addr_macro(f.place&, self.program.ptr_ty(f.place.ty), .NewMemory)
                fn Deref(arg) => self.compile_expr(arg[], .NewMemory);
                @default => panic("TODO: other `place=e;` :(");
            };
            self.statement();
            @fmt(self.out, "*% = %;\n", dest, src);
        }
        fn DeclVarPattern(f) => {
            b := f.binding.bindings.items();
            @if_let(f.value.expr&) fn Tuple(parts) => if parts.len == b.len {
                range(0, b.len) { i |
                    self.decl(b[i]&.var().unwrap(), parts[i]&); 
                };
                return();
            };
        
            base := self.compile_expr(f.value&, .NewMemory);
            self.decl_var_pattern(base, f.value.ty, b)
        };
        fn Noop() => ();
        @default => @panic("ICE: stmt not desugared %", self.program.log(stmt));
    }
}

fn decl(self: *Emit, v: Var, value: *FatExpr) void = {
    name := self.var_name(v);
    _ := self.compile_expr(value, (Declare = name));
}

fn decl_var_pattern(self: *Emit, parent: Str, ty: Type, bindings: []Binding) void = {
    info := self.program.get_type(ty);
    if !info.is(.Struct) || bindings.len == 1 {
        v := bindings[0]&.var().unwrap();
        _ := self.var_lookup&.insert(v.id, parent);
        return()
    };
    self.program.finish_layout(ty); // :extra
    fields := info.Struct.fields&;
    @debug_assert(info.Struct.layout_done && fields.len == bindings.len);
    enumerate bindings { i, b |
        f       := fields[i]&;
        v    := b.var().unwrap();
        name := self.var_name(v);
        self.statement();
        @fmt(self.out, "% % = %._%;\n", self.type_name(b.ty.Finished), name, parent, i);
    };
}

fn compile_expr(self: *Emit, expr: *FatExpr, p: Placement) Str = {
    @debug_assert(!expr.ty.is_unknown() && expr.ty != CVariadicType);
    expr_ty := expr.ty;
    (@match(expr.expr&) {
        fn Cast(v)  => return(self.compile_expr(v[], p));
        fn Call(f)    => return(self.emit_call(f.f, f.arg, p));
        fn Block(f)   => return(self.emit_block_expr(expr, p));
        fn Value(f)   => return(self.emit_constant(f.bytes&, p, expr.ty, expr.loc));
        fn If(_)      => return(self.emit_call_if(expr, p));
        fn Loop(arg)  => return(self.emit_call_loop(arg[]));
        fn Addr(arg)  => return(self.addr_macro(arg[], expr.ty, p));
        fn StructLiteralP(pattern) => return(self.construct_aggregate(pattern, expr.ty, p));
        fn Slice(arg) => {
            container_ty := arg.ty;
            // Note: number of elements, not size of the whole array value.
            ty, count := @match(arg.expr) {
                fn Tuple(parts) Ty(Type, i64) => { 
                    fst := parts[0];
                    (fst.ty, parts.len) 
                };
                @default => (arg.ty, 1);
            };
            ptr  := self.compile_expr(arg[], .NewMemory);
            declare_now(self, p&, expr_ty) {
                @fmt(self.out, "(%) { .ptr = (*%) %, .len = %, }", 
                    self.type_name(expr.ty), self.type_name(ty), ptr, count);
            }
        };
        fn GetVar(it) => {
            name := self.var_lookup&.get_ptr(it.id).unwrap()[];
            @match(p) {
                fn NewMemory() => name;
                @default => self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name));
            }
        }
        fn DataSymbol(info) => {
            name := self.program.get_string(info.name);
            self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name))
        }
        fn Deref(arg) => {
            @if_let(arg.expr&) fn GetVar(v) => {
                return self.declare_now(p&, expr.ty, => @fmt(self.out, "%", self.var_lookup&.get(v.id).unwrap()));
            };
            src := self.compile_expr(arg[], .NewMemory); // get the pointer
            self.deref(src, p, expr_ty)
        };
        fn FnPtr(arg) => {
            f := arg[].as_const(FuncId);
            name := self.func_ref(f);
            self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name))
        };
        fn Unreachable() => {
            _ := self.unify_placement(p&, expr.ty);
            self.statement();
            @fmt(self.out, "while(1) {};\n");
            ""
        }
        fn Uninitialized() => {
            self.unify_placement(p&, expr.ty)
        };
        fn Tuple(values) => {
            @if(values.len == 0) return("");
            if values.len == 1 {
                return self.compile_expr(values[0]&, p);
            };
            fields := self.pre_eval_tuple(values.items());
            @if(p&.is(.Discard)) return("");
            ty := self.program.raw_type(expr.ty);
            declare_now(self, p&, ty) {
                @fmt(self.out, "(%) {\n", self.type_name(ty));
                indented self {
                    @match(self.program.get_type(ty)) {
                        fn Struct(f) => enumerate fields { i, value |
                            @fmt(self.out, "._% = %, ", i, value);
                        };
                        fn Array(f) => {
                            @fmt(self.out, ".data = {");
                            enumerate fields { i, value |
                                @fmt(self.out, "[%] = %, ", i, value);
                            };
                            @fmt(self.out, "}");
                        }
                        @default => unreachable();
                    };
                };
                @fmt(self.out, "\n");
                self.statement("}");
            }
        }
        fn PtrOffset(f) => {
            base  := self.compile_expr(f.ptr, .NewMemory);
            @if(p&.is(.Discard)) return("");
            result := self.declare_now(p&, expr.ty);
            @fmt(self.out, "&%->%;\n", base, self.program.get_string(f.name));
            result
        }
        fn Switch(f) => return(self.emit_switch(expr, p));
        @default => @panic("ICE: didn't desugar: %", self.program.log(expr));
    })
}

fn deref(self: *Emit, src: Str, p: Placement, expr_ty: Type) Str = {
    value_type := expr_ty;
    size: i64 = self.program.get_info(value_type)[].stride_bytes.zext();
    if(size == 0, => return("")); // :NoRuntimeRepr
    self.declare_now(p&, expr_ty, => @fmt(self.out, "*%", src))
}

fn emit_call(self: *Emit, f: *FatExpr, arg: *FatExpr, p: Placement) Str #once = {
    self.program.finish_layout(arg.ty); // :extra
    callee, f_ty := @match(self.program.get_type(f.ty)) {
        fn Fn() => {
            f_id := f.as_const(FuncId);
            func := self.program.get_function(f_id);
            @debug_assert(!func.get_flag(.Generic) && !func.get_flag(.MayHaveAquiredCaptures));
            f_ty := func.finished_ty().unwrap();  // see tests/todo/wrong_call_type.fr
            
            @if_let(func.body&) fn NewIntrinsic(op) => {
                arg := self.pre_eval_tuple(arg.items());
                return self.emit_intrinsic(p, op, f_ty.ret, arg);
            };

            callee_r := self.func_ref(f_id);
            (callee_r, f_ty)
        }
        fn FnPtr(f_ty) => (self.compile_expr(f, .NewMemory), f_ty.ty);
        fn Label(_) => {
            label := f.as_const(LabelId);
            ret := self.inlined_return_addr&.get_ptr(label);
            ret := ret || @panic("missing return label. forgot '=>' on function?");
            ret.used = true;  // note: updating the one in the map! not a copy
            _ := self.compile_expr(arg, ret.p);
            self.statement();
            @fmt(self.out, "goto %;\n", ret.blk);
            return "";
        }
        @default => unreachable();
    };
    
    fields := self.pre_eval_tuple(arg.items());
    output := self.declare_now(p&, f_ty.ret);
    @fmt(self.out, "%(", callee);
    for fields { it |
        if it.len != 0 {
            @fmt(self.out, "%, ", it);
        };
    };
    self.out.len -= 2*int(self.out.items().ends_with(", "));
    @fmt(self.out, ");\n");
    output
}

fn emit_intrinsic(self: *Emit, p: Placement, op: *NewIntrinsicPayload, t: Type, arg: []Str) Str = {
    o, k := (@as(Qbe.O) op.ir_op, @as(Qbe.Cls) op.ir_cls);
    if o == .copy {
        return self.declare_now(p&, t, => @fmt(self.out, "(%) %", self.type_name(t), arg[0]));
    };
    if @is(o, .extub, .extuh, .extuw, .extsb, .extsh, .extsw) {
        // TODO
        return self.declare_now(p&, t, => @fmt(self.out, "(%) %", self.type_name(t), arg[0]));
    };
    
    // TODO: unscale pointer arithmetic
    bin := @match(o) {
        fn add() => "+";
        fn sub() => "-";
        fn mul() => "*";
        fn div() => "/";
        fn udiv() => "/";
        fn rem() => "%";
        fn urem() => "%";
        fn and() => "&";
        fn or() => "|";
        fn xor() => "^";
        fn shl() => "<<";
        fn shr() => ">>";
        fn sar() => ">>";
        @default => {
            cc: i32 = 0;
            cmp_cls := Qbe.Cls.zeroed();
            if iscmp(o, cmp_cls&, cc&) {
                // TODO: force right signedness
                @match(@as(Qbe.Cmp) cc) {
                    fn Cieq() => "==";
                    fn Cine() => "!=";
                    fn Cisge() => ">=";
                    fn Cisgt() => ">";
                    fn Cisle() => "<=";
                    fn Cislt() => "<";
                    fn Ciuge() => ">=";
                    fn Ciugt() => ">";
                    fn Ciule() => "<=";
                    fn Ciult() => "<";
                    fn Cfeq() => "==";
                    fn Cfge() => ">=";
                    fn Cfgt() => ">";
                    fn Cfle() => "<=";
                    fn Cflt() => "<";
                    fn Cfne() => "!=";
                    fn Cfo() => "todo";
                    fn Cfuo() => "todo";
                }
            } else {
                @tfmt("/*TODO: % %*/", o, k)
            }
        };
    };
    T := @match(k) {
        fn Kw() => "uint32_t";
        fn Kl() => "uint64_t";
        fn Ks() => "float";
        fn Kd() => "double";
        @default => unreachable();
    };
    self.declare_now(p&, t, => @fmt(self.out, "(%) (((%) %) % %)", 
        self.type_name(t), T, arg[0], bin, @if(arg.len > 1, arg[1], "_")))
}

fn func_ref(self: *Emit, f_id: FuncId) Str #inline = {
    self.use.insert(FuncId = f_id);
    self.fmt_fn_name(f_id)
}

fn emit_block_expr(self: *Emit, expr: *FatExpr, p: Placement) Str #once = {
    block   := expr.expr.Block&;
    ret_var := or block.ret_label {
        each block.body& { stmt |
            self.compile_stmt(stmt);
        };
        return self.compile_expr(block.result, p);
    };
    
    dest := self.unify_placement(p&, expr.ty);
    self.next_blk += 1;
    ret: ReturnTarget = (
        blk = @tfmt("B%", self.next_blk),
        p = p,
        used = false,
    );
    prev := self.inlined_return_addr&.insert(ret_var, ret);
    @debug_assert(prev.is_none(), "stomped ret var");
    self.statement();
    each block.body& { stmt | 
        self.compile_stmt(stmt);
    };
    _ := self.compile_expr(block.result, p);
    ret := self.inlined_return_addr&.remove(ret_var).unwrap();
    if ret.used {
        self.statement();
        @fmt(self.out, "%:\n", ret.blk);
    };
    dest
}

stores :: import("@/backend/opt/mem.fr")'store_by_size;

fn emit_constant(self: *Emit, value: *Values, p: Placement, expr_ty: Type, loc: Span) Str #once = {
    @if(p&.is(.Discard) || expr_ty == void) return("");
    info := self.program.get_info(expr_ty);
    use_int_literal := value.is(.Small) && (!info.contains_pointers || value.Small._0 == 0);
    if use_int_literal {
        return self.declare_now(p&, expr_ty, => @fmt(self.out, "%", value.Small._0));
    };
    id := self.program.emit_relocatable_constant(expr_ty, value.bytes(), loc).unwrap();
    
    // TODO: these should be global
    name := @tfmt("C%", id.id);
    baked := self.program.get_baked(id);
    
    if baked.relocations.len == 1 && value.len() == 8 {
        // TODO: shouldn't need the "()"
        return (declare_now(self, p&, expr_ty) {
            @fmt(self.out, "(%) ", self.type_name(expr_ty));
            bake_iter_legacy baked { part |
                self.emit_baked_part(part);
            };
        });
    };
    
    self.use.insert(BakedVarId = id);
    self.declare_now(p&, expr_ty, => @fmt(self.out, "*(%*) C%", self.type_name(expr_ty), id.id))
}

fn emit_baked_part(self: *Emit, part: BakedEntry) void = {
    @match(part) {
        fn Num(it)      => @fmt(self.out, "(void*) %", it.value);
        fn FnPtr(it)    => @fmt(self.out, "%", self.func_ref(it));
        fn AddrOf(it)   => {
            self.use.insert(BakedVarId = it);
            @fmt(self.out, "Cb%", it.id);
        }
        // TODO: unscale pointers
        fn AddrOfA(it)  => {
            self.use.insert(BakedVarId = it.base);
            @fmt(self.out, "C% + %", it.base.id, it.addend);
        }
    };
}

fn define_baked_var(self: *Emit, id: BakedVarId) void = {
    // TODO: only const when used as a value
    name := @tfmt("C%", id.id);
    baked := self.program.get_baked(id);
    if baked.relocations.len == 0 {
        @fmt(self.out, "const static uint8_t %[%] = { ", name, baked.len());
        @match(baked.template) {
            fn Bytes(it) => {
                i := self.out.len;
                safe_print(it, self.out);
                if !self.out.items().ends_with("\"") {  // HACK
                    self.out[i - 1] = "\"".ascii();
                    self.out.push("\"".ascii());
                };
            }
            fn Zeroes() => @fmt(self.out, "0");
        };
    } else {
        @fmt(self.out, "const static void *%[%] = { ", name, baked.len().ualign_to(8).udiv(8));
        bake_iter_legacy baked { part |
            self.emit_baked_part(part);
            @fmt(self.out, ", ");
        };
    };
    @fmt(self.out, "};\n");
}

fn addr_macro(self: *Emit, arg: *FatExpr, t: Type, p: Placement) Str #once = {
    var := arg.expr.GetVar;
    @debug_assert(arg.expr&.is(.GetVar) && var.kind != .Const, "took address of r-value");
    ref := self.var_lookup&.get_ptr(var.id).expect("addr runtime var");
    declare_now(self, p&, t) {
        @fmt(self.out, "&%", ref)
    }
}

fn emit_call_if(self: *Emit, arg: *FatExpr, p: Placement) Str #once = {
    parts := arg.expr.If&;
    cond := self.compile_expr(parts.cond, .NewMemory);
    result := self.unify_placement(p&, arg.ty);
    self.statement();
    invert := parts.if_true.is_empty() && !parts.if_false.is_empty();
    @fmt(self.out, "if (%%) {\n", @if(invert, "!", ""), cond);
    parts := @slice(parts.if_true, parts.if_false);
    @if(invert) parts.swap(0, 1);
    indented self {
        _ := self.compile_expr(parts[0], p);
        if self.last_statement_start == self.out.len {
            @fmt(self.out, "\n");
        };
    };
    if parts[1].is_empty() {
        self.statement("}\n");
    } else {
        self.statement("} else {\n");
        indented self {
            _ := self.compile_expr(parts[1], p);
            if self.last_statement_start == self.out.len {
                @fmt(self.out, "\n");
            };
        };
        self.statement("}\n");
    };
    result
}

fn emit_switch(self: *Emit, arg: *FatExpr, p: Placement) Str #once = {
    parts := arg.expr.Switch;
    inspect := self.compile_expr(parts.value, .NewMemory); 
    result := self.unify_placement(p&, arg.ty);
    self.statement();
    @fmt(self.out, "switch (%) {\n", inspect);
    indented self {
        each parts.cases { f |
            value, body := (f._0, f._1&);
            self.statement();
            @fmt(self.out, "case %: {\n", value);
            indented self {
                _ := self.compile_expr(body, p);
                self.statement("break;\n");
            };
            self.statement("}\n");
        };
        self.statement("default: {\n");
        indented self {
            _ := self.compile_expr(parts.default, p);
        };
        self.statement("}\n");
    };
    self.statement("}\n");
    result
}

fn emit_call_loop(self: *Emit, arg: *FatExpr) Str #once = {
    self.statement();
    @fmt(self.out, "while(1){\n");
    indented self {
        _ := self.compile_expr(arg, .Discard);
    };
    self.statement();
    @fmt(self.out, "}\n");
    ""
}

fn construct_aggregate(self: *Emit, pattern: *Pattern, requested: Type, p: Placement) Str #once = {
    raw_container_ty := self.program.raw_type(requested);
    self.program.finish_layout(raw_container_ty);  // :extra
    @match(self.program.get_type(raw_container_ty)) {
        fn Struct(f) => {
            fields := @ref Str.list(pattern.bindings.len, temp());
            enumerate pattern.bindings& { i, b | 
                fields.push(self.compile_expr(b.default&, .NewMemory));
            };
            @if(p&.is(.Discard)) return("");
            self.declare_now(p&, requested) {
                @fmt(self.out, "(%) {\n", self.type_name(requested));
                indented self {
                    enumerate pattern.bindings& { i, b | 
                        name := self.program.get_string(b.ident().unwrap());
                        self.statement();
                        @fmt(self.out, ".% = %,\n", name, fields[i]);
                    };
                };
                self.statement("}");
            }
        }
        fn Tagged(f) => {
            @debug_assert_eq(pattern.bindings.len, 1, "@tagged must have one active varient");
            value := pattern.bindings.index(0).get_default().unwrap();
            name := pattern.bindings[0].name.unwrap();
            i    := f.cases.index_of(fn(f) => f._0 == name).expect("case name to exist in type");
            payload := self.compile_expr(value, .NewMemory);
            @if(p&.is(.Discard)) return("");
            self.declare_now(p&, requested) {
                case_name := self.program.get_string(name);
                @fmt(self.out, "(%) { .tag = %, .% = %, }", self.type_name(requested), i, case_name, payload);
            }
        }
        @default => unreachable();
    }
}

fn as_const(self: *FatExpr, $T: Type) T #generic = {
    @assert(self.expr&.is(.Value), "as_const");
    T.assume_cast(self.expr.Value.bytes&)[]
}

fn fmt_fn_name(self: *Emit, f: FuncId) []u8 = 
    self.program.fmt_fn_name(f);

fn pre_eval_tuple(self: *Emit, values: []FatExpr) []Str = {
    fields := @ref Str.list(values.len, temp());
    each values { expr | 
        fields.push(self.compile_expr(expr, .NewMemory));
    };
    fields.items()
}

fn is_empty(e: *FatExpr) bool = {
    e.ty == void && e.expr&.is(.Value)
}

fn type_name(self: *Emit, t: Type) Str = {
    self.use.insert(Type = t);
    @tfmt("T%", t)
}

fn indented(self: *Emit, $body: @Fn() void) void = {
    self.indent += 1;
    self.statement();
    body();
    self.indent -= 1;
}

fn declare_now(self: *Emit, p: *Placement, t: Type, $body: @Fn() void) Str = {
    self.statement();
    result := self.declare_now(p, t);
    body();
    @fmt(self.out, ";\n");
    result
}

fn statement(self: *Emit, s: Str) void = {
    self.statement();
    @fmt(self.out, "%", s);
}

fn statement(self: *Emit) void = {
    @if(self.last_statement_start == self.out.len) return();
    @debug_assert(self.out.items().ends_with("\n"));
    self.out.push_repeated(self.indent, "\t".ascii());
    self.last_statement_start = self.out.len;
}

fn declare_now(self: *Emit, p: *Placement, t: Type) Str = {
    t = self.program.raw_type(t);
    @debug_assert(t != UnknownType);
    if self.program.get_info(t)[].stride_bytes == 0 {
        p[] = .Discard;
    };
    @match(p[]) {
        fn NewMemory() => {
            p[] = (Declare = self.new_tmp_name());
            self.declare_now(p, t)
        }
        fn Declare(name) => {
            self.statement();
            @fmt(self.out, "% ", self.type_name(t));
            p[] = (Assign = name);
            @fmt(self.out, "% = ", name);
            name
        }
        fn Assign(name) => {
            self.statement();
            @fmt(self.out, "% = ", name);
            name
        }
        fn Discard() => {
            self.statement();
            ""
        }
    }
}
fn unify_placement(self: *Emit, p: *Placement, t: Type) Str = {
    t = self.program.raw_type(t);
    @debug_assert(t != UnknownType);
    if self.program.get_info(t)[].stride_bytes == 0 {
        p[] = .Discard;
    };
    @match(p[]) {
        fn NewMemory() => {
            p[] = (Declare = self.new_tmp_name());
            self.unify_placement(p, t)
        }
        fn Declare(name) => {
            self.statement();
            @fmt(self.out, "% %;\n", self.type_name(t), name);
            p[] = (Assign = name);
            name
        }
        fn Assign(name) => {
            self.statement();
            name
        };
        fn Discard() => {
            self.statement();
            ""
        }
    }
}

fn define_type(self: *Emit, it: Type) void = {
    // @fmt(self.out, "/* % */\n", self.program.log(it)); 
    @fmt(self.out, "typedef ");
    @match(self.program.get_type(it)[]) {
        fn Struct(it) => {
            @fmt(self.out, "% {\n", @if(it.is_union, "union", "struct"));
            each it.fields { it |
                @fmt(self.out, "\t% %;\n", self.type_name(it.ty), self.program.get_string(it.name));
            };
            @fmt(self.out, "}");
        }
        fn Tagged(it) => {
            @fmt(self.out, "struct {\n");
            @fmt(self.out, "\tint64_t tag;\n");
            @fmt(self.out, "\tunion {\n");
            for it.cases { name, type |
                if type != void {
                    @fmt(self.out, "\t\t% %;\n", self.type_name(type), self.program.get_string(name));
                }
            };
            @fmt(self.out, "\t};\n}");
        }
        fn Array(it) => @fmt(self.out, "struct { % data[%]; }", self.type_name(it.inner), it.len);
        fn Ptr(it) => @fmt(self.out, "%*", self.type_name(it));
        fn F32() => @fmt(self.out, "float");
        fn F64() => @fmt(self.out, "double");
        fn Int(it) => {
            bits := it.bit_count;
            if !(bits == 8 || bits == 16 || bits == 32 || bits == 64) {
                bits = 64;
            };
            @fmt(self.out, "%int%_t", @if(it.signed, "", "u"), bits);
        };
        fn Enum(it) => @fmt(self.out, "%", self.type_name(it.raw));
        fn Named(it) => @fmt(self.out, "%", self.type_name(it._0));
        fn void() => @fmt(self.out, "void");
        fn Never() => @fmt(self.out, "void");
        fn VoidPtr() => @fmt(self.out, "void *");
        fn FnPtr(f_ty) => {
            @fmt(self.out, "% ", self.type_name(f_ty.ty.ret));
            @fmt(self.out, "(*%)(", self.type_name(it));
            for self.program.arg_types(f_ty.ty.arg) { it |
                @fmt(self.out, "%, ", self.type_name(it));
            };
            self.out.len -= 2*int(self.out.items().ends_with(", "));
            @fmt(self.out, ");\n");
            return();  // name goes in the middle
        }
        fn Bool() => @fmt(self.out, "uint8_t");
        fn Placeholder() => @fmt(self.out, "void");  // TODO ???
        @default => @panic("TODO: /* % */", self.program.log(it)); 
    };
    @fmt(self.out, " %;\n", self.type_name(it));
}

pump :: fn(comp: *SelfHosted, fns: []FuncId) Str = {
    a := comp.get_alloc();
    
    // TODO: if this is too slow, try EnumMap(Tag(ItemKey), List(ItemData));
    all_items: HashMap(ItemKey, ItemData) = init(a);
    pending: List(ItemKey) = list(a);
    use: HashSet(ItemKey) = init(a);
    out := u8.list(a);
    out&.reserve(1.shift_left(23));
    
    for fns { it |
        all_items&.insert((FuncId = it), zeroed(ItemData));
        pending&.push(FuncId = it);
    };
    
    // doing it this way is worse than main_thread_pump at making sure intrinsics are first. 
    // but i need an extra level of sorting to output them in order and it feels dumb to keep track of it twice. 
    // Func.callees isn't enough (doesn't have types/data) and also misses some (mutual, shims, etc.). 
    while => pending&.pop() { key |
        emit: Emit = init(comp, use&, out&);
        check_for_new_aot_bake_overloads(comp).unwrap();
        @match(key) {
            fn FuncId(fid) => {
                func := comp.get_function(fid);
                xx := comp.poll_in_place(void, => comp.compile_body(fid));
                or xx { err | 
                    @eprintln("failed compile %", comp.get_string(func.name));
                    comp.report_error(err)
                };
                emit&.emit_body(fid);
                
                // HACK: makes complation order more similar to the other one because my overloading is garbage
                for func.callees& { fid |
                    comp.poll_in_place(void, => comp.compile_body(fid));
                };
            }
            fn Type(it) => emit&.define_type(it);
            fn BakedVarId(it) => emit&.define_baked_var(it);
        };
        
        used := @ref ItemKey.list(use.raw.len_including_tombstones, a);
        each use.raw.arr& { slot |
            if slot.hash != 0 && slot.key& != key& {
                @debug_assert(slot.hash != 1);
                _ := all_items&.get_or_insert(slot.key) {
                    pending&.push(slot.key);
                    zeroed(ItemData)
                };
                
                used.push(slot.key);
            }
            slot.hash = 0;  // remove without toubstone valid because removing all. 
        };
        use.raw.len_including_tombstones = 0;
        it := all_items&.get_ptr(key).unwrap();
        @debug_assert(it.use.len == 0 && it.src.len == 0, "double emit");
        it[] = (use = used.items(), src = out.items().shallow_copy(a), id = -1);
        out&.clear();
    };
    
    @fmt(out&, "/* @generated by franca/examples/emit_c.fr */\n");
    @fmt(out&, "#include <stdint.h>\n");
    
    // sort to minimize required forward declarations
    @assert(fns.len == 1, "TODO: fake root for multiple entry points");
    fillrpo(all_items&, (FuncId = fns[0]));
    ordered := temp().alloc_zeroed(ItemData, all_items.raw.len_including_tombstones);
    each all_items& { _, it |
        @debug_assert(ordered[it.id].src.len == 0 && it.src.len != 0, "stomp");
        ordered[it.id] = it[];
    };
    for_rev ordered { it |
        out&.push_all(it.src);
    };
    
    @fmt(out&, """
        #ifdef __wasm32__
        #error "TODO: deal with 32 bit pointers"
        #endif
    """);
    @fmt(out&, "\n/* deps:\n");
    @fmt(out&, " * % %\n", comp.vtable.self_hash, Incr.self_filename);
    each comp.codemap.files& { it |
        @fmt(out&, " * % %\n", it.hash&, it.name);
    };
    @fmt(out&, " */\n");
    out.items()
}

main :: fn() void = {
    Incr'set_self_hash();
    driver_vtable_exports;
    vtable := init_driver_vtable(false);
    opts := vtable.default_build_options();
    if cli_args().contains(fn(it) => it[] == "-unsafe") {
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    opts.retain_function_names = true;
    src := """#include_std("lib/core.fr"); #include_std("compiler/main.fr"); """;
    c := new_with_src(vtable, src, "entry_file", opts);
    c := vtable.with(c);
    fid := or c.get_unique_named("main") {
        panic("expected exactly one function called 'main'")
    };
    self := c.data.cast()[][];
    result := pump(self, @slice(fid));
    println(result);
    c'vtable'destroy_compiler(c.data);
}

ItemKey :: @tagged(Type: Type, FuncId: FuncId, BakedVarId: BakedVarId);
ItemData :: @struct {
    use: []ItemKey;
    src: Str;
    id: i64;
};

::AutoEq(ItemKey);  ::AutoHash(ItemKey, TrivialHasher);
::AutoEq(BakedVarId); ::AutoHash(BakedVarId, TrivialHasher);

fn fillrpo(it: *HashMap(ItemKey, ItemData), start: ItemKey) void = {
    n := rporec(it, start, it.raw.len_including_tombstones - 1) + 1;
    @assert_eq(n, 0);
    rporec :: fn(it: *HashMap(ItemKey, ItemData), i: ItemKey, x: i64) i64 = {
        self := it.get_ptr(i).unwrap();
        @if(self.id != -1) return(x);
        self.id = 1;
        for self.use { i |
            x = rporec(it, i, x);
        };
        self.id = x;
        x - 1
    }
}

DISABLE_IMPORT_FRC :: true;
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr");
