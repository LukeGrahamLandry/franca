// THIS IS UNFINISHED
// currently it can convert compiler/main.fr to a 212k line / 7MB c file
// which when compiled by clang (or my import_c/cc.fr) can jit examples/kaleidoscope.fr. 
// there are many things that are still broken. 
// ---
// - gcc doesn't have __builtin_rotate_xxx
// - get_stack_base_for_tls is probably ub. use asm instead?
// - FuncImpl.FrcImport
// - CVariadic
// - sar
// - copy_bytes_static -> memmove? set_bytes -> memset? because mine do unaligned stores. 
//  - not a perf thing, with -O2, clang notices what im doing either way
// - not address sanitizer clean: "load of misaligned address", "applying zero offset to null pointer"
// - decide if i care about doing things in a way thread sanitizer understands
// - make it work with tcc `error: incompatible types for redefinition of 'write'`

Emit :: @struct(
    program: *SelfHosted,
    var_lookup: HashMap(VarId, Str),
    inlined_return_addr: HashMap(LabelId, ReturnTarget),
    use: *HashSet(ItemKey),
    next_var := 0,
    next_blk := 0,
    indent := 0,
    out: *List(u8),
    last_statement_start := 0,
    current_block_is_dead := false,
    prev_cas0: ?Str = .None,
    locals: HashMap(Type, List(Str)),
);

ReturnTarget :: @struct(
    blk: Str,
    p: Placement,
    used: bool,
);

Placement :: @tagged(Assign: Str, Declare: Str, NewMemory, Discard, Trivial, Return);

fn init(comp: *SelfHosted, use: *HashSet(ItemKey), out: *List(u8)) Emit #inline = (
    program = comp,
    var_lookup = init(temp()),
    inlined_return_addr = init(temp()),
    use = use,
    out = out,
    locals = init(temp()),
);

fn emit_body(self: *Emit, f: FuncId) void #once = {
    func := self.program.get_function(f);
    if func.body&.is(.Asm) {
        // this fixes clang warning about missing `return;` but causes gcc to warn about it being ignored. 
        // there's no winning. either way works. 
        @fmt(self.out, "__attribute__((naked)) ");
    };
    @if_let(func.body&) fn DynamicImport(info) => {
        f_ty := func.finished_ty().unwrap();
        self.write_extern(info, f_ty);
    };
    args := self.write_sig_names(f, self.fmt_fn_name(f));
    arg_ty := func.finished_arg.unwrap();
    ret := func.finished_ret.unwrap();
    
    body: *FatExpr = @match(func.body&) {
        fn Normal(body) => body;
        fn NewIntrinsic(op) => {
            @fmt(self.out, "{\n");
            indented self {
                self.statement();
                result := self.emit_intrinsic(.NewMemory, op, ret, args, arg_ty, .None);
                self.statement();
                @fmt(self.out, "return %;\n}\n", result);
            };
            return()
        };
        fn Redirect(fid) => {
            self.forward_to(self.fmt_fn_name(fid[]), args);
            self.use.insert(FuncId = fid[]);
            return()
        } 
        fn DynamicImport(info) => {
            self.forward_to(self.ident(info.name), args);
            return()
        }
        fn Asm(it) => {
            @fmt(self.out, "{\n");
            it := bit_cast_unchecked(@type it, *EnumMap(Arch, []u8), it);
            for_enum Arch { arch |
                self.statement();
                @fmt(self.out, "#if __%__ || __%\n", arch, arch);
                @fmt(self.out, "\tasm(\"");
                for it[arch] { byte |
                    @fmt(self.out, ".byte %\\n", byte);
                };
                @fmt(self.out, "\");\n");
                self.statement("#endif\n");
            };
            @fmt(self.out, "}\n");
            return()
        }
        @default => @panic("no acceptable impl %", self.program.log(func));
    };
    
    @fmt(self.out, " {\n");
    start := self.out.len;
    indented self {
        result := self.compile_expr(body, .Return);
        @debug_assert_eq(result, "");
    };
    
    if self.locals.raw.len_including_tombstones != 0 {
        // :SLOW
        // see lift_declare_local()
        body := self.out.items().slice(start, self.out.len).shallow_copy(temp());
        self.out.len = start;
        each self.locals& { ty, names |
            type := self.type_name(ty);
            if type.ends_with("*") {
                @fmt(self.out, "\ttypeof(%) ", type);
            } else {
                @fmt(self.out, "\t% ", type);
            };
            for names { it |
                @fmt(self.out, "%, ", it);
            };
            self.out.len -= 2*int(self.out.items().ends_with(", "));
            @fmt(self.out, ";\n");
        };
        self.out.push_all(body);
    };
    
    self.statement();
    @fmt(self.out, "}\n");
}

fn write_extern(self: *Emit, info: *DynamicImport, f_ty: FnType) void = {
    @fmt(self.out, "extern ");
    name := self.ident(info.name);
    real_name := self.program.get_string(info.name);
    alias: ?Str = @if(name != real_name, (Some = real_name), .None);
    self.write_sig(f_ty, name, info.weak, alias);
} 

fn write_sig_names(self: *Emit, f: FuncId, name: Str) []Str = {
    func := self.program.get_function(f);
    arg_ty := func.finished_arg.unwrap();
    ret := func.finished_ret.unwrap();
    @fmt(self.out, "static % %(", self.type_name(ret), name);
    args := @ref Str.list(temp());
    if func.finished_arg.unwrap() != void {
        each func.arg.bindings { b |
            ty := b.ty&.unwrap();
            v := b.var().unwrap();
            //if self.program.get_info(ty)[].stride_bytes != 0 {
            if ty != void {
                name := self.var_name(v);
                @fmt(self.out, "% %, ", self.type_name(ty), name);
                args.push(name);
            } else {
                self.var_lookup&.insert(v.id, "");
            };
        };
        self.out.len -= 2*int(self.out.items().ends_with(", "));
    }
    @fmt(self.out, ")");
    args.items()
}

fn forward_to(self: *Emit, name: Str, args: []Str) void = {
    @fmt(self.out, "{\n");
    @fmt(self.out, "\treturn %(", name);
    for args { it |
        @fmt(self.out, "%, ", it);
    };
    self.out.len -= 2*int(self.out.items().ends_with(", "));
    @fmt(self.out, ");\n}\n");
}

fn new_tmp_name(self: *Emit) Str = {
    self.next_var += 1;
    @tfmt("v%", self.next_var)
}

fn var_name(self: *Emit, v: Var) Str = {
    s := self.ident(v.name);
    self.next_var += 1;
    name := @tfmt("%__v%", s, self.next_var);
    _ := self.var_lookup&.insert(v.id, name);
    name
}

fn compile_stmt(self: *Emit, stmt: *FatStmt) void = {
    @match(stmt.stmt&) {
        fn Eval(expr) => {
            self.compile_expr(expr, .Discard);
        }
        fn Decl(f) => self.decl(f[].var().unwrap(), f.default&);
        fn Set(f) => {
            src := self.compile_expr(f.value&, .NewMemory);
            if self.program.get_info(f.value.ty)[].stride_bytes == 0 {
                return();
            };
            dest := @match(f.place.expr&) {
                fn GetVar(it) => self.addr_macro(f.place&, self.program.ptr_ty(f.place.ty), .NewMemory)
                fn Deref(arg) => self.compile_expr(arg[], .NewMemory);
                @default => panic("TODO: other `place=e;` :(");
            };
            self.statement();
            @fmt(self.out, "*% = %;\n", dest, src);
        }
        fn DeclVarPattern(f) => {
            // TODO: very unfortunate how many extra bindings this adds. 
            //       every time a => function is called. 
            //       should forward vars that are not mutated.
            //       but they might be so can't just do it whenever the expr is GetVar. 
            
            b := f.binding.bindings.items();
            parts := f.value&.items();
            if parts.len == b.len {
                range(0, b.len) { i |
                    self.decl(b[i]&.var().unwrap(), parts[i]&); 
                };
                return();
            };
        
            base := self.compile_expr(f.value&, .NewMemory);
            self.decl_var_pattern(base, f.value.ty, b)
        };
        fn Noop() => ();
        @default => @panic("ICE: stmt not desugared %", self.program.log(stmt));
    }
}

fn decl(self: *Emit, v: Var, value: *FatExpr) void = {
    name := self.var_name(v);
    if value.ty == Never {
        self.var_lookup&.insert(v.id, "");
    };
    _ := self.compile_expr(value, (Declare = name));
}

fn decl_var_pattern(self: *Emit, parent: Str, ty: Type, bindings: []Binding) void = {
    info := self.program.get_type(ty);
    @debug_assert(info.is(.Struct));
    fields := info.Struct.fields&;
    @debug_assert(info.Struct.layout_done && fields.len == bindings.len);
    enumerate bindings { i, b |
        f       := fields[i]&;
        v    := b.var().unwrap();
        name := self.var_name(v);
        self.statement();
        @fmt(self.out, "% % = %._%;\n", self.type_name(b.ty.Finished), name, parent, i);
    };
}

// this goes through a lot of hassle to not use gnu statement expressions. 
is_trivial :: fn(self: *Emit, e: *FatExpr) bool = {
    @match(e.expr&) {
        fn Block(it) => {
            @if(it.ret_label.is_some() || !is_trivial(self, it.result)) return(false);
            each it.body { it |
                @match(it.stmt&) {
                    fn Noop() => ();
                    fn Eval(it) => @if(!self.is_trivial(it)) return(false);
                    @default => return(false);
                };
            };
            true
        }
        fn Call(it) => {
            @if_let(self.program.get_type(it.f.ty)) fn Fn() => {
                f_id := it.f.as_const(FuncId);
                func := self.program.get_function(f_id);
                @if_let(func.body&) fn NewIntrinsic(op) => if !@is(@as(Qbe.O) op.ir_op, .cas0, .cas1) {
                    each it.arg.items() { it |
                        @if(!self.is_trivial(it)) return(false);
                    };
                    return true;
                };
            }
            false
        }
        fn PtrOffset(it) => self.is_trivial(it.ptr);
        fn Deref(it) => self.is_trivial(it[]);
        @default => @is(e.expr&, .Value, .GetVar, .Addr, .FnPtr, .Cast);
    }
};

fn compile_expr(self: *Emit, expr: *FatExpr, p: Placement) Str = {
    xxx := !@is(p&, .Trivial, .Return, .Discard);
    if xxx && self.program.get_info(expr.ty)[].stride_bytes == 0 {
        p = .Discard;
    };
    if @is(p&, .Discard, .NewMemory, .Trivial) {
        trivial := p&.is(.Trivial) || self.is_trivial(expr);
        @if(trivial) @match(p&) {
            fn Discard() => return("");
            @default => {
                p = .Trivial;
            };
        };
        // note: things that can't return void will still be non trivial 
        //       if they contain calls/assignments (which can be hidden anywhere in the expr). 
    };

    @debug_assert(!expr.ty.is_unknown() && expr.ty != CVariadicType);
    expr_ty := expr.ty;
    (@match(expr.expr&) {
        // TODO: bitcast shouldn't be a nop
        fn Cast(v)  => return(self.compile_expr(v[], p));
        fn Call(f)    => return(self.emit_call(f.f, f.arg, p));
        fn Block(f)   => return(self.emit_block_expr(expr, p));
        fn Value(f)   => return(self.emit_constant(f.bytes&, p, expr.ty, expr.loc));
        fn If(_)      => return(self.emit_call_if(expr, p));
        fn Loop(arg)  => return(self.emit_call_loop(arg[]));
        fn Addr(arg)  => return(self.addr_macro(arg[], expr.ty, p));
        fn StructLiteralP(pattern) => return(self.construct_aggregate(pattern, expr.ty, p));
        fn Slice(arg) => {
            @if(p&.is(.Discard)) return(self.compile_expr(arg[], .Discard));
            
            container_ty := arg.ty;
            // Note: number of elements, not size of the whole array value.
            parts := arg[].items();
            ty, count := (parts[0].ty, parts.len);
            
            dest := Placement.NewMemory;
            if self.is_trivial(arg[]) {
                dest = (Declare = self.new_tmp_name());  // can't &rvalue
            };
            
            ptr  := self.compile_expr(arg[], dest);
            declare_now(self, p&, expr_ty) {
                @fmt(self.out, "(%) { .ptr = (%*) &%, .len = %, }", 
                    self.type_name(expr.ty), self.type_name(ty), ptr, count);
            }
        };
        fn GetVar(it) => {
            name := self.var_lookup&.get_ptr(it.id).unwrap()[];
            self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name))
        }
        fn DataSymbol(info) => {
            name := self.ident(info.name);
            @if_let(self.program.get_type(expr.ty)) fn FnPtr(f_ty) => {
                self.statement();
                self.write_extern(info, f_ty.ty);
            };
            self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name))
        }
        fn Deref(arg) => {
            @if_let(arg.expr&) fn Addr(arg) => {
                @if_let(arg.expr&) fn GetVar(v) => {
                    return self.declare_now(p&, expr.ty, => @fmt(self.out, "%", self.var_lookup&.get(v.id).unwrap()));
                };
                unreachable();
            };
            src := self.compile_expr(arg[], p.new_or_discard());
            self.deref(src, p, expr_ty)
        };
        fn FnPtr(arg) => {
            f := arg[].as_const(FuncId);
            name := self.func_ref(f);
            self.declare_now(p&, expr.ty, => @fmt(self.out, "%", name))
        };
        fn Unreachable() => {
            if !self.current_block_is_dead {
                self.statement();
                @fmt(self.out, "while(1) {};\n");
            }
            self.current_block_is_dead = true;
            ""
        }
        fn Uninitialized() => {
            self.unify_placement(p&, expr.ty)
        };
        fn Tuple(values) => {
            @if(values.len == 0) return("");
            if values.len == 1 {
                return self.compile_expr(values[0]&, p);
            };
            fields := self.pre_eval_tuple(values.items());
            @if(p&.is(.Discard)) return("");
            ty := self.program.raw_type(expr.ty);
            declare_now(self, p&, ty) {
                @fmt(self.out, "(%) {\n", self.type_name(ty));
                indented self {
                    @match(self.program.get_type(ty)) {
                        fn Struct(f) => enumerate fields { i, value |
                            @fmt(self.out, "._% = %, ", i, value);
                        };
                        fn Array(f) => {
                            @fmt(self.out, ".data = { ");
                            enumerate fields { i, value |
                                @fmt(self.out, "[%] = %, ", i, value);
                            };
                            @fmt(self.out, "}");
                        }
                        @default => unreachable();
                    };
                };
                @fmt(self.out, "\n");
                self.statement("}");
            }
        }
        fn PtrOffset(f) => {
            if self.program.get_info(self.program.unptr_ty(expr.ty).unwrap())[].stride_bytes == 0 {
                p = .Discard;
            };
        
            base  := self.compile_expr(f.ptr, p.new_or_discard());
            @if(p&.is(.Discard)) return("");
            self.declare_now(p&, expr.ty) {
                @fmt(self.out, "&%->%", base, self.ident(f.name));
            }
        }
        fn Switch(f) => return(self.emit_switch(expr, p));
        @default => @panic("ICE: didn't desugar: %", self.program.log(expr));
    })
}

fn new_or_discard(p: Placement) Placement = {
    @if(p&.is(.Discard), .Discard, .NewMemory)
}

fn deref(self: *Emit, src: Str, p: Placement, expr_ty: Type) Str = {
    value_type := expr_ty;
    size: i64 = self.program.get_info(value_type)[].stride_bytes.zext();
    if(size == 0, => return("")); // :NoRuntimeRepr
    self.declare_now(p&, expr_ty, => @fmt(self.out, "*%", src))
}

fn emit_call(self: *Emit, f: *FatExpr, arg: *FatExpr, p: Placement) Str #once = {
    self.program.finish_layout(arg.ty); // :extra
    callee, f_ty := @match(self.program.get_type(f.ty)) {
        fn Fn() => {
            f_id := f.as_const(FuncId);
            func := self.program.get_function(f_id);
            @debug_assert(!func.get_flag(.Generic) && !func.get_flag(.MayHaveAquiredCaptures));
            f_ty := func.finished_ty().unwrap();  // see tests/todo/wrong_call_type.fr
            
            @if_let(func.body&) fn NewIntrinsic(op) => {
                args := self.pre_eval_tuple(arg.items());
                return self.emit_intrinsic(p, op, f_ty.ret, args, arg.ty, (Some = arg));
            };

            callee_r := self.func_ref(f_id);
            (callee_r, f_ty)
        }
        fn FnPtr(f_ty) => (self.compile_expr(f, .NewMemory), f_ty.ty);
        fn Label(_) => {
            label := f.as_const(LabelId);
            ret := self.inlined_return_addr&.get_ptr(label);
            ret := ret || @panic("missing return label. forgot '=>' on function?");
            ret.used = !ret.p&.is(.Return);  // note: updating the one in the map! not a copy
            _ := self.compile_expr(arg, ret.p);
            self.current_block_is_dead = true;
            @if(ret.p&.is(.Return)) return("");
            self.statement();
            @fmt(self.out, "goto %;\n", ret.blk);
            return "";
        }
        @default => unreachable();
    };
    
    fields := self.pre_eval_tuple(arg.items());
    self.declare_now(p&, f_ty.ret) {
        self.write_call(callee, fields);
    }
}

fn write_call(self: *Emit, callee: Str, fields: []Str) void = {
    @fmt(self.out, "%(", callee);
    for fields { it |
        if it.len != 0 {
            @fmt(self.out, "%, ", it);
        };
    };
    self.out.len -= 2*int(self.out.items().ends_with(", "));
    @fmt(self.out, ")");
}

fn emit_intrinsic(self: *Emit, p: Placement, op: *NewIntrinsicPayload, t: Type, arg: []Str, arg_ty: Type, expr: ?*FatExpr) Str = {
    o, k := (@as(Qbe.O) op.ir_op, @as(Qbe.Cls) op.ir_cls);
    if o == .copy {
        return self.declare_now(p&, t, => @fmt(self.out, "(%) %", self.type_name(t), arg[0]));
    };
    if @is(o, .extsb, .extsh, .extsw) {
        // TODO
        return self.declare_now(p&, t, => @fmt(self.out, "(%) %", self.type_name(t), arg[0]));
    };
    
    if o == .cas0 {
        @assert(self.prev_cas0.is_none(), "expected paired cas0");
        self.prev_cas0 = (Some = arg[0]);
        return "";
    };
    if o == .cas1 {  // kinda hacky
        self.next_var += 1;
        expected := self.next_var;
        self.statement();
        @fmt(self.out, "% v% = %;\n", self.type_name(t), expected, arg[0]);
        self.statement();
        pointer := self.prev_cas0&.take().expect("paired cas1");
        @fmt(self.out, "atomic_compare_exchange_weak((_Atomic(%)*) %, &v%, %);\n", self.type_name(t), pointer, expected, arg[1]);
        self.statement();
        return self.declare_now(p&, t, => @fmt(self.out, "v%", expected));
    };
    if o == .cast {
        // int<->float bit cast
        in, out := (k_to_type(argcls(.cast, k, 0)), k_to_type(k));
        self.statement();
        return self.declare_now(p&, t, => @fmt(self.out, "((union { % a; % b; }) {%}).b", in, out, arg[0]));
    };
    
    cast_with_suffix :: fn(it) => 
        return self.declare_now(p&, t, => @fmt(self.out, "(%) (%%)", k_to_type(k), arg[0], it));
        
    emit_builtin_call :: fn(name) => 
        return self.declare_now(p&, t, => self.write_call(name, arg));

    // -fsanitize=undefined avoid ub when passing 0
    // relies on arg expression not having side effects
    emit_builtin_call_nonzero :: fn(if_zero, name) => 
        return self.declare_now(p&, t, => @fmt(self.out, "% == 0 ? % : %(%)", arg[0], if_zero, name, arg[0]));
    
    unsigned := false;
    bin := @match(o) {
        fn add() => "+";
        fn sub() => "-";
        fn mul() => "*";
        fn div() => "/";
        fn udiv() => "/";
        fn rem() => "%";
        fn urem() => "%";
        fn and() => "&";
        fn or() => "|";
        fn xor() => "^";
        fn shl() => "<<";
        fn shr() => ">>";
        fn sar() => ">>";  // TODO
        fn rotr() => return(emit_builtin_call(@if(k == .Kl, "__builtin_rotateright64", "__builtin_rotateright32"))); 
        fn rotl() => return(emit_builtin_call(@if(k == .Kl, "__builtin_rotateleft64", "__builtin_rotateleft32")));
        fn byteswap() => return(emit_builtin_call(@if(k == .Kl, "__builtin_bswap64", "__builtin_bswap32")));
        fn clz() => return(emit_builtin_call_nonzero(64, @if(k == .Kl, "__builtin_clzl", "__builtin_clz")));
        fn ctz() => return(emit_builtin_call_nonzero(64, @if(k == .Kl, "__builtin_ctzl", "__builtin_ctz")));
        fn ones() => return(emit_builtin_call_nonzero(0, @if(k == .Kl, "__builtin_popcountl", "__builtin_popcount")));
        fn sltof()  => cast_with_suffix("");  // TODO
        fn dtosi()  => cast_with_suffix(""); // TODO
        fn exts()   => cast_with_suffix("");
        fn truncd() => cast_with_suffix("");
        fn extub()  => cast_with_suffix("&0xFF");
        fn extuh()  => cast_with_suffix("&0xFFFF");
        fn extuw()  => cast_with_suffix("&0xFFFFFFFF");
        @default => {
            cc: i32 = 0;
            if !iscmp(o, k&, cc&) {
                @panic("/*TODO: % %*/", o, k)
            };
                // TODO: force right signedness in the other direction as well
                unsigned = @is(@as(Qbe.Cmp) cc, .Ciuge, .Ciugt, .Ciule, .Ciult);
                @match(@as(Qbe.Cmp) cc) {
                    fn Cieq() => "==";
                    fn Cine() => "!=";
                    fn Cisge() => ">=";
                    fn Cisgt() => ">";
                    fn Cisle() => "<=";
                    fn Cislt() => "<";
                    fn Ciuge() => ">=";
                    fn Ciugt() => ">";
                    fn Ciule() => "<=";
                    fn Ciult() => "<";
                    fn Cfeq() => "==";
                    fn Cfge() => ">=";
                    fn Cfgt() => ">";
                    fn Cfle() => "<=";
                    fn Cflt() => "<";
                    fn Cfne() => "!=";
                    fn Cfo() => "todo";
                    fn Cfuo() => "todo";
                }
        };
    };
    // -fsanitize=undefined avoid ub for signed overflow and when shift distance wraps
    unsigned := unsigned || @is(o, .add, .sub, .mul, .udiv, .urem, .shl, .shr);
    shift := @is(o, .shl, .shr, .sar, .rotl, .rotr);
    // shift := shift && (expr.is_none() || !expr.Some.items()[0].expr&.is(.Value));
    arg_ty := self.program.arg_types(arg_ty);
    self.declare_now(p&, t) {
        if self.program.get_type(t).is(.Ptr) {
            @fmt(self.out, "(%) (", self.type_name(t));
        }
        self.argument(k, arg[0], arg_ty[0], unsigned);
        @fmt(self.out, " % ", bin);
        @if(shift) @fmt(self.out, "(");
        @if(arg.len > 1) self.argument(k, arg[1], arg_ty[1], unsigned);
        @if(shift) @fmt(self.out, "&%)", @if(k == .Kw, 31, 63));
        if self.program.get_type(t).is(.Ptr) {
            @fmt(self.out, ")");
        }
    }
}

fn argument(self: *Emit, k: Qbe.Cls, value: Str, ty: Type, unsigned: bool) void = {
    T := k_to_type(k);
    info := self.program.get_type(ty);
    if info.is(.Ptr) || (unsigned && info.is(.Int) && info.Int.signed) {
        @fmt(self.out, "(%)", T);
    }
    @fmt(self.out, "%", value);
}

k_to_type :: fn(k: Qbe.Cls) Str = @match(k) {
    fn Kw() => "u32";
    fn Kl() => "u64";
    fn Ks() => "f32";
    fn Kd() => "f64";
    @default => unreachable();
};

fn func_ref(self: *Emit, f_id: FuncId) Str #inline = {
    self.use.insert(FuncId = f_id);
    self.fmt_fn_name(f_id)
}

fn emit_block_expr(self: *Emit, expr: *FatExpr, p: Placement) Str #once = {
    block   := expr.expr.Block&;
    ret_var := or block.ret_label {
        each block.body& { stmt |
            self.compile_stmt(stmt);
        };
        return self.compile_expr(block.result, p);
    };
    
    dest := self.unify_placement(p&, expr.ty);
    self.next_blk += 1;
    ret: ReturnTarget = (
        blk = @tfmt("B%", self.next_blk),
        p = p,
        used = false,
    );
    prev := self.inlined_return_addr&.insert(ret_var, ret);
    @debug_assert(prev.is_none(), "stomped ret var");
    self.statement();
    each block.body& { stmt | 
        self.compile_stmt(stmt);
    };
    _ := self.compile_expr(block.result, p);
    ret := self.inlined_return_addr&.remove(ret_var).unwrap();
    if ret.used {
        self.statement();
        @fmt(self.out, "%:;\n", ret.blk);
        self.current_block_is_dead = false;
    };
    dest
}

fn emit_constant(self: *Emit, value: *Values, p: Placement, expr_ty: Type, loc: Span) Str #once = {
    @if(p&.is(.Discard) || expr_ty == void) return("");
    meta := self.program.get_info(expr_ty);
    info := self.program.get_type(expr_ty);
    use_int_literal := value.is(.Small) && (!meta.contains_pointers || value.Small._0 == 0);
    if use_int_literal && @is(info, .Int, .Enum, .Bool, .VoidPtr, .Ptr) {
        // TODO: don't always need a cast. but im afraid of when i want it to wrap to negative
        //       does the warning mean it won't?
        //target/a.c:5311:38: warning: result of comparison of constant 4294967292 with expression of type 'int32_t' (aka 'int') is always true [-Wtautological-constant-out-of-range-compare]
        //5311 |                         uint8_t cond__v14 = (result__v13) != (4294967292);
        //     |                                             ~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~
        return self.declare_now(p&, expr_ty, => @fmt(self.out, "(%) %", self.type_name(expr_ty), value.Small._0));
    };
    id := self.program.emit_relocatable_constant(expr_ty, value.bytes(), loc).unwrap();
    
    baked := self.program.get_baked(id);
    
    if baked.relocations.len == 1 && value.len() == 8 && info.is(.Ptr) {
        // TODO: shouldn't need the "()"
        return (declare_now(self, p&, expr_ty) {
            @fmt(self.out, "(%) &", self.type_name(expr_ty));
            bake_iter_legacy baked { part |
                self.emit_baked_part(part);
            };
        });
    };
    
    if baked.relocations.len == 0 && baked.template&.is(.Zeroes) {
        return (declare_now(self, p&, expr_ty) {
            @fmt(self.out, "(%) {0}", self.type_name(expr_ty));
        });
    };
    
    // this is a lot of fucking around for 60kb
    if self.program.string_type { string |
        if expr_ty == string {
            parts := bake_collect_legacy(baked, temp());
            @if_let(parts[0]) fn AddrOfA(it) => if it.addend == 0 {
                baked := self.program.get_baked(it.base);
                @if_let(baked.template) fn Bytes(string) => if string.len <= 256 {
                    @if_let(parts[1]) fn Num(it) => {
                        return (declare_now(self, p&, expr_ty) {
                            @fmt(self.out, "(%) { .ptr = (u8*) %, .len = %, }", 
                                self.type_name(expr_ty), => self.string_literal(string), it.value);
                        });
                    }
                }
            }
        };
    };
    
    name := self.ref_baked(id);
    self.declare_now(p&, expr_ty, => @fmt(self.out, "*(%*) %", self.type_name(expr_ty), name))
}

fn ref_baked(self: *Emit, id: BakedVarId) Str = {
    self.use.insert(BakedVarId = id);
    @tfmt("C%", id.id)
}

fn emit_baked_part(self: *Emit, part: BakedEntry) void = {
    @match(part) {
        fn Num(it)      => @fmt(self.out, "(void*) %", it.value);
        fn FnPtr(it)    => @fmt(self.out, "%", self.func_ref(it));
        fn AddrOf(it)   => self.emit_baked_part(AddrOfA = (base = it, addend = 0));
        fn AddrOfA(it)  => if it.addend == 0 {
            @fmt(self.out, "%", self.ref_baked(it.base));
        } else {
            // not needing pointer scaling relies on emitting as void *[].
            @fmt(self.out, "% + %", self.ref_baked(it.base), it.addend);
        };
    };
}

fn string_literal(self: *Emit, it: []u8) void = {
    printable :: fn(c) => 
        c >= 32 && c <= 126 && c != "\"".ascii() && c != "\\".ascii();
    
    self.out.push("\"".ascii());
    for it { c |
        @if_else {
            @if(printable(c)) => self.out.push(c);
            @if(c == "\n".ascii()) => @fmt(self.out, "\\n");
            @else => @fmt(self.out, "\\%%%", c / 64, (c / 8).mod(8), c.mod(8));
        };
    };
    self.out.push("\"".ascii());
}

fn define_baked_var(self: *Emit, id: BakedVarId) void = {
    name := @tfmt("C%", id.id);
    baked := self.program.get_baked(id);
    if baked.relocations.len == 0 {
        alignment := @if(baked.type == UnknownType, 8, self.program.get_info(baked.type)[].align_bytes.zext());
        @debug_assert(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
        @fmt(self.out, "static u% %[%] = { ", alignment * 8, name, baked.len() / alignment);
        @match(baked.template) {
            fn Bytes(it) => @switch(alignment) {
                @case(1) => self.string_literal(it);
                @case(2) => self.bytes_literal(it, u16);
                @case(4) => self.bytes_literal(it, u32);
                @case(8) => self.bytes_literal(it, u64);
                @default => @panic("TODO: big alignment");
            }
            fn Zeroes() => @fmt(self.out, "0");
        };
    } else {
        @fmt(self.out, "static void *%[%] = { ", name, baked.len().ualign_to(8).udiv(8));
        bake_iter_legacy baked { part |
            self.emit_baked_part(part);
            @fmt(self.out, ", ");
        };
    };
    @fmt(self.out, "};\n");
}

// { 1, 0 } is much more compact than "\x01\x00\x00...etc" for .None
fn bytes_literal(self: *Emit, bytes: []u8, $T: Type) void = {
    @debug_assert_eq(bytes.len.umod(size_of(T)), 0);
    while => bytes.len > 0 {
        n := bytes&.pop_type(T)[];
        @fmt(self.out, "%, ", n);
    }
}

fn addr_macro(self: *Emit, arg: *FatExpr, t: Type, p: Placement) Str #once = {
    var := arg.expr.GetVar;
    @debug_assert(arg.expr&.is(.GetVar) && var.kind != .Const, "took address of r-value");
    ref := self.var_lookup&.get_ptr(var.id).expect("addr runtime var");
    declare_now(self, p&, t) {
        @fmt(self.out, "&%", ref)
    }
}

fn emit_call_if(self: *Emit, arg: *FatExpr, p: Placement) Str #once = {
    parts := arg.expr.If&;
    cond := self.compile_expr(parts.cond, .NewMemory);
    
    if arg.ty != void && self.is_trivial(parts.if_true) && self.is_trivial(parts.if_false) {
        return (self.declare_now(p&, arg.ty) {
            t := self.compile_expr(parts.if_true, .NewMemory);
            f := self.compile_expr(parts.if_false, .NewMemory);
            @fmt(self.out, "% ? % : %", cond, t, f);
        });
    };
    
    result := self.unify_placement(p&, arg.ty);
    self.statement();
    invert := parts.if_true.is_empty() && !parts.if_false.is_empty();
    @fmt(self.out, "if (%%) {\n", @if(invert, "!", ""), cond);
    parts := @slice(parts.if_true, parts.if_false);
    @if(invert) parts.swap(0, 1);
    indented self {
        _ := self.compile_expr(parts[0], p);
        if self.last_statement_start == self.out.len {
            @fmt(self.out, "\n");
        };
    };
    if parts[1].is_empty() {
        self.statement("}\n");
    } else {
        self.statement("} else {\n");
        indented self {
            _ := self.compile_expr(parts[1], p);
            if self.last_statement_start == self.out.len {
                @fmt(self.out, "\n");
            };
        };
        self.statement("}\n");
    };
    result
}

fn emit_switch(self: *Emit, arg: *FatExpr, p: Placement) Str #once = {
    parts := arg.expr.Switch;
    inspect := self.compile_expr(parts.value, .NewMemory); 
    result := self.unify_placement(p&, arg.ty);
    self.statement();
    @fmt(self.out, "switch (%) {\n", inspect);
    indented self {
        each parts.cases { f |
            value, body := (f._0, f._1&);
            self.statement();
            @fmt(self.out, "case %: {\n", value);
            indented self {
                _ := self.compile_expr(body, p);
                if !self.current_block_is_dead {
                    self.statement("break;\n");
                }
            };
            self.statement("}\n");
        };
        self.statement("default: {\n");
        indented self {
            _ := self.compile_expr(parts.default, p);
        };
        self.statement("}\n");
    };
    self.statement("}\n");
    result
}

fn emit_call_loop(self: *Emit, arg: *FatExpr) Str #once = {
    self.statement();
    @fmt(self.out, "while(1){\n");
    indented self {
        _ := self.compile_expr(arg, .Discard);
    };
    self.statement();
    @fmt(self.out, "}\n");
    ""
}

fn construct_aggregate(self: *Emit, pattern: *Pattern, requested: Type, p: Placement) Str #once = {
    raw_container_ty := self.program.raw_type(requested);
    self.program.finish_layout(raw_container_ty);  // :extra
    @match(self.program.get_type(raw_container_ty)) {
        fn Struct(f) => {
            fields := @ref Str.list(pattern.bindings.len, temp());
            enumerate pattern.bindings& { i, b | 
                fields.push(self.compile_expr(b.default&, .NewMemory));
                
            };
            @if(p&.is(.Discard)) return("");
            self.declare_now(p&, requested) {
                @fmt(self.out, "(%) {\n", self.type_name(requested));
                indented self {
                    enumerate pattern.bindings& { i, b | 
                        name := self.ident(b.ident().unwrap());
                        if self.program.get_info(b.ty.Finished)[].stride_bytes != 0 {
                            self.statement();
                            @fmt(self.out, ".% = %,\n", name, fields[i]);
                        };
                    };
                };
                self.statement("}");
            }
        }
        fn Tagged(f) => {
            @debug_assert_eq(pattern.bindings.len, 1, "@tagged must have one active varient");
            value := pattern.bindings.index(0).get_default().unwrap();
            name := pattern.bindings[0].name.unwrap();
            i    := f.cases.index_of(fn(f) => f._0 == name).expect("case name to exist in type");
            payload := self.compile_expr(value, .NewMemory);
            @if(p&.is(.Discard)) return("");
            self.declare_now(p&, requested) {
                case_name := self.ident(name);
                @fmt(self.out, "(%) { .tag = %, ", self.type_name(requested), i);
                if value.ty != void {
                    @fmt(self.out, ".% = %, ", case_name, payload);
                };
                @fmt(self.out, "}");
            }
        }
        @default => unreachable();
    }
}

fn as_const(self: *FatExpr, $T: Type) T #generic = {
    @assert(self.expr&.is(.Value), "as_const");
    T.assume_cast(self.expr.Value.bytes&)[]
}

fn fmt_fn_name(self: *Emit, f: FuncId) []u8 = 
    self.program.fmt_fn_name(f);

fn pre_eval_tuple(self: *Emit, values: []FatExpr) []Str = {
    fields := @ref Str.list(values.len, temp());
    each values { expr | 
        fields.push(self.compile_expr(expr, .NewMemory));
    };
    fields.items()
}

fn is_empty(e: *FatExpr) bool = {
    e.ty == void && e.expr&.is(.Value)
}

fn type_name(self: *Emit, t: Type) Str = {
    if self.simple_type(t) { s |
        return s;
    };
    self.use.insert(Type = t);
    @tfmt("T%", t)
}

fn simple_type(self: *Emit, t: Type) ?Str = {
    (Some = @match(self.program.get_type(t)) { 
        fn F32() => "f32";
        fn F64() => "f64";
        fn Int(it) => {
            bits := it.bit_count;
            if !(bits == 8 || bits == 16 || bits == 32 || bits == 64) {
                bits = 64;
            };
            @tfmt("%%", @if(it.signed, "i", "u"), bits)
        };
        fn Enum(it) => self.type_name(it.raw);
        fn Named(it) => self.type_name(it._0);
        fn void() => "void";
        fn Never() => "void";
        fn VoidPtr() => "void*";
        fn Bool() => "u8";
        fn Ptr(inner) => @tfmt("%*", self.type_name(inner[]));
        @default => return(.None);
    })
}

// franca has @"raw identifiers", fewer keywords, and comptime code can create arbitrary asts. 
// so some will need to be mangled. TODO: this is not conflict proof. 
fn ident(self: *Emit, sym: Symbol) Str = {
    s := self.program.get_string(sym);
    for s { c |  
        if !(c.is_ascii_alpha() || c.is_ascii_digit() || c == "_".ascii()) {
            return @tfmt("S__%", sym);
        };
    };
    @if(s.len == 0 || s[0].is_ascii_digit()) return(@tfmt("S__%", sym));
    kw := import("@/examples/import_c/tokenize.fr").keyword_tokens;
    if kw.contains(s) {  // :SLOW
        s = @tfmt("%_", s);
    };
    s
}

fn indented(self: *Emit, $body: @Fn() void) void = {
    self.indent += 1;
    self.statement();
    body();
    self.indent -= 1;
    self.current_block_is_dead = false;
}

fn declare_now(self: *Emit, p: *Placement, t: Type, $body: @Fn() void) Str = {
    i := self.out.len;
    result := "";
    trivial := p.is(.Trivial);
    if !trivial {
        self.statement();
        result = self.declare_now(p, t);
    } else {
        @fmt(self.out, "(");
    };
    if self.program.get_info(t)[].stride_bytes == 0 && !@is(p, .Trivial, .Return) {
        p[] = .Discard;
    };
    body();
    if p.is(.Return) {
        self.current_block_is_dead = true;
    }
    if !trivial {
        @fmt(self.out, ";\n");
    } else {
        @fmt(self.out, ")");
        result = self.out.items().rest(i).shallow_copy(temp());
        self.out.len = i;
    };
    result
}

fn statement(self: *Emit, s: Str) void = {
    self.statement();
    @fmt(self.out, "%", s);
}

fn statement(self: *Emit) void = {
    @if(self.last_statement_start == self.out.len) return();
    @debug_assert(self.out.items().ends_with("\n"));
    self.out.push_repeated(self.indent, "\t".ascii());
    self.last_statement_start = self.out.len;
}

fn declare_now(self: *Emit, p: *Placement, t: Type) Str = {
    t = self.program.raw_type(t);
    @debug_assert(t != UnknownType);
    if self.program.get_info(t)[].stride_bytes == 0 {
        p[] = .Discard;
    };
    @match(p[]) {
        fn Trivial() => todo();
        fn Return() => {
            @fmt(self.out, "return ");
            ""
        }
        fn NewMemory() => {
            p[] = (Declare = self.new_tmp_name());
            self.declare_now(p, t)
        }
        fn Declare(name) => {
            self.lift_declare_local(t, name, true);
            p[] = (Assign = name);
            name
        }
        fn Assign(name) => {
            self.statement();
            @fmt(self.out, "% = ", name);
            name
        }
        fn Discard() => {
            self.statement();
            ""
        }
    }
}

// -fsanitize=address Use of out-of-scope stack memory
// in c it's ub for a reference to a stack slot to escape it's scope, 
// but in franca it's only a problem if it escapes the function or loop iteration. 
// and i rely on that a lot, any time @ref/@slice/#inline/*semantic*/ is used in a nested expression. 
fn lift_declare_local(self: *Emit, t: Type, name: Str, have_value: bool) void = {
    lift := self.indent > 1;
    if lift {
        @if(have_value) self.statement();
        names := self.locals&.get_or_insert(t, => list(temp()));
        names.push(name);
        @if(have_value) @fmt(self.out, "%", name);
    } else {
        self.statement();
        @fmt(self.out, "% %", self.type_name(t), name);
    };
    @if(have_value) @fmt(self.out, " = ");
    @if(!have_value && !lift) @fmt(self.out, ";\n");
}

fn unify_placement(self: *Emit, p: *Placement, t: Type) Str = {
    t = self.program.raw_type(t);
    @debug_assert(t != UnknownType);
    if self.program.get_info(t)[].stride_bytes == 0 {
        p[] = .Discard;
    };
    @match(p[]) {
        fn Return() => "";
        fn Trivial() => {
            p[] = .NewMemory;
            self.unify_placement(p, t)
        }
        fn NewMemory() => {
            p[] = (Declare = self.new_tmp_name());
            self.unify_placement(p, t)
        }
        fn Declare(name) => {
            self.lift_declare_local(t, name, false);
            p[] = (Assign = name);
            name
        }
        fn Assign(name) => {
            self.statement();
            name
        };
        fn Discard() => {
            self.statement();
            ""
        }
    }
}

fn define_type(self: *Emit, it: Type) void = {
    info := self.program.get_type(it);
    @fmt(self.out, "typedef ");
    name := self.type_name(it);
    if self.simple_type(it) { s |
        @fmt(self.out, "%", s);
    } else {
    @match(info[]) {
        fn Struct(it) => {
            @fmt(self.out, "% % {\n", @if(it.is_union, "union", "struct"), name);
            each it.fields { it |
                if self.program.get_info(it.ty)[].stride_bytes != 0 {
                    @fmt(self.out, "\t% %;\n", self.type_name(it.ty), self.ident(it.name));
                };
            };
            @fmt(self.out, "}");
        }
        fn Tagged(it) => {
            @fmt(self.out, "struct % {\n", name);
            @fmt(self.out, "\tint64_t tag;\n");
            i, count := (self.out.len, 0);
            @fmt(self.out, "\tunion {\n");
            for it.cases { name, type |
                if type != void {
                    count += 1;
                    @fmt(self.out, "\t\t% %;\n", self.type_name(type), self.ident(name));
                }
            };
            @fmt(self.out, "\t};\n");
            if count == 0 {
                self.out.len = i;
            };
            @fmt(self.out, "}");
        }
        fn Array(it) => @fmt(self.out, "struct % { % data[%]; }", name, self.type_name(it.inner), it.len);
        fn FnPtr(f_ty) => {
            self.write_sig(f_ty.ty, @tfmt("*%", name), false, .None);
            return();  // name goes in the middle
        }
        fn Placeholder() => @fmt(self.out, "void");  // TODO ???
        @default => @panic("TODO: /* % */", self.program.log(it)); 
    };
    };
    @fmt(self.out, " %;\n", name);
}

fn write_sig(self: *Emit, f_ty: FnType, name_string: Str, weak: bool, alias: ?Str) void = {
    @fmt(self.out, "% ", self.type_name(f_ty.ret));
    @fmt(self.out, "(%)(", name_string);
    for self.program.arg_types(f_ty.arg) { it |
        @fmt(self.out, "%, ", self.type_name(it));
    };
    self.out.len -= 2*int(self.out.items().ends_with(", "));
    @fmt(self.out, ")");
    if alias { alias |
        // rn only used for macos-amd FOO$INODE64 so the "_" mangle is always right
        @fmt(self.out, " asm(\"_%\")", alias);
    };
    if weak {
        @fmt(self.out, " __attribute__((weak))");
    };
    @fmt(self.out, ";\n");
}

pump :: fn(comp: *SelfHosted, fns: []FuncId) Str = {
    a := comp.get_alloc();
    
    all_items: HashMap(ItemKey, ItemData) = init(a);
    pending: List(ItemKey) = list(a);
    use: HashSet(ItemKey) = init(a);
    out := u8.list(a);
    out&.reserve(1.shift_left(23));
    
    for fns { it |
        all_items&.insert((FuncId = it), zeroed(ItemData));
        pending&.push(FuncId = it);
    };
    
    rt_init := comp.env.runtime_init.expect("declaration of franca_runtime_init (forgot to include lib/core.fr?)");
    pending&.push(FuncId = rt_init);
    all_items&.insert((FuncId = rt_init), zeroed(ItemData));
    roots := pending.items().shallow_copy(a).assume_owned(a);
    
    // doing it this way is worse than main_thread_pump at making sure intrinsics are first. 
    // but i need an extra level of sorting to output them in order and it feels dumb to keep track of it twice. 
    // Func.callees isn't enough (doesn't have types/data) and also misses some (mutual, shims, etc.). 
    while => pending&.pop() { key |
        emit: Emit = init(comp, use&, out&);
        check_for_new_aot_bake_overloads(comp).unwrap();
        @match(key) {
            fn FuncId(fid) => {
                func := comp.get_function(fid);
                xx := comp.poll_in_place(void, => comp.compile_body(fid));
                or xx { err | 
                    @eprintln("failed compile %", comp.get_string(func.name));
                    comp.report_error(err)
                };
                emit&.emit_body(fid);
                
                // HACK: makes complation order more similar to the other one because my overloading is garbage
                for func.callees& { fid |
                    comp.poll_in_place(void, => comp.compile_body(fid));
                };
            }
            fn Type(it) => emit&.define_type(it);
            fn BakedVarId(it) => emit&.define_baked_var(it);
        };
        
        used := @ref ItemKey.list(use.raw.len_including_tombstones, a);
        each use.raw.arr& { slot |
            // TODO: ugh, this removes info about when a type refers to itself indirectly
            //       so then need lots of extra typedefs but don't want to count the one for getting its own name. 
            if slot.hash != 0 && slot.key& != key& {
                @debug_assert(slot.hash != 1);
                _ := all_items&.get_or_insert(slot.key) {
                    pending&.push(slot.key);
                    zeroed(ItemData)
                };
                
                used.push(slot.key);
            }
            slot.hash = 0;  // remove without tombstone valid because removing all. 
        };
        use.raw.len_including_tombstones = 0;
        it := all_items&.get_ptr(key).unwrap();
        @debug_assert(it.use.len == 0 && it.src.len == 0, "double emit");
        it[] = (use = used.items(), src = out.items().shallow_copy(a), id = -1, key = key);
        out&.clear();
    };
    
    @fmt(out&, """
        /* @generated by franca/examples/emit_c.fr */
        // -Wl,-undefined,dynamic_lookup are the magic words for apple's linker.
        #include <stdint.h>
        #include <stdatomic.h>
        #pragma GCC diagnostic push
        #pragma GCC diagnostic ignored "-Wparentheses-equality"
        #pragma GCC diagnostic ignored "-Wincompatible-library-redeclaration"
        #pragma GCC diagnostic ignored "-Wreturn-type"
        
        static uint64_t __franca_base_address[1] = { % };
        static uint8_t __franca_aot_debug_info[%];
    """, FRHOSTED_MAGIC, size_of(import("@/lib/crash_report.fr").AotDebugInfo));
    @fmt(out&, "\n");
    
    // shorter names save lots of bytes but not as unreadable as mangling to T%.
    sizes := @slice(8, 16, 32, 64);
    for sizes { it |
        @fmt(out&, "typedef uint%_t u%;\n", it, it);
        @fmt(out&, "typedef int%_t i%;\n", it, it);
    };
    @fmt(out&, "typedef float f32;\n");
    @fmt(out&, "typedef double f64;\n");
    
    @assert(fns.len == 1, "TODO: wrap exports");
    wrapped_main := @tfmt("""
        int main(int argc, char **argv, char **envp) { 
            %(argc, (void*) argv, %, (void*) envp, 0); 
            return 0; 
        }
    """, comp.fmt_fn_name(rt_init), comp.fmt_fn_name(fns[0]));
    root := zeroed(FuncId);  // fake root node so whole graph is reachable
    all_items&.insert((FuncId = root), (
        use = roots.items(),
        key = (FuncId = root),
        src = wrapped_main,
        id = -1,
    ));
    
    // sort to minimize required forward declarations
    fillrpo(all_items&, (FuncId = root));
    ordered := temp().alloc_zeroed(*ItemData, all_items.raw.len_including_tombstones);
    each all_items& { _, it |
        ordered[it.id] = it;
    };
    
    // TODO: if this is how i do it, don't include types in the graph
    //       but i don't like how this gets rid of the locality of the graph way of doing it. 
    forward: DynamicBitSet = empty(temp());
    for comp.hack_order_types_were_sized { it |
        if all_items&.get_ptr(Type = it) { it |
            maybe_forward :: fn(check) => @if_let(check) fn Type(t) => {
                check_data := all_items&.get_ptr(check).unwrap();
                xx := @is(comp.get_type(t), .Struct, .Tagged, .Array);
                union := comp.get_type(t).is(.Struct) && comp.get_type(t)[].Struct.is_union;
                if check_data.src.len != 0 && !forward&.get_set(t.as_index()) && xx {
                    @fmt(out&, "typedef % T% T%;\n", @if(union, "union", "struct"), t, t);
                };
            };
            maybe_forward(it.key);  // TODO: aaa
            for it.use { check |
                maybe_forward(check);
            };
        
            out&.push_all(it.src);
            it.src = "";
        };
    };
    
    defined: HashSet(FuncId) = init(temp());
    emit: Emit = init(comp, use&, out&);
    for_rev ordered { it |
        @if_let(it.key) fn FuncId(it) => {
            defined&.insert(it);
        };
        for it.use { it |
            @if_let(it) fn FuncId(it) => {
                if !defined&.insert(it) {
                    // call graph had a cycle.
                    emit&.write_sig_names(it, emit&.fmt_fn_name(it));
                    @fmt(out&, ";\n");
                };
            };
        };
    
        out&.push_all(it.src);
    };
    
    @fmt(out&, """
        #ifdef __wasm32__
        #error "TODO: deal with 32 bit pointers"
        #endif
        #pragma GCC diagnostic pop
    """);
    @fmt(out&, "\n/* deps:\n");
    @fmt(out&, " * % %\n", comp.vtable.self_hash, Incr.self_filename);
    each comp.codemap.files& { it |
        @fmt(out&, " * % %\n", it.hash&, it.name);
    };
    @fmt(out&, " */\n");
    out.items()
}

main :: fn() void = {
    Incr'set_self_hash();
    driver_vtable_exports;
    
    #use("@/lib/args.fr");
    args := parse_args(@struct(i := "", o := "", unsafe := false));
    @assert(args.i != "" && args.o != "", "USAGE: [emit_c.fr] -i filename.fr -o a.c [-unsafe]");
    
    vtable := init_driver_vtable(false);
    opts := vtable.default_build_options();
    if args.unsafe {
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    opts.retain_function_names = true;
    src := @tfmt("""#include_std("lib/core.fr"); #include_std("%"); """, args.i);
    c := new_with_src(vtable, src, "entry_file", opts);
    c := vtable.with(c);
    fid := or c.get_unique_named("main") {
        panic("expected exactly one function called 'main'")
    };
    self := c.data.cast()[][];
    result := pump(self, @slice(fid));
    write_entire_file_or_crash(args.o, result);
    c'vtable'destroy_compiler(c.data);
}

ItemKey :: @tagged(Type: Type, FuncId: FuncId, BakedVarId: BakedVarId);
ItemData :: @struct {
    use: []ItemKey;
    src: Str;
    id: i64;
    key: ItemKey;
};

::AutoEq(ItemKey);  ::AutoHash(ItemKey, TrivialHasher);
::AutoEq(BakedVarId); ::AutoHash(BakedVarId, TrivialHasher);

fn fillrpo(it: *HashMap(ItemKey, ItemData), start: ItemKey) void = {
    n := rporec(it, start, it.raw.len_including_tombstones - 1) + 1;
    @assert_eq(n, 0);
    rporec :: fn(it: *HashMap(ItemKey, ItemData), i: ItemKey, x: i64) i64 = {
        self := it.get_ptr(i).unwrap();
        @if(self.id != -1) return(x);
        self.id = 1;
        for self.use { i |
            x = rporec(it, i, x);
        };
        self.id = x;
        x - 1
    }
}

DISABLE_IMPORT_FRC :: true;  // TODO
DEBUG_SPAM_LOG :: false;
#include_std("compiler/lib.fr");
