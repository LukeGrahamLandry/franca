// This is the same idea as via_wasm.fr except this time we're running a bf
// program that isn't available at comptime so it can't be statically 
// compiled into a normal function. Instead the translation must happen at runtime, 
// and the wasm compiler must be included in the executable as a library. 
// You'll notice that via_wasm_rt.fr has a much larger AOT binary than via_wasm.fr. 

// Reusing the bf->wasm translation code from the comptime example. 
ViaWasm :: import("@/examples/bf/via_wasm.fr");

main :: fn() void = {
    bf_source := import("@/examples/bf/README.fr").HELLO_WORLD;
    wasm := ViaWasm'to_wasm_module(temp(), bf_source).items();
    
    rt: Wasm.Engine = init(temp(), (arch = query_current_arch(), os = query_current_os(), type = .JitOnly), "");
    memory, ctx := new_memory(65536, 65536);
    mod := rt&.compile(wasm);
    exports := ViaWasm'collect_exports(memory, ctx);
    instance := mod.instantiate(exports&);
    
    f := instance.exports&.get("main").unwrap();
    c := bit_cast_unchecked(rawptr, @FnPtr(ctx: rawptr, p: u32) void, f.Function.callee);
    c(f.Function.context, 0);
}

Wasm :: import("@/examples/import_wasm/runtime.fr");
