// compile a bf program to a wasm module. 
// then import the wasm module to call it from franca. 

main :: fn() void = {
    module := @run {
        bf_source := import("@/examples/bf/README.fr").HELLO_WORLD;
        wasm := to_wasm_module(ast_alloc(), bf_source).items();
        #use("@/examples/import_wasm/ffi.fr");
        public    := scope_of(Type, Exports);
        include(wasm, current_compiler_context(), public)
    };
    // TODO: you should be able to instantiate at comptime too 
    //       and then generate wrappers that close over the *Instance 
    //       so you can call the exports like normal functions. 
    
    rt: Rt.Engine = init_for_jit(general_allocator(), "");
    memory, ctx := rt&.new_memory(65536, 65536);
    exports := collect_exports(memory, ctx);
    instance := instantiate(rt&, module, exports&);
    f := instance.exports&.get("main").unwrap();
    callee, ctx := (f.Function.callee, f.Function.context);
    callee := bit_cast_unchecked(rawptr, @FnPtr(ctx: rawptr, p: u32) void, callee);
    
    callee(ctx, 0);
    drop(rt&);
}

// These are the functions we allow the wasm module to import. 
Exports :: @struct {
    env :: @struct {
        putchar :: fn(ctx: *Rt.UserContext, c: u8) u8 = {
            putchar_UNBUFFERED(c);
            c
        }
        getchar :: fn(ctx: *Rt.UserContext) i32 = {
            getchar_UNBUFFERED()
        }
    }
};

collect_exports :: fn(memory: Rt.Export, ctx: *Rt.UserContext) Rt.ExportsEnv = {
    exports: Rt.ExportsEnv = (_ = init(temp()));
    exports&.insert("env", "putchar", Exports.env.putchar, ctx);
    exports&.insert("env", "getchar", Exports.env.getchar, ctx);
    exports&.insert("main", "memory", memory);
    exports
}

// 
// At this point, the cool meta programming is over (import_wasm did the heavy lifting). 
// The rest of this program is just translating the bf to wasm. 
// 

// translates the bf to wasm bytecode (which goes in the CODE section). 
// imports = [putchar, getchar], locals[0] = the pointer
// since all the indices are low, leb encoding is always one byte and i don't have to worry about it. 
to_wasm_bytecode :: fn(out: *List(u8), code: Str) void = {
    #use("@/backend/lib.fr");  // overkill just to get wasm/bits.fr but i also need O/Cls for lookup
    #use("@/examples/bf/README.fr");
    
	for code { c | @switch(@as(Bf) c) {
        @case(.Inc) => deref(.add);
        @case(.Dec) => deref(.sub);
        @case(.Right) => move(.add);
        @case(.Left)  => move(.sub);
        @case(.Output) => {
            get(); 
            op(.loadub, .Kw); out.push(0); out.push(0);
            inst(.Call); out.push(0);
            inst(.Drop)
        }
        @case(.Input)  => {
            get(); 
            inst(.Call); out.push(1);
            op(.storeb, .Kw); out.push(0); out.push(0);
        }
        @case(.Open)   => {
            inst(.Block);  // def break
            out.push(@as(u8) Wasm.ValType.EmptyBlock);
            inst(.Loop);   // def continue
            out.push(@as(u8) Wasm.ValType.EmptyBlock);
            
            get();
            op(.loadub, .Kw); out.push(0); out.push(0);
            inst(.I32_Const); out.push(0);
            op(.ceqw, .Kw);
            inst(.BrIf); out.push(1);  // goto break
        }
        @case(.Close)  => {
            inst(.Br); out.push(0);  // goto continue
            inst(.End);  // of loop
            inst(.End);  // of block
        }
        @default()     => ();
    }}
    inst(.End);  // of the function
    
    // Some helpers used above:
    
    inst :: fn(i: Wasm.Inst) => 
        out.push(i.raw());
    op :: fn($o: Qbe.O, $k: Qbe.Cls) => 
        out.push(:: { b := lookup_wasm_encoding(o, k); b.unwrap() });
    get :: fn() => {
        inst(.LocalGet); out.push(0);
    }
    set :: fn() => {
        inst(.LocalSet); out.push(0);
    }
    deref :: fn($o: Qbe.O) => {
        get();
        get();
        op(.loadub, .Kw); out.push(0); out.push(0);
        inst(.I32_Const); out.push(1);
        op(o, .Kw);
        op(.storeb, .Kw); out.push(0); out.push(0);
    }
    move :: fn($o: Qbe.O) => {
        get();
        inst(.I32_Const); out.push(1);
        op(o, .Kw);
        set();
    };
}

// TODO: im not sure if it makes a more interesting example to write out the bytes manually like this 
//       or to import some abstraction for making modules in a way that doesn't suck. 
// create a wasm module that exports a single function called "main"
// in general you need to use leb128_unsigned but i don't because i know the indices are low enough to fit in one byte. 
// this returns a normal wasm module (you can write it to a file and run it with examples/import_wasm/run.fr if you want). 
to_wasm_module :: fn(a: Alloc, code: Str) List(u8) = {
    Wasm :: import("@/backend/wasm/bits.fr");
    out := u8.list(a); out := out&;
    out.push_all(Wasm.version_magic); 
    string :: fn(s) => uleb_patch_delta(out, => out.push_all(s));
    
    // We need 3 function types: putchar, getchar, and our exported function. 
    out.push(@as(u8) Wasm.Section.Type);
    uleb_patch_delta out {
        out.push(3);  // number of types
        
        // (u32) -> (u32)
        out.push(@as(u8) Wasm.ValType.ResultStart);
        out.push(1);
        out.push(@as(u8) Wasm.ValType.I32);
        out.push(1);
        out.push(@as(u8) Wasm.ValType.I32);
        
        // () -> (u32)
        out.push(@as(u8) Wasm.ValType.ResultStart);
        out.push(0);
        out.push(1);
        out.push(@as(u8) Wasm.ValType.I32);
        
        // (u32) -> ()
        out.push(@as(u8) Wasm.ValType.ResultStart);
        out.push(1);
        out.push(@as(u8) Wasm.ValType.I32);
        out.push(0);
    };
    
    // We need two function imports and a memory. 
    out.push(@as(u8) Wasm.Section.Import);
    uleb_patch_delta out {
        out.push(3);  // number of imports
        
        string "env";
        string "putchar";
        out.push(@as(u8) Wasm.ImportType.Func);
        out.push(0);  // type index
        
        string "env";
        string "getchar";
        out.push(@as(u8) Wasm.ImportType.Func);
        out.push(1);
        
        string "main";
        string "memory";
        out.push(@as(u8) Wasm.ImportType.Memory);
        out.push(0); // has max?
        out.push(1); // min number of pages
    };
    
    // We are required to forward declare our function. 
    out.push(@as(u8) Wasm.Section.Function);
    uleb_patch_delta out {
        out.push(1);  // number of local functions
        out.push(2);  // type index
    };
    
    // Make our one function public
    out.push(@as(u8) Wasm.Section.Export);
    uleb_patch_delta out {
        out.push(1);  // number of exports
        
        string "main";
        out.push(@as(u8) Wasm.ImportType.Func);
        out.push(2);  // function index (includes imports)
    };
    
    // Now we're finally allowed to give the function body. This is the meat of the module. 
    {
        out.push(@as(u8) Wasm.Section.Code);
        uleb_patch_delta out {
            out.push(1);  // number of functions
            uleb_patch_delta out {
                out.push(0);  // number of non-parameter locals
                to_wasm_bytecode(out, code);
            }
        }
    };
    
    out[]
}

Rt :: import("@/examples/import_wasm/runtime.fr");
