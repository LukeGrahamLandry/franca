#include_std("lib/core.fr");
#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;

main :: fn() void = {
    src := TINY;
    a := cli_args();
    logging := "";
    range(0, a.len) { i |
        if a[i] == "---literal_input" && i < a.len - 1 {
            src = a[i + 1].str();
        }
        if a[i] == "-d" && i < a.len - 1 {
            logging = a[i + 1].str();
        }
        
        @if(TODOWASM)
        @if(query_current_arch() == .wasm32)
        if a[i] == "-file" && i < a.len - 1 {
            name := a[i + 1].str();
            fetch_file :: fn(ptr: *u8, len: i64) *u8 #weak #import("libc");
            result := fetch_file(name.ptr, name.len);
            @assert(!result.is_null(), "failed to read %", name);
            result: CStr = (ptr = result);
            src = result.str();
        }
    };
    src := @tfmt("""#include_std("lib/core.fr");%""", src);

    if query_current_arch() != .wasm32 {
        update_global_stdlib_path();
    };
    a := general_allocator();
    vtable := init_driver_vtable();
    comp := {vtable.init_compiler}(vtable.default_build_options()); // TODO: comptime get the current arch
    c := vtable.with(comp);
    
    file := c.add_file("repl!", src);
    self := c.data.cast()[][];
    self.tempdebug = true;
    self.comptime_codegen.m.set_debug_types(logging, true);
    
    self.do_export("putchar", @Fn(c: u8) void, putchar_UNBUFFERED);
    self.do_export("exit", @Fn(c: i32) Never, Syscall.exit);
    self.do_export("write", @Fn(fd: i32, p: *u8, l: i64) i64, fn(a, b, c) = { x := Syscall'write((fd = a), b, c); x.value });
    self.do_export("mprotect", @Fn(a: rawptr, b: i64, c: i64) i64, fn(a, b, c) = { x := Syscall'mprotect(a, b, c); x.value });
    self.do_export("mmap", @Fn(a: rawptr, b: i64, c: i64, d: i64, e: i32, f: i64) i64, fn(a, b, c, d, e, f) = { Syscall'mmap(a, b, c, d, (fd = e), f) });
    self.do_export("munmap", @Fn(a: rawptr, b: i64) i64, fn(a, b) = { x := Syscall'munmap(a, b); x.value });
    jit_instantiate_module :: fn(a: *u8, b: i64, c: i64, d: u32) void #weak #import("libc");
    self.do_export("jit_instantiate_module", @Fn(a: *u8, b: i64, c: i64, d: u32) void, jit_instantiate_module);
    
    weak :: import("@/examples/import_wasm/run.fr").weak_imports;
    inline_for weak { $name |
        // TODO: use the right signetures so you actually get the message. 
        self.do_export(::name[], @Fn() void, fn() = @panic("comptime code tried to call a weak import"));
    };
    
    id := self.parser.push_parse(src, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RawList(FatStmt), stmts);
    stmts := stmts.items();
    r := {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts);
    self.unwrap_report_error(void, r);
    
    fid := c.get_unique_named("main") || @panic("no function called 'main'");
    
    SAME_MODULE :: true;
    f := if !SAME_MODULE {
        // TODO: this is what i want but unfortunatly it's slower
        //       because it doesn't allow jit shims so it has to compile the whole program
        //       and can't skip vtables you don't call. like if you use the backend it has to do all targets. 
        
        name := c.fmt_fn_name(fid);
    
        m := general_allocator().box(QbeModule);
        backend'init_module(m, (
            arch = query_current_arch(), 
            os = query_current_os(), 
            type = .JitOnly,
        ));
        self.other_module&.push(m, self.get_alloc());
        shared := init_codegen(m, self.get_alloc(), false); // nothreads
        main_thread_pump(c, shared, @slice(fid), false);  // nowrapmain
        m.make_exec();
        m.get_addr(name) || @panic("ICE: lost %", name)
    } else {
        c.get_jitted(fid)
    };
    
    f := bit_cast_unchecked(rawptr, @FnPtr() void, f);
    push_dynamic_context {
        context(DefaultContext)[].cli_arguments = empty();
        f();
    };
}

do_export :: fn(self: *SelfHosted, name: Str, $T: Type, $F: FuncId) void = {
    ff: T : F;
    f: rawptr = ff;
    self.todo_injected.insert(name, f);
}

TINY :: """
fn main() void = {
    write :: fn(fd: u32, p: *u8, l: i64) i64 #libc;
    s := "Hello World";
    write(1, s.ptr, s.len);
};
""";
