
#use("@/examples/web/demo.fr")
main :: fn() void = {
    args := get_args(TINY);
    
    src := u8.list(temp());
    src&.push_all("""#include_std("lib/core.fr");""");
    src&.push_all(args.src);
    gfx := args.src.contains("graphics/lib.fr") && args.target.type == .JitOnly && query_current_arch() == .wasm32;
    if gfx {
        src&.push_all("\n:: Sapp.Wgpu;");
        src&.push_all("\nSOKOL_BACKEND :: RenderBackend.WGPU;");
        src&.push_all("\nGRAPHICS_TARGET_WEB :: true;");
    };
    src := src.items();
    
    if query_current_arch() != .wasm32 {
        update_global_stdlib_path();
    };
    a := general_allocator();
    vtable := init_driver_vtable();
    opts := vtable.default_build_options();
    if true {  // TODO: ui toggle for this
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    comp := {vtable.init_compiler}(opts); // TODO: comptime get the current arch
    c := vtable.with(comp);
    
    file := c.add_file("repl!", src);
    self := c.data.cast()[][];
    self.comptime_codegen.m.set_debug_types(args.logging, true);
    
    for_exports { name, addr |
        self.todo_injected.insert(name, addr);
    };
    if gfx {
        //WGPU :: Sg.Webgpu.WGPU;
        WGPU :: import("@/target/franca/webgpu.g.fr");
        //addr := @import_symbol("francaRequestState", "webgpu");  
        fid :: get_constant(FuncId, Sapp.Wgpu, @symbol francaRequestState).unwrap();
        addr :: current_compiler_context().get_jitted(fid);
        self.todo_injected.insert("francaRequestState", addr);
        inline_for WGPU.get_constants() { $n |
            name :: n[].str();
            @if(@run name.starts_with("wgpu")) {
                fid :: get_constant(FuncId, WGPU, n[]).unwrap();
                addr :: current_compiler_context().get_jitted(fid);
                self.todo_injected.insert(name, addr);
            };
        };
    };
    
    id := self.parser.push_parse(src, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RawList(FatStmt), stmts);
    stmts := stmts.items();
    r := {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts);
    self.unwrap_report_error(void, r);
    
    fid := c.get_unique_named("main") || @panic("no function called 'main'");
    
    SAME_MODULE :: false;
    f := if !SAME_MODULE {
        // TODO: this is what i want but unfortunatly it's slower
        //       because it doesn't allow jit shims so it has to compile the whole program
        //       and can't skip vtables you don't call. like if you use the backend it has to do all targets. 
        
        name := c.fmt_fn_name(fid);
    
        m := general_allocator().box_uninit(QbeModule);
        backend'init_module(m, args.target);
        m.set_debug_types(args.logging, true);
        self.other_module&.push(m, self.get_alloc());
        shared := init_codegen(m, self.get_alloc(), false); // nothreads
        ::enum(@type m.goal.type);
        aot := m.goal.type != .JitOnly;
        main_thread_pump(c, shared, @slice(fid), aot);
        if aot {
            yield_module_main(m);
            return();
        };
        
        m.make_exec();
        m.get_addr(name) || @panic("ICE: lost %", name)
    } else {
        c.get_jitted(fid)
    };
    f := bit_cast_unchecked(rawptr, @FnPtr() void, f);
    push_dynamic_context {
        context(DefaultContext)[].cli_arguments = empty();
        f();
    };
}

TINY :: """
fn main() void = {
    write :: fn(fd: u32, p: *u8, l: i64) i64 #libc;
    s := "Hello World";
    write(1, s.ptr, s.len);
};
""";

#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
