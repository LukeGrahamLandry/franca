
#use("@/examples/web/demo.fr")
main :: fn() void = {
    args := get_args(TINY);
    src := @tfmt("""#include_std("lib/core.fr");%""", args.src);

    if query_current_arch() != .wasm32 {
        update_global_stdlib_path();
    };
    a := general_allocator();
    vtable := init_driver_vtable();
    comp := {vtable.init_compiler}(vtable.default_build_options()); // TODO: comptime get the current arch
    c := vtable.with(comp);
    
    file := c.add_file("repl!", src);
    self := c.data.cast()[][];
    self.tempdebug = true;
    self.comptime_codegen.m.set_debug_types(args.logging, true);
    
    for_exports { name, addr |
        self.todo_injected.insert(name, addr);
    };
    
    id := self.parser.push_parse(src, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RawList(FatStmt), stmts);
    stmts := stmts.items();
    r := {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts);
    self.unwrap_report_error(void, r);
    
    fid := c.get_unique_named("main") || @panic("no function called 'main'");
    
    SAME_MODULE :: false;
    f := if !SAME_MODULE {
        // TODO: this is what i want but unfortunatly it's slower
        //       because it doesn't allow jit shims so it has to compile the whole program
        //       and can't skip vtables you don't call. like if you use the backend it has to do all targets. 
        
        name := c.fmt_fn_name(fid);
    
        m := general_allocator().box(QbeModule);
        backend'init_module(m, args.target);
        m.set_debug_types(args.logging, true);
        self.other_module&.push(m, self.get_alloc());
        shared := init_codegen(m, self.get_alloc(), false); // nothreads
        ::enum(@type m.goal.type);
        aot := m.goal.type != .JitOnly;
        main_thread_pump(c, shared, @slice(fid), aot);
        if aot {
            m.seal_debug_info("", false, empty());  // TODO
            chunks := {c.vtable.finish_qbe_module}(QbeModule.raw_from_ptr(m));
            bytes := concat(chunks&, temp());
            
            if query_current_arch() == .wasm32 {
                @println("size = %;", bytes.len);
                yield_file :: fn(p: *u8, l: i64) void #weak #libc;
                yield_file(bytes.ptr, bytes.len);
            } else {
                write_entire_file_or_crash("a.out", bytes);
                @println("wrote % bytes to a.out", bytes.len);
            };
            return();
        };
        
        m.make_exec();
        m.get_addr(name) || @panic("ICE: lost %", name)
    } else {
        c.get_jitted(fid)
    };
    f := bit_cast_unchecked(rawptr, @FnPtr() void, f);
    push_dynamic_context {
        context(DefaultContext)[].cli_arguments = empty();
        f();
    };
}

TINY :: """
fn main() void = {
    write :: fn(fd: u32, p: *u8, l: i64) i64 #libc;
    s := "Hello World";
    write(1, s.ptr, s.len);
};
""";

#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
