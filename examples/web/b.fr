
#use("@/examples/web/demo.fr")
main :: fn() void = {
    args := get_args(TINY);
    
    src := u8.list(temp());
    src&.push_all("""#include_std("lib/core.fr");""");
    src&.push_all(args.src);
    // :HackyGraphicsDetection
    gfx := args.src.contains("graphics/lib.fr");
    if gfx {
        src&.push_all("\n:: Sapp.Wgpu;");
        src&.push_all("\nSOKOL_BACKEND :: RenderBackend.WGPU;");
        src&.push_all("\nGRAPHICS_TARGET_WEB :: true;");
        @assert(args.target.type == .JitOnly && query_current_arch() == .wasm32, "TODO: web cross compile graphcis programs");
    };
    src := src.items();
    
    if query_current_arch() != .wasm32 {
        update_global_stdlib_path();
    };
    a := general_allocator();
    vtable := init_driver_vtable();
    opts := vtable.default_build_options();
    opts.retain_function_names = true;
    ;{
        args := cli_args();
        if args.index_of(fn(it) => it[] == "-D") { i |
            if i < args.len() - 1 {
                opts.frontend_logging = args[i + 1].str();
            };
        };
    };
    if false {  // TODO: ui toggle for this
        it := opts.safety_checks&;
        it.insert(.Bounds, false);
        it.insert(.DebugAssertions, false);
        it.insert(.InvalidTag, false);
    };
    comp := {vtable.init_compiler}(opts); // TODO: comptime get the current arch
    c := vtable.with(comp);
    
    file := c.add_file("repl!", src);
    self := c.data.cast()[][];
    self.comptime_codegen.m.set_debug_types(args.logging, true);
    self.comptime_codegen.m.goal.dis = args.target.dis;
    
    if gfx {
        self.comptime_libraries&.insert(
            self.pool.insert_owned("webgpu"), 
            self.comptime_libraries&.get(self.pool.insert_owned("libc")).unwrap(),
        );
    };
    
    id := self.parser.push_parse(src, file);
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self.unwrap_report_error(RawList(FatStmt), stmts);
    stmts := stmts.items();
    r := {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts);
    self.unwrap_report_error(void, r);
    
    fid := c.get_unique_named("main") || @panic("no function called 'main'");
    
    SAME_MODULE :: false;
    m := general_allocator().box_uninit(QbeModule);
    f := if !SAME_MODULE {
        // TODO: this is what i want but unfortunatly it's slower
        //       because it doesn't allow jit shims so it has to compile the whole program
        //       and can't skip vtables you don't call. like if you use the backend it has to do all targets. 
        
        name := c.fmt_fn_name(fid);
    
        backend'init_module(m, args.target);
        m.set_debug_types(args.logging, true);
        self.other_module&.push(m, self.get_alloc());
        shared := init_codegen(m, self.get_alloc(), true);
        ::enum(@type m.goal.type);
        aot := m.goal.type != .JitOnly;
        main_thread_pump(c, shared, @slice(fid), aot);
        // TODO: emit_qbe_included_dyn(m, c&, @slice(fid), @if(aot, .WrapMain, .ExportWithNames));
        
        if aot {
            yield_module_main(m);
            c'vtable'destroy_compiler(c.data);
            return();
        };
        each self.comptime_libraries& { _, lib |
            Qbe'fill_pending_dynamic_imports(m, lib[]);
        };
        Qbe'seal_imports(m);
        m.make_exec();
        m.get_addr(name) || @panic("ICE: lost %", name)
    } else {
        c.get_jitted(fid)
    };
    f := bit_cast_unchecked(rawptr, @FnPtr() void, f);
    push_tls_value(.cli_arguments, empty()) {
        f();
    };
    @if(!SAME_MODULE) drop(m);
    c'vtable'destroy_compiler(c.data);
}

TINY :: """
fn main() void = {
    write :: fn(fd: u32, p: *u8, l: i64) i64 #libc;
    s := "Hello World";
    write(1, s.ptr, s.len);
};
""";

#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
