#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;
#include_std("graphics/lib.fr");
SOKOL_BACKEND :: RenderBackend.WGPU;
GRAPHICS_TARGET_WEB :: true;
::Sapp.Wgpu;

#export
fn main(argc: i64, argv: *CStr, envp: *CStr, sp: i64) void = {
    franca_runtime_init(argc, argv, main2, envp, sp);
}

main2 :: fn() void = {
    lang := "";
    a := cli_args();
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "-lang" {
            lang = value;
        }
    };
    @switch(lang) {
        @case("franca") => import("@/examples/web/b.fr")'main();
        @case("c") => import("@/examples/web/c.fr")'main();
        @case("qbe") => import("@/examples/web/d.fr")'main();
        @case("kaleidoscope") => kaleidoscope_main();
        @default => println("other");
    };
}

#use("@/examples/kaleidoscope.fr")
kaleidoscope_main :: fn() void = {
    args := get_args(EXAMPLE_PROGRAM);
    m := zeroed QbeModule;
    init_default_module(m&, args.target);
    c: *Ctx = init(general_allocator(), args.src, m&);
    c.m.set_debug_types(args.logging, true);
    
    @match(c.compile_loop()) {
        fn Ok() => ();
        fn Err(s) => @panic("%\n before line %", s, c.line);
    };
    
    // TODO: provide implementations of printd/putchard 
    //       or only allow outputting libraries with imports, not exes (and then this main function wouldn't make sense). 
    {
        default_init(c.f, c.m);
        c.f.lnk.id = c.m.intern("main");
        c.f.ret_cls = .Kw;
        c.f.lnk.export = true;
        c.link = c.f.start&;
        b := c.push_block();
        env := c.f.newtmp("env", .Kl);
        c.f.emit(.pare, .Kl, env, QbeNull, QbeNull);
        for c.top_level { id |
            c.f.emit(.arge, .Kl, QbeNull, env, QbeNull);
            c.f.emit(.call, .Kd, Qbe.Null, c.f.symcon(id), QbeNull);
        };
        c.f.copy_instructions_from_scratch_reversed_which_means_forwards(b);
        b.jmp = (type = .retw, arg = Qbe.ConZero);
        c.end_fn();
    };
    
    yield_module_main(m&);
    drop(c);
    
}

CompileArgs :: @struct {
    src: Str;
    logging: Str;
    target: QbeTargetEnv;
};

get_args :: fn(default_src: Str) CompileArgs = {
    a := cli_args();
    out: CompileArgs = (src = default_src, logging = "", target = (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .JitOnly,
    ));
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "---literal_input" {
            out.src = value;
        }
        if a[i] == "-d" {
            out.logging = value;
        }
        
        // TODO: this is dumb. should do a more official wasi thing? 
        if a[i] == "-file" {
            if query_current_arch() == .wasm32 {
                fetch_file :: fn(ptr: *u8, name_len: i64, len_out: *i64) *u8 #weak #import("libc");
                length := -1;
                result := fetch_file(value.ptr, value.len, length&);
                @assert(!result.is_null() && length >= 0, "failed to read %", value);
                out.src = result.slice(length);
            } else {
                out.src = read_entire_file_or_crash(temp(), value);
            }
        }
        if a[i] == "-target" {
            out.target.type = @if(value == "wasm-jit", .JitOnly, .Exe);
            // TODO: decide what OS to say for wasm... wasi? freestanding? 
            (ar: Arch, os: Os) := @switch(value) {
                @case("wasm-jit") => (.wasm32, .macos);
                @case("wasm-aot") => (.wasm32, .macos);
                @case("arm64-macos") => (.aarch64, .macos);
                @case("amd64-macos") => (.x86_64, .macos);
                @case("arm64-linux") => (.aarch64, .linux);
                @case("amd64-linux") => (.x86_64, .linux);
                @case("riscv64-linux") => (.rv64, .linux);
                @default => @panic("invalid -target '%'", value);
            };
            out.target.arch = ar;
            out.target.os = os;
        }
    };
    out
}

FnTypeOf :: fn(fid: FuncId) Type #fold = {
    func := get_function_ast(fid, true, false, true, false);
    f_ty := func.finished_ty().unwrap();
    intern_type(Fn = f_ty)
}

for_exports :: fn($body: @Fn(name: Str, addr: rawptr) void #duplicated) void = {
    do_export :: fn(name: Str, $T: Type, $F: FuncId) void => {
        ff: T : F;
        f: rawptr = ff;
        body(name, f);
    };
   
    WellKnown :: import("@/examples/import_wasm/well_known.fr");
    inline_for get_constants(WellKnown) { $name |
        fid :: get_constant(FuncId, WellKnown, name[]).unwrap();
        do_export(::name[].str(), FnTypeOf(fid), fid);
    };
    
    do_export("exit", @Fn(c: i32) Never, fn(c) = { Syscall'exit(c.intcast()) });
    do_export("write", @Fn(fd: Fd, p: *u8, l: i64) i64Result, Syscall'write);
    do_export("mprotect", @Fn(a: rawptr, b: i64, c: i64) voidResult, Syscall'mprotect);
    do_export("mmap", @Fn(a: rawptr, b: i64, c: i64, d: i64, e: i32, f: i64) i64, Syscall'mmap);
    do_export("munmap", @Fn(a: rawptr, b: i64) voidResult, Syscall'munmap);
    do_export("fsync", @Fn(a: u32) voidResult, fn(a) voidResult = (value = 0));
    jit_instantiate_module :: fn(a: *u8, b: i64, c: i64, d: u32) void #weak #import("libc");
    do_export("jit_instantiate_module", @Fn(a: *u8, b: i64, c: i64, d: u32) void, jit_instantiate_module);

    do_export("calloc", @Fn(m: u32, n: u32) i64, fn(m, n) = {
        n := m.mul(n).zext().align_to(65536);
        Syscall'mmap(zeroed(rawptr), n, 0, 0, (fd = -1), 0)  // only works on wasm cause i don't care about flags
    });
    
    Run :: import("@/examples/import_wasm/run.fr");
    do_export("printf", @Fn(fmt: *u8, va: CVariadic) i32, fn(fmt, va) = {
        // TODO: this won't work on amd64 (env + vararg)
        out := u8.list(temp());
        Run'printf_impl(out&, (ptr = fmt), va&.start());
        print(out.items());
        out.len.intcast()
    });
    
    do_export("sprintf", @Fn(dest: *u8, fmt: *u8, va: CVariadic) i32, fn(dest, fmt, va) = {
        // TODO: this won't work on amd64 (env + vararg)
        out := u8.list(temp());
        Run'printf_impl(out&, (ptr = fmt), va&.start());
        dest.slice(out.len).copy_from(out.items());
        out.len.intcast()
    });
    
    do_export("clock_gettime", @Fn(c: i64, p: *TimeSpec) void, fn(c, p) = { Syscall'clock_gettime(c, p); });
    
    fetch_file :: fn(ptr: *u8, len: i64, len_out: *i64) *u8 #weak #import("libc");
    do_export("fetch_file", @Fn(p: *u8, l: i64, len_out: *i64) *u8, fetch_file);
    
    do_export("fmodf", @Fn(a: f32, b: f32) f32, @as(@Fn(a: f32, b: f32) f32) fmodf);
    fmod :: fn(a: f64, b: f64) f64 #libc;
    do_export("fmod", @Fn(a: f64, b: f64) f64, fmod);
    do_export("sinf", @Fn(a: f32) f32, @as(@Fn(a: f32) f32) sinf);
    do_export("cosf", @Fn(a: f32) f32, @as(@Fn(a: f32) f32) cosf);
    
    weak :: Run.weak_imports;
    inline_for weak { $name |
        // TODO: use the right signetures so you actually get the message. 
        do_export(::name[], @Fn() void, fn() = @panic("comptime code tried to call a weak import"));
    };
}

yield_module_main :: fn(m: *Qbe.Module) void = {
    ::enum(@type m.goal.type);
    backend'compile_suspended(m);
    if m.goal.type == .JitOnly {
        for_exports { name, f |
            id := m.intern(name);
            use_symbol(m, id) { s |
                ::enum(@type s.kind);
                // it's fine if they declared thier own function with one of the well known names (ie. backend/test/strcmp.ssa)
                if s.kind == .Pending {
                    m.put_jit_addr(id, f);
                };
            };
        };
    
        m.make_exec();
        f, _ := m.get_addr(m.intern("main")) 
            || @panic("missing function main()");
        f := assume_types_fn(Arg = void, Ret = i32, ptr = f);
        status := f();
        @if(status != 0) @panic("\n\nReturned status %", status);
    } else {
        m.seal_debug_info("", false, empty());  // TODO
        chunks := {m.target.finish_module}(m);
        bytes := concat(chunks&, temp());
        
        if query_current_arch() == .wasm32 {
            @println("size = %;", bytes.len);
            yield_file :: fn(p: *u8, l: i64) void #weak #libc;
            yield_file(bytes.ptr, bytes.len);
        } else {
            write_entire_file_or_crash("a.out", bytes);
            @println("wrote % bytes to a.out", bytes.len);
        };
    };
 
    // TODO: something's messed up. some specific tests die calling a null function index if you do this? 
    //drop(m);
}

#use("@/lib/variadic.fr");
