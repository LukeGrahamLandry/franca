
main :: fn() void = {
    import_names_raw := @import_symbol("__franca_wasm_import_names");
    import_names_raw := u8.ptr_from_raw(import_names_raw).slice(1.shift_left(16));
    import_names := Str.list(general_allocator());
    dowhile {
        name := import_names_raw&.pop_cstr();
        import_names&.push(name);
        name.len > 0
    };

    lang := "";
    a := cli_args();
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "-lang" {
            lang = value;
        }
    };
    @switch(lang) {
        @case("franca") => import("@/examples/web/b.fr")'main();
        @case("c") => import("@/examples/web/c.fr")'main();
        @case("qbe") => import("@/examples/web/d.fr")'main();
        @case("kaleidoscope") => kaleidoscope_main();
        @case("") => ();
        @default => @panic("unknown -lang %", lang);
    };
    
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "-yield" {
            bytes := read_entire_file_or_crash(temp(), value);
            yield_file :: fn(p: *u8, l: i64) void #weak #libc;
            yield_file(bytes.ptr, bytes.len);
        };
    };
}

#use("@/examples/kaleidoscope.fr")
kaleidoscope_main :: fn() void = {
    args := get_args(EXAMPLE_PROGRAM);
    m := zeroed QbeModule;
    init_default_module(m&, args.target);
    c: *Ctx = init(general_allocator(), args.src, m&);
    c.m.set_debug_types(args.logging, true);
    
    @match(c.compile_loop()) {
        fn Ok() => ();
        fn Err(s) => @panic("%\n before line %", s, c.line);
    };
    
    // TODO: provide implementations of printd/putchard 
    //       or only allow outputting libraries with imports, not exes (and then this main function wouldn't make sense). 
    {
        default_init(c.f, c.m);
        c.f.lnk.id = c.m.intern("main");
        c.f.ret_cls = .Kw;
        c.f.lnk.export = true;
        c.link = c.f.start&;
        b := c.push_block();
        for c.top_level { id |
            c.f.emit(.call, .Kd, Qbe.Null, c.f.symcon(id), QbeNull);
        };
        c.f.copy_instructions_from_scratch_reversed_which_means_forwards(b);
        b.jmp = (type = .retw, arg = Qbe.ConZero);
        c.end_fn();
    };
    
    yield_module_main(m&);
    drop(c);
    
}

CompileArgs :: @struct {
    src: Str;
    logging: Str;
    target: QbeTargetEnv;
};

get_args :: fn(default_src: Str) CompileArgs = {
    a := cli_args();
    out: CompileArgs = (src = default_src, logging = "", target = (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .JitOnly,
        dis = fn(out, module, arch) = {
            if arch == .wasm32 && module.starts_with(Qbe.Wasm.version_magic) {
                // TODO: use `out`!
                import("@/examples/dump_wasm.fr")'dump(module);
            } else {
                // TODO: if arch=wasm and it's just one function for aot, support that too. 
                out.push_all("no disassembler included\n");
            }
        },
    ));
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "---literal_input" {
            out.src = value;
        }
        if a[i] == "-d" {
            out.logging = value;
        }
        
        if a[i] == "-file" {
                out.src = read_entire_file_or_crash(temp(), value);
        }
        if a[i] == "-target" {
            out.target.type = @if(value == "wasm-jit", .JitOnly, .Exe);
            // TODO: decide what OS to say for wasm... wasi? freestanding? 
            (ar: Arch, os: Os) := @switch(value) {
                @case("wasm-jit") => (.wasm32, .macos);
                @case("wasm-aot") => (.wasm32, .macos);
                @case("arm64-macos") => (.aarch64, .macos);
                @case("amd64-macos") => (.x86_64, .macos);
                @case("arm64-linux") => (.aarch64, .linux);
                @case("amd64-linux") => (.x86_64, .linux);
                @case("riscv64-linux") => (.rv64, .linux);
                @default => @panic("invalid -target '%'", value);
            };
            out.target.arch = ar;
            out.target.os = os;
        }
    };
    out
}

FnTypeOf :: fn(fid: FuncId) Type #fold = {
    func := get_function_ast(fid, true, false, true, false);
    f_ty := func.finished_ty().unwrap();
    intern_type(Fn = f_ty)
}

yield_module_main :: fn(m: *Qbe.Module) void = {
    backend'compile_suspended(m);
    if m.goal.type == .JitOnly {
        Qbe'fill_from_libc(m);

        m.make_exec();
        f, _ := m.get_addr(m.intern("main")) 
            || @panic("missing function main()");
        f := assume_types_fn(Arg = void, Ret = i32, ptr = f);
        status := f();
        @if(status != 0) @panic("\n\nReturned status %", status);
    } else {
        m.seal_debug_info("", false, empty());  // TODO
        chunks := {m.target.finish_module}(m);
        bytes := concat(chunks&, temp());
        
        if query_current_arch() == .wasm32 {
            @println("size = %;", bytes.len);
            yield_file :: fn(p: *u8, l: i64) void #weak #libc;
            yield_file(bytes.ptr, bytes.len);
        } else {
            write_entire_file_or_crash("a.out", bytes);
            @println("wrote % bytes to a.out", bytes.len);
        };
    };
 
    drop(m);
}

#use("@/lib/variadic.fr");
