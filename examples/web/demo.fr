#include_std("compiler/lib.fr");
DEBUG_SPAM_LOG :: false;
DISABLE_IMPORT_FRC :: false;

main :: fn() void = {
    lang := "";
    a := cli_args();
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "-lang" {
            lang = value;
        }
    };
    @switch(lang) {
        @case("franca") => import("@/examples/web/b.fr")'main();
        @case("c") => import("@/examples/web/c.fr")'main();
        @case("qbe") => import("@/examples/web/d.fr")'main();
        @case("kaleidoscope") => import("@/examples/kaleidoscope.fr")'main();
        @default => println("other");
    };
}

CompileArgs :: @struct {
    src: Str;
    logging: Str;
    target: QbeTargetEnv;
};

get_args :: fn(default_src: Str) CompileArgs = {
    a := cli_args();
    out: CompileArgs = (src = default_src, logging = "", target = (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .JitOnly,
    ));
    range(0, a.len - 1) { i |
        value := a[i + 1].str();
        if a[i] == "---literal_input" {
            out.src = value;
        }
        if a[i] == "-d" {
            out.logging = value;
        }
        
        // TODO: this is dumb. should do a more official wasi thing? 
        if a[i] == "-file" {
            if query_current_arch() == .wasm32 {
                fetch_file :: fn(ptr: *u8, len: i64) *u8 #weak #import("libc");
                result := fetch_file(value.ptr, value.len);
                @assert(!result.is_null(), "failed to read %", value);
                result: CStr = (ptr = result);
                out.src = result.str();
            } else {
                out.src = read_entire_file_or_crash(temp(), value);
            }
        }
        if a[i] == "-target" {
            out.target.type = @if(value == "wasm-jit", .JitOnly, .Exe);
            // TODO: decide what OS to say for wasm... wasi? freestanding? 
            (ar: Arch, os: Os) := @switch(value) {
                @case("wasm-jit") => (.wasm32, .macos);
                @case("wasm-aot") => (.wasm32, .macos);
                @case("arm64-macos") => (.aarch64, .macos);
                @case("amd64-macos") => (.x86_64, .macos);
                @case("arm64-linux") => (.aarch64, .linux);
                @case("amd64-linux") => (.x86_64, .linux);
                @default => @panic("invalid -target '%'", value);
            };
            out.target.arch = ar;
            out.target.os = os;
        }
    };
    out
}

for_exports :: fn($body: @Fn(name: Str, addr: rawptr) void #duplicated) void = {
    do_export :: fn(name: Str, $T: Type, $F: FuncId) void => {
        ff: T : F;
        f: rawptr = ff;
        body(name, f);
    };
    
    do_export("putchar", @Fn(c: u8) void, putchar_UNBUFFERED);
    do_export("exit", @Fn(c: i32) Never, Syscall.exit);
    do_export("write", @Fn(fd: i32, p: *u8, l: i64) i64, fn(a, b, c) = { x := Syscall'write((fd = a), b, c); x.value });
    do_export("mprotect", @Fn(a: rawptr, b: i64, c: i64) i64, fn(a, b, c) = { x := Syscall'mprotect(a, b, c); x.value });
    do_export("mmap", @Fn(a: rawptr, b: i64, c: i64, d: i64, e: i32, f: i64) i64, fn(a, b, c, d, e, f) = { Syscall'mmap(a, b, c, d, (fd = e), f) });
    do_export("munmap", @Fn(a: rawptr, b: i64) i64, fn(a, b) = { x := Syscall'munmap(a, b); x.value });
    jit_instantiate_module :: fn(a: *u8, b: i64, c: i64, d: u32) void #weak #import("libc");
    do_export("jit_instantiate_module", @Fn(a: *u8, b: i64, c: i64, d: u32) void, jit_instantiate_module);
    
    weak :: import("@/examples/import_wasm/run.fr").weak_imports;
    inline_for weak { $name |
        // TODO: use the right signetures so you actually get the message. 
        do_export(::name[], @Fn() void, fn() = @panic("comptime code tried to call a weak import"));
    };
}
