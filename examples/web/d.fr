Qbe :: import("@/backend/lib.fr");
C :: import("@/examples/import_c/lib.fr");
Ffi :: import("@/examples/import_c/ffi.fr");
main :: fn() void = { 
    src := "";
    a := cli_args();
    logging := "";
    range(0, a.len) { i |
        if a[i] == "---literal_input" && i < a.len - 1 {
            src = a[i + 1].str();
        }
        if a[i] == "-d" && i < a.len - 1 {
            logging = a[i + 1].str();
        }
    };
    @assert(src.len > 0 && src[src.len - 1] == 10, "TODO: input must end in a new line");

    global_module := @static(Qbe.Module);
    m := global_module;
    Qbe'backend'init_module(global_module, (type = .JitOnly, os = query_current_os(), arch = query_current_arch(), exe_debug_symbol_table = true, prefer_libc_memmove = false));
    m.set_debug_types(logging, true);
    
    parse :: import("@/backend/meta/parse.fr").parse_top_level;
    res := parse(global_module, src, Qbe'backend'compile_dat, Qbe.backend.compile_fn, true);
    if res&.is_err() {
        panic(res.Err);
    };
    
    c := C'Compile.Ctx.zeroed();
    Ffi'import_c'init_c(c&, m);
    c.enqueue_task = Qbe.backend.worker_enqueue;
    ctx: *C'Compile.CodegenShared = Qbe'backend'worker_start(m, general_allocator(), zeroed C'Compile.CodegenWorker, false);
    c.emitter = (Some = ctx);
    // TODO: this way of doing it means you lose location information which sucks
    result := Ffi'import_c'compile_c(c&, ">>>driver", res.Ok&.items());
    result.or(fn(e) => panic(e));
    c.arena_storage&.deinit();
    Qbe'backend'worker_join(ctx);
    res.Ok&.drop();
    
    m.put_jit_addr(m.intern("putchar"), fn(c: u8) u32 = { putchar_UNBUFFERED(c); 0 });
    global_module.emit_suspended_inlinables();
    global_module.make_exec();
    f := or global_module.get_addr("main") {
        panic("couldn't find main()")
    };
    f := assume_types_fn(Arg = void, Ret = i32, ptr = f);
    status := f();
    @if(status != 0) @panic("Returned status %", status);
    drop(m);
}
