Qbe :: import("@/backend/lib.fr");
C :: import("@/examples/import_c/lib.fr");
Ffi :: import("@/examples/import_c/ffi.fr");

#use("@/examples/web/demo.fr")
main :: fn() void = { 
    args := get_args("");
    src := args.src;
    @assert(src.len > 0 && src[src.len - 1] == 10, "TODO: input must end in a new line");

    m := @uninitialized Qbe.Module; m := m&;
    Qbe'backend'init_module(m, args.target);
    m.set_debug_types(args.logging, true);
    
    parse :: import("@/backend/meta/parse.fr").parse_top_level;
    res := parse(m, src, Qbe'backend'compile_dat, Qbe.backend.compile_fn, true);
    if res&.is_err() {
        panic(res.Err);
    };
    
    if res.Ok.len > 0 {
        c := C'Compile.Ctx.zeroed();
        Ffi'import_c'init_c(c&, m);
        c.enqueue_task = Qbe.backend.worker_enqueue;
        ctx: *C'Compile.CodegenShared = Qbe'backend'worker_start(m, general_allocator(), zeroed C'Compile.CodegenWorker, false);
        c.emitter = (Some = ctx);
        // TODO: this way of doing it means you lose location information which sucks
        result := Ffi'import_c'compile_c(c&, ">>>driver", res.Ok&.items());
        result.or(fn(e) => panic(e));
        c.arena_storage&.deinit();
        Qbe'backend'worker_join(ctx);
        res.Ok&.drop();
    }
    
    yield_module_main(m);
}
