driver :: fn(vtable: *ImportVTable) void = {
    ci := Foreign.ENV.GITHUB_REPOSITORY.get_environment_variable().is_some();
    franca := get_executable_path(temp());
    make_dirs_or_crash("target/web/target");

    ok := run_cmd_blocking(franca, @slice("graphics/web/webgpu_api.fr"));
    @assert(ok, "failed build");
    ok := run_cmd_blocking(franca, @slice("examples/default_driver.fr", "build", 
        "examples/os/host/web.fr", "-o", "target/web/target/demo.wasm", 
        "-arch", "wasm32", "-unsafe", "-dynamiclib", "-keep-names", "-wasm_threads",
    ));
    @assert(ok, "failed build");
    
    commit := if ci {
        git := Foreign.EXE.git;
        ok, o, e := exec_and_catch(git, @slice("rev-parse", "HEAD"), temp());
        @assert(ok, "failed git rev-parse");
        while => o[o.len - 1].is_ascii_whitespace() {
            o.len -= 1;
        };
        @assert_eq(o.len, 40, "failed git rev-parse");
        o.items()
    } else {
        now := time_t.zeroed();
        time(now&);
        tm := zeroed BigTime;
        localtime_r(now&, tm&);
        @tfmt("%-%-%_dev", tm.hour, tm.min, tm.sec)
    };
        
    m := manifest(commit);
    
    ::DeriveJson(Manifest);
    ::DeriveJson(Manifest.Compiler);
    manifest := u8.list(temp());
    m&.dump_json(manifest&);
    
    copy :: fn(dest, src) => write_entire_file_or_crash(dest, read_entire_file_or_crash(temp(), src));
    write_entire_file_or_crash("target/web/target/manifest.json", manifest.items());
    copy("target/web/target/app.js", "graphics/web/app.js");
    copy("target/web/target/gfx.js", "graphics/web/gfx.js");
    copy("target/web/target/webgpu.g.js", "target/franca/webgpu.g.js");
    copy("target/web/main.js", "examples/web/main.js");
    copy("target/web/worker.js", "examples/web/worker.js");
    copy("target/web/index.html", "examples/web/index.html");
    
    // TODO: this is slowly approching crazy town...
    if ci {
        default := "Math.floor(new Date().valueOf())";
        prefix := "let manifest_version = ";
        main_js := read_entire_file_or_crash(temp(), "examples/web/main.js");
        dest := main_js.rest(prefix.len).slice(0, default.len);
        @assert(main_js.starts_with(prefix) && dest == default);
        commit.len = min(commit.len, dest.len - 2);
        dest[0] = "\"".ascii();
        dest[dest.len - 1] = "\"".ascii();
        dest.slice(1, commit.len + 1).copy_from(commit);
        dest.slice(commit.len + 1, dest.len - 1).set_bytes("-".ascii());
        write_entire_file_or_crash("examples/web/main.js", main_js);
    };
}

manifest :: fn(commit: Str) Manifest = (
    compilers = (@slice(@as(Manifest.Compiler) (
        name = "franca",
        about = "",
        examples = @const_slice(
            "examples/mandelbrot_ui.fr",
            "examples/mandelbrot.fr", "examples/sudoku.fr", "examples/kaleidoscope.fr",
            "examples/bf/bf2ir.fr", "examples/bf/code_string.fr", "examples/bf/inline_for.fr",
            "compiler/main.fr", "examples/bf/c_string.fr", "tests/exe/c_ffi.fr",
            "examples/chess/perft.fr",
            "examples/chess/gui.fr",
            "examples/app_events.fr", 
            "examples/farm_game.fr", 
            "examples/terminal.fr", 
        ),
    ), (
        name = "c",
        about = "See also: https://github.com/rui314/chibicc",
        examples = filenames("tests/c", ".c"),
    ), (
        name = "qbe",
        about = "See also: https://c9x.me/compile",
        examples = filenames("tests/ssa", ".ssa"),
    ), (
        name = "kaleidoscope",
        about = "See also: https://llvm.org/docs/tutorial/MyFirstLanguageFrontend",
        examples = @const_slice("mandel.txt"),
    ))).shallow_copy(temp()),
    commit = commit,
    wisdom = @const_slice(
        "Blazingly 9x slower than native!", 
        "Abstraction will continue until moral improves.",
        "High precision timers are considered unsafe.",
    ),
);

collect_fs :: fn(a: Alloc) Ty(Fs, List(u8)) = {
    paths := collect_paths(a, @const_slice("lib", "compiler", "backend", "examples", "graphics", "tests", "boot/src"));
    if file_exists("target/franca/webgpu.g.fr") {
        paths&.push("target/franca/webgpu.g.fr");
    };
    fs: HashMap(Str, Ty(i64, i64)) = init(a);
    contents := u8.list(a);
    for paths { s |
        l := contents.len;
        read_and_push_or_crash(contents&, s);
        insert(fs&, s, (l, contents.len - l));
    };
    mandel := import("@/examples/kaleidoscope.fr").EXAMPLE_PROGRAM;
    insert(fs&, "mandel.txt", (contents.len, mandel.len));
    contents&.push_all(mandel);
    (fs.raw, contents)
} 

filenames :: fn(path: Str, ext: Str) []Str = {
    files := collect_with_extension(path, ext) || panic("lost tests");
    
    @if(ext == ".ssa") // TODO: this is dumb
    ordered_retain files& { it |
        it := it[];
        !it.ends_with("-na.ssa")
    };
    
    out := Str.list(temp());
    for files { it |
        full := @tfmt("%/%", path, it);
        out&.push(full);
    };
    out.items()
}

Fs :: RawHashMap(Str, Ty(i64, i64));

Manifest :: @struct {
    compilers: []Compiler;
    commit: Str;
    wisdom: []Str;
    
    Compiler :: @struct {
        name: Str;
        about: Str;
        examples: []Str;
    };
}

collect_paths :: fn(a: Alloc, root: []Str) List(Str) = {
    extensions := @const_slice(".fr", ".md", ".ssa", ".c", ".h");
    files := Str.list(a);
    dirs := Str.list(temp());
    dirs&.push_all(root);
    while => dirs&.pop() { s |
        prev_f, prev_d := (files.len, dirs.len);
        (walk_directory_unordered(as_cstr s) { e |
            continue :: local_return;
            if e.is(.Directory) {
                skip := @const_slice(".", "..", ".git", "node_modules", "target");
                if(skip.contains(e.name), => continue());
                
                dirs&.push(@tfmt("%/%", s, e.name));
            } else {
                // TODO: this is getting stupid... should clean it up at some point...
                ok := e.name == "perft" || e.name == "bitboards";
                for extensions { ext |
                    if e.name.ends_with(ext) {
                        ok = true;
                    }
                }
                if ok {
                    path := @tfmt("%/%", s, e.name);
                    path := path.shallow_copy(a);
                    files&.push(path);
                }
            }
        }) || @panic("walk dir '%' failed", s);
        Sort :: import("@/lib/sort.fr");
        sort :: Sort'quicksort(Str, Sort.order_strings);
        sort(files.items().rest(prev_f));
        sort(dirs.items().rest(prev_d));
    };
    files
}

#use("@/lib/sys/process.fr");
#use("@/lib/sys/subprocess.fr");
#use("@/lib/sys/fs.fr");
#use("@/examples/testing.fr");
#use("@/lib/encoding/json_reflect.fr");
#use("@/lib/collections/map.fr");
