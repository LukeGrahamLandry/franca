// this reads a flattened devicetree (.dtb file) and dumps it as readable text. 
// you can get the binary form out of qemu by adding `,dumpdtb=a.dtb` to the `-machine` argument. 
// its a format bootloaders use to tell an operating system the shape of the hardware its running on, 
// so you don't have to hard code memory mapped io addresses, etc. and ship a seperate kernel for each board.

main :: fn() void = {
    #use("@/lib/sys/fs.fr");
    input := read_file_from_last_arg();
    out := u8.list(temp());
    dump(out&, input);
    print(out.items());
}

dump :: fn(out: *List(u8), in: []u8) void = {
    #use("@/examples/os/drivers/devicetree.fr");
    ::DeriveFmt(Header);
    ::DeriveFmt(ReserveEntry);
    ::DeriveFmt(Prop);
    ::enum(FDT);

    if in.len < Header.size_of() {
        @fmt(out, "(ERROR: input too small to fit the header)\n");
        return();
    };
    header := in.peek_type(Header)[];
    Header.byte_swap_fields(header&);
    @fmt(out, "Header:\n%\n", header&);
    if header.magic != MAGIC || header.last_comp_version != 16 {
        @fmt(out, "(ERROR: bad magic/version)\n");
        return();
    };
    @fmt(out, "Memory Reservation Block:\n");
    {
        in := in.rest(header.off_mem_rsvmap.zext());
        dowhile {
            it := in&.pop_type(ReserveEntry)[];
            ReserveEntry.byte_swap_fields(it&);
            @fmt(out, "- %\n", it&);
            it.address != 0 || it.size != 0
        };
    };
    @fmt(out, "Structure Block:\n");
    depth := 0;
    width :: 4;
    for_props in { tag, name, data |
            out.push_repeated(depth*width, " ".ascii());
            @match(tag) {
                fn BEGIN_NODE() => {
                    depth += 1;
                    @fmt(out, "% {\n", name);
                }
                fn END_NODE() => {
                    depth -= 1;
                    out.len -= width;
                    @fmt(out, "};\n");
                }
                fn END() => ();
                fn NOP() => ();
                fn PROP() => {
                    @fmt(out, "%", name);
                    // TODO: show the data properly. i think you need to know the types of the fields already. 
                    if data.len > 0 {
                        @fmt(out, " =");
                        if looks_like_strings(data) {
                            dowhile {
                                s := data&.pop_cstr();
                                @fmt(out, " \"%\"", s);
                                data.len > 0
                            }
                        } else {
                            // hard to pick between u32/u64 list
                            for data { it |
                                @fmt(out, " ");
                                out.push_hex_byte(it, true);
                            };
                        };
                    };
                    @fmt(out, ";\n");
                }
        };
    };
}
