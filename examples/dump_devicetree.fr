// this reads a flattened devicetree (.dtb file) and dumps it as readable text. 
// you can get the binary form out of qemu by adding `,dumpdtb=a.dtb` to the `-machine` argument. 
// its a format bootloaders use to tell an operating system the shape of the hardware its running on, 
// so you don't have to hard code memory mapped io addresses, etc. and ship a seperate kernel for each board.

main :: fn() void = {
    input := read_file_from_last_arg();
    out := u8.list(temp());
    dump(out&, input);
    print(out.items());
}

dump :: fn(out: *List(u8), in: []u8) void = {
    if in.len < Header.size_of() {
        @fmt(out, "(ERROR: input too small to fit the header)\n");
        return();
    };
    header := in.peek_type(Header)[];
    Header.byte_swap_fields(header&);
    @fmt(out, "Header:\n%\n", header&);
    if header.magic != MAGIC || header.last_comp_version != 16 {
        @fmt(out, "(ERROR: bad magic/version)\n");
        return();
    };
    @fmt(out, "Memory Reservation Block:\n");
    {
        in := in.rest(header.off_mem_rsvmap.zext());
        dowhile {
            it := in&.pop_type(ReserveEntry)[];
            ReserveEntry.byte_swap_fields(it&);
            @fmt(out, "- %\n", it&);
            it.address != 0 || it.size != 0
        };
    };
    @fmt(out, "Structure Block:\n");
    depth := 0;
    width :: 4;
    for_props in { tag, name, data |
            out.push_repeated(depth*width, " ".ascii());
            @match(tag) {
                fn BEGIN_NODE() => {
                    depth += 1;
                    @fmt(out, "% {\n", name);
                }
                fn END_NODE() => {
                    depth -= 1;
                    out.len -= width;
                    @fmt(out, "};\n");
                }
                fn END() => ();
                fn NOP() => ();
                fn PROP() => {
                    @fmt(out, "%", name);
                    // TODO: show the data properly. i think you need to know the types of the fields already. 
                    if data.len > 0 {
                        @fmt(out, " =");
                        if looks_like_strings(data) {
                            dowhile {
                                s := data&.pop_cstr();
                                @fmt(out, " \"%\"", s);
                                data.len > 0
                            }
                        } else {
                            // hard to pick between u32/u64 list
                            for data { it |
                                @fmt(out, " ");
                                out.push_hex_byte(it, true);
                            };
                        };
                    };
                    @fmt(out, ";\n");
                }
        };
    };
}

Iter :: @struct {
    in: []u8;
    strings: []u8;
    depth: i64;
    
    Node :: @struct(tag: FDT, name: Str, data: []u8);
};

iter :: fn(in: []u8) Iter = {
    header := in.peek_type(Header)[];
    Header.byte_swap_fields(header&);
    @debug_assert_eq(header.magic, MAGIC);
    (
        strings = in.subslice(header.off_dt_strings.zext(), header.size_dt_strings.zext()),
        in = in.subslice(header.off_dt_struct.zext(), header.size_dt_struct.zext()),
        depth = 0,
    )
}

fn next(self: *Iter) Iter.Node = {
    loop {
        continue :: local_return;
        tag := self.in&.pop_type(FDT)[];
        name, data := @match(tag) {
            fn BEGIN_NODE() => {
                name := self.in&.pop_cstr();
                self.in = self.in.rest(name.len.add(1).ualign_to(4) - name.len.add(1));
                (name, "")
            }
            fn END_NODE() => ("", "");
            fn END() => ("", "");
            fn NOP() => continue();
            fn PROP() => {
                prop := self.in&.pop_type(Prop)[];
                Prop.byte_swap_fields(prop&);
                name: CStr = (ptr = self.strings.index(prop.nameoff.zext()));
                data := self.in.slice(0, prop.len.zext());
                self.in = self.in.rest(prop.len.zext().ualign_to(4));
                (name.str(), data)
            }
        };
        self.depth += int(tag == .BEGIN_NODE);
        self.depth -= int(tag == .END_NODE);
        return(tag = tag, name = name, data = data);
    }
}

for_props :: fn(in: []u8, $body: @Fn(tag: FDT, name: Str, data: []u8) void #duplicated) void = {
    self := iter(in);
    dowhile {
        it := self&.next();
        body(it.tag, it.name, it.data);
        it.tag != .END
    };
}

// if its just ascii with null terminators, assume its a string. 
// numbers tend to contain consecutive zeros and disallowing empty strings a decent heuristic. 
// disallowing quotes because that makes it ambiguous between a list and just an inner `" "`. 
looks_like_strings :: fn(data: []u8) bool = {
    @if(data.len == 0 || data[data.len - 1] != 0) return(false);
    zero_count := 0;
    for data { it |
        if it == 0 {
            zero_count += 1;
            @if(zero_count > 1) return(false);
        } else {
            zero_count = 0;
            @if(it < 32 || it > 127 || it == "\"".ascii()) return(false);
        }
    };
    true
}

#use("@/lib/sys/fs.fr");
::DeriveFmt(Header);
::DeriveFmt(ReserveEntry);
::DeriveFmt(Prop);
::enum(FDT);

// Devicetree Specification, Release v0.4
// https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.4
// all the numbers in this format are big endian. 

MAGIC :: 0xd00dfeed;
Header :: @struct {
    magic: u32;
    totalsize: u32;
    off_dt_struct: u32;
    off_dt_strings: u32;
    off_mem_rsvmap: u32;
    version: u32;
    last_comp_version: u32;
    boot_cpuid_phys: u32;
    size_dt_strings: u32;
    size_dt_struct: u32;
}

ReserveEntry :: @struct(address: u64, size: u64);

FDT :: @enum(u32) (
    BEGIN_NODE = byte_swap(1),
    END_NODE = byte_swap(2),
    PROP = byte_swap(3),
    NOP = byte_swap(4),
    END = byte_swap(9),
);

Prop :: @struct(len: u32, nameoff: u32);
