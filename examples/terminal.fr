#include_std("graphics/lib.fr");
Repl :: import("@/examples/repl.fr");

ENABLE_FRANCA_REPL :: false;

State :: @struct(
    pass_action: SgPassAction,
    text: *Sdtx.Self,
    buffers: List(TextBuffer),
    selected_buffer: i64,
    app: Sapp.Self,
    sg: Sg.Self,
    process: ?RunningProcess,
    scratch: List(u8),
    lock_to_bottom: bool,
    history: RawList(Str),
    history_index: i64,
    background: SgColor,
    font_color: u32,
    repl: @if(ENABLE_FRANCA_REPL, Repl.ReplState, void),
    dirty: bool,
);

// This needs the extra level of indirection so it can be shared with the repl. 
state :: @static(*State);

allocator :: libc_allocator;

do_init :: fn(userdata: rawptr) void = {
    state := state[];
    sapp := state.app&;
    state.sg&.setup(
        environment = Easy'glue_environment(sapp),
        allocator = allocator,
    );
    @if(ENABLE_FRANCA_REPL) {
        prelude := "#include_std(\"lib/core.fr\");#include_std(\"examples/terminal.fr\");\n";
        state.repl = Repl'init_repl(allocator, prelude);
        if Repl.STDLIB_PATH { path |
            cd(path[]);
        };
        res := state.repl&.run_chunk(@tfmt("real_state := State.ptr_from_int(%); state[] = real_state; state := state[];", raw_from_ptr(@type state[], state)));
        ::Repl;
        state.repl.program.Repl'unwrap_report_error(void, res);
    };
    state.scratch = list(u8, 4*1024*1024, allocator);  // :BigOutputBuffer
    state.lock_to_bottom = true;
    state.history_index = 0;
    state.history&.push("", allocator);
    state.history&.push("", allocator);
    state.background = (r = 0.156, g = 0.156, b = 0.156, a = 1);
    state.font_color = pack_rgba(235, 219, 178, 255);
    state.dirty = true;
    
    state.text.setup(
        allocator = allocator,
        fonts = @slice(Sdtx.font.cpc),
        sg = state.sg&,
        context = (char_width = CHAR_W, char_height = CHAR_H),
    );
    
    b := state.buffers.index(0);
    b.at.w = sapp.width().float() / state.buffers.len.float();
    b.at.h = sapp.height().float();
    if state.buffers.len >= 2 {
        b := state.buffers.index(1);
        b.at.w = sapp.width().float() / 2;
        b.at.h = sapp.height().float();
        b.at.pos.x = sapp.width().float() / 2;
    };
    
    W :: CHAR_W*2;  // TODO: why *2
    H :: CHAR_H*2;
    font_pixels :: {
        #use(StbTrueType);
        tex_width := 256;
        bitmap := temp().alloc(u8, tex_width*tex_width);
        chars := temp().alloc(stbtt_bakedchar, 128-32);
        result := stbtt_BakeFontBitmap(font_data_ttf.as_ptr(), 0, 32.0, bitmap.ptr, intcast tex_width, intcast tex_width, 33, 128, chars.ptr);
        @assert(result >= 0, "didn't fit all characters");
        // TODO: is this bigger than atlas + metadata? 
        pixels := ast_alloc().alloc_zeroed(u8, 256*W*H);
        x: f32 = 0; y: f32 = 0;
        range(0, 128-32) { i |
            // These are the positions of the texture in the atlas
            x0, y0, x1, y1 := (@as(i64) chars[i].x0.zext(), @as(i64) chars[i].y0.zext(), @as(i64) chars[i].x1.zext(), @as(i64) chars[i].y1.zext());
            // These are how much you have to move it to account for the blank part. 
            // ie. the square above will just cover the filled in part of `_` and this tells us to move it down. 
            x, y := (chars[i].xoff.cast().int(), chars[i].yoff.cast().int());
            range(y0, y1) { j |
                char_w := x1 - x0;
                src  := bitmap.subslice(j*tex_width + x0, char_w);
                dest := pixels.subslice((j-y0+(y+20))*W*256 + x + (i+32+1)*W, char_w);
                dest.copy_from(src);
            };
        };
        // make non ascii bytes show as filled in squares
        range(0, H) { j |
            base := j*W*256;
            pixels.slice(base + 0, base + 32*W).set_bytes(0xFF);
            pixels.slice(base + 128*W, base + 255*W).set_bytes(0xFF);
        };
        pixels
    };
    font_img: Sg.Image = state.sg&.make(
        width = W*256,
        height = H,
        pixel_format = .R8,
        data = (subimage = ((font_pixels, ..empty()), ..zeroed(Array([]u8, 16)))),
        label = "font_texture",
    );
    state.text.font_img = font_img;
};

CHAR_W :: 8;
CHAR_H :: 16;

Colour :: @struct(r: i64, g: i64, b: i64, a := 255);
Pos :: @struct(x: f64, y: f64);
Rect :: @struct(pos: Pos, w: f64, h: f64);

do_render :: fn(userdata: rawptr) void = {
    state := state[];
    if state.process& { p |
        buffer := state.buffers&[0]&;
        status := poll(p, state.scratch&);
        buffer.append_string(state.scratch.items());
        state.scratch&.clear();
        @match(status) {
            fn Ok(status) => if status { status |
                ms := timestamp() - p.start;
                state.process = .None;
                buffer.append_string(@tfmt("\nExited with status %", status));
                if ms > 16 {
                    // if it didn't span multiple frames the time is not super interesting. 
                    buffer.append_string(@tfmt(" (in % ms)", ms));
                };
                buffer.append_string("\n");
            } else {
                // still running
            };
            fn Err(msg) => buffer.append_string(msg);
        };
    };
    
    if !state.dirty {
        // if no events and no text from process, don't render a frame
        return();
    };
    state.dirty = false;
    
    each state.buffers& { b |
        draw_text(b);
    };
    sg := state.sg&;
    
    state.pass_action.colors&[0] = (
        load_action = .CLEAR,
        clear_value = state.background,
    );
    Easy'glue_begin_pass(state.app&, sg, state.pass_action);
    
    sdtx := state.text.default_context&;
    sdtx.draw_layer(0);
    
    sg.end_pass();
    sg.commit();
};

fn append_string(buffer: *TextBuffer, new: Str) void = {
    state := state[];
    if buffer.lines.len == 0 {
        buffer.lines&.push(empty_line, buffer.gpa);
    };
    if(new == "", => return());
    last := buffer.lines[buffer.lines.len - 1]&;
    start := 0;
    range(0, new.len) { i |
        if new[i] == "\n".ascii() {
            line := new.slice(start, i);
            buffer.max_x = max(buffer.max_x, float(last.len() + line.len));
            last.push_all(line, buffer.gpa);
            buffer.lines&.push(empty_line, buffer.gpa);
            last = buffer.lines[buffer.lines.len - 1]&;
            start = i + 1;
            if state[].lock_to_bottom && buffer.lines.len > buffer.num_lines_fit_on_screen {
                // If you're already near the bottom of the document, scroll down as new text
                // is added so you can see it stream in, but if you carefully scrolled up to 
                // look at something, don't rip you away from your place. 
                buffer.render.y = float(buffer.lines.len - buffer.num_lines_fit_on_screen + 1);
            }
        };
    };
    line := new.rest(start);
    buffer.max_x = max(buffer.max_x, float(last.len() + line.len));
    last.push_all(line, buffer.gpa);
}

fn echo(s: Str) void = {
    if selected_buffer() { buffer |
        buffer.append_string(s);
    }
}

fn cd(s: Str) void = {
    chdir(@fmt_cstr("%", s)) 
        || echo(@tfmt("failed to set working directory to '%'\n", s));
}

fn exit() void = {
    state[].app.quit_requested = true;
}

do_event :: fn(userdata: rawptr, event: *Sapp.Event) void = {
    state := state[];
    if event.type != .MOUSE_MOVE {
        state.dirty = true;
    }
    if event.type == .MOUSE_DOWN {
        pos: Pos = (x = event.mouse_x.cast(), y = event.mouse_y.cast());
        enumerate state.buffers& { i, b |
            if b.at.contains(pos) {
                state.selected_buffer = i;
                b.cursor = (x = pos.x / CHAR_W + b.render.x, y = pos.y / CHAR_H + b.render.y);
                line, col := (b.cursor.y.int(), b.cursor.x.int());
                if line < b.lines.len {
                    line := b.lines[line]&.str();
                    if col < line.len {
                        line[col] = "@".ascii();
                    }
                }
            };
        };
    };
    
    if event.type == .RESIZED {
        // the main buffer always covers the whole window
        buffer := state.buffers[0]&;
        buffer.at.w = state.app.framebuffer_width.float();
        buffer.at.h = state.app.framebuffer_height.float();
    }
    
    if event.type == .KEY_DOWN {
        if event.key_code == .W && event.modifiers.get(.super) != 0 {
            state.app.quit_requested = true;
        };
        
        // ^c -> SIGINT, ^C -> SIGKILL
        if event.key_code == .C && event.modifiers.get(.control) != 0 {
            if state.process& { p |
                if event.modifiers.get(.shift) != 0 {
                    kill(p.pid, @as(i32) SignalNum.Kill);
                } else {
                    // TODO: how do i make this work on make? (i assume the nesting is the problem? do i send it to all children somehow?)
                    kill(p.pid, @as(i32) SignalNum.Interupt);
                }
            } else {
                if selected_buffer() { buffer |
                    buffer.append_string("nothing is running right now\n");
                }
            }
        }
        buffer := selected_buffer() || return();
        
        if event.key_code == .BACKSPACE && buffer.lines.len > 0 {
            last := buffer.lines[buffer.lines.len - 1]&;
            if last.len() > 0 {
                last.set_len(last.len() - 1);
            } else {
                buffer.lines.len -= 1;
            };
        }
        
        // history
        if event.key_code == .UP {
            if buffer.lines.len > 0 {
                buffer.lines&[buffer.lines.len - 1]&.set_len(0);
            };
            state.history_index = max(state.history_index - 1, 0);
            cmd := state.history[state.history_index];
            buffer.append_string(cmd);
        }
        
        // history
        if event.key_code == .DOWN {
            if buffer.lines.len > 0 {
                buffer.lines&[buffer.lines.len - 1]&.set_len(0);
            }
            state.history_index = min(state.history_index + 1, state.history.len - 1);
            cmd := state.history[state.history_index];
            buffer.append_string(cmd);
        }
        
        if event.key_code == .LEFT {
            buffer.cursor.x = max(buffer.cursor.x - 1, 0);
        };
        
        if event.key_code == .RIGHT {
            // TODO: get the current line so we know the max 
        };
        
        if event.key_code == .ENTER {
            if event.modifiers.get(.shift) != 0 {
                buffer.append_string("\n");
                return();
            };
            
            if buffer.lines.len == 0 {
                buffer.lines&.push(empty_line, buffer.gpa);
            };
        
            raw_command := buffer.lines&[buffer.lines.len - 1]&.str();
            exec(buffer, raw_command);
        };
    };
    buffer := selected_buffer() || return();
    
    if event.type == .CHAR && event.char_code < 127 && event.char_code >= 32 && event.modifiers.get(.super) == 0 {
        s: Str = (ptr = ptr_cast_unchecked(u32, u8, event.char_code&), len = 1);
        buffer.append_string(s);
    };
    
    @match(event.type) {
        fn CLIPBOARD_PASTED() => {
            buffer.append_string(state.app&.get_clipboard_string().items());
        }
        fn MOUSE_SCROLL() => {
            scroll_speed :: -2.0;
            buffer.render.x += event.scroll_x.cast() * scroll_speed;
            buffer.render.y += event.scroll_y.cast() * scroll_speed;
        };
        fn MOUSE_MOVE() => if event.modifiers.get(.right_mouse) != 0 {
            state.dirty = true;
            buffer.render.x += event.mouse_dx.cast() * -1.0 / CHAR_W.float();
            buffer.render.y += event.mouse_dy.cast() * -1.0 / CHAR_H.float();
        }
        fn FILES_DROPPED() => if state.app.drop.num_files == 1 {
            buffer.append_string(state.app&.get_dropped_file_path(0));
        };
        @default => ();
    };
};

fn selected_buffer() ?*TextBuffer = {
    state := state[];
    if(state.selected_buffer >= state.buffers.len, => return(.None));
    (Some = state.buffers.index(state.selected_buffer))
}

fn main() void = {
    state[] = allocator.box(State);
    state := state[];
    state[] = zeroed @type state[];
    state.text = allocator.box(@type state.text[]);
    state.buffers = list(allocator);
    state.process = .None;
    
    // :SLOW
    fn load_new_buffer(path: Str, a: Alloc) TextBuffer = {
        buffer := TextBuffer.zeroed();
        buffer.gpa = a;
        input := buffer.gpa.read_to_string_or_crash(path).items(); // :panic :leak
        buffer&.append_string(input);
        buffer
    };
    //state.buffers&.push(load_new_buffer("compiler/v2/sema.fr", allocator));
    
    buffer := TextBuffer.zeroed();
    buffer.gpa = allocator;
    push(state.buffers&, buffer);
    //state.buffers&.push(load_new_buffer("examples/terminal.fr", allocator));
    state.app&.run(
        init_cb = do_init,
        frame_cb = do_render,
        event_cb = do_event,
        user_data = zeroed rawptr,
        window_title = "pls run da program",
        allocator = general_allocator(),
        enable_clipboard = true,
        enable_dragndrop = true,
    );
}

fn driver(vtable: *ImportVTable) void = 
    Easy'build_for_graphics(vtable, "examples/terminal.fr");

#include_std("backend/lib.fr");

TextBuffer :: @struct(
    lines: RawList(Line),
    at: Rect,
    gpa: Alloc,
    cursor: Pos,
    render: Pos,
    max_x: f64,
    dead: bool,
    num_lines_fit_on_screen: i64,
);

fn draw_text(self: *TextBuffer) void = {
    if(self.dead, => return());
    state := state[];
    w, h := (self.at.w, self.at.h);
    max_line_width := self.max_x - (w / CHAR_W);
    self.render.x = max(0, min(self.render.x, max_line_width));
    state[].lock_to_bottom = self.render.y > self.lines.len.float() - self.num_lines_fit_on_screen.float();
    self.render.y = max(0, min(self.render.y, self.lines.len.float()));
    
    sdtx := state.text.default_context&;
    sdtx.color = state.font_color; 
    sapp := state.app&;
    sdtx.canvas(state.app.framebuffer_width.float().cast(), state.app.framebuffer_height.float().cast());
    
    // the fractional component of your scroll position is used to offset the text rendering on the screen.
    // and the integral component chooses which range of lines we draw.
    sdtx.pos.y = cast(self.at.pos.y / CHAR_H - (self.render.y - self.render.y.floor()));
    x := cast(self.at.pos.x / CHAR_W - (self.render.x - self.render.x.floor()));
    sdtx.pos.x = x;
    line_count := int(h / CHAR_H);
    self.num_lines_fit_on_screen = line_count;
    start := min(max(0, self.render.y.int()), self.lines.len);
    end   := min(start + line_count, self.lines.len);
    chars_that_fit := int(w / CHAR_W);
    range(start, end) { i |
        line := self.lines&.index(i).str();
        col := self.render.x.int();
        if col < line.len {
            count := min(line.len - col, chars_that_fit);
            sdtx.put(line.subslice(col, count)); 
        };
        sdtx.pos.y += 1;
        sdtx.pos.x = x;
    };
}

Line :: @struct(
    // small string optimisation:
    // a valid list will never have a negative capacity, so if capacity < 0 (high bit is set), 
    // interpret the rest of the high byte of capacity (which is the 24th byte in this struct 
    // because two's complement) as the length of a string stored inline in the other 23 bytes. 
    // 
    // note length can still be 0..24 with an allocation if you pushed past 24 and then deleted 
    // some characters, we don't deallocate the list since you're likely to retype them immediately. 
    repr: RawList(u8),
);

empty_line: Line : (repr = zeroed RawList(u8));

fn raw_bytes(self: *Line) []u8 = self.slice(1).interpret_as_bytes();

fn str(self: *Line) Str #inline = if self.repr.len <= 0 {
    b := self.raw_bytes();
    b.subslice(0, b[23].zext().bit_and(0x7F))
} else {
    self.repr.items()
};

fn len(self: *Line) i64 #inline = if self.repr.len <= 0 {
    self.repr.len.shift_right_logical(64-8).bit_and(0x7F)
} else {
    self.repr.len
};

fn set_len(self: *Line, new_len: i64) void #inline = if self.repr.len <= 0 {
    @debug_assert(new_len <= 23 && new_len >= 0);
    not_high_byte := (@as(i64)0xFF).shift_left(64-8).bit_not();
    part_of_string := self.repr.len.bit_and(not_high_byte);
    self.repr.len = new_len.bit_or(0x80).shift_left(64-8).bit_or(part_of_string);
} else {
    self.repr.len = new_len;
};

fn push_all(self: *Line, s: []u8, a: Alloc) void = if self.repr.len <= 0 {
    l := self.repr.len.shift_right_logical(64-8).bit_and(0x7F);
    b := self.raw_bytes();
    if s.len + l > 23 {
        dest := a.alloc(u8, s.len + l);
        dest.slice(0, l).copy_from(b.subslice(0, l));
        dest.rest(l).copy_from(s);
        self.repr = dest.as_raw_list();
    } else {
        self.set_len(l + s.len);  // TODO: why does this need to be first
        b.subslice(l, s.len).copy_from(s);
        @debug_assert_le(self.repr.len, 0);
    }
} else {
    self.repr&.push_all(s, a);
};

fn contains(r: Rect, p: Pos) bool = 
    p.x > r.pos.x && p.x < r.pos.x + r.w && p.y > r.pos.y && p.y < r.pos.y + r.h;

#use("@/lib/sys/fs.fr");

RunningProcess :: @struct {
    pipes: Array(Fd, 3);  // in, out, err
    pid: i32;
    start: i64;
};

fn exec(buffer: *TextBuffer, raw_command: Str) void = {
    if(raw_command == "", => return());
    
    push_history(raw_command);
    
    if raw_command.starts_with(";") || raw_command.ends_with(";") {
        exec_franca(buffer, raw_command);
    } else {
        exec_program(buffer, raw_command);
    }
}

push_history :: fn(raw_command: Str) void = {
    state := state[];
    @debug_assert(state.history.len >= 2);
    if state.history[state.history.len - 2] != raw_command {
        state.history.len -= 1;  // blank
        state.history&.push(raw_command.shallow_copy(allocator), allocator);
        state.history&.push("", allocator);
    };
    state.history_index = state.history.len - 1;
}

exec_franca :: fn(buffer: *TextBuffer, raw_command: Str) void = {
    state := state[];
    if !raw_command.ends_with(";") {
        raw_command = buffer.lines&[buffer.lines.len - 1]&.str();
        buffer.append_string(";");
        raw_command.len += 1;
    }
    
    buffer.append_string("\n");
    @if(ENABLE_FRANCA_REPL, {
        result := state.repl&.run_chunk(raw_command);
        if result&.is_err() {
            out: List(u8) = list(temp());
            state.repl.program.fmt_error(result.Err, out&, false);
            buffer.append_string(out.items());
        };
    }, echo("This copy of terminal.fr was not compiled with FRANCA_REPL_ENABLED"));
    //const_eval(void)(@{ import(@[@literal @tfmt("{ result :: { state := state; %;  }; _HACK :: %; };", raw_command, timestamp())]).result });
    buffer.append_string("\n");
}

exec_program :: fn(buffer: *TextBuffer, raw_command: Str) void = {
    state := state[];
    cmd := CStr.list(temp());
    start := 0;
    range(0, raw_command.len) { i |
        if raw_command[i] == " ".ascii() {
            cmd&.push(@fmt_cstr("%", raw_command.slice(start, i)));
            start = i + 1;
        };
    };
    cmd&.push(@fmt_cstr("%", raw_command.rest(start)));
    cmd&.push(zeroed CStr);
    if cmd[0].str().ends_with(".fr") {
        cmd&.insert(0, @as(CStr) "franca");
    };
    if cmd[0].str() == "cd" {
        buffer.append_string("\nassuming you meant to call the shell builtin 'cd'\n");
        if cmd.len > 1 {
            cd(cmd[1].str());
        };
        return();
    }
    
    buffer.append_string("\n");
    cmd := cmd.items();
    if state.process.is_none() {
        @match(sys_exec(cmd)) {
            fn Ok(it) => {
                state.process = (Some = it);
                buffer.append_string(@tfmt("pid = %, time = %|\n", it.pid, it.start));
            }
            fn Err(msg) => buffer.append_string(msg);
        };
        buffer.append_string("=======================\n");
    } else {
        buffer.append_string("something is already running.\npress control + c to interrupt it (+ shift to kill it)\n");
    };
}

sys_exec :: fn(args: []CStr) Result(RunningProcess, Str) = {
    pipes := zeroed Array(Array(Fd, 2), 3);
    each pipes& { p |
        pipe(p) || return(Err = "libc::pipe() failed");
    };
    @debug_assert(args[args.len - 1].ptr.is_null());
    
    pid := fork();
    if pid == 0 { // Child
        dup2(pipes&[0]&[0], STD_IN);
        dup2(pipes&[1]&[1], STD_OUT);
        dup2(pipes&[2]&[1], STD_ERR);
        
        execvp(args[0], args.ptr);
        eprintln("libc::execvp() failed!");
        exit(1);
    };
    // else: Parent

    close(pipes&[0]&[0]);  // close the read end
    close(pipes&[1]&[1]);  // close the write end
    close(pipes&[2]&[1]);  // "
    
    (Ok = (pid = pid, pipes = (pipes&[0]&[1], pipes&[1]&[0], pipes&[2]&[0]), start = timestamp()))
}

fn poll(self: *RunningProcess, buf: *List(u8)) Result(?i32, Str) = {
    @debug_assert(buf.maybe_uninit.len > buf.len);
    flag: u16 = (@as(i64) PollEvents.In).trunc();
    poll_data: Array(PollFds, 2) = (
        (fd = self.pipes&[1], events = flag, revents = 0),
        (fd = self.pipes&[2], events = flag, revents = 0)
    );
    poll_data := poll_data&.items();

    status: i32 = 0;
    _ := poll(poll_data, 0) || return(Err = "libc::poll() failed");
    done := waitpid(self.pid, status&, @as(i64) WaitPidOptions.NoHang);
    
    full := false;
    each poll_data { p |
        have_data := (@as(i64) p.revents.zext()).bit_and(@as(i64) PollEvents.In) != 0;
        if have_data {
            dowhile {
                space := buf.maybe_uninit.len - buf.len;
                len := read(p.fd, buf.maybe_uninit.ptr.offset(buf.len), space)
                    || return(Err = "libc::read() failed");
                buf.len += len;
                full = full || buf.maybe_uninit.len == buf.len;
                
                // :BigOutputBuffer (see devlog May 9, 2025)
                system_pipe_buffer_capacity :: 65536;
                len == system_pipe_buffer_capacity && len < space
            };
        }
    };
    
    // the hope is that you're alllowed to waitpid again after the caller clears the buffer and get the status then
    // TODO: is that true?
    if done != 0 && !full {
        close(self.pipes&[0]);
        close(self.pipes&[1]);
        close(self.pipes&[2]);
        
        return(Ok = (Some = status));
    };
    
    (Ok = .None)
};

// TODO: todo.c i cheated and just changed stb_truetype.h for now
StbTrueType :: {
    get  :: import("@/examples/testing.fr").fetch_or_crash;
    root := get("https://github.com/nothings/stb/archive/f0569113c93ad095470c54bf34a17b36646bbbb5.zip", 1754150, "b62be3009cb9d4b6385bd4854bddf72d8e91f4e19d1347d6cf9589b19f70d45d", "stb-f0569113c93ad095470c54bf34a17b36646bbbb5");
    Ffi  :: import("@/examples/import_c/ffi.fr");
    namespace :: scope_of(Type, @struct {});
    c_source := @tfmt("""
        #define STB_TRUETYPE_IMPLEMENTATION
        #include "%/stb_truetype.h"
    """, root);
    Ffi'include(current_compiler_context(), namespace, c_source);
    namespace
}

font_data_ttf :: {
    get :: import("@/examples/testing.fr").fetch_or_crash;
    root := get("https://download.jetbrains.com/fonts/JetBrainsMono-2.304.zip", 5622857, "6f6376c6ed2960ea8a963cd7387ec9d76e3f629125bc33d1fdcd7eb7012f7bbf", "");
    path := @tfmt("%/fonts/ttf/JetBrainsMonoNL-Bold.ttf", root);
    ast_alloc().read_to_string_or_crash(path).items()
}

#include_std("backend/lib.fr");
