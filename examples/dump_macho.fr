#!/usr/bin/env franca
//! I think writing a pretty printer for a file format is good practice for trying to emit them myself. 
//! https://en.wikipedia.org/wiki/Mach-O
//! note: if you're ever tempted to use this code for something don't forget to use buffered printing. :SLOW

#include_std("backend/macho/bits.fr");
fn main() void = {
    args := cli_args();
    assert(args.len > 1, "Last argument is path to macho file");
    path := args[args.len - 1].str(); 
    bytes := temp().read_to_string(path).items(); // :panic
    
    full_bytes := bytes;
    @println("Read % bytes from %", bytes.len, path);
    header := bytes&.pop_type(MachoHeader);
    @println("[Header] %", header);
    if header.magic != macho_magic {
        eprintln("bad magic");
    };
    total := 0;
    start := bytes.ptr;
    unknown := 0;
    range(0, header.commands_count.zext()) { i |
        beginning_len := bytes.len;
        header := bytes&.pop_type(LoadCommandHeader);
        @println("  [Load Command %] %", i, header);
        @switch(header.type) {
            @case(LoadCommand.SegmentLoad.raw()) => {
                header := bytes&.pop_type(SegmentLoad);
                @println("        [Segment Load] %", header);
                name: []u8 = (ptr = ptr_cast_unchecked(u128, u8, header.name&), len = 16);
                @println("      name: %", name);
                
                // note: its fine if there's no sections. like __LINKEDIT.
                range(0, header.section_count.zext()) { i |
                    header := bytes&.pop_type(SegmentSection);
                    @println("      [Section %] %", i, header);  // this index is misleading. really it should include the preceding ones. 
                    name: []u8 = (ptr = ptr_cast_unchecked(u128, u8, header.section_name&), len = 16);
                    @println("          section_name: %", name);
                    name: []u8 = (ptr = ptr_cast_unchecked(u128, u8, header.segment_name&), len = 16);
                    @println("          segment_name: %", name);
                    
                    if header.relocations_count != 0 {
                        @println("          % relocations:", header.relocations_count);
                        relocations := ptr_cast_unchecked(u8, RelocationEntry, full_bytes.ptr.offset(header.relocations_file_offset.zext()));
                        relocations: []RelocationEntry = (ptr = relocations, len = header.relocations_count.zext());
                        for relocations { r | 
                            symbol := r.packed_fields.bit_and(1.shift_left(24) - 1); // index in __LINKEDIT Symbol Table (when extern=true?) 
                            relative := r.packed_fields.shift_right_logical(24).bit_and(0b1) == 1;
                            length := r.packed_fields.shift_right_logical(25).bit_and(0b11); // (byte, word, long, quad)
                            extern := r.packed_fields.shift_right_logical(27).bit_and(0b1) == 1;
                            type := r.packed_fields.shift_right_logical(28).bit_and(0b1111); // 4=ARM64_RELOC_PAGEOFF12, 3=ARM64_RELOC_PAGE21
                            @println("          - (offset = %, symbol = %, relative = %, length = %, extern = %, type = %)", r.offset, symbol, relative, length, extern, type);
                        };
                    };
                };
                //@println("current offset is %", ptr_diff(start, bytes.ptr));
            };
            @case(LoadCommand.LinkEditSymbolInfo.raw()) => {
                command := bytes&.pop_type(LinkEditSymbolInfo);
                @println("    [__LINKEDIT Symbol Info] %", command);
                // Offset from the beginning of the file. (the data will be after all the load commands).
                // (index in __stubs = index in LinkEditSymbolTable)
                if command.indirect_symbol_count > 0 {
                    println("        Indirect Symbols:");
                };
                indirect_bytes := full_bytes.slice(command.indirect_symbol_offset.zext(), full_bytes.len);
                range(0, command.indirect_symbol_count.zext()) { i | 
                    if i.mod(10) == 0 {
                        if(i != 0, => print("\n"));
                        print("        ");
                    };
                    symbol_index := indirect_bytes&.pop_type(u32);
                    ::FmtPad(i64);
                    ::FmtPad(u32);
                    @print("(% = %), ", f_pad(i, 3, .After), f_pad(symbol_index[], 3, .Before));
                };
                print("\n");
            };
            @case(LoadCommand.LinkEditSymbolTable.raw()) => {
                command := bytes&.pop_type(LinkEditSymbolTable);
                if 24 != (@as(i64) header.size.zext()) {
                    eprintln("bad fixed command size");
                };
                @println("    [__LINKEDIT Symbol Table] %", command);
                // Offsets from the beginning of the file. (the data will be after all the load commands).
                symbols_bytes := full_bytes.slice(command.symbols_offset.zext(), full_bytes.len);
                strings_bytes := full_bytes.slice(command.strings_offset.zext(), full_bytes.len);
                
                range(0, command.symbol_count.zext()) { i | 
                    command := symbols_bytes&.pop_type(SymbolEntry);
                    @println("      [Symbol %] %", i, command);
                    name: CStr = (ptr = strings_bytes.ptr.offset(command.name_offset.zext()));
                    name := name.str();
                    if name.len + command.name_offset.zext() < strings_bytes.len {
                        @println("          name: %", name);
                    } else {
                        eprintln("string goes out of bounds of string table");
                    };
                };
            };
            @case(LoadCommand.MinimumOsVersion.raw()) => {
                command := bytes&.pop_type(MinimumOsVersion);
                @println("    [Minimum Os Version] %", command);
                range(0, command.number_of_tools_used.zext()) { i |
                    @println("        [Tool %] %", i, bytes&.pop_type(ToolType));
                };
            };
            @case(LoadCommand.LinkLibrary.raw()) => 
                with_trailing_string(bytes&, header, LinkLibrary, "Link Library");
            @case(LoadCommand.LoadDynamicLinker.raw()) => 
                with_trailing_string(bytes&, header, LoadDynamicLinker, "Load Dynamic Linker");
            @case(LoadCommand.LinkLibrarySelf.raw()) => 
                with_trailing_string(bytes&, header, LinkLibrary, "Link Library Self");
            @case(LoadCommand.MainEntryPoint.raw()) => {
                command := bytes&.pop_type(MainEntryPoint);
                @println("    [Main Entry Point] %", command);
            };
            @case(LoadCommand.SourceVersion.raw()) => {
                command := bytes&.pop_type(SourceVersion);
                @println("    [Source Version] %", command);
            };
            @case(LoadCommand.FunctionStarts.raw()) => {
                command := bytes&.pop_type(LinkEditBlob);
                @println("    [Function Starts] %", command);
                // first number is offset from start of __TEXT to first function. the rest are delta to next function. 
                function_starts := full_bytes.slice(command.offset.zext(), command.offset.zext() + command.size.zext());
                i := 0;
                while => !function_starts.is_empty() {
                    if i.mod(20) == 0 {
                        if(i != 0, => print("\n"));
                        print("        ");
                    };
                    value, rest, ok := read_leb128_unsigned(function_starts);
                    assert(ok, "failed to read a leb128");
                    @print("%, ", value);
                    function_starts = rest;
                    i += 1;
                };
                println("");
            };
            @case(LoadCommand.DataInCode.raw()) => {
                command := bytes&.pop_type(LinkEditBlob);
                @println("    [Data In Code] %", command);
                data := full_bytes.slice(command.offset.zext(), command.offset.zext() + command.size.zext());
                count := data.len / DataInCodeEntry.size_of();
                range(0, count) { i |
                    @println("      [%] %", i, data&.pop_type(DataInCodeEntry));
                };
            };
            @case(LoadCommand.CodeSigneture.raw()) => {
                command := bytes&.pop_type(LinkEditBlob);
                @println("    [Code Signeture] %", command);
                data := full_bytes.slice(command.offset.zext(), command.offset.zext() + command.size.zext());
            };
            @case(LoadCommand.ApplicationUuid.raw()) => {
                command := bytes&.pop_type(ApplicationUuid);
                @println("    [Application UUID] %", command);
            };
            @case(LoadCommand.ChainedFixups.raw()) => {
                // https://github.com/qyang-nj/llios/blob/main/dynamic_linking/chained_fixups.md
                command := bytes&.pop_type(LinkEditBlob);
                @println("    [Chained Fixups] %", command);
                full_data := full_bytes.slice(command.offset.zext(), command.offset.zext() + command.size.zext());
                data := full_data;
                header := data&.pop_type(ChainedFixupsHeader);
                @println("        %", header);
                seg_count := data&.pop_type(u32);
                @println("           chained_starts_in_image.seg_count %", seg_count);
                range(0, seg_count[].zext()) { _ |
                    @println("           %", data&.pop_type(u32)); // TODO: untested
                };
                starts := data&.pop_type(ChainedStartsInSegment);
                @println("           ChainedStartsInSegment: %", starts);
                imports_data := full_data.slice(header.imports_offset.zext(), full_data.len);
                symbols_data := full_data.slice(header.symbols_offset.zext(), full_data.len);
                
                println("           Imports:");
                range(0, header.imports_count.zext()) { i |
                    if header.imports_format == 1 {
                        import := decode_import(imports_data&.pop_type(u32)[]);
                        name := "";
                        if header.symbols_format == 0 { 
                            n: CStr = (ptr = symbols_data.ptr.offset(import.name_offset.zext()));
                            name = n.str();
                            if name.len + (@as(i64) header.symbols_offset.zext()) > full_data.len {
                                name = "";
                                eprintln("name of out bounds");
                            };
                        };
                        @println("           [%] % %", i, import&, name);
                    } else {
                        @print("(% = %]), ", i, data&.pop_type(u64));
                    };
                };
            };
            @case(LoadCommand.ExportsTrie.raw()) => {
                command := bytes&.pop_type(LinkEditBlob);
                @println("    [Exports Trie] %", command);
                data := full_bytes.slice(command.offset.zext(), command.offset.zext() + command.size.zext());
                // https://github.com/qyang-nj/llios/blob/main/exported_symbol/README.md#export-trie
                S :: @struct(string: Str, ptr: *u8, depth: i64);
                nodes := list(S, temp());
                nodes&.push(string = "", ptr = data.ptr, depth = 0);
                first := true;
                while => nodes&.pop() { node |
                    bytes: []u8 = (ptr = node.ptr, len = data.len - ptr_diff(data.ptr, node.ptr));
                    terminal_size, rest, ok := read_leb128_unsigned(bytes);
                    assert(ok, "failed read leb128");
                    if !first {
                        range(0, node.depth * 3) { _ |
                            print("=");
                        };
                        @print(" |%| ", node.string);
                    };
                    range(0, terminal_size.bitcast()) { i |
                        b := rest&.pop_type(u8)[];
                        t := u8.list(temp());
                        t&.push_prefixed_hex_byte(b);
                        @print("% ", t.items());
                    };
                    println("");
                    first = false;
                    child_count := rest&.pop_type(u8)[];
                    range(0, child_count.zext()) { i |
                        s: CStr = (ptr = rest.ptr);
                        s := s.str();
                        rest.ptr = rest.ptr.offset(s.len + 1);
                        child_offset, rest2, ok := read_leb128_unsigned(rest);
                        assert(ok, "failed read leb128");
                        rest = rest2;
                        nodes&.push(string = s, ptr = data.ptr.offset(child_offset.bitcast()), depth = node.depth + 1);
                    };
                };
            };
            @default => {
                unknown += 1;
                // -8 because we already ate the header
                bytes.ptr = bytes.ptr.offset(header.size.zext() - 8);
                bytes.len -= header.size.zext() - 8;
                @println("    [dont know what that is yet]");
            };
        };
        size_taken := beginning_len - bytes.len;
        total += size_taken;
        if size_taken != header.size.zext() {
            @eprintln("      bad command size (cmd said %, we read %)", @as(i64) header.size.zext(), size_taken);
            diff := (@as(i64) header.size.zext()) - size_taken;
            bytes.ptr = bytes.ptr.offset(diff);
            bytes.len -= diff;
        };
    };
    println("Finished file");
    if total != header.commands_size.zext() {
        @eprintln("load commands size mismatch. header said % bytes but we counted %", header.commands_size, total);
    };
    if unknown != 0 {
        @println("     % unknown load commands. (probably a problem with this tool, not your macho file)", unknown);
    };
}

fn with_trailing_string(bytes: *[]u8, header: *LoadCommandHeader, $Command: Type, command_name: Str) void = {
    command := bytes.pop_type(Command);
    @println("    [%] %", command_name, command);
    header_size :: LoadCommandHeader.size_of() + Command.size_of();
    @assert_eq(command.string_offset, header_size, "expected % string here", command_name);
    string_size: i64 = header.size.zext() - header_size;
    name: CStr = (ptr = bytes.ptr);
    name := name.str();
    assert(name.len <= string_size, "name too long");
    @println("      filepath: %", name);
    // Skip the extra zero padding (added for alignment, i assume, thats nice of them).
    bytes.ptr = bytes.ptr.offset(string_size);
    bytes.len -= string_size;
}

fn pop_type(bytes: *[]u8, $T: Type) *T #generic = {
    @debug_assert(bytes.len >= T.size_of(), "pop_type: not enough bytes");
    @debug_assert(u8.int_from_ptr(bytes.ptr).mod(T.align_of()) == 0, "pop_type: unaligned");
    start := bytes.ptr;
    bytes.ptr = bytes.ptr.offset(T.size_of());
    bytes.len -= T.size_of();
    ptr_cast_unchecked(u8, T, start)
}

::enum_basic(LoadCommand);
::DeriveFmt(MachoHeader);
::DeriveFmt(LoadCommandHeader);
::DeriveFmt(SegmentLoad);
::DeriveFmt(LoadCommand);
::DeriveFmt(SegmentSection);
::DeriveFmt(LinkEditSymbolTable);
::DeriveFmt(SymbolEntry);
::DeriveFmt(LinkEditSymbolInfo);
::DeriveFmt(MinimumOsVersion);
::DeriveFmt(ToolType);
::DeriveFmt(LinkLibrary);
::DeriveFmt(LoadDynamicLinker);
::DeriveFmt(MainEntryPoint);
::DeriveFmt(SourceVersion);
::DeriveFmt(LinkEditBlob);
::DeriveFmt(DataInCodeEntry);
::DeriveFmt(ApplicationUuid);
::DeriveFmt(ChainedFixupsHeader);
::DeriveFmt(ChainedStartsInSegment);
::DeriveFmt(DecodedImport);
::DeriveFmt(u128);

fn display(a: *u64, out: *List(u8)) void = a[].display(out);
fn display(a: *u16, out: *List(u8)) void = a[].display(out);
fn display(a: *u8, out: *List(u8)) void = a[].display(out);
