//! TLDR: use invalid values of types to store enum tags. It's like Rust. 
//! Better explination of the same trick: https://craftinginterpreters.com/optimization.html#nan-boxing

@script

when any(tricks(), NonNilRef | Ptr48Bit) {
    let z: i64 = 42;
    let y: ?*i64 = @addr(z);
    assert_eq(size_of(*i64), size_of(?*i64)));
    let y: &i64 = @unsafe transmute(y); // This is legal.
    assert_eq(y, 42);
    
    when none(tricks(), Ptr48Bit) {
        // Since raw pointers allow zero, they don't have room for the type tag. 
        assert_ne(size_of(?*i64), size_of(i64)));
        @assert_compile_error {
            let x: ?*i64 = nil();
            let x: &i64 = @unsafe transmute(x);  // Comptime size check
        }
    }
    
    when any(tricks(), Ptr48Bit) {
        // TODO
    }
    
    let x: *i64 = nil_ptr();
    assert_eq(size_of(*i64), size_of(i64)));
    let zero: i64 = @unsafe transmute(x);  // This is legal
    assert_eq(zero, 0);
    
    @assert_safety_checked(NonNilRef | Ptr48Bit) {
        compile_warning("This program invokes illegal behaviour. See comments.");
        let a: *i64 = nil_ptr();
        let a: &i64 = @unsafe transmute(a);  // This is illegal and safety checked by specilization of transmute() &T. 
        // It was already UB as soon as you created the nil reference, you don't even have to use it. 
        // This allows the optimisation of representing an empty optional reference as a null pointer. 
        blackbox(a);  // This is still UB, but its not unsafe, because we're already in crazy land.
    };
}

when none(tricks(), NonNilRef | Ptr48Bit) {
    assert(gt(size_of(?*i64), size_of(*i64)));
    assert(gt(size_of(?&i64), size_of(&i64)));
}

// IEEE floating point numbers also behave strangely. 
let nan1: f64 = nan();
let nan2: f64 = nan();
assert_ne(nan1, nan2);
assert(is_nan(nan1));
assert(is_nan(nan2));
assert_eq(size_of(i64), size_of(f64)));
let nan1: i64 = @unsafe transmute(nan1);  // This is legal
let nan2: i64 = @unsafe transmute(nan2);  // This is legal
assert_eq(nan1, nan2); // damn, odd that they're equal now
assert_eq(nan1, blessed_nan_bits());  // Extra nans are reserved. 
let nan1: f64 = @unsafe transmute(nan1);  // This is legal
let nan2: f64 = @unsafe transmute(nan2);  // This is legal
assert_ne(nan1, nan2);  // bro, im starting to think we have different definitions of equality...
assert(is_nan(nan1));
assert(is_nan(nan2));
