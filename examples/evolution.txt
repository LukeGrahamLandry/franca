

// Discovered swifts type checker is really slow. 
// Wanted to design a language that had lots of function overloading and see if i could write a fast compiler. 

// defining interface for a list of types:
// for T in [i64, f64] { fn add(T, T) T }

// automatic convience methods that can be overriden later with more efficient versions for specific types. 
// avoids the c++ thing where operator + doesn't give you operator += 
// for T with fn eq(T, T) bool { fn ne(a: T, b: T) = not(eq(a, b)); }
// I figured i'd just write a few base ones for numbers in a c header file and target that. 


//////////////////////////////////////////

// Syntax like closures but always inlined so compile to c easily without figuring out how to promote upvalues. 

// `if(condition, fn = { true_branch() }, fn = { false_branch() }))`
// enums with a match function `match(value, [(TagName, fn(_: Payload) = { handler() })])`

//////////////////////////////////////////

// magic functions called be the compiler: move, copy, cast, drop
// conventions for collections: eq, hash

//////////////////////////////////////////

// Comptime execution with types as values like zig. 

//////////////////////////////////////////

// your whole code as a build-script for itself. 
// long sarcasting function names to change defaults. 
// relaxed mode with auto unwrap for prototyping

//////////////////////////////////////////

// Modules for dependency injection. 

//////////////////////////////////////////

// dynamic typing as a library feature.
// any, vtable, duck

//////////////////////////////////////////

// Inline embed_src for defining a function body as a string in the target language. 

//////////////////////////////////////////

// traits as syntax sugar for generics
// now you can describe an interface without 

//////////////////////////////////////////

// Giant enum of all the restrictions different languages have on pointers.
// you wouldn't need to refer to them everywhere, just give the compiler something to check when using ffi.
// configurable semantics 

//////////////////////////////////////////

// Meta Types
// it was always hard 
// `fn Tag(E: @type EnumType) Type`
// really this is just pattern matching accross function definitions kinda like haskel. 
//
// CHANGED: This became types just implementing traits. 

//////////////////////////////////////////


// Type providers for ffi 
// thinking about how i'd write an lsp and it would be nice to just parse the typescript interfaces from the spec
// and use that for type checking the jsonrpc. 
// why not do the same for json-schema, or c, or rust, or anything. 
// wouldn't even be slow because you could serialize declarations to normal code and the compiler could cache it. 
// I reinvented F#
//
// would be nice to have a little parser combinator library for these.  
//

//////////////////////////////////////////

// Annotations as macros transforming the ast. 
// use that for dumb match that becomes a chain of ifs but can specialize

//////////////////////////////////////////

// TODO: its a little strange that most things im adding are things i originally judged nim for having. maybe my preferences have just changed and thats ok. 
