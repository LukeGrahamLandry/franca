//
// Notes on how to choose how to add new abstractions.
//


// # Funtime Functions
// - Arguments are egarly evaluated expressions. 
// - Every language has these
//
// # Comptime Functions
// - Arguments are eagerly evaluated expressions, but thier result must be statically known.  
// - Arguments can be of type Type. 
//
// - Similar
//      - Zig, Nim, 
//      - no types: c++ constexpr, rust
//      - generics: rust, c++, java (different because not inlined)
//      - build scripts: build.rs, build.zig, gradle
//
// # Annotations
// - Arguments are Ast nodes. 
// - syntax is limited because it must parse as a valid ast. 
// - however, it doesn't need to typecheck, so the syntax is more flexible than normal comptime function
// - gives you a way to run pre-comptime code, kinda. 
//
// - Similar: 
//      - rust macros if you use the crate that parses it again
//      - swift macros: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/
//      - nim macros? https://nim-lang.org/docs/macros.html
//      - java annotation processors
//


// # Macros
// - Arguments are arbitrary characters. 
// - you're free to invent new syntax
// - TODO: replace this. you just need a raw string literal. 
//         otherwise make it tokens like rust but i really dont see the point 
// 

// - Similar: 
//      - rust macros
//      - c/c++ macros (but they aren't code)
// 
//      