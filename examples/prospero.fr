//
// https://www.mattkeeter.com/projects/prospero
// They've got some ssa programs that represent pretty pictures. 
// "Assembly language for shapes" is such a cool idea.
//
// the basic structure of this program is:
// - at comptime, fetch their examples and parse them into a simple Program struct to embed in the exe
// - at runtime, generate ir and use my jit to compile the functions
// - call the function for each pixel and write out a ppm image
// but there are some tricks to make it faster:
// - recurse down a quad tree and calculate the intervals of outputs based on the input intervals
// - if output interval is statically known positive or negative, no more work for that region
// - to evaluate a pixel use the expression after interval simplification
//
// More detailed write-up: https://lukegrahamlandry.ca/words/prospero
// 
// note: only the 2d examples work 
// TODO: i want to make this a self contained example that doesn't need to fetch thier program. 
//       so i guess i need to figure out how to make sdf fonts and convert those to ssa? 

AstExternal :: import("@/compiler/ast_external.fr");
#use("@/backend/lib.fr");

FEAT_JIT :: true;  // true is slower but more fun
FEAT_THREADS :: true;
FEAT_PNG :: false;  // true adds dependency on stb_image_write
FEAT_BAKE_IR :: true;  // true removes runtime dependency on prospero.vm file and makes the -i cli arg optional. 

main :: fn() void = {
    vtable := ImportVTable.zeroed();
    @if(FEAT_JIT) AstExternal'fill_backend_vtable(vtable&);
    import("@/lib/crash_report.fr")'hook_backtrace();
    impl(vtable&);
}

driver :: fn(vtable: *ImportVTable) void = 
    impl(vtable);

fn impl(v: *ImportVTable) void = {
    #use("@/lib/args.fr");
    Args :: @struct {
        hush: bool = false;
        o: Str = "";
        i := "";
        width: i64 = 1024;
    }
    args := parse_args(Args);
    
    p := @if(FEAT_BAKE_IR, @run parse_program(ast_alloc(), Foreign'fidget()), zeroed(Program));
    
    if args.i != "" {
        s := read_entire_file_or_crash(temp(), args.i);
        p = parse_program(temp(), s);
    } else {
        @assert(FEAT_BAKE_IR, "missing -i path/to/.vm");
    };
    
    pixels, yes, no := render(p&, args.width, v);
    
    if args.hush || args.o != "" {
        set := bscount(pixels&);
        // don't do this in the other case because running with `orb` dumps out+err together
        @eprintln("%/%:%", yes, no+yes, set); 
        
        if args.width == 64 {  // i do this in run_tests.fr
            // hardcoding the numbers is lame but i'm can't just check the picture every time i run the tests so here we are
            // it's fine if you make optimise_intervals smarter and it makes `yes` go up, 
            // that just means it did less work (`set` should stay the same or the picture changed).
            @assert(yes == 23 && no+yes == 253 && set == 3578, "something changed!");
            eprintln("ok!");
        }
    }
    
    if !args.hush {
        out := u8.list(temp());
        draw :: @if(FEAT_PNG, draw_png, draw_ppm);
        draw(out&, pixels, args.width);
        if args.o == "" {
            @if(FEAT_PNG) if query_current_arch() == .wasm32 {
                encode :: import("@/lib/encoding/base64.fr").encode;
                in := out.items();
                out = u8.list(temp());
                out&.push_all("data:image/png;base64,");
                encode(out&, in);
            };
            print(out.items());
        } else {
            write_entire_file_or_crash(args.o, out.items())
        };
    }
}

render :: fn(p: *Program, width: i64, v: *ImportVTable) Ty(Qbe.BSet, i64, i64) = {
    i: Interval = (min = -1.0, max = 1.0);
    i: Interval2 = (x = i, y = i);
    w: Work = (
        p = p, width = width, v = v, i = i, 
        pixels = init_bitset(width * width),
        depth = max(log(width, 2) - 3, 1) - 1,
        yes = @ref 0, no = @ref 0, 
    );
    if FEAT_THREADS {
        threads := list(*Thread, 4, temp());
        for_quads(i) { i |
            w := temp().boxed(Work, w);
            w.i = i;
            threads&.push(start_thread_data(Work, w, render2));
        };
        for(threads, join);
    } else {
        render2(w&);
    };
    (w.pixels, w.yes[], w.no[])
}

render2 :: fn(a: *Work) void = {
    p, N, v := (a.p, a.depth, a.v);

    m := zeroed QbeModule;
    if FEAT_JIT {
        init_default_module_dyn(m&, v, (type = .JitOnly, os = query_current_os(), arch = query_current_arch()));
        do_imports(m&);
    } else {
        init_empty_for_template_only(m&, general_allocator());
    };
    f0 := temp().box_uninit(Qbe.Fn);
    n := 64+3+p.o.len;
    s: RecState = (
        f = temp().alloc_uninit(Qbe.Fn, N+2),
        vals = temp().alloc_uninit(f32, n),
        ints = temp().alloc_uninit(Interval, n),
        w = a,
        top = zeroed F,
        copy = temp().alloc_zeroed(Qbe.Ref, n),
        jit_at = max(0, N - 3),
        enable_jit = FEAT_JIT,
    );
    each s.f { f |
        f.start = temp().box_zeroed(Qbe.Blk);
        f.start.ins = init(temp(), n);
    };
    f := s.f.index(N+1);
    default_init(f, m&);
    compile_program(f, p);
    
    quad_rec(s&, a.i, N);
    @if(FEAT_JIT, v'drop_qbe_module(QbeModule.raw_from_ptr(m&)), drop(m&))
}

Interval2 :: @struct {
    x: Interval;
    y: Interval;
}

RecState :: @struct {
    f: []Qbe.Fn;
    vals: []f32;
    ints: []Interval;
    top: F;
    copy: []Qbe.Ref;
    jit_at: i64;
    n := 0;
    enable_jit: bool;
    w: *Work #use;
}

Work :: @struct {
    p: *Program;
    width: i64;
    depth: i64;
    v: *ImportVTable;
    i: Interval2;
    pixels: Qbe.BSet;
    yes: *i64;
    no: *i64;
}

fn quad_rec(s: *RecState, int: Interval2, depth: i64) void = {
    f := s.f.index(depth);
    f0 := s.f.index(depth+1);
    dup(f, f0);

    n: Interval = (min = NaN, max = NaN);
    
    known := optimise_intervals(f, int&, s);
    f0.ncon = f.ncon;
    f0.con = f.con;
    
    // Check if the whole output range is positive or negative, 
    // then we already know the colour of all the pixels. 
    if !known.is_nan() {
        if known.min > 0.0  {
            iter_intervals(s.width, int.x, int.y) { x, y, i |
                s.pixels&.bsset(i);
            }
        };
        if (known.max < 0.0 || known.min > 0.0) {
            s.yes[] += 1;
            return();
        };
    }
    
    dead_code(s, f);
    renumber(f);

    @if(FEAT_JIT)
    if s.enable_jit && depth == s.jit_at {
        mark := mark_temporary_storage();
        f := dup(f);
        s.top = compile(f, @tfmt("%", s.n));
        s.n += 1;
        reset_temporary_storage(mark);
    }
    
    if depth == 0 {
        s.no[] += 1;
        if !s.enable_jit {
            iter_intervals(s.width, int.x, int.y) { x, y, i |
                hit := interpret(f, s.vals, x, y) > 0.0;
                if hit {
                    s.pixels&.bsset(i);
                };
            };
        } else {
            @if(!FEAT_JIT) unreachable();
            draw(s.width, s.pixels, s.top, int.x, int.y);
        }
        return();
    }

    for_quads int { it |
        quad_rec(s, it, depth - 1);
    };
}

// remove instructions with unused results
fn dead_code(s: *RecState, f: *Qbe.Fn) void = {
    needed := @ref init_bitset(f.ntmp.zext());
    needed.bsset(f.start.jmp.arg.val());
    f.reset_scratch();
    
    // never change signeture (matters on wasm even if just removing the last par)
    range(0, 3) { i |  // :ThreePar
        needed.bsset(f.start.ins[i].to.val());
    };
    
    for_insts_rev f.start { i |
        if needed.bshas(i.to.val()) {
            each i.arg& { a |
                if rtype(a[]) == .RTmp {
                    needed.bsset(a[].val());
                }
            };
            f.emit(i[][]);
        };
    };
    changed := f.len_scratch() != f.start.ins.len;
    @if(changed) f.copy_instructions_from_scratch(f.start); 
}

// shrink the tmp array
fn renumber(f: *Qbe.Fn) void = {
    j := Qbe.Tmp0;
    // cfg is flat and always def before use so don't need to init this. 
    map := temp().alloc_uninit(Qbe.Ref, f.ntmp.zext());
    for_insts_forward f.start { i |
        each i.arg& { a |
            if rtype(a[]) == .RTmp {
                a[] = map[a[].val()];
            }
        };
        
        @debug_assert(i.to != Qbe.Null);
        map[i.to.val()] = TMP(j);
        i.to = TMP(j);
        j += 1;
    };
    a := f.start.jmp.arg&;
    @debug_assert(rtype(a[]) == .RTmp);
    a[] = map[a[].val()];
    f.ntmp = j.trunc();
}

fn for_quads(int: Interval2, $do: @Fn(i: Interval2) void #duplicated) void = {
    wx := abs(int.x.max - int.x.min) / 2;
    wy := abs(int.y.max - int.y.min) / 2;
    do(x = (min = int.x.min, max = int.x.min + wx), y = (min = int.y.max - wy, max = int.y.max));
    do(x = (min = int.x.max - wx, max = int.x.max), y = (min = int.y.max - wy, max = int.y.max));
    do(x = (min = int.x.min, max = int.x.min + wx), y = (min = int.y.min, max = int.y.min + wy));
    do(x = (min = int.x.max - wx, max = int.x.max), y = (min = int.y.min, max = int.y.min + wy));
}

F :: @FnPtr(x: f64, y: f64, z: f64) f64;

fn compile(f: *Qbe.Fn, name: Str) F = {
    m := f.globals;
    f.lnk.id = m.intern(name);
    f.mem.first = Qbe.Addr.ptr_from_int(0);
    f.nmem = 0;
    run_qbe_passes(f);
    emit_suspended_inlinables(m);
    make_exec(m);
    f := get_addr(m, name).unwrap();
    f := bit_cast_unchecked(rawptr, F, f);
    f
}

// since i only append to con/tmp and they don't have any useful information, 
// the functions can just share and i don't need to spend time copying them. 
fn dup(dest: *Qbe.Fn, src: *Qbe.Fn) void = {
    i, b := (dest.start.ins, dest.start);
    dest[] = src[];
    dest.start = b;
    dest.start[] = src.start[];
    dest.start.ins = i;
    dest.start.ins.len = 0;
    dest.start.ins&.push_all_assume_capacity(src.start.ins.items());  // reserved when making RecState
}

fn dup(f0: *Qbe.Fn) *Qbe.Fn = {
    f := temp().box_uninit(Qbe.Fn);
    f[] = f0[];
    f.start = temp().boxed(Qbe.Blk, f0.start[]);
    f.start.ins = init(temp(), f.start.ins.len);
    f.tmp = new(f.ntmp.zext());
    f.con = new(f.ncon.zext());
    f.tmp.slice(0, f.ntmp.zext()).copy_from(f0.tmp.slice(0, f.ntmp.zext()));
    f.con.slice(0, f.ncon.zext()).copy_from(f0.con.slice(0, f.ncon.zext()));
    f.start.ins.len = f0.start.ins.len;
    f.start.ins.items().copy_from(f0.start.ins.items());
    f
}

fn interpret(f: *Qbe.Fn, vals: []f32, x: f64, y: f64) f32 = {
    // vals is uninit. always def before use so it's fine. 
    vals[64+0] = x.cast();
    vals[64+1] = y.cast();
    
    GET :: fn(r: Qbe.Ref) f32 => @match(rtype(r)) {
        fn RTmp() => { vals[r.val()] }
        // the jit one uses Kd so that's how they're stored in .con, but this uses Ks. 
        fn RCon() => { f.get_constant(r).bits().bitcast().cast() }
        fn RNull() => NaN;
        @default => unreachable();
    };
    each f.start.ins.items().rest(3) { i | // :ThreePar
        // tiny bit faster than calling the normal do_fold
        gen :: Qbe.Precompiled.gen_do_fold_impl;
        impl :: gen(fn(o) = @is(o, .neg, .add, .sub, .mul, .div, .sqrt, .max, .min));
        a: u32 = GET(i.arg&[0]).bitcast();
        b: u32 = GET(i.arg&[1]).bitcast();
        r := impl'Ks(i.op().raw().zext(), a.zext(), b.zext());
        vals[i.to.val()] = r;
    };
    
    vals[f.start.jmp.arg.val()]
}

// TODO: im a bit concerned this might be able to miss pixels?
fn iter_intervals(width: i64, x_int: Interval, y_int: Interval, $body: @Fn(x: f64, y: f64, i: i64) void) void = {
    back :: fn(n) => int((n.cast() + 1.0) / 2.0 * width.float());
    range_rev(back(y_int.min), back(y_int.max)) { y |
        range(back(x_int.min), back(x_int.max)) { x |
            continue :: local_return;
            move :: fn(n) => n.float() / width.float() * 2.0 - 1.0;
            i := y * width + x;
            body(move(x), move(y), i);
        };
    };
}

fn draw(width: i64, out: Qbe.BSet, f: @FnPtr(x: f64, y: f64, z: f64) f64, x_int: Interval, y_int: Interval) void = {
    iter_intervals(width, x_int, y_int) { x, y, i |
        hit := f(x, y, 0.0) > 0.0;
        if hit {
            out&.bsset(i);
        }
    };
}

fn draw_ppm(out: *List(u8), pixels: Qbe.BSet, width: i64) void = {
    @fmt(out, "P5 % % 255\n", width, width);
    n := width * width;
    out.reserve(n);
    p := out.maybe_uninit.subslice(out.len, n);
    range_rev(0, width) { y |
        range(0, width) { x |
            i := y * width + x;
            hit := bshas(pixels&, i);
            i := (width - y - 1) * width + x;
            p[i] = @if(hit, 0, 255);
        };
    };
    out.len += n;
}

fn do_imports(m: *QbeModule) void = {
    imports := @slice("log", "exp", "sin", "cos", "fabs");
    Dyn :: import("@/lib/dynamic_lib.fr");
    for find_os_libc_dylib() { libc_path | 
        if Dyn'open(libc_path) { lib |
            for imports { name |
                n := m.intern(name);
                if lib.get(name) { found |
                    put_jit_addr(m, n, found);
                }
            };
        };
    };
};

Interval :: @struct {
    nan: Interval : (min = NaN, max = NaN);

    min: f32;
    max: f32;
};

fn is_nan(self: Interval) bool = 
    is_nan(self.min + self.max);

fn optimise_intervals(f: *Qbe.Fn, input: *Interval2, s: *RecState) Interval = {
    r := f.start.jmp.arg&;
    @debug_assert_eq(r[].rtype(), .RTmp);

    k := 0;
    j := f.start.ins.ptr;
    j = j.offset(3); // :ThreePar
    
    ints: OptMap(Interval) = init(s.ints);
    ints&.insert(64+0, input.x);
    ints&.insert(64+1, input.y);
    copy: OptMap(Qbe.Ref) = init(s.copy);
    
    GET :: fn(r: Qbe.Ref) Interval => {
        ::?Interval;
        @match(rtype(r)) {
            fn RTmp() => ints&.get(r.val()) || Interval.nan;
            fn RCon() => {
                v: f32 = f.get_constant(r).bits().bitcast().cast();
                (min = v, max = v)
            }
            @default => Interval.nan;
        }
    };
    
    end := f.start.ins.ptr.offset(f.start.ins.len);
    while => !identical(j, end) {
        continue :: local_return;
        i := j; j = i.offset(1);
        a, b := (GET(i.arg&[0]), GET(i.arg&[1]));
        
        // remove useless copy chains
        {
            each i.arg& { a |
                if rtype(a[]) == .RTmp {
                    if copy&.get(a[].val()) { r |
                        a[] = r;
                    };
                }
            };
        };
        
        xx := a.is_nan() && rtype(i.arg&[0]) == .RTmp;
        if xx || (b.is_nan() && i.arg&[1] != QbeNull) {
            continue(); 
        };
        
        // when min/max args have intervals that don't overlap, only care about one side. 
        only :: fn(n) => {
            copy&.insert(i.to.val(), i.arg&[n]);
            i[] = make_ins(.copy, .Kd, i.to, i.arg&[n], QbeNull);
            @if(n == 0, a, b)
        }
        
        new: Interval = @match(i.op()) {
            fn copy() => only(0);
            fn add() => (min = a.min + b.min, max = a.max + b.max);
            fn sub() => (min = a.min - b.max, max = a.max - b.min);
            fn mul() => {
                // https://en.wikipedia.org/wiki/Interval_arithmetic
                v0, v1, v2, v3 := (a.min*b.min, a.min*b.max, a.max*b.min, a.max*b.max);
                r: Interval = (min = v0.min(v1).min(v2).min(v3), max = v0.max(v1).max(v2).max(v3));
                if i.arg&[0] == i.arg&[1] {
                    // x^2 can't be negative
                    r.min = r.min.max(0);
                    r.max = r.max.max(0);
                }
                r
            };
            // mul specialized for -1
            fn neg() => {
                v0, v1 := (-a.min, -a.max);
                (min = v1, max = v0)
            }
            fn min() => @if_else { 
                @if(a.max < b.min) => only(0);
                @if(b.max < a.min) => only(1);
                @else => (min = min(a.min, b.min), max = min(a.max, b.max));
            };
            fn max() => @if_else { 
                @if(a.min > b.max) => only(0);
                @if(b.min > a.max) => only(1);
                @else => (min = max(a.min, b.min), max = max(a.max, b.max));
            };
            // we're not doing complex numbers so if it could be negative, who knows man just skip it
            fn sqrt() => {
                @debug_assert(a.max >= 0.0, "proved complex: % %", a.min, a.max);
                if(a.min < 0.0 || a.max < 0.0 || a.is_nan(), => continue());
                (min = a.min.sqrt(), max = a.max.sqrt())
            }
            @default => continue();
        };
        @debug_assert_le(new.min, new.max, "thats not in order %", i.op());
        ints&.insert(i.to.val(), new);
    };
    
    a := f.start.jmp.arg&;
    if copy&.get(a[].val()) { r |
        a[] = r;
    };
    
    @debug_assert_eq(rtype(r[]), .RTmp);
    final := ints&.get(r[].val()) || Interval.nan;
    final
}

fn compile_program(f: *Qbe.Fn, p: *Program) void = {
    f.ret_cls = .Kd;
    vars := @slice(f.newtmp("x", .Kd), f.newtmp("y", .Kd), f.newtmp("z", .Kd));
    vals := temp().alloc_init(Qbe.Ref, p.o.len, fn(_) => f.newtmp("v", .Kd));
    f.start = temp().box_zeroed(Qbe.Blk);
    f.start.ins = init(temp(), vals.len+3);
    f.nblk = 1;
    f.lnk.id = f.globals.intern("sdf");
    f.lnk.export = true;
    
    for vars { v |  // :ThreePar
        f.emit(.par, .Kd, v, QbeNull, QbeNull);
    };
    f.start.jmp = (type = .retd, arg = vals[vals.len - 1]);
    
    range(0, p.o.len) { i |
        r, a, b := (vals[i], vals[p.a[i].zext()], vals[p.b[i].zext()]);
        @match(p.o[i]) {
            fn const() => f.emit(.copy, .Kd, r, f.getcon(p.consts[p.a[i].zext()].bitcast()), QbeNull);
            fn var() => f.emit(.copy, .Kd, r, vars[p.a[i].zext()], QbeNull);
            fn neg() => f.emit(.neg, .Kd, r, a, QbeNull);
            fn add() => f.emit(.add, .Kd, r, a, b);
            fn sub() => f.emit(.sub, .Kd, r, a, b);
            fn mul() => f.emit(.mul, .Kd, r, a, b);
            fn div() => f.emit(.div, .Kd, r, a, b);
            fn sqrt() => f.emit(.sqrt, .Kd, r, a, QbeNull);
            fn exp()  => f.call("exp", r, a, .None);
            fn ln()   => f.call("log", r, a, .None);
            fn cos()  => f.call("cos", r, a, .None);
            fn sin()  => f.call("sin", r, a, .None);
            fn abs()  => f.call("fabs", r, a, (Some = b));
            fn max()  => f.emit(.max, .Kd, r, a, b);
            fn min()  => f.emit(.min, .Kd, r, a, b);
        };
    };
    
    emit :: fn(f: *Qbe.Fn, o: Qbe.O, k: Qbe.Cls, r: Qbe.Ref, a: Qbe.Ref, b: Qbe.Ref) void = { 
        f.start.push(make_ins(o, k, r, a, b)); 
    }
    call :: fn(f: *Qbe.Fn, name: Str, r: Qbe.Ref, a: Qbe.Ref, b: ?Qbe.Ref) void = {
        s := f.globals.intern(name);
        f.emit(.arg, .Kd, QbeNull, a, QbeNull);
        if b { b | 
            f.emit(.arg, .Kd, QbeNull, b, QbeNull);
        };
        f.emit(.call, .Kd, r, f.symcon(s), QbeNull);
        @assert(is_linking_libc(), "TODO: need my own version of %", name);
        @assert(FEAT_JIT, "TODO: abs, exp, ln, cos, sin");
    }
}

Operation :: @enum(u8) (
    const,  // consts[a]
    var,    // (x, y)[a]
    neg, sqrt, abs, exp, ln, cos, sin, // unary(a)
    add, sub, mul, div, max, min,  // binary(a, b)
);

Program :: @struct {
    consts: []f64;
    o: []Operation;
    a: []u16;
    b: []u16;
}

// a list of instructions like `out op arg0 arg1`
fn parse_program(al: Alloc, s: Str) Program = {
    #use("@/lib/collections/map.fr");
    consts, o, a, b := (f64.list(temp()), Operation.list(temp()), u16.list(temp()), u16.list(temp()));
    names: HashMap(Str, u16) = init(temp());
    
    if true {
        break :: local_return;
        i := 0;
        while => i < s.len {
            continue :: local_return;
            while => s[i].is_ascii_whitespace() {
                i += 1;
                if(i >= s.len, => break());
            }
            if s[i] == "#".ascii() {
                while => s[i] != "\n".ascii() {
                    i += 1;
                }
                continue();
            }
            
            eat_word :: fn() Str => {
                while => s[i].is_ascii_whitespace() {
                    i += 1;
                }
                start := i;
                while => !s[i].is_ascii_whitespace() {
                    i += 1;
                }
                s.slice(start, i)
            }
            eat_arg :: fn() u16 => {
                s := eat_word();
                names&.get(s) || @panic("undeclared variable '%'", s)
            }
            
            name := eat_word();
            names&.insert(name, o.len.trunc());
            op := eat_word();
            
            (o2: Operation, a2: u16, b2: u16) := @switch(op) {
                @case("const") => {
                    while => s[i].is_ascii_whitespace() {
                        i += 1;
                    }
                    f, ss := parse_float(s.rest(i));
                    consumed := (s.len - i) - ss.len;
                    @assert(consumed > 0, "failed to parse float: %", s);
                    i += consumed;
                    consts&.push(f);
                    (.const, consts.len.sub(1).trunc(), 0)
                }
                @case("var-x") => (.var, 0, 0);
                @case("var-y") => (.var, 1, 0);
                @case("var-z") => (.var, 2, 0);
                @case("square") => {
                    x := eat_arg();
                    (.mul, x, x)
                }
                @default => {
                    o := Operation.from_name(op) 
                        || @panic("invalid operation '%' in '%'", op, name);
                    a := eat_arg();
                    b := @if(o.raw() >= Operation.add.raw(), eat_arg(), 0);
                    (o, a, b)
                };
            };
            o&.push(o2);
            a&.push(a2);
            b&.push(b2);
            continue();
        }
    };
    
    (
        consts = consts.items().shallow_copy(al),
        o = o.items().shallow_copy(al),
        a = a.items().shallow_copy(al),
        b = b.items().shallow_copy(al),
    )
}

fn OptMap($T: Type) Type = {
    Self :: @struct(mem: []T, valid: Qbe.BSet);
    
    fn init(uninit: []T) Self #inline = 
        (mem = uninit, valid = init_bitset(uninit.len));
    
    fn get(self: *Self, i: i64) ?T #inline = {
        @if(!self.valid&.bshas(i)) return(.None);
        (Some = self.mem[i])
    }
    
    fn insert(self: *Self, i: i64, t: T) void #inline = {
        self.valid&.bsset(i);
        self.mem[i] = t;
    }
    
    Self
}

#use("@/lib/sys/fs.fr");
#use("@/lib/sys/threads.fr");

fn draw_png(out: *List(u8), pixels: Qbe.BSet, width: i64) void = {
    @assert(is_linking_libc(), "FEAT_PNG doesn't work when built with -syscalls");
    data := temp().alloc_uninit(u8, width*width);
    range(0, width) { y |
        range(0, width) { x |
            i := y * width + x;
            hit := bshas(pixels&, i);
            i := (width - y - 1) * width + x;
            data[i] = @if(hit, 0, 255);
        };
    };
    
    #use(Stb);
    callback: stbi_write_func : fn(context, data, size) = {
        data := u8.ptr_from_raw(data).slice(size.zext());
        List(u8).ptr_from_raw(context).push_all(data);
    };
    width: i32 = intcast(width);
    res := stbi_write_png_to_func(callback, List(u8).raw_from_ptr(out), width, width, 1, u8.raw_from_ptr(data.ptr), width);
    @assert(res != 0, "failed to write image");
}

Stb :: {
    @assert(FEAT_PNG);
    root := Foreign'stb();
    Ffi  :: import("@/examples/import_c/ffi.fr");
    c_source := @tfmt("""
        #define STB_IMAGE_WRITE_IMPLEMENTATION
        #include "%/stb_image_write.h"
    """, root);
    Ffi'include(current_compiler_context(), c_source)
}
