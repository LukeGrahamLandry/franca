//! For debugging codegen. Parses a binary wasm module and outputs an arbitrary text format. 
//! For my current purposes it only needs to support the subset of the format that my backend actually outputs. 

#include_std("backend/lib.fr");
#include_std("examples/import_wasm/parse.fr");

LoadWasm :: void;  // TODO: bleh

fn main() void = {
    input := read_file_from_last_arg();
    w: Wasm.Module = empty(temp()); w := w&;
    @println("--- read % bytes ---", input.len);
    p: ParseWasm = (w = w, src = input);
    or parse_wasm(p&) { e |
        @panic("% (at byte index %)", e, p.cursor);
    };
    println("--- initial parse successful ---");
    
    out := u8.list(temp()); out := out&;
    
    ::enum(Wasm.ValType);
    @fmt(out, "=== BEGIN IMPORT SECTION ===\n");
    each w.imports { it |
        @fmt(out, "- '%' from '%'", it.name.items(), it.module.items());
        // TODO: other info
        @fmt(out, "\n");
    };
    @fmt(out, "=== END IMPORT SECTION ===\n\n");
    
    @fmt(out, "=== BEGIN EXPORT SECTION ===\n");
    each w.exports { it |
        ::enum(Wasm.ImportType);
        @fmt(out, "- '%' % %\n", it.name.items(), it.type, it.id);
    };
    @fmt(out, "=== END EXPORT SECTION ===\n\n");
    
    @fmt(out, "=== BEGIN DATA SECTION ===\n");
    each w.data { it |
        start := ptr_diff(input.ptr, it.bytes.ptr);
        @fmt(out, "- % bytes // [%..<%]\n  ", it.bytes.len, start, start + it.bytes.len);
        if it.active_offset_expr.len == 0 {
            @fmt(out, "(passive)\n");
        } else {
            @fmt(out, "active at offset ");
            dump_wasm_expr(w, input, it.active_offset_expr.items(), out);
        };
    };
    @fmt(out, "=== END DATA SECTION ===\n\n");
    
    @fmt(out, "=== BEGIN TYPE SECTION ===\n");
    range(0, w.types.len) { i |
        @fmt(out, "- ");
        show_type(out, w, (id = i.trunc()));  
        @fmt(out, "\n");
    };
    @fmt(out, "=== END TYPE SECTION ===\n\n");
    print(out.items()); out.clear();
    
    @fmt(out, "=== BEGIN FUNCTION/CODE SECTION ===\n");
    if w.functions.len != w.code.len {
        @fmt(out, "ERROR: % function types and % function bodies.\n", w.functions.len, w.code.len);
        print(out.items()); out.clear();
    };
    
    f_count := min(w.functions.len, w.code.len);
    enumerate w.code { i, code | 
        @fmt(out, "[F%]: \n- signeture ", i);
        if i < w.functions.len {
            show_type(out, w, w.functions[i]);
        } else {
            @fmt(out, "(ERROR: missing. only % entries signeture section)", w.functions.len);
        };
        @fmt(out, "\n");
        if code.locals.len == 0 {
            @fmt(out, "- only argument locals\n");
        } else {
            @fmt(out, "- (non-argument) locals: ");
            each code.locals { it |
                @fmt(out, "(% x %), ", it.type, it.count);
            };
            @fmt(out, "\n");
        };
        
        @fmt(out, "- code ");
        dump_wasm_expr(w, input, code.insts.items(), out);
    };
    @fmt(out, "=== END FUNCTION/CODE SECTION ===\n");
    
    print(out.items());
}

fn dump_wasm_expr(w: *Wasm.Module, full_input: []u8, insts: []u8, out: *List(u8)) void = {
    start := ptr_diff(full_input.ptr, insts.ptr);
    @fmt(out, "{  // [%..<%]", start, start + insts.len);
    c := 0;
    indent := 1;
    while => c < insts.len {
        continue :: local_return;
        
        ::enum(Wasm.Inst);
        byte := insts[c]; c += 1;
        encoding := lookup_wasm_encoding(byte);
        inst := @as(Wasm.Inst) byte;
        
        if @is(inst, .End) {
            indent -= 1;
            if indent < 0 {
                @fmt(out, "         (ERROR: closed too many blocks)");
            } else {
                if indent == 0 && c != insts.len {
                    @fmt(out, "        (ERROR: closed all blocks but there is still code)");
                };
            };
            indent = max(indent, 0);
        };
        
        @fmt(out, "\n  %", f_rep("    ", indent));
        if indent == 0 && c != insts.len {
            @fmt(out, "?");
        };
        
        if @is(inst, .End) {
            @fmt(out, "};");
            continue();
        };
        
        ::enum(@type encoding.kind);
        if encoding.kind != .other {
            k_name := @const_slice("I32", "I64", "F32", "F64", "???");
            k := min(k_name.len - 1, zext(@as(i32)encoding.cls));
            @fmt(out, "%_%(", k_name[k], encoding.op);
            if @is(encoding.kind, .load, .store) {
                @fmt(out, "// TODO: imm");
            };
            @fmt(out, ");");
            continue();
        };
        
        push_leb :: fn() => {
            value, r, ok := read_leb128_unsigned(insts.rest(c));
            if ok {
                c += ptr_diff(insts.ptr.offset(c), r.ptr);
                @fmt(out, "%", value);
                @as(i64) value.bitcast()
            } else {
                @fmt(out, " ERROR: invalid leb encoding");
                continue()
            }
        };
        
        
        read_leb_s :: fn() => {
            value, r, ok := read_leb128_signed(insts.rest(c));
            if ok {
                c += ptr_diff(insts.ptr.offset(c), r.ptr);
                value
            } else {
                @fmt(out, " ERROR: invalid leb encoding");
                continue()
            }
        };
        
        if @is(inst, .Block, .Loop, .If) {
            indent += 1;
            @fmt(out, "% {", inst);
            first_type_byte := insts[c];
            type_index := read_leb_s();
            if type_index >= 0 {
                @fmt(out, " // [T%]", type_index);
            } else {
                type := @as(Wasm.ValType) first_type_byte;
                if type != .EmptyBlock {
                    @fmt(out, " // -> (%)", type);
                };
            };
            continue();
        };
        
        @fmt(out, "%(", inst);
        if @is(inst, .LocalGet, .LocalSet, .LocalTee, .GlobalGet, .GlobalSet, .I32_Const, .I64_Const) {
            push_leb();
            @fmt(out, ");");
            continue()
        };
        
        if inst == .Call {
            v := push_leb();
            @fmt(out, "); ");
            if v < w.imported_function_count {
                @fmt(out, "  // import");
            } else {
                @fmt(out, "  // F%", v - w.imported_function_count);
            };
            continue()
        };
        @fmt(out, ");");
        
    };
    @fmt(out, "\n");
}

fn show_type(out: *List(u8), w: *Wasm.Module, i: TypeIdx) void = {
    i: i64 = i.id.zext();
    @fmt(out, "[T%]: (", i);
    if i >= w.types.len {
        @fmt(out, "ERROR: not enough entries in `type` section)");
        return();
    };
    type := w.types.index(i);
    for(type.arg, fn(t) => @fmt(out, "%,", t));
    @fmt(out, ") -> (");
    for(type.ret, fn(t) => @fmt(out, "%,", t));
    @fmt(out, ")");
}
