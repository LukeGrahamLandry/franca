//! For debugging codegen. Parses a binary wasm module and outputs an arbitrary text format. 
//! For my current purposes it only needs to support the subset of the format that my backend actually outputs. 

#include_std("backend/lib.fr");
#include_std("examples/import_wasm/parse.fr");

LoadWasm :: void;  // TODO: bleh

fn main() void = {
    input := read_file_from_last_arg();
    w: Wasm.Module = empty(temp()); w := w&;
    @println("--- read % bytes ---", input.len);
    p: ParseWasm = (w = w, src = input);
    or parse_wasm(p&) { e |
        @panic("% (at byte index %)", e, p.cursor);
    };
    println("--- initial parse successful ---");
    
    out := u8.list(temp()); out := out&;
    
    ::enum(Wasm.ValType);
    @fmt(out, "=== BEGIN IMPORT SECTION ===\n");
    each w.imports { it |
        @fmt(out, "- '%' from '%'", it.name.items(), it.module.items());
        // TODO: other info
        @fmt(out, "\n");
    };
    @fmt(out, "=== END IMPORT SECTION ===\n\n");
    
    @fmt(out, "=== BEGIN EXPORT SECTION ===\n");
    each w.exports { it |
        ::enum(Wasm.ImportType);
        @fmt(out, "- '%' % %\n", it.name.items(), it.type, it.id);
    };
    @fmt(out, "=== END EXPORT SECTION ===\n\n");
    
    @fmt(out, "=== BEGIN TYPE SECTION ===\n");
    range(0, w.imports.len) { i |
        @fmt(out, "- ");
        show_type(out, w, (id = i.trunc()));  
        @fmt(out, "\n");
    };
    @fmt(out, "=== END TYPE SECTION ===\n\n");
    print(out.items()); out.clear();
    
    @fmt(out, "=== BEGIN FUNCTION/CODE SECTION ===\n");
    if w.functions.len != w.code.len {
        @fmt(out, "ERROR: % function types and % function bodies.\n", w.functions.len, w.code.len);
        print(out.items()); out.clear();
    };
    
    f_count := min(w.functions.len, w.code.len);
    enumerate w.code { i, code | 
        @fmt(out, "[F%]: \n- signeture ", i);
        if i < w.functions.len {
            show_type(out, w, w.functions[i]);
        } else {
            @fmt(out, "(ERROR: missing. only % entries signeture section)", w.functions.len);
        };
        @fmt(out, "\n");
        if code.locals.len == 0 {
            @fmt(out, "- only argument locals\n");
        } else {
            @fmt(out, "- (non-argument) locals: ");
            each code.locals { it |
                @fmt(out, "(% x %), ", it.type, it.count);
            };
            @fmt(out, "\n");
        };
        start := ptr_diff(input.ptr, code.insts.ptr);
        @fmt(out, "- code {  // [%..<%]", start, start + code.insts.len);
        c := 0;
        indent := 1;
        while => c < code.insts.len {
            continue :: local_return;
            
            ::enum(Wasm.Inst);
            byte := code.insts[c]; c += 1;
            encoding := lookup_wasm_encoding(byte);
            inst := @as(Wasm.Inst) byte;
            
            if @is(inst, .End) {
                indent -= 1;
                if indent < 0 {
                    @fmt(out, "         (ERROR: closed too many blocks)");
                } else {
                    if indent == 0 && c != code.insts.len {
                        @fmt(out, "        (ERROR: closed all blocks but there is still code)");
                    };
                };
                indent = max(indent, 0);
            };
            
            @fmt(out, "\n  %", f_rep("    ", indent));
            if indent == 0 && c != code.insts.len {
                @fmt(out, "?");
            };
            
            if @is(inst, .End) {
                @fmt(out, "};");
                continue();
            };
            
            ::enum(@type encoding.kind);
            if encoding.kind != .other {
                k_name := @const_slice("I32", "I64", "F32", "F64", "???");
                k := min(k_name.len - 1, zext(@as(i32)encoding.cls));
                @fmt(out, "%_%(", k_name[k], encoding.op);
                if @is(encoding.kind, .load, .store) {
                    @fmt(out, "// TODO: imm");
                };
                @fmt(out, ");");
                continue();
            };
            
            push_leb :: fn() => {
                value, r, ok := read_leb128_unsigned(code.insts.items().rest(c));
                if ok {
                    c += ptr_diff(code.insts.ptr.offset(c), r.ptr);
                    @fmt(out, "%", value);
                    @as(i64) value.bitcast()
                } else {
                    @fmt(out, " ERROR: invalid leb encoding");
                    continue()
                }
            };
            
            if @is(inst, .Block, .Loop, .If) {
                indent += 1;
                @fmt(out, "% {", inst);
                continue();
            };
            
            @fmt(out, "%(", inst);
            if @is(inst, .LocalGet, .LocalSet, .LocalTee, .GlobalGet, .GlobalSet, .I32_Const, .I64_Const) {
                push_leb();
                @fmt(out, ");");
                continue()
            };
            
            if inst == .Call {
                v := push_leb();
                @fmt(out, "); ");
                if v < w.imported_function_count {
                    @fmt(out, "  // import");
                } else {
                    @fmt(out, "  // F%", v - w.imported_function_count);
                };
                continue()
            };
            @fmt(out, ");");
            
        };
        @fmt(out, "\n");
    };
    @fmt(out, "=== END FUNCTION/CODE SECTION ===\n");
    
    print(out.items());
}

fn show_type(out: *List(u8), w: *Wasm.Module, i: TypeIdx) void = {
    i: i64 = i.id.zext();
    @fmt(out, "[T%]: (", i);
    if i >= w.types.len {
        @fmt(out, "ERROR: not enough entries in `type` section)");
        return();
    };
    type := w.types.index(i);
    for(type.arg, fn(t) => @fmt(out, "%,", t));
    @fmt(out, ") -> (");
    for(type.ret, fn(t) => @fmt(out, "%,", t));
    @fmt(out, ")");
}
