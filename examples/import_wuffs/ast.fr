base_module_source :: 
    import("@/lib/sys/fs.fr")'read_entire_file_or_crash(ast_alloc(), "examples/import_wuffs/base.wuffs");

Program :: @struct {
    modules := zeroed RawList(Module);
    codemap: CodeMap;
    names: StringPool;
    literals := zeroed RawList(LiteralValue);
    arena: Alloc;
};

Module :: @rec @struct {
    name: Symbol;
    body := zeroed RawList(TopLevelStmt);
    // TODO: if i start transforming (adding new nodes) while doing infer, 
    //       turn this into a BucketArray for pointer stability. 
    //       careful to deal with splits across buckets correctly because need contiguous slices. 
    nodes := zeroed RawList(Node);
    arena: Alloc;
    program: *Program;
    index: i64;
};

TopLevelStmt :: @tagged(
    DeclareFunc: Function,
    DeclareStruct: @struct {
        fields: []Field;
        init_field_count: i64;
        implements: Node;
    },
    Constant: @struct {
        var: Field;
        value: Node;
        vis: Visibility;
    },
    Use: Symbol,
    DeclareType: @struct {
        name: Symbol;
        value: Node;
    },
);

Function :: @struct {
    body: []Node;
    vars: []Field;
    params: []Field;
    return_type: Node;
    self_type: Symbol;
    name: Symbol;
    has_body: bool;
};

Visibility :: @enum(u8) (Public, Private);

Field :: @struct(name: Symbol, type: Node);
Node :: @struct(id: u32);

Call :: @struct {
    tag := NodeType.Call;
    effect: Effect;
    callee: Node;
    count: u32;
    // [Node]
};

Effect :: @enum(u8) (Pure, Impure, Yielding);

GetVar :: @struct {
    tag := NodeType.GetVar;
    name: Symbol;
};

GetField :: @struct {
    tag := NodeType.GetField;
    name: Symbol;
    place: Node;
};

Op :: @struct {
    tag := NodeType.Op;
    op: TokenType;
    style: Style;
    assign: bool;
    lhs: Node;
    rhs: Node;
    
    Style :: @enum(u8) (Safe, Mod, Sat);
};

Assign :: @struct {
    tag := NodeType.Assign;
    is_choose := false;
    effect: Effect;
    place: Node;
    value: Node;
};

If :: @struct {
    tag := NodeType.If;
    cond: Node;
    then_count: u32;
    else_count: u32;
    // [Node] [Node]
};

While :: @struct {
    tag := NodeType.While;
    cond: Node;
    count: u32;
    // invarients are at the beginning 
    // [Node]
};

Jump :: @struct {
    tag := NodeType.Jump;
    style: Style;
    value: Node;  // Break/Continue has a label (points to the loop node). Yield/Return have a status. 
    Style :: @enum(u8) (Break, Continue, Yield, Return);
};

Literal :: @struct {
    tag := NodeType.Literal;
    index: u32;  // into literal pool
};

LiteralValue :: @tagged(
    Number: i64,
    Status: Symbol,
    Bool: bool,
);

Generic :: @struct {
    tag := NodeType.Generic;
    op: TokenType;
    inner: Node;
    length: Node;
};

Builtin :: @struct {
    tag := NodeType.Builtin;
    op: TokenType;
    call: Node;
    count: u32;
    // [Node]
};

Invarient :: @struct {
    tag := NodeType.Invarient;
    style: TokenType;  // pre, post, inv
    cond: Node;
}

Assert :: @struct {
    tag := NodeType.Assert;
    cond: Node;
    proof: Node;  // this is a call node like `"axiom"(c: value)`
}

Array :: @struct {
    tag := NodeType.Array;
    count: u32;
    // [Node]
}

Index :: @struct {
    tag := NodeType.Index;
    op: TokenType;
    self: Node;
    lo: Node;
    hi: Node;
}

Iterate :: @struct {
    tag := NodeType.Iterate;
    // These are both Builtin(length:advance:unroll:)
    then: Node;
    else: Node;
    // These are Assign nodes for the initial values of the loop variables
    count: u32;
    // [Node]
}

Empty :: @struct(tag := NodeType.Empty);

NodeType :: @enum(u8) (
    Call,
    GetVar,
    GetField,
    Op,
    Assign,
    If,
    While,
    Jump,
    Literal,
    Generic,
    Builtin,
    Invarient,
    Assert,
    Array,
    Index,
    Iterate,
    Empty,
);

// This is not actually stored. It's just for reading the node conveniently. 
NodeFull :: @tagged(
    Call: *Call,
    GetVar: *GetVar,
    GetField: *GetField,
    Op: *Op,
    Assign: *Assign,
    If: *If,
    While: *While,
    Jump: *Jump,
    Literal: *Literal,
    Generic: *Generic,
    Builtin: *Builtin,
    Invarient: *Invarient,
    Assert: *Assert,
    Array: *Array,
    Index: *Index,
    Iterate: *Iterate, 
    Empty: *Empty,
);

fn new_node(self: *Module, $T: Type, node: T) Node #generic = {
    result: Node = (id = self.nodes.len.trunc());
    count :: size_of(T).align_to(size_of(Node)) / size_of(Node);
    // TODO: this puts uninit stack memory in if T is not 4 byte aligned. 
    //       but it shouldn't matter because you don't read it
    values: []Node = bit_cast_unchecked(*T, *Node, node&).slice(count);
    self.nodes&.push_all(values, self.arena);
    result
}

fn new_node(self: *Module, $T: Type, node: T, extra: []Node) Node #generic = {
    node := self.new_node(T, node);
    self.nodes&.push_all(extra, self.arena);
    node
}

fn new_literal(self: *Program, it: LiteralValue) u32 = {
    self.literals&.push(it, self.arena);
    self.literals.len.trunc() - 1
}

fn get(self: *Module, node: Node) NodeFull = {
    p := self.nodes.index(node.id.zext());
    tag := bit_cast_unchecked(*Node, *NodeType, p)[];
    tag := @as(i64) zext(@as(u8) tag);
    it := (tag, p);
    bit_cast_unchecked(Ty(i64, *Node), NodeFull, it)
}

fn get_body(self: *Module, node: Node) []Node = {
    data := self.get(node);
    count := @match(data) {
        fn If(it) => it.then_count + it.else_count;
        fn While(it)   => it.count;
        fn Builtin(it) => it.count;
        fn Array(it)   => it.count;
        fn Iterate(it) => it.count;
        fn Call(it)    => it.count;
        @default => return(empty());
    };
    
    // TODO: this is stupid HACK. it needs to be less painful to get an array of the sizes of Deref(payload)
    //       [size_of(Deref(T)).align_to(size_of(Node)) / size_of(Node) for T in cases(NodeFull)]
    // keep in sync with new_node
    static_count := @generic_match(data&, fn(it) => size_of(@type it[][]).align_to(size_of(Node)) / size_of(Node));
    
    self.nodes.items().subslice(node.id.zext() + static_count, count.zext())
}

fn init(a: Alloc) Program = 
    (names = init(a), arena = a, codemap = init(a));

fn new_module(program: *Program, name: Str) i64 = {
    module: Module = (
        name = program.names&.insert_owned(name), 
        arena = program.arena, program = program,
        index = program.modules.len,
    );
    module&.new_node(Empty, ());
    program.modules&.push(module, program.arena);
    program.modules.len - 1
}

fn get(self: *Module, it: Symbol) Str =
    self.program.names&.get(it);

// TODO: put these in @/lib
#use("@/compiler/pool.fr");
#use("@/compiler/codemap.fr");
