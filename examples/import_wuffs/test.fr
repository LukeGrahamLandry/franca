// #foreign("wuffs"); 

driver :: fn(vtable: *ImportVTable) void = {
    parse_test();
    w :: {
        fr := current_compiler_context();
        bytes := hello_test(fr.vtable, ast_alloc());
        
        import("@/lib/sys/fs.fr")'
            write_entire_file_or_crash("target/hello_w.frc", bytes);  // TODO: don't hardcode this path!
        result := fr'vtable'import_frc(fr.data, bytes);
        or result { err |
            fr.report_error(err)
        }
    };
    w;
    
    c :: import("@/examples/import_c/ffi.fr")'include(hello_c);
    c;
    
    c'main();
    
    number: CStr = "123";
    
    p := ptr_cast_unchecked(u8, i8, number.ptr);
    @assert_eq(c'parse(p, 4), 123);
    
    parser := zeroed w.wuffs_demo__parser;
    buf := c'wuffs_base__ptr_u8__reader(number.ptr, 4, 1);
    
    // TODO: need to export real function signetures not just abi ones. 
    status := w'wuffs_demo__parser__parse(
        bit_cast_unchecked(@type parser&, i64, parser&),
        bit_cast_unchecked(@type buf&, i64, buf&),
    );
    @assert(status == 0);
    value := w'wuffs_demo__parser__value(
        bit_cast_unchecked(@type parser&, i64, parser&),
    );
    @assert_eq(value, 123);
}

main :: fn() void = {
    vtable := ImportVTable.zeroed();
    import("@/compiler/ast_external.fr")'fill_backend_vtable(vtable&);
    driver(vtable&);
}

parse_test :: fn() void = {
    root := import("@/examples/import_c/test/wuffs.fr")'root();
    dirs := collect_directory_ordered(@tfmt("%/std", root), temp(), temp()).unwrap();
    program: Program = init(temp());
    
    for dirs { it |
        continue :: local_return;
        module := program.modules&.index(program&.new_module(it.name));
        path := @tfmt("%/std/%", root, it.name);
        
        // TODO: this would suck a lot less if `collect_directory_ordered` 
        //       would just tell you "hey error because that's not a directory"
        //       because just blindly ignoring errors sounds like a bad plan 
        //       but crashing because there's a file in there (like .DS_Store if you 
        //       happened to open it in apple's shitty finder) is also bad. 
        //       clearly i should reevaluate fuck-it-we-ball-oriented-error-handling
        @if(!dir_exists(path)) continue();
        files := collect_directory_ordered(path, temp(), temp())
            || @panic("failed to walk_dir %", path);
        
        for files { jt |
            if jt.name.ends_with(".wuffs") {
                path := @tfmt("%/std/%/%", root, it.name, jt.name);
                src := read_entire_file_or_crash(temp(), path);
                parse_top_level(path, src, module);
            }
        };
        _ := print_module(module);
    };
};

fn print_module(module: *Module) Str = {
    out := u8.list(temp());
    p: Print = (module = module, out = out&);
    each module.body& { it |
        show(p&, it);
    };
    out.items()
}

hello_test :: fn(vtable: *ImportVTable, out_alloc: Alloc) Str = {
    a: ArenaAlloc = init(page_allocator, 10000); 
    program: Program = init(a&.borrow());
    {
        module := program.modules&.index(program&.new_module("base"));
        parse_top_level("base", base_module_source, module);
        _ := print_module(module);
    };
    module := program.modules&.index(program&.new_module("demo"));
    parse_top_level("hello_wuffs", hello_w, module);
    _ := print_module(module);
    bytes := import("@/examples/import_wuffs/emit.fr")'emit_full_program(program&, out_alloc, vtable);
    a&.deinit();
    bytes
}

#use("@/examples/import_wuffs/lex.fr");
#use("@/examples/import_wuffs/ast.fr");
#use("@/examples/import_wuffs/parse.fr");
#use("@/examples/import_wuffs/print.fr");

// https://github.com/google/wuffs/tree/1e2e58cea012ea4c7553f327b63fafe196b0f9e2/hello-wuffs-c
hello_w :: """
// Copyright 2019 The Wuffs Authors.
// SPDX-License-Identifier: Apache-2.0 OR MIT

pri status "#not a digit"
pri status "#too large"

pub struct parser?(
        val : base.u32,
)

pub func parser.parse?(src: base.io_reader) {
    var c : base.u8
    while true {
        c = args.src.read_u8?()
        if c == 0 {
            return ok
        }
        if (c < 0x30) or (0x39 < c) {  // '0' and '9' are ASCII 0x30 and 0x39.
            return "#not a digit"
        }
        // Rebase from ASCII (0x30 ..= 0x39) to the value (0 ..= 9).
        c -= 0x30

        if this.val < 429_496729 {
            this.val = (10 * this.val) + (c as base.u32)
            continue
        } else if (this.val > 429_496729) or (c > 5) {
            return "#too large"
        }
        this.val = (10 * this.val) + (c as base.u32)
    }
}

pub func parser.value() base.u32 {
    return this.val
}
""";

hello_c :: """
// Copyright 2019 The Wuffs Authors.
// SPDX-License-Identifier: Apache-2.0 OR MIT

#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdio.h>
// TODO: don't hardcode this path!
#include <target/hello_w.frc>

// TODO: just include the wuffs header file to get the base module
//       but if i want to call some of those functions from franca, 
//       i need an option to make `static` not mangle the names. 
// ---
typedef struct wuffs_base__slice_u8__struct {
    char *ptr;
    size_t len;
} wuffs_base__slice_u8;

typedef struct wuffs_base__io_buffer_meta__struct {
  size_t wi;
  size_t ri;
  uint64_t pos;
  long closed;
} wuffs_base__io_buffer_meta;

typedef struct wuffs_base__io_buffer__struct {
  wuffs_base__slice_u8 data;
  wuffs_base__io_buffer_meta meta;
  int extra[10];
} wuffs_base__io_buffer;
  
wuffs_base__io_buffer
wuffs_base__ptr_u8__reader(uint8_t* ptr, size_t len, char closed) {
  wuffs_base__io_buffer ret = { 0 };
  ret.data.ptr = ptr;
  ret.data.len = len;
  ret.meta.wi = len;
  ret.meta.ri = 0;
  ret.meta.pos = 0;
  ret.meta.closed = closed;
  return ret;
}
// ---

uint32_t parse(char* p, size_t n) {
  char *status;
  wuffs_demo__parser parser;
  wuffs_base__io_buffer iobuf =
      wuffs_base__ptr_u8__reader((uint8_t*)p, n, 1);

  status = wuffs_demo__parser__initialize(&parser, sizeof__wuffs_demo__parser(), 0, 0);
  
  if (status == 0) {
    status = wuffs_demo__parser__parse(&parser, &iobuf);
  }
  if (status != 0) {
    printf("parse: %s\n", status);
    return 0;
  }

  return wuffs_demo__parser__value(&parser);
}

void run(char* p) {
  size_t n = strlen(p) + 1;  // +1 for the trailing NUL that ends a C string.
  uint32_t i = parse(p, n);
  printf("%" PRIu32 "\n", i);
}

int main() {
  run("0");
  run("12");
  run("56789");
  run("4294967295");
  run("4294967296");
  run("123456789012");
  return 0;
}
""";
