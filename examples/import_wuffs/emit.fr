
emit_full_program :: fn(program: *Program, out_alloc: Alloc, vtable: *ImportVTable) []u8 = {
    m := zeroed Qbe.Module;
    init_default_module_dyn(m&, vtable, (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .CachedEarly,
    ));
    //m&.set_debug_types("Pd", true);
    
    each program.modules { module |
        emit_early(module, m&, vtable);
    };
    
    writer := m.save.unwrap();
    // TODO: making everyone remember to do this is kinda lame
    range(0, Qbe.Incremental.FTy.COUNT) { _ |
        writer.fty&.push(zeroed Qbe.Incremental.FTy);   // skip builtin types so offsets work out
    };
    
    decls := Qbe.Incremental.Fld.list(temp());
    each program.modules { module |
        emit_late(module, m&, vtable, decls&);
    };
    root_scope := save_fields(writer, .Scope, decls.items());
    
    // TODO: i'd rather not have any imports. could do the same trick for memset as for builtin_memmove. 
    //       alternativly make managing imports less painful so you could easily replace with your own memset, 
    //       or go all the way to providing my libc implementations as a .frc
    {
        // Qbe'backend'writer_finish_imports(writer, m&);  // TODO: why doesn't this do the same thing? 
        set_library(m&, m&.intern("memset"), "libc", false);
        
        // sanity check that invalid code didn't trick me into importing something from libc somehow. 
        // TODO: this will have to change when i want to use stuff written in c from the base module 
        count := 0;
        each writer.sym { it |
            count += int(@is(it.segment, .Import, .MachineCode));
        };
        @assert_eq(count, 1); // memset
    };
    
    meta: Qbe.Incremental.Meta = (arch_os = 0x0F0F, root_scope = root_scope);
    b := writer.to_bytes(meta, m&);
    b := concat(b, out_alloc);
    vtable'drop_qbe_module(Qbe.QbeModule.raw_from_ptr(m&));
    b
}

fn emit_early(module: *Module, m: *Qbe.Module, vtable: *ImportVTable) void = {
    each module.body { stmt |
        @match(stmt) {
            fn Function(it) => {
                name := @tfmt("wuffs_%__%__%", module.get(module.name), module.get(it.self_type), module.get(it.name));
                it.mangled = m.intern(name);
            };
            fn Constant(it) => {
                name := @tfmt("wuffs_%__%", module.get(module.name), module.get(it.var.name));
                it.mangled = m.intern(name);
            }
            fn DeclareStruct(it) => {
                for it.fields { field |
                    it.field_offset_bytes += module.size_of(module.eval_type(field.type)).align_to(8);
                }
            }
            @default => ();
        }
    };
    module.public_ready = 1;
}

fn emit_late(module: *Module, m: *Qbe.Module, vtable: *ImportVTable, decls: *List(Qbe.Incremental.Fld)) void = {
    @debug_assert_eq(module.public_ready, 1);
    each module.body { stmt |
        @match(stmt) {
            fn Function(it) => if it.has_body {
                f := emit(module, m, it);
                finish_func(f, vtable, decls);
            };
            fn Constant(it) => {
                ty := module.eval_type(it.var.type);
                ::tagged_derive(TypeData);  // HACK: @rec
                @assert(ty.is(.Status), "TODO: non-status constant");
                // status is just a string
                data := module.get(it.var.name);  // TODO: get from the literal instead
                m.Qbe'backend'emit_data(
                    export = true,
                    id = it.mangled,
                    template = (Bytes = data),
                    relocations = empty(),
                );
            }
            @default => ();
        }
    };
    // seperate loop so we know layout for var fields is done. 
    each module.body { stmt |
        @match(stmt) {
            fn DeclareStruct(it) => {
                it.field_offset_bytes = it.field_offset_bytes.align_to(8);  // for good luck
                // TODO: don't do these for things in the base module. probably just want to import those from c. 
                decls.push(export_struct(m, it));
                emit_sizeof_func(m, it).finish_func(vtable, decls);
                emit_init_func(m, it).finish_func(vtable, decls);
            }
            @default => ();
        }
    };
}

fn export_struct(m: *Qbe.Module, s: *Struct) Qbe.Incremental.Fld = {
    writer := m.save.unwrap();
    module := s.module;
    name := @tfmt("wuffs_%__%", module.get(module.name), module.get(s.name));

    // TODO: field names (but it's meh because they're private anyway)
    //       for now, just make it an array of the right size
    writer.fty&.push(
        tag = .Array,
        payload = (array = (
            inner = (off = Qbe.Incremental.FTy.I64), 
            count = trunc(s.field_offset_bytes / 8),
        )),
    );
    id := writer.fty.len - 1;
    
    id := save_fields(writer, .Struct, @slice(
        @as(Qbe.Incremental.Fld) (
            name = writer.push("repr"),
            type = (off = id.trunc()),
        ),
    ));
    
    (
        name = writer.push(name),
        type = (off = Qbe.Incremental.FTy.TYPE),
        payload = (type = id),
    )
}

fn emit_sizeof_func(m: *Qbe.Module, s: *Struct) *Qbe.Fn = {
    f := temp().box_uninit(Qbe.Fn);
    b := temp().box_zeroed(Qbe.Blk);
    default_init(f, m);
    f.lnk.id = m.intern(@tfmt("sizeof__wuffs_%__%", s.module.get(s.module.name), s.module.get(s.name)));
    f.lnk.export = true;
    f.start = b;
    f.nblk = 1;
    f.ret_cls = .Kl;
    b.jmp = (type = .retl, arg = f.getcon(s.field_offset_bytes));
    f
}

fn emit_init_func(m: *Qbe.Module, s: *Struct) *Qbe.Fn = {
    f := temp().box_uninit(Qbe.Fn);
    b := temp().box_zeroed(Qbe.Blk);
    default_init(f, m);
    f.lnk.id = m.intern(@tfmt("wuffs_%__%__initialize", s.module.get(s.module.name), s.module.get(s.name)));
    f.lnk.export = true;
    f.start = b;
    f.nblk = 1;
    r, size, version, options := (f.newtmp("this", .Kl), f.newtmp("", .Kl), f.newtmp("", .Kl), f.newtmp("", .Kw));
    push(b, .par, .Kl, r, Qbe.Null, Qbe.Null);
    push(b, .par, .Kl, size, Qbe.Null, Qbe.Null);
    push(b, .par, .Kl, version, Qbe.Null, Qbe.Null);
    push(b, .par, .Kl, options, Qbe.Null, Qbe.Null);
    // TODO: check size+version and return error
    push(b, .arg, .Kl, Qbe.Null, r, Qbe.Null);
    push(b, .arg, .Kl, Qbe.Null, f.getcon(0), Qbe.Null);
    push(b, .arg, .Kl, Qbe.Null, f.getcon(s.field_offset_bytes), Qbe.Null);
    push(b, .call, .Kl, Qbe.Null, f.symcon(m.intern("memset")), Qbe.Null);
    f.ret_cls = .Kl;
    b.jmp = (type = .retl, arg = f.getcon(0));  // return ok status
    f
}

fn finish_func(f: *Qbe.Fn, vtable: *ImportVTable, decls: *List(Qbe.Incremental.Fld)) void = {
    m := f.globals;
    writer := m.save.unwrap();
    decls.push(
        name = writer.push(m.str(f.lnk.id)),
        type = abi_function_type(writer, f),
        payload = (offset = trunc writer.map_sym(m, f.lnk.id))
    );
    
    vtable'run_qbe_passes(Qbe.Fn.raw_from_ptr(f));
}

Emit :: @struct {
    m: *Qbe.Module;
    module: *Module;
    f: *Qbe.Fn;
    b: *Qbe.Blk;
    vars: HashMap(Symbol, Value);
    args: HashMap(Symbol, Value);
    self_type: *Struct;
    this := Qbe.Null;
    yield_state := Qbe.Null;
    yield_points: List(*Qbe.Blk);
    todo_type: Typ;
    void_value: Value;
    loops: List(Loop);
}

Value :: Ty(Qbe.Ref, Typ);
fn is_a(r: Qbe.Ref, type: Typ) Value = (r, type);

Loop :: @struct(node: Node, break: *Qbe.Blk, continue: *Qbe.Blk);

fn emit(module: *Module, m: *Qbe.Module, func: *Function) *Qbe.Fn = {
    self_type := module.find_type(func.self_type);
    e: Emit = (
        m = m, module = module,
        f = temp().box_uninit(Qbe.Fn),
        b = temp().box_zeroed(Qbe.Blk),
        vars = init(temp()),
        args = init(temp()),
        self_type = self_type.expect("func to have receiver in current module"),
        yield_points = list(temp()),
        todo_type = zeroed Typ,
        void_value = zeroed Value,
        loops = list(temp()),
    );
    default_init(e.f, m);
    e.f.start = e.b;
    e.f.lnk.id = func.mangled;
    // TODO: this doesn't do much but it probably should. 
    //       like it could prevent it going in root_scope but then i need 
    //       to put type info for symbols elsewhere because franca frontend needs it for shims. 
    //       it would make sense to replace root_scope with symbols_scope (which has all, but 
    //       maybe just enough types for shim abi) and exports_scope (which is a subset, but with full type info). 
    e.f.lnk.export = func.vis == .Public;  
    e.f.nblk = 1;
    
    e.this = e.f.newtmp("this", .Kl);
    this_type := e.module.new_type(Struct = e.self_type);
    e.vars&.insert(module.program.names&.insert_owned("this")/*:SLOW*/, e.this.is_a(this_type));
    push(e.b, .par, .Kl, e.this, Qbe.Null, Qbe.Null);
    
    for func.params { it |
        r := e.f.newtmp(module.get(it.name), .Kl);
        e.args&.insert(it.name, r.is_a(e&.eval(it.type)));
        // TODO: parc for slices
        push(e.b, .par, .Kl, r, Qbe.Null, Qbe.Null);
    };
    
    off := e.self_type.field_offset_bytes&;
    // For now, locals are always just a field of the reciever struct (so the coroutine can yield). 
    // TODO: simple improvement would be to only save things that are actually held across a yield point. 
    for func.vars { it |
        r := e.f.newtmp(module.get(it.name), .Kl);
        e.vars&.insert(it.name, r.is_a(e&.eval(it.type)));
        push(e.b, .add, .Kl, r, e.this, e.f.getcon(off[]));
        off[] += 8; // TODO: need to know types for size
    };
    
    e.yield_state = e.f.newtmp("yield_state", .Kl);
    push(e.b, .add, .Kl, e.yield_state, e.this, e.f.getcon(off[]));
    off[] += 4;
    entry_state := e.f.newtmp("entry_state", .Kl);
    push(e.b, .loaduw, .Kl, entry_state, e.yield_state, Qbe.Null);
    push(e.yield_points&, e&.new_block());
    
    for func.body { it |
        e&.emit(it);
    };
    // TODO: fallthrough in void functions should just be a normal return (and reset state)
    e.b.jmp.type = .hlt;  
    
    s := e.f.new_switch(e.yield_points.len, e.f.start, entry_state, e&.new_block());
    s := e.f.switches&[s]&;
    e.b.jmp.type = .hlt;  // invalid yield_state. TODO: return an error status?
    
    for e.yield_points& { it |
        s.cases&.push(s.case_count&, (it, it.id.intcast() - 1));
        // TODO: start block needs to dispatch based on entry_state
    };
    
    e.f
}

fn emit(e: *Emit, node: Node) Value = {
@match(e.module.get(node)) {
    fn Call(it) => {
        // TODO: make sure these are in order by label
        args := Qbe.Ref.list(temp());
        receiver: ?Typ = .None;
        for e.module.get_body(node) { it |
            r, ty := e.emit(it);
            args&.push(r);
            if receiver.is_none() {
                receiver = (Some = ty);
            }
        };
        
        receiver := receiver.expect("call have parameters");
        
        if receiver.is(.Slice) && it.callee == e.module.program.names&.insert_owned("length")/*:SLOW*/ {
            r := e.f.newtmp("length", .Kl);
            push(e.b, .add, .Kl, r, args[0], e.f.getcon(8));
            push(e.b, .load, .Kl, r, r, Qbe.Null);
            return r.is_a(e.todo_type);
        }
        
        callee := find_method(receiver, it.callee)
            .expect("method to exist");
        
        for args { it |
            // TODO: need to know types for argc
            push(e.b, .arg, .Kl, Qbe.Null, it, Qbe.Null);
        };
        
        r := e.f.newtmp("", .Kl);
        callee := e.f.symcon(callee.mangled);
        push(e.b, .call, .Kl, r, callee, Qbe.Null);
        
        // TODO: if it's yielding, yield if the result status is nonnull. 
        //       i guess i need to special case things that return multiple things like readers. 
        //       store a state variable when you yield and wrap the whole function in a switch on that state. 
        r.is_a(e.todo_type)
    }
    fn Op(it) => {
        lhs, l_ty := e.emit(it.lhs);
        if it.op == .as {
            return lhs.is_a(e.eval(it.rhs));  // TODO: cast
        }
        // TODO: are and/or short-circuiting? i think subexpressions can't be effectful so it doesn't matter. 
        rhs, r_ty := e.emit(it.rhs);
        
        op: Qbe.O = @match(it.op) {
            fn @"+"() => .add;
            fn @"-"() => .sub;
            fn @"*"() => .mul;
            fn @"=="() => .ceql;
            fn @"<"() => .cultl;
            fn @">"() => .cugtl;
            fn or() => .or;
            @default => @panic("TODO: op %", it.op);
        };
        
        r := e.f.newtmp("", .Kl);
        push(e.b, op, .Kl, r, lhs, rhs);
        r.is_a(e.todo_type)
    }
    fn Assign(it) => {
        // TODO: if the place is in args., need to use .copy, it's just a value. 
        //       but if it's big (like a slice) it needs to be a blit instead. 
        value, v_ty := e.emit(it.value);
        place, p_ty := e.emit_addr(it.place);
        
        // TODO: need to produce types all the time
        //size := e.module.size_of(v_ty);
        //@assert(size <= 8, "TODO: large assign as blit");
        
        op := Qbe.O.storel; // TODO: need to know the types to use the right size
        push(e.b, op, .Kw, Qbe.Null, value, place);
        e.void_value
    }
    fn If(it) => {
        cond, cond_ty := e.emit(it.cond);
        cond_block := e.b;
        
        body := e.module.get_body(node);
        cond_block.s1 = e.emit_body(body.slice(0, it.then_count.zext()));
        end_then_block := e.b;
        
        cond_block.s2 = e.emit_body(body.rest(it.then_count.zext()));
        end_else_block := e.b;
        
        cond_block.jmp = (type = .jnz, arg = cond);
        after := e.new_block();
        end_else_block.jmp.type = .jmp; end_else_block.s1 = after;
        end_then_block.jmp.type = .jmp; end_then_block.s1 = after;
        
        e.void_value
    }
    fn While(it) => {
        // TODO: keep the loop's label and use it in the ir for debugging
        old := e.b;
        start_cond := e.new_block();
        old.jmp.type = .jmp; old.s1 = start_cond;

        cond, cond_ty := e.emit(it.cond);
        @assert_eq(e.b.jmp.type, .Jxxx);
        end_cond := e.b;
        break := e.new_block();
        e.b = end_cond;  // bleh. just to make the link chain work out. should just be a normal list
        
        push(e.loops&, (node = node, break = break, continue = start_cond));
        start_body := e.emit_body(e.module.get_body(node));
        e.b.jmp.type = .jmp; e.b.s1 = start_cond;
        
        end_cond.s1 = start_body;
        end_cond.s2 = break;
        end_cond.jmp = (type = .jnz, arg = cond);
        e.b.link = break;  // bleh
        e.b = break;
        
        e.void_value
    }
    fn Jump(it) => {
        @match(it.style) {
            fn Return() => {
                // TODO: need to know types. and it might be big like a slice
                value, ty := e.emit(it.value);
                // reset yield_state to the entry block
                push(e.b, .storew, .Kw, Qbe.Null, e.f.getcon(0), e.yield_state);
                e.b.jmp = (type = .retl, arg = value);
                e.f.ret_cls = .Kl;
                e.new_block();
            }
            fn Yield() => {
                status, ty := e.emit(it.value);
                
                // save where the start block should dispatch to next
                state: i64 = e.f.nblk.intcast() - 1;
                push(e.b, .storew, .Kw, Qbe.Null, e.f.getcon(state), e.yield_state);
                
                e.b.jmp = (type = .retl, arg = status);
                push(e.yield_points&, e.new_block());
            }
            @default => {
                ::@assert_eq(Jump.Style.enum_count(), 4, "TODO: added new jump");
                each_rev e.loops { check |
                    if check.node.id == it.value.id {
                        e.b.jmp.type = .jmp;
                        e.b.s1 = @if(it.style == .Break, check.break, check.continue);
                        e.new_block();
                        return e.void_value;
                    }
                };
                @panic("missing jump target")
            };
        };
        e.void_value
    }
    fn Literal(it) => {
        it := e.module.program.literals.index(it.index.zext());
        @match(it) {
            fn Number(it) => e.f.getcon(it[]).is_a(e.todo_type);
            fn Bool(it) => e.f.getcon(it[].int()).is_a(e.todo_type);
            fn Status(it) => 
                @panic("status const. unreachable because status strings are treated as a var identifier");
            fn Type() => @panic("invalid literal (expected value found type)");
        }
    }
    fn Builtin() => {
        @println("XXX");
        // TODO
        e.void_value
    }
    fn Iterate() => {
        @println("XXX");
        // TODO
        e.void_value
    }
    fn GetVar()   => e.deref(node);
    fn GetField() => e.deref(node);
    fn Index()    => e.deref(node);
    fn Array(it) => @panic("TODO: are you allowed a local array literal or is that just for constants?");
    fn Generic() => @panic("Shouldn't have a type in an expression");
    // assert and invarient are for checking but are a nop at runtime. 
    fn Invarient() => e.void_value;
    fn Assert(it)  => e.void_value;
    fn Empty()     => e.void_value;
}}

fn deref(e: *Emit, node: Node) Value = {
    place, ty := e.emit_addr(node);
    if place == Qbe.Null {
        @match(e.module.get(node)) {
            fn GetVar(it) => {
                each e.module.body& { check |
                    @if_let(check) fn Constant(check) => {
                        if it.name == check.var.name {
                            // return the value without dereferencing. 
                            // TODO: need to know types. if it's an int just return the value not an address 
                            // TODO: return a symcon. need to emit in the top level loop. 
                            // statuses are just the address of a string (matching wuffs-c abi)
                            // (i think even wasm abi treats single field struct the same as it's one type)
                            return e.f.symcon(check.mangled).is_a(e.eval(check.var.type));
                        }
                    }
                };
                @panic("Undeclared var: %", e.module.get(it.name))
            }
            @default => @panic("failed to emit_addr");
        };
    }

    size := e.module.size_of(ty);
    op: Qbe.O = @switch(size) {
        @case(1) => .loadub;
        @case(2) => .loaduh;
        @case(4) => .loaduw;
        @case(8) => .load;
        // large things are just represented as a pointer. 
        @default => return(place.is_a(ty));
    }
    r := e.f.newtmp("", .Kl);
    push(e.b, op, .Kl, r, place, Qbe.Null);
    r.is_a(ty)
}

// This returns a pointer but the type is the deref of it. 
fn emit_addr(e: *Emit, node: Node) Value = {
@match(e.module.get(node)) {
    fn GetVar(it) => {
        if it.is_arg {
            return e.args&.get(it.name) || @panic("Undeclared arg: %", e.module.get(it.name));
        };
        e.vars&.get(it.name) || e.void_value
    }
    fn GetField(it) => {
        lhs, ty := e.emit_addr(it.place);
        // TODO: assert ty is a struct and find the type of this field
        
        @assert(ty.is(.Struct), "tried to access field of non-struct");
        field_type, field_offset := e.module.find_field(ty.Struct, it.name) 
            || @panic("invalid field %", e.module.get(it.name));
        
        r := e.f.newtmp(e.module.get(it.name), .Kl);
        push(e.b, .add, .Kl, r, lhs, e.f.getcon(field_offset));
        r.is_a(field_type)
    }
    fn Index(it) => {
        lhs, l_ty := e.emit(it.self);
        idx, i_ty := e.emit(it.lo);
        
        child := @match(l_ty) {
            fn Slice(it) => {
                // .ptr is the first field, load it. 
                r := e.f.newtmp("", .Kl);
                push(e.b, .load, .Kl, r, lhs, Qbe.Null);
                lhs = r;
                
                it.child
            }
            fn Array(it) => it.child;
            @default => @panic("invalid type for index expression");
        };
        step := e.module.size_of(child);
        
        // TODO: asserty i_ty is an integer
        
        r := e.f.newtmp("", .Kl);
        push(e.b, .mul, .Kl, r, idx, e.f.getcon(step));
        push(e.b, .add, .Kl, r, lhs, r);
        r.is_a(child)
    }
    @default => @panic("invalid place expression");
}}

fn emit_body(e: *Emit, body: []Node) *Qbe.Blk = {
    b := e.new_block();
    for body { it |
        e.emit(it);
    };
    @assert_eq(e.b.jmp.type, .Jxxx);
    b
}

fn new_block(e: *Emit) *Qbe.Blk = {
    prev := e.b;
    e.b = temp().box_zeroed(Qbe.Blk);
    prev.link = e.b;
    e.b.id = e.f.nblk;
    e.f.nblk += 1;
    e.b
}

fn eval(e: *Emit, node: Node) Typ = eval_type(e.module, node);

fn eval_type(module: *Module, node: Node) Typ = {
    // TODO: maybe this should cache it and convert the node to a Literal.Type = Typ? 
@match(module.get(node)) {
    fn Literal(it) => {
        it := module.program.literals.index(it.index.zext());
        @match(it) {
            fn Type(it) => it[];
            @default => @panic("TODO: invalid type literal");
        }
    }
    fn GetVar(it)   => {
        // TODO: look it up in the current module
        println("A");
        zeroed Typ
    }
    fn GetField(it) => {
        name := it.name;
        module_name := {
            parent := module.get(it.place);
            @assert(parent&.is(.GetVar), "TODO: complex expression in type access (expected module name)");
            parent.GetVar.name
        };
        @assert_eq(module.get(module_name), "base", "TODO: find it in use statements");
        parent := module.program.modules.items().find(fn(it) => it.name == module_name)
            .expect("module to exist");
        
        ::?*Struct;
        // TODO: don't be dumb as rocks
        // TODO: don't allocate a new thing every time you reference a type!
        @switch(module.get(name)) {
            @case("u8") => module.new_type(Int = (bits = 8));
            @case("u32") => module.new_type(Int = (bits = 32));
            @case("u64") => module.new_type(Int = (bits = 64));
            @case("bool") => module.new_type(Int = (bits = 8));
            @case("io_reader") => module.new_type(Struct = parent.find_type(name).unwrap());
            @default => @panic("TODO: support more type names: %.%", module.get(module_name), module.get(name));
        }
    }
    fn Generic(it) => {
        @match(it.op) {
            fn slice() => module.new_type(Slice = (child = module.eval_type(it.inner), mut = true));
            @default => @panic("TODO: eval generic %", it.op);
        }
    }
    fn Empty() => {
        // TODO
        zeroed Typ
    }
    @default => @panic("TODO: invalid type expression");
}
}

Qbe :: import("@/backend/lib.fr").Qbe;
#use("@/examples/import_wuffs/ast.fr");
