
emit_full_program :: fn(program: *Program, out_alloc: Alloc, vtable: *ImportVTable) []u8 = {
    m := zeroed Qbe.Module;
    init_default_module_dyn(m&, vtable, (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .CachedEarly,
    ));
    //m&.set_debug_types("Pd", true);
    
    each program.modules { module |
        emit_early(module, m&, vtable);
    };
    
    writer := m.save.unwrap();
    // TODO: making everyone remember to do this is kinda lame
    range(0, Qbe.Incremental.FTy.COUNT) { _ |
        writer.fty&.push(zeroed Qbe.Incremental.FTy);   // skip builtin types so offsets work out
    };
    
    decls := Qbe.Incremental.Fld.list(temp());
    each program.modules { module |
        emit_late(module, m&, vtable, decls&);
    };
    
    s := save_fields(writer, .Scope, decls.items());
    meta: Qbe.Incremental.Meta = (arch_os = 0x0F0F, root_scope = s);
    b := writer.to_bytes(meta, m&);
    b := concat(b, out_alloc);
    vtable'drop_qbe_module(Qbe.QbeModule.raw_from_ptr(m&));
    b
}

fn emit_early(module: *Module, m: *Qbe.Module, vtable: *ImportVTable) void = {
    each module.body { stmt |
        @match(stmt) {
            fn Function(it) => {
                name := @tfmt("%__%__%", module.get(module.name), module.get(it.self_type), module.get(it.name));
                it.mangled = m.intern(name);
            };
            fn Constant(it) => {
                name := @tfmt("%__%", module.get(module.name), module.get(it.var.name));
                it.mangled = m.intern(name);
            }
            fn DeclareStruct(it) => {
                for it.fields { field |
                    it.field_offset_bytes += module.size_of(module.eval_type(field.type)).align_to(8);
                }
            }
            @default => ();
        }
    };
    module.public_ready = 1;
}

fn emit_late(module: *Module, m: *Qbe.Module, vtable: *ImportVTable, decls: *List(Qbe.Incremental.Fld)) void = {
    @debug_assert_eq(module.public_ready, 1);
    writer := m.save.unwrap();
    each module.body { stmt |
        @match(stmt) {
            fn Function(it) => if it.has_body {
                f := emit(module, m, it);
                
                decls.push(
                    name = writer.push(m.str(f.lnk.id)),
                    type = abi_function_type(writer, f),
                    payload = (offset = trunc writer.map_sym(m, f.lnk.id))
                );
                
                vtable'run_qbe_passes(Qbe.Fn.raw_from_ptr(f));
            };
            fn Constant(it) => {
                ty := module.eval_type(it.var.type);
                ::tagged(@type ty[]);
                @assert(ty.is(.Status), "TODO: non-status constant");
                // status is just a string
                data := module.get(it.var.name);  // TODO: get from the literal instead
                m.Qbe'backend'emit_data(
                    export = true,
                    id = it.mangled,
                    template = (Bytes = data),
                    relocations = empty(),
                );
            }
            @default => ();
        }
    };
    // TODO: emit frc types for structs but they have to be after all functions are done so you know the size
    //       or could do that layout in emit_early instead
}

Emit :: @struct {
    m: *Qbe.Module;
    module: *Module;
    f: *Qbe.Fn;
    b: *Qbe.Blk;
    vars: HashMap(Symbol, Value);
    args: HashMap(Symbol, Value);
    self_type: *Struct;
    this := Qbe.Null;
    yield_state := Qbe.Null;
    yield_points: List(*Qbe.Blk);
    todo_type: Typ;
    void_value: Value;
    loops: List(Loop);
}

Value :: Ty(Qbe.Ref, Typ);
fn is_a(r: Qbe.Ref, type: Typ) Value = (r, type);

Loop :: @struct(node: Node, break: *Qbe.Blk, continue: *Qbe.Blk);

fn emit(module: *Module, m: *Qbe.Module, func: *Function) *Qbe.Fn = {
    self_type := module.find_type(func.self_type);
    e: Emit = (
        m = m, module = module,
        f = temp().box(Qbe.Fn),
        b = temp().box_zeroed(Qbe.Blk),
        vars = init(temp()),
        args = init(temp()),
        self_type = self_type.expect("func to have receiver in current module"),
        yield_points = list(temp()),
        todo_type = zeroed Typ,
        void_value = zeroed Value,
        loops = list(temp()),
    );
    default_init(e.f, m);
    e.f.start = e.b;
    e.f.lnk.id = func.mangled;
    e.f.nblk = 1;
    
    e.this = e.f.newtmp("this", .Kl);
    this_type := e.module.new_type(Struct = e.self_type);
    e.vars&.insert(module.program.names&.insert_owned("this")/*:SLOW*/, e.this.is_a(this_type));
    push(e.b, .par, .Kl, e.this, Qbe.Null, Qbe.Null);
    
    for func.params { it |
        r := e.f.newtmp(module.get(it.name), .Kl);
        e.args&.insert(it.name, r.is_a(e&.eval(it.type)));
        // TODO: parc when it's a struct
        push(e.b, .par, .Kl, r, Qbe.Null, Qbe.Null);
    };
    
    //// This is lazy. make stack slots for small arguments (since they're mutable)
    //// so Assign and fn deref below don't have to handle small values specially. 
    //// (which would also be an option because i do have mutable vars in the ir)
    //for func.params { it |  
    //    size := 8;  // TODO: need to know types
    //    if size <= 8 {
    //        addr := e.f.newtmp("", .Kl);
    //        value, _ := e.args&.insert(it.name, addr.is_a(e&.eval(it.type))).unwrap();
    //        // TODO: have all allocs at the start before any stores to make sure they get fast-allocs 
    //        //       (i don't remember if the backend reorders for you. it probably should). 
    //        push(e.b, .alloc8, .Kl, addr, e.f.getcon(size), Qbe.Null);
    //        push(e.b, .storel, .Kw, Qbe.Null, value, addr);
    //    }
    //};
    
    off := e.self_type.field_offset_bytes&;
    // For now, locals are always just a field of the reciever struct (so the coroutine can yield). 
    // TODO: simple improvement would be to only save things that are actually held across a yield point. 
    for func.vars { it |
        r := e.f.newtmp(module.get(it.name), .Kl);
        e.vars&.insert(it.name, r.is_a(e&.eval(it.type)));
        push(e.b, .add, .Kl, r, e.this, e.f.getcon(off[]));
        off[] += 8; // TODO: need to know types for size
    };
    
    e.yield_state = e.f.newtmp("yield_state", .Kl);
    push(e.b, .add, .Kl, e.yield_state, e.this, e.f.getcon(off[]));
    off[] += 4;
    entry_state := e.f.newtmp("entry_state", .Kl);
    push(e.b, .loaduw, .Kl, entry_state, e.yield_state, Qbe.Null);
    push(e.yield_points&, e&.new_block());
    
    for func.body { it |
        e&.emit(it);
    };
    // TODO: fallthrough in void functions should just be a normal return (and reset state)
    e.b.jmp.type = .hlt;  
    
    s: Qbe.SwitchPayload = (
        cases = new(e.yield_points.len),
        case_count = 0,
        default = e&.new_block(),
        inspect = entry_state,
        src = e.f.start,
    );
    e.b.jmp.type = .hlt;  // invalid yield_state. TODO: return an error status?
    
    for e.yield_points& { it |
        s.cases&.push(s.case_count&, (it, it.id.intcast() - 1));
        // TODO: start block needs to dispatch based on entry_state
    };
    e.f.start.jmp = (type = .switch, arg = INT(0));
    e.f.switches = new(1);
    e.f.switch_count = 1;
    e.f.switches[0] = s;
    
    e.f
}

fn emit(e: *Emit, node: Node) Value = {
@match(e.module.get(node)) {
    fn Call(it) => {
        // TODO: make sure these are in order by label
        args := Qbe.Ref.list(temp());
        receiver: ?Typ = .None;
        for e.module.get_body(node) { it |
            r, ty := e.emit(it);
            args&.push(r);
            if receiver.is_none() {
                receiver = (Some = ty);
            }
        };
        
        receiver := receiver.expect("call have parameters");
        ::tagged(TypeData);
        
        if receiver.is(.Slice) && it.callee == e.module.program.names&.insert_owned("length")/*:SLOW*/ {
            r := e.f.newtmp("length", .Kl);
            push(e.b, .add, .Kl, r, args[0], e.f.getcon(8));
            push(e.b, .load, .Kl, r, r, Qbe.Null);
            return r.is_a(e.todo_type);
        }
        
        callee := find_method(receiver, it.callee)
            .expect("method to exist");
        
        for args { it |
            // TODO: need to know types for argc
            push(e.b, .arg, .Kl, Qbe.Null, it, Qbe.Null);
        };
        
        r := e.f.newtmp("", .Kl);
        callee := e.f.symcon(callee.mangled);
        push(e.b, .call, .Kl, r, callee, Qbe.Null);
        
        // TODO: if it's yielding, yield if the result status is nonnull. 
        //       i guess i need to special case things that return multiple things like readers. 
        //       store a state variable when you yield and wrap the whole function in a switch on that state. 
        r.is_a(e.todo_type)
    }
    fn Op(it) => {
        lhs, l_ty := e.emit(it.lhs);
        ::enum(@type it.op);
        if it.op == .as {
            return lhs.is_a(e.eval(it.rhs));  // TODO: cast
        }
        // TODO: are and/or short-circuiting? i think subexpressions can't be effectful so it doesn't matter. 
        rhs, r_ty := e.emit(it.rhs);
        
        op: Qbe.O = @match(it.op) {
            fn @"+"() => .add;
            fn @"-"() => .sub;
            fn @"*"() => .mul;
            fn @"=="() => .ceql;
            fn @"<"() => .cultl;
            fn @">"() => .cugtl;
            fn or() => .or;
            @default => @panic("TODO: op %", it.op);
        };
        
        r := e.f.newtmp("", .Kl);
        push(e.b, op, .Kl, r, lhs, rhs);
        r.is_a(e.todo_type)
    }
    fn Assign(it) => {
        value, v_ty := e.emit(it.value);
        place, p_ty := e.emit_addr(it.place);
        op := Qbe.O.storel; // TODO: need to know the types to use the right size
        push(e.b, op, .Kw, Qbe.Null, value, place);
        e.void_value
    }
    fn If(it) => {
        cond, cond_ty := e.emit(it.cond);
        cond_block := e.b;
        
        body := e.module.get_body(node);
        cond_block.s1 = e.emit_body(body.slice(0, it.then_count.zext()));
        end_then_block := e.b;
        
        cond_block.s2 = e.emit_body(body.rest(it.then_count.zext()));
        end_else_block := e.b;
        
        cond_block.jmp = (type = .jnz, arg = cond);
        after := e.new_block();
        end_else_block.jmp.type = .jmp; end_else_block.s1 = after;
        end_then_block.jmp.type = .jmp; end_then_block.s1 = after;
        
        e.void_value
    }
    fn While(it) => {
        // TODO: keep the loop's label and use it in the ir for debugging
        old := e.b;
        start_cond := e.new_block();
        old.jmp.type = .jmp; old.s1 = start_cond;

        cond, cond_ty := e.emit(it.cond);
        ::enum(Qbe.J);
        @assert_eq(e.b.jmp.type, .Jxxx);
        end_cond := e.b;
        break := e.new_block();
        e.b = end_cond;  // bleh. just to make the link chain work out. should just be a normal list
        
        push(e.loops&, (node = node, break = break, continue = start_cond));
        start_body := e.emit_body(e.module.get_body(node));
        e.b.jmp.type = .jmp; e.b.s1 = start_cond;
        
        end_cond.s1 = start_body;
        end_cond.s2 = break;
        end_cond.jmp = (type = .jnz, arg = cond);
        e.b.link = break;  // bleh
        e.b = break;
        
        e.void_value
    }
    fn Jump(it) => {
        ::enum(@type it.style);
        @match(it.style) {
            fn Return() => {
                // TODO: need to know types. and it might be big like a slice
                value, ty := e.emit(it.value);
                // reset yield_state to the entry block
                push(e.b, .storew, .Kw, Qbe.Null, e.f.getcon(0), e.yield_state);
                e.b.jmp = (type = .retl, arg = value);
                e.new_block();
            }
            fn Yield() => {
                status, ty := e.emit(it.value);
                
                // save where the start block should dispatch to next
                state: i64 = e.f.nblk.intcast() - 1;
                push(e.b, .storew, .Kw, Qbe.Null, e.f.getcon(state), e.yield_state);
                
                e.b.jmp = (type = .retl, arg = status);
                push(e.yield_points&, e.new_block());
            }
            @default => {
                ::@assert_eq(Jump.Style.enum_count(), 4, "TODO: added new jump");
                each_rev e.loops { check |
                    if check.node.id == it.value.id {
                        e.b.jmp.type = .jmp;
                        e.b.s1 = @if(it.style == .Break, check.break, check.continue);
                        e.new_block();
                        return e.void_value;
                    }
                };
                @panic("missing jump target")
            };
        };
        e.void_value
    }
    fn Literal(it) => {
        it := e.module.program.literals.index(it.index.zext());
        @match(it) {
            fn Number(it) => e.f.getcon(it[]).is_a(e.todo_type);
            fn Bool(it) => e.f.getcon(it[].int()).is_a(e.todo_type);
            fn Status(it) => 
                @panic("status const. unreachable because status strings are treated as a var identifier");
            fn Type() => @panic("invalid literal (expected value found type)");
        }
    }
    fn Builtin() => {
        @println("XXX");
        // TODO
        e.void_value
    }
    fn Iterate() => {
        @println("XXX");
        // TODO
        e.void_value
    }
    fn GetVar()   => e.deref(node);
    fn GetField() => e.deref(node);
    fn Index()    => e.deref(node);
    fn Array(it) => @panic("TODO: are you allowed a local array literal or is that just for constants?");
    fn Generic() => @panic("Shouldn't have a type in an expression");
    // assert and invarient are for checking but are a nop at runtime. 
    fn Invarient() => e.void_value;
    fn Assert(it)  => e.void_value;
    fn Empty()     => e.void_value;
}}

fn deref(e: *Emit, node: Node) Value = {
    place, ty := e.emit_addr(node);
    if place == Qbe.Null {
        @match(e.module.get(node)) {
            fn GetVar(it) => {
                each e.module.body& { check |
                    @if_let(check) fn Constant(check) => {
                        if it.name == check.var.name {
                            // return the value without dereferencing. 
                            // TODO: need to know types. if it's an int just return the value not an address 
                            // TODO: return a symcon. need to emit in the top level loop. 
                            // statuses are just the address of a string (matching wuffs-c abi)
                            // (i think even wasm abi treats single field struct the same as it's one type)
                            return e.f.symcon(check.mangled).is_a(e.eval(check.var.type));
                        }
                    }
                };
                @panic("Undeclared var: %", e.module.get(it.name))
            }
            @default => @panic("failed to emit_addr");
        };
    }
    
    if !ty.is_null() && e.module.size_of(ty) > 8 {
        return(place.is_a(ty)); // TODO: HACK
    }
    
    // TODO: when passing large thing to a call, just pass the pointer. so don't always load here. 
    // TODO: need to know the types to use the right size
    op := Qbe.O.load; 
    
    if !ty.is_null() && e.module.size_of(ty) == 1 {
        op = .loadub;
    }
    r := e.f.newtmp("", .Kl);
    push(e.b, op, .Kl, r, place, Qbe.Null);
    r.is_a(ty)
}

// This returns a pointer but the type is the deref of it. 
fn emit_addr(e: *Emit, node: Node) Value = {
@match(e.module.get(node)) {
    fn GetVar(it) => {
        if it.is_arg {
            return e.args&.get(it.name) || @panic("Undeclared arg: %", e.module.get(it.name));
        };
        e.vars&.get(it.name) || e.void_value
    }
    fn GetField(it) => {
        lhs, ty := e.emit_addr(it.place);
        // TODO: assert ty is a struct and find the type of this field
        
        ::tagged(@type ty[]);
        @assert(ty.is(.Struct), "tried to access field of non-struct");
        field_type, field_offset := e.module.find_field(ty.Struct, it.name) 
            || @panic("invalid field %", e.module.get(it.name));
        
        r := e.f.newtmp(e.module.get(it.name), .Kl);
        push(e.b, .add, .Kl, r, lhs, e.f.getcon(field_offset));
        r.is_a(field_type)
    }
    fn Index(it) => {
        lhs, l_ty := e.emit(it.self);  // TODO: _addr
        idx, i_ty := e.emit(it.lo);
        
        {  // HACK
            op := Qbe.O.load; 
            r := e.f.newtmp("", .Kl);
            push(e.b, op, .Kl, r, lhs, Qbe.Null);
            lhs = r;
        };
        child := @match(l_ty) {
            fn Slice(it) => it.child;
            fn Array(it) => it.child;
            @default => @panic("invalid type for index expression");
        };
        step := e.module.size_of(child);
        
        // TODO: asserty i_ty is an integer
        
        r := e.f.newtmp("", .Kl);
        push(e.b, .mul, .Kl, r, idx, e.f.getcon(step));
        push(e.b, .add, .Kl, r, lhs, r);
        r.is_a(child)
    }
    @default => @panic("invalid place expression");
}}

fn emit_body(e: *Emit, body: []Node) *Qbe.Blk = {
    b := e.new_block();
    for body { it |
        e.emit(it);
    };
    @assert_eq(e.b.jmp.type, .Jxxx);
    b
}

fn new_block(e: *Emit) *Qbe.Blk = {
    prev := e.b;
    e.b = temp().box_zeroed(Qbe.Blk);
    prev.link = e.b;
    e.b.id = e.f.nblk;
    e.f.nblk += 1;
    e.b
}

fn eval(e: *Emit, node: Node) Typ = eval_type(e.module, node);

fn eval_type(module: *Module, node: Node) Typ = {
    // TODO: maybe this should cache it and convert the node to a Literal.Type = Typ? 
@match(module.get(node)) {
    fn Literal(it) => {
        it := module.program.literals.index(it.index.zext());
        @match(it) {
            fn Type(it) => it[];
            @default => @panic("TODO: invalid type literal");
        }
    }
    fn GetVar(it)   => {
        // TODO: look it up in the current module
        println("A");
        zeroed Typ
    }
    fn GetField(it) => {
        name := it.name;
        module_name := {
            parent := module.get(it.place);
            @assert(parent&.is(.GetVar), "TODO: complex expression in type access (expected module name)");
            parent.GetVar.name
        };
        @assert_eq(module.get(module_name), "base", "TODO: find it in use statements");
        parent := module.program.modules.items().find(fn(it) => it.name == module_name)
            .expect("module to exist");
        
        ::?*Struct;
        // TODO: don't be dumb as rocks
        // TODO: don't allocate a new thing every time you reference a type!
        @switch(module.get(name)) {
            @case("u8") => module.new_type(Int = (bits = 8));
            @case("u32") => module.new_type(Int = (bits = 32));
            @case("u64") => module.new_type(Int = (bits = 64));
            @case("bool") => module.new_type(Int = (bits = 8));
            @case("io_reader") => module.new_type(Struct = parent.find_type(name).unwrap());
            @default => @panic("TODO: support more type names: %.%", module.get(module_name), module.get(name));
        }
    }
    fn Generic(it) => {
        ::enum(@type it.op);
        @match(it.op) {
            fn slice() => module.new_type(Slice = (child = module.eval_type(it.inner), mut = true));
            @default => @panic("TODO: eval generic %", it.op);
        }
    }
    fn Empty() => {
        // TODO
        zeroed Typ
    }
    @default => @panic("TODO: invalid type expression");
}
}

Qbe :: import("@/backend/lib.fr").Qbe;
#use("@/examples/import_wuffs/ast.fr");
