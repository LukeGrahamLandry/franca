// TODO: don't panic on errors

Parser :: @struct {
    lex: Lexer;
    module: *Module;
    program: *Program;
    span: Span;
    previous := zeroed FullToken;
    current := zeroed FullToken;
    loops := zeroed RawList(Loop);
    unnamed_loop: Symbol;
    
    status_type: Node;
    void_type := zeroed Node; // TODO
    builtin_callee := zeroed Node;  // TODO
    empty_node := zeroed Node; // TODO
};

Loop :: @struct(label: Symbol, jump: Node);

fn parse_top_level(file_name: Str, source: Str, module: *Module) void = {
    self: Parser = (
        lex = (src = source), 
        program = module.program, 
        module = module,
        span = module.program.codemap&.add_file(file_name, source),
        status_type = module.new_type_node(.Status),
        unnamed_loop = module.program.names&.insert_owned("?"), // :SLOW
    );
    self := self&;

    ::enum(TokenType);
    self.pop();
    loop {
        stmt := @match(self.pop()) {
            fn use() => {
                name := self.next_name();
                (Use = name)
            }
            fn pub()  => self.top_level_declare(.Public);
            fn pri()  => self.top_level_declare(.Private);
            fn EndOfFile() => return();
            @default => {
                self.error(@tfmt("expected top level statment found %", self.previous.type));
                unreachable()
            };
        };
        self.module.body&.push(stmt, self.module.arena);
    };
}

fn top_level_declare(self: *Parser, vis: Visibility) TopLevelStmt = {
    @match(self.pop()) {
        fn Ident() => {
            name := self.prev_name();
            // :SLOW, can't be a keyword because it's contextual
            if name == self.program.names&.insert_owned("status") {
                name := self.next_name();
                return(Constant = (
                    var = (name = name, type = self.status_type), 
                    value = self.new_node(GetVar, (name = name, is_arg = false)),
                    vis = vis,
                ));
            };
            panic("expected top level expression found Ident")
        }
        fn const() => {
            name := self.next_name();
            self.eat(.@":");
            type := self.type();
            self.eat(.@"=");
            value := self.expr();
            (Constant = (var = (name = name, type = type), value = value, vis = vis))
        }
        fn struct() => {
            name := self.next_name();
            self.eat(.@"?");
            interface := self.empty_node;
            if self.maybe(.implements) {
                interface = self.type();
            };
            self.eat(.@"(");
            vars := Field.list(self.module.arena);
            self.var_list(vars&, false);
            self.eat(.@")");
            init := vars.len;
            if self.maybe(.@"+") {
                self.eat(.@"(");
                self.var_list(vars&, false);
                self.eat(.@")");
            };
            (DeclareStruct = (
                fields = vars.items(), 
                init_field_count = init, 
                implements = interface,
                name = name,
                module = self.module,
            ))
        }
        fn func() => {
            reciever := self.next_name();
            self.eat(.@".");
            name := self.next_name();
            impure := self.maybe(.@"!");  // TOOD
            yielding := self.maybe(.@"?");  // TODO
            @if(impure && yielding) self.error("function is marked '?' and '~'");
            self.eat(.@"(");
            params := Field.list(self.module.arena);
            self.var_list(params&, false);
            self.eat(.@")");
            ret := self.void_type;
            if !@is(self.current.type, .@"{", .@",") {
                ret = self.type();
            }
            if self.maybe(.@",") {
                if self.maybe(.choosy) {
                    self.eat(.@",");
                    // TODO: do something with that information
                    // this is the default one
                }
                if self.maybe(.choose) {
                    cond := self.expr();
                    self.eat(.@",");
                    // TODO: do something with that information
                    // the expression is like which archetecture for simd. 
                }
            }
            vars := Field.list(self.module.arena);
            body := Node.list(self.module.arena);
            has_body := self.maybe(.@"{");
            if has_body {
                self.var_list(vars&, true);
                self.block(body&);
            };
            (Function = (
                name = name,
                body = body.items(),
                vars = vars.items(),
                params = params.items(),
                return_type = ret,
                self_type = reciever,
                has_body = has_body,  // :extension
                vis = vis,
            ))
        }
        fn @"$"() => {  // :extension
            self.eat(.Ident);
            @if(self.previous.payload != "type") self.error("expected $type");
            name := self.next_name();
            value := self.empty_node;
            if self.maybe(.@"=") {
                value = self.type();
            };
            (DeclareType = (name = name, value = value))
        };
        @default => panic("TODO: declare");
    }
}

fn var_list(self: *Parser, out: *List(Field), is_locals: bool) void = {
    loop {
        done := @if(is_locals, !self.maybe(.var), self.current.type != .Ident);
        @if(done) return();
        
        name := self.next_name();
        self.eat(.@":");
        type := self.type();
        out.push(name = name, type = type);
        if !is_locals && !self.maybe(.@",") {
           return();
        };
    }
}

// consumes the closing }
fn block(self: *Parser, nodes: *List(Node)) void = {
    while => !self.maybe(.@"}") {
        nodes.push(self.stmt());
    };
}

fn stmt(self: *Parser) Node = {
    @match(self.current.type) {
        fn if() => {
            self.pop();
            cond := self.expr();
            body := Node.list(temp());
            self.eat(.@"{");
            self.block(body&);
            then: u32 = body.len.trunc();
            if self.maybe(.else) {
                if self.current.type == .if {
                    body&.push(self.stmt());
                } else {
                    self.eat(.@"{");
                    self.block(body&);
                };
            };
            self.new_node(If, (
                cond = cond, 
                then_count = then, 
                else_count = body.len.trunc() - then,
            ), body.items())
        }
        fn return() => {
            self.pop();
            value := self.expr();
            self.new_node(Jump, (style = .Return, value = value))
        }
        fn yield() => {
            self.pop();
            self.eat(.@"?");
            value := self.expr();
            self.new_node(Jump, (style = .Yield, value = value))
        }
        fn continue() => self.loop_flow(.Continue);
        fn break() => self.loop_flow(.Break);
        fn while() => {
            self.pop();
            start_label := self.unnamed_loop;
            if self.maybe(.@".") {
                start_label = self.next_name();
            };
            cond := self.expr();
            body := Node.list(temp());
            if self.maybe(.@",") {
                dowhile {
                    style := self.pop();
                    cond := self.expr();
                    body&.push(self.new_node(Invarient, (cond = cond, style = style)));
                    self.maybe(.@",");
                    self.current.type != .@"{"
                };
            }
            self.eat(.@"{");
            self.block(body&);
            if self.maybe(.@".") {
                end_label := self.next_name();
                @assert_eq(start_label, end_label, "while loop labels must match");
            };
            
            node := self.new_node(While, (
                cond = cond, 
                count = body.len.trunc(),
            ), body.items());
            
            // TODO: im not super happy with needing to track these and patch. feels :SLOW
            //       but the way i represent the ast i can't have the while node until im done parsing the body. 
            //       maybe it would be better to have a Block node that has the trailing stuff 
            //       and use that for if/else/builtin as well? 
            unordered_retain(self.loops&) { it |
                if it.label == start_label {
                    it := self.module.get(it.jump);
                    @assert(it&.is(.Jump));
                    it.Jump.value = node;
                };
                !(it.label == start_label)
            };

            node
        }
        fn assert() => {
            self.pop();
            cond := self.expr();
            proof := self.empty_node;
            if self.maybe(.via) {
                proof = self.expr();
            }
            self.new_node(Assert, (cond = cond, proof = proof))
        }
        fn choose() => {
            self.pop();
            place := self.expr();
            self.eat(.@"=");
            // TODO: assert that it's an array
            value := self.expr();
            self.new_node(Assign, (effect = .Pure, is_choose = true, place = place, value = value))
        }
        fn iterate() => {
            self.pop();
            self.eat(.@"(");
            vars := Node.list(temp());
            while => !self.maybe(.@")") {
                vars&.push(self.stmt());  // TODO: assert it's an Assign
                self.maybe(.@",");
            };
            then := self.builtin_call(.iterate);
            else := self.empty_node;
            if self.maybe(.else) {
                else = self.builtin_call(.iterate);
            };
            self.new_node(Iterate, (
                then = then,
                else = else,
                count = vars.len.trunc(), 
            ), vars.items())
        }
        @default => {
            if @is(self.current.type, .io_forget_history, .io_bind, .io_limit) {
                return self.builtin_call(self.pop());
            }
            node := self.expr();
            @match(self.current.type) {
                fn @"="() => self.assign(node, .Pure);
                fn @"=?"() => self.assign(node, .Yielding);
                @default => node;
            }
        };
    }
}

fn builtin_call(self: *Parser, op: TokenType) Node = {
    call := self.call(self.builtin_callee, .Impure);
    body := Node.list(temp());
    self.eat(.@"{");
    self.block(body&);
    self.new_node(Builtin, (
        op = op,
        call = call, 
        count = body.len.trunc(),
    ), body.items())
}

fn loop_flow(self: *Parser, style: Jump.Style) Node = {
    self.pop();
    label := self.unnamed_loop;
    if self.maybe(.@".") {
        label = self.next_name();
    }
    
    node := self.new_node(Jump, (style = style, value = self.empty_node));
    push(self.loops&, (label = label, jump = node), temp());
    node
}

fn assign(self: *Parser, place: Node, effect: Effect) Node = {
    self.pop();
    value := self.expr();
    self.new_node(Assign, (
        effect = effect, place = place, value = value,
    ))
}

fn type(self: *Parser) Node = {
    @match(self.pop()) {
        fn Ident() => {  
            // TODO: really this case should be shared with expr()
            name := self.prev_name();
            node := self.new_node(GetVar, (name = name, is_arg = false));
            while => self.maybe(.@".") {
                name := self.next_name();
                node = self.new_node(GetField, (place = node, name = name));
            };
            
            if self.maybe(.@"[") {
                self.eat(.@"..=");
                high := self.expr();
                self.eat(.@"]");
                node = self.new_node(Generic, (inner = node, length = high, op = .@"..="))
            };
            
            node
        }
        fn array() => self.array_type(.array);
        fn roarray() => self.array_type(.roarray);
        @default => {
            // TODO: is there rotable?
            if @is(self.previous.type, .slice, .roslice, .ptr, .nptr, .table) {
                return self.unary_generic(self.previous.type);
            } 
            @panic("TODO: type %", self.previous.type);
        };
    }
}

fn array_type(self: *Parser, op: TokenType) Node = {
    self.eat(.@"[");
    length := self.expr();
    self.eat(.@"]");
    inner := self.type();
    self.new_node(Generic, (inner = inner, length = length, op = op))
}

fn unary_generic(self: *Parser, op: TokenType) Node = 
    self.new_node(Generic, (inner = self.type(), length = self.empty_node, op = op));

fn expr(self: *Parser) Node = {
    lhs := self.prefix_expr();
    effect := Effect.Pure;
    style := Op.Style.Safe;
    loop {
        lhs = @match(self.current.type) {
            fn @"."() => {
                self.pop();
                name := self.next_name();
                self.new_node(GetField, (place = lhs, name = name))
            }
            fn @"~"() => {
                self.pop();
                style = @match(self.pop()) {
                    fn mod() => .Mod;
                    fn sat() => .Sat;
                    @default => @panic("Expected ~mod or ~sat");
                };
                @assert(self.current.type.is_op(), "expected an operator after ~mod/~sat");
                lhs
            }
            fn @"?"() => {
                self.pop();
                @assert_eq(self.current.type, .@"(", "expected call after '?'");
                effect = .Yielding;
                lhs
            }
            fn @"!"() => {
                self.pop();
                @assert_eq(self.current.type, .@"(", "expected call after '!'");
                effect = .Impure;
                lhs
            }
            fn @"("() => self.call(lhs, effect);
            fn as() => {
                self.pop();
                type := self.type();
                self.new_node(Op, (op = .as, style = .Safe, lhs = lhs, rhs = type))
            }
            fn @"["() => {  // TODO: type refinements could use this instead of Generic
                op := self.pop();
                lo := self.empty_node;
                if @is(self.current.type, .@"..", .@"..=") {
                    op = self.pop();
                } else {
                    lo = self.expr();
                }
                if @is(self.current.type, .@"..", .@"..=") {
                    @assert(op == .@"[");
                    op = self.pop();
                }
                hi := self.empty_node;
                if self.current.type != .@"]" {
                    hi = self.expr();
                };
                self.eat(.@"]");
                self.new_node(Index, (
                    op = op,
                    self = lhs,
                    lo = lo,
                    hi = hi,
                ))
            }
            @default => {
                if !self.current.type.is_op() {
                    return lhs;
                };
                self.operator(lhs, style)
            };
        };
    };
}

fn is_op(t: TokenType) bool = @is(t, 
    .@"+", .@"-", .@"*", .@"/", .@"%", 
    .@"==", .@"<>", .@"<", .@">", .@"<=", .@">=",
    .and, .or, 
    .@"&", .@"|", .@"<<", .@">>", .@"^", 
);

fn prefix_expr(self: *Parser) Node = {
    @match(self.pop()) {
        fn Ident() => {
            name := self.prev_name();
            self.new_node(GetVar, (name = name, is_arg = false))
        }
        fn args() => {
            self.eat(.@".");
            name := self.next_name();
            self.new_node(GetVar, (name = name, is_arg = true))
        }
        fn Number() => self.literal_node(Number = self.previous.payload.len);
        fn true()   => self.literal_node(Bool = true);
        fn false()  => self.literal_node(Bool = false);
        // ok status is a null pointer
        fn ok()  => self.literal_node(Number = 0);
        fn @"("() => {
            node := self.expr();
            self.eat(.@")");
            node
        }
        fn not() => {
            it := self.expr();
            self.new_node(Op, (
                op = .not, style = .Safe,
                lhs = it, rhs = self.empty_node,
            ))
        }
        fn @"["() => {
            nodes := Node.list(temp());
            while => !self.maybe(.@"]") {
                nodes&.push(self.expr());
                self.maybe(.@",");
            };
            self.new_node(Array, (count = nodes.len.trunc()), nodes.items())
        }
        @default => @panic("TODO: expr %", self.previous.type);
    }
}

fn literal_node(self: *Parser, it: LiteralValue) Node = {
    value := self.program.new_literal(it);
    self.new_node(Literal, (index = value))
}

// If callee is a field access, this is a method call 
fn call(self: *Parser, callee: Node, effect: Effect) Node = {
    self.eat(.@"(");
    // TODO: check the labels. might have to reorder !!
    labels := Symbol.list(temp());
    args := Node.list(temp());
    
    method_name := @match(self.module.get(callee)) {
        fn GetField(it) => {  // normal method call
            args&.push(it.place);
            it.name
        };
        fn GetVar(it) => it.name; // assert via
        fn Empty() => self.module.program.names&.insert_owned("?"); // builtin :SLOW
        @default => {
            self.error("invalid callee");
            unreachable()
        };
    }
    while => !self.maybe(.@")") {
        labels&.push(self.next_name());
        self.eat(.@":");
        args&.push(self.expr());
        self.maybe(.@",");
    };
    self.new_node(Call, (
        callee = method_name, 
        count = args.len.trunc(), 
        effect = effect,
    ), args.items())
}

fn operator(self: *Parser, lhs: Node, style: Op.Style) Node = {
    op := self.current.type;
    self.pop();
    assign := self.maybe(.@"=");
    rhs := self.expr();
    node := self.new_node(Op, (op = op, style = style, lhs = lhs, rhs = rhs));
    if assign {
        node = self.new_node(Assign, (effect = .Pure, place = lhs, value = node));
    }
    node
}

fn error(self: *Parser, msg: Str) void = {
    c: u32 = self.lex.start.trunc();
    span := self.span.subspan(c, c); 
    out := u8.list(temp());
    @fmt(out&, "[import_wuffs] %\n", msg);
    self.program.codemap&.fmt_error_line(span, out&, true);
    panic(out.items());
}

fn new_node(self: *Parser, $T: Type, node: T) Node #generic = 
    self.module.new_node(T, node);

fn new_node(self: *Parser, $T: Type, node: T, extra: []Node) Node #generic = 
    self.module.new_node(T, node, extra);

fn eat(self: *Parser, t: TokenType) void = {
    if !self.maybe(t) {
        msg := @tfmt("expected % but found % (%)", 
            t, self.current.type, self.lex.src.slice(self.lex.start, self.lex.current));
        self.error(msg);
    }
}

fn maybe(self: *Parser, t: TokenType) bool = {
    if self.current.type == t {
        self.pop();
        return(true);
    };
    false
}

fn next_name(self: *Parser) Symbol = {
    t := self.pop();
    @assert_eq(t, .Ident);
    self.prev_name()
}

fn prev_name(self: *Parser) Symbol = {
    self.program.names&.insert_owned(self.previous.payload)
}

fn pop(self: *Parser) TokenType = {
    self.previous = self.current;
    self.current = (
        type = self.lex&.pop(), 
        loc = self.lex.start.trunc(),
        payload = self.lex.payload, 
    );
    
    @match(self.current.type) {  // :SLOW
        fn @"{{"() => {
            self.current.type = .@"{";
        }
        fn @"}}"() => {
            self.current.type = .@"}";
        }
        fn Error() => self.error(@tfmt("lex error: %", self.current.payload));
        @default => ();
    };
    
    self.previous.type
}

FullToken :: @struct(type: TokenType, loc: u32, payload: Str);

#use("@/examples/import_wuffs/lex.fr");
#use("@/examples/import_wuffs/ast.fr");
