TURN_SPEED :: 0.005;
MOVE_SPEED :: 0.015;
MAX_VERTICES :: 1_000_000;
VERTICES_PER_POINT :: 6;
max_points :: MAX_VERTICES / VERTICES_PER_POINT;

// first i tried making a dumb .obj file but meshlab ran out of memory trying to render it for my 185MB point cloud. 

// no fancy triangulation stuff. just put the raw points on the screen. 
fn draw_point_cloud(state: *State, $next_point: @Fn() ?PointData) void = {
    sgl := state.draw.default_context&;

    // TODO: caching these is dumb but it's so fun to me that i can compute things at comptime. 
    //       and also my jit is really bad at arithmetic 6609829 times. 
    //max_intensity :: 183;
    //colours :: {
    //    c := ast_alloc().alloc(u32, max_intensity);
    //    enumerate c { i, c |
    //        hue := clamp(i.float() / max_intensity.float() * 5.0, 0.0, 1.0) * 360.0;
    //        c[] = hsv2rgb(hue, 1.0, 1.0, 1.0);
    //    }
    //    c
    //}
    
    to_vec :: fn(r) => {
        f :: fn(x) => (@as(i64) x.intcast()).float().cast();
        vec3(f(r.x), f(r.y), f(r.z))
    }
    
    
    lo := state.lo;
    hi := state.hi;
    percent :: fn(v, l, h) => (v - l) / (h - l);
    
    //off := vec3(state.header.x_offset.cast(), state.header.y_offset.cast(), state.header.z_offset.cast());
    average := vec3(0, 0, 0);
    
    while => next_point() { r |
        i: i64 = r.intensity.zext();
        max_intensity :: 65000;
        hue := clamp(i.float() / max_intensity.float() * 5.0, 0.0, 1.0) * 360.0;
        //c := @if(i < colours.len(), colours[i], 0xFFFFFFFF);
        v := to_vec(r);
        //hue := percent(v&[2], lo&[2], hi&[2]).cast() * 360.0;   // only makes sense if you pre-pass to calculate
        c := hsv2rgb(hue, 1.0, 1.0, 1.0);
        sgl.v3f_c1i(v, c);
        
        //average += v * ((@as(f32)1.0) / (point_count/max_points).float().cast());
        
        //@println("(%, %, %)", v&[0], v&[1], v&[2]);
        // there are min/max fields in the header but it seems they tend to lie
        hi = max(hi, v);
        lo = min(lo, v);
    }
    state.lo = lo;
    state.hi = hi;
    
    //@println("(%, %, %) (%, %, %)", hi&[0], hi&[1], hi&[2], lo&[0], lo&[1], lo&[2]);
    
    // mark the center for debugging rotation
    //sgl.point_size = 10.0;
    //center := (state.lo + (state.hi - state.lo) * 0.5);
    //sgl.v3f_c1i(center, 0xFFFFFFFF);
    //sgl.v3f_c1i(average, 0xFF00FFFF);
    
    //sgl.v3f_c1i(vec3(0, 0, 0), 0xFFF00FFF);
    
    if sgl.error.vertices_full {
        @println("too many vertices");
    }
}

fn fmod(a: f64, b: f64) f64 #libc;

// https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative
// i dont do common subexpression elimination so this is kinda dumb, 
// but i'm morally opposed to changing the code instead of fixing the compiler. 
//
// H is 0-360
fn hsv2rgb(H: f64, S: f64, V: f64, a: f64) u32 = {
    f :: fn(n) => {
        k := fmod(n.float() + (H / 60.0), 6.0);
        V - V * S * max(0.0, min(min(k, 4 - k), 1.0))
    }
    pack_rgba(f(5), f(3), f(1), a)
}

/////////////////////////

fn sqrtf(a: f32) f32 #libc;
fn sin_cos(rad: f32) Ty(f32, f32) = {
    //s := rad.sinf();
    //(s, sqrtf(1.0 - s*s))
    (rad.sinf(), rad.cosf())
}

frame_index :: @static(i64) 0;

do_render :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    set_dynamic_context(state.env);
    mark := mark_temporary_storage();
    sgl := state.draw.default_context&;
    if state.vertex_dirty {
        sgl.rewind();
        sgl.defaults();
        sgl.viewport(0.intcast(), 0.intcast(), sapp_width(), sapp_height(), true);
        sgl.load_pipeline(state.pipe);
        
        a := timestamp();
        sgl.begin(.POINTS);
        sgl.load_identity();
        sgl.point_size = 0.5;
        
        if state.file.vlr { vlr |
            chunks := state.chunks&;
            
            state.lo = vec3(99999999.0, 99999999.0, 99999999.0);
            state.hi = state.lo * @as(f32) -1.0;
            step_points := max(1, chunks.points_per_chunk * chunks.chunks.len / max_points);
            @println("%", step_points);
            
            
            for chunks.chunks.slice(0, chunks.chunks.len - 1) { chunk | 
                continue :: local_return;
                state.chunk_i += 1;
                if state.chunk_i.mod(5) != 0 {
                    continue();
                }
            //chunk := chunks.chunks[0];
                mark := mark_temporary_storage();
                iter: Laz.Iterator = init(state.file.laz_items, temp(), chunk);
                //@println("% % %", iter.point.prev.x, iter.point.prev.y, iter.point.prev.z);
                // TODO: don't lose the first point!
                n := 0;
                draw_point_cloud(state) { // chunks.points_per_chunk - 1) {
                    range(n, min(step_points + n, chunks.points_per_chunk-1)) { _ |
                        n += 1;
                        iter&.next();
                    };
                    n += 1;
                    //@println("%", n);
                    @if(n >= chunks.points_per_chunk, .None, (Some = iter&.next()))
                };
                @debug_assert_eq(iter.stream.i, iter.stream.input.len, "decompression did not consume all bytes");
                println(state.chunk_i);
                reset_temporary_storage(mark);
            };
            
            //println("TODO");
            //exit(1);
        } else {
            i := 0;
            step_bytes: i64 = state.file&.header()[].point_record_length.zext();
            point_count: i64 = state.file.data.len / step_bytes;
            step_points := max(1, point_count / max_points);
            
            draw_point_cloud(state) {
                @if(i >= point_count, .None, {
                    i = min(step_points + i, point_count-1);
                    
                    r := ptr_cast_unchecked(u8, Las.Format._1, state.file.data.ptr.offset(i * step_bytes));
                    i += 1;
                    (Some = (x = r.x, y = r.y, z = r.z, intensity = r.intensity))
                })
            }
        };
        
        sgl.end();
        b := timestamp();
        @println("%ms", b - a);
        
        sgl.update_vertex_buffer();
        state.vertex_dirty = false;
    };    
    
    mvp := sgl.uniforms[0].mvp&;
    h := state.file&.header();
    center := (state.lo + (state.hi - state.lo) * 0.5);
    
    state.model_yaw += state.d_model_yaw;
    model := @uninitialized Sgl.Matrix;
    identity(model&);
    foo: f32 = frame_index[].float().cast() * 1.1;
    translate(model&, vec3(0, @if(state.file.vlr.is_some(), 2.5, -2.5), 0));
    SCALE: f32 = 1.0 / @if(state.file.vlr.is_some(), 10000.0, 1000000000.0); // HACK
    //SCALE: f32 = 1.0 / 10000.0;
    //SCALE: f32 = 1.0 / 100000000.0;
    //SCALE: f32 = 1.0 / 100000.0;
    scale(model&, SCALE, SCALE, SCALE);
    translate(model&, center);
    
    //SCALE: f32 =  1.0 + frame_index[].float().cast() * 0.01;
    //scale(model&, SCALE, SCALE, SCALE);
    
    rotate(model&, deg_to_rad(state.model_yaw), 0.0, 1.0, 0.0);
    translate(model&, -center);
    frame_index[] += 1;
    
    identity(mvp);
    update_camera(state, mvp);
    mul(mvp, model&);
    
    desc := SgPass.zeroed();
    desc.action = state.pass_action;
    desc.swapchain = sglue_swapchain();
    desc.swapchain.width = sapp_width();
    desc.swapchain.height = sapp_height();
    sg_begin_pass(desc&);
    sgl.draw_layer(0);
    sg_end_pass();
    sg_commit();
    reset_temporary_storage(mark);
};

fn update_camera(state: *State, mvp: *Sgl.Matrix) void = {
    look_dir, forward, right := {
        sp, cp := state.pitch.sin_cos();
        sy, cy := state.yaw.sin_cos();
        (vec3(cp * cy, sp, cp * sy), vec3(cy, 0.0, sy), vec3(-sy, 0.0, cy))
    };
    normalize(look_dir&);
    normalize(forward&);
    normalize(right&);

    // TODO: adjust speeds for frame rate
    
    state.camera_pos     += forward * state.dx * MOVE_SPEED.cast();
    state.camera_pos     += right * state.dz * MOVE_SPEED.cast();
    state.camera_pos&[1] += state.dy * MOVE_SPEED;
    state.pitch += state.d_pitch * TURN_SPEED;
    state.yaw += state.d_yaw * TURN_SPEED;
    
    limit: f32 = 3.1415 / 2.0;
    state.pitch = clamp(state.pitch, -limit, limit);  // don't let you flip your neck backwards because that feels bad
    
    state.d_pitch = 0;
    state.d_yaw   = 0;
    
    view := @uninitialized Sgl.Matrix;
    identity(view&);
    lookat(view&, state.camera_pos, state.camera_pos + look_dir, vec3(0.0, 1.0, 0.0));  // eye, center, up
    
    projection := @uninitialized Sgl.Matrix;
    identity(projection&);
    aspect := intcast(sapp_width() / sapp_height()).float().cast();
    perspective(projection&, deg_to_rad(70.0), aspect, 0.01, 100.0);
    
    mul(mvp, projection&);
    mul(mvp, view&);
}

do_event :: fn(event: *SappEvent, userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    set_dynamic_context(state.env);
    
    ::enum(@type event.type); ::enum(@type event.key_code);
    
    if event.type == .MOUSE_MOVE {
        state.d_pitch -= event.mouse_dy;
        state.d_yaw   += event.mouse_dx;
    };
    
    dir, sign := @match(event.key_code) {
        fn W()          => (state.dx&, 1);
        fn S()          => (state.dx&, -1);
        fn A()          => (state.dz&, -1);
        fn D()          => (state.dz&, 1);
        fn LEFT_SHIFT() => (state.dy&, -1);
        fn SPACE()      => (state.dy&, 1);
        fn LEFT()       => (state.d_model_yaw&, -1);
        fn RIGHT()      => (state.d_model_yaw&, 1);
        fn ESCAPE()     => exit(0);
        @default        => return();         // !!
    };
    
    if event.type == .KEY_DOWN {
        dir[] = sign.float().cast();
    };
    if event.type == .KEY_UP {
        dir[] = 0;
    };
};

/////////////////////////

launch :: fn(state: *State) void = {
    state.draw = general_allocator().box(@type state.draw[]);
    desc := SappDesc.zeroed();
    desc.init_userdata_cb = do_init;
    desc.frame_userdata_cb = do_render;
    desc.event_userdata_cb = do_event;
    desc.user_data = State.raw_from_ptr(state);
    desc.logger.func = slog_func;
    desc.window_title = "Point Cloud Viewer";
    //desc.width = 400;
    //desc.height = 200;
    sapp_run(desc&);
}

do_init :: fn(userdata: rawptr) void = {
    state := State.ptr_from_raw(userdata);
    set_dynamic_context(state.env);
    
    desc := SgDesc.zeroed();
    desc.environment = sglue_environment();
    desc.logger.func = slog_func;
    sg_setup(desc&);
    
    vertices_needed := min(state.file&.header()[].legacy_point_record_count.zext() * 6, MAX_VERTICES);
    desc: Sgl.Desc = (
        allocator = general_allocator(),
        context = (
            max_vertices = vertices_needed.intcast(),
            lazy_record = true,
        ),
    );
    setup(state.draw, desc&);
    
    desc := SgPipelineDesc.zeroed();
    colour := desc.colors&[0]&;
    colour.blend.enabled = true;
    colour.blend.src_factor_rgb = .SRC_ALPHA;
    colour.blend.dst_factor_rgb = .ONE_MINUS_SRC_ALPHA;
    desc.alpha_to_coverage_enabled = true;
    desc.depth.write_enabled = true;
    desc.depth.compare = .LESS_EQUAL;
    
    init_pipeline(state.draw.default_context&, state.pipe&, desc&);
    state.pass_action.colors&[0].load_action = .CLEAR;
    state.pass_action.colors&[0].clear_value = (r = 0.3, g = 0.3, b = 0.3, a = 1.0);
    
    sapp_lock_mouse(true)
};
