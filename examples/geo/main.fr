#include_std("graphics/src/lib.fr");

Render :: import("@/examples/geo/render.fr");
Las :: import("@/examples/geo/las.fr");
Laz :: import("@/examples/geo/laz.fr");

LasFile :: @struct {
    input: []u8;
    data: []u8;
    vlr: ?*Laz.SpecialVlr;
    laz_items: []Laz.ItemRecord;
}

fn header(self: *LasFile) *Las.Header = {
    peek_type(self.input, Las.Header)
}

State :: @struct {
    pipe: Sgl.Pipeline;
    pass_action: SgPassAction;
    env: rawptr;
    draw: *Sgl.Common;
    file: LasFile;
    vertex_dirty: bool;
    pitch: f32;
    yaw: f32;
    camera_pos: Vec3;
    d_pitch: f32;
    d_yaw: f32;
    dx: f32;
    dy: f32;
    dz: f32;
    hi: Vec3;
    lo: Vec3;
    model_yaw: f32;
    d_model_yaw: f32;
    is_compressed: bool;
};

PointData :: @struct {
    x: u32;
    y: u32;
    z: u32;
    intensity: u16;
}

fn check_las_version(input: []u8) LasFile = {
    h := input.peek_type(Las.Header);
    @assert_eq(h.fourcc, 0x4653414C, "bad magic for las file. expected LASF");
    @println("version = %.%", h.version_major, h.version_minor);
    is_legacy := h.version_minor < 4;
    format := h.point_record_format;
    @println("fmt = %, len = %, count = %, vlr_count = %", format, h.point_record_length, h.legacy_point_record_count, h.vlr_count);
    is_compressed := format >= 128;
    format -= 128 * int(is_compressed).trunc();
    @assert(format < 6, "TODO: implement more point formats");
    records := input.rest(h.offset_to_point_data.zext());
    file: LasFile = (input = input, data = records, vlr = .None, laz_items = empty());
    if is_compressed {
        vv, iits := Laz'laz_header(input) 
            || @panic("expected compressed laz file but couldn't find special header");  // TODO: result
        file.vlr = (Some = vv);
        file.laz_items = iits;
    }
    file
}

Args :: @struct {
    path: CStr = "";
    mmap := false;
};

fn main() void = {
    args := parse_args();
    state := zeroed State;
    input := if args.mmap {
        mmap_read(args.path) || @panic("failed to open %", args.path)
    } else {
        general_allocator().read_to_string_or_crash(args.path.str()).items()
    }
    
    state.file = check_las_version(input);
    state.vertex_dirty = true;
    Render'launch(state&);
}

fn driver(vtable: *ImportVTable) void #export = {    
    src := "#include_std(\"lib/core.fr\");".clone(temp());
    the_code := temp().read_to_string_or_crash("examples/geo/main.fr");  // TODO: don't depend on cwd.
    src&.push_all(the_code.items());
    
    opts := vtable.default_build_options();
    opts.retain_function_names = true;
    comp := vtable.new_with_src(src.items(), opts);
    c := vtable.with(comp);
    
    libs := c.empty_libs();
    libs&.add_lib(sokol_macos_lib);
    
    main_sym := {vtable.intern_string}(comp, "main");
    main_f := {vtable.find_unique_func}(comp, main_sym).unwrap();
    
    // for now only suport running jitted
    ptr := c.get_jitted(main_f);
    f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
    f();
}

// :ugly
fn parse_args() Args = {
    a: Args = ();
    i := 0; 
    args := cli_args();
    while => i < args.len {
        continue :: local_return;
        arg := args[i].str();
        i += 1;
        if arg.starts_with("-") {
            arg = arg.rest(1);
            ::enum(Fields(Args));
            inline_for_enum Fields(Args) { $ff |
                f :: ff[];
                if arg == f.name_str() {
                    @inline_switch(Args.FieldType(f)) {
                        @case(bool) => {
                            Args.get_field(a&, f)[] = true;
                            continue();
                        }
                        @case(CStr) => {
                            Args.get_field(a&, f)[] = args[i];
                            i += 1;
                            continue();
                        }
                        @default => @panic("unhandled field type %", f);
                    }
                }
            };
            @panic("invalid argument -%", arg);
        };
    };
    a
}
