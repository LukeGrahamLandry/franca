main :: fn() void = {
    bytes := read_file_from_last_arg();  // TODO: dumb. just mmap the file?
    h := bytes.peek_type(Elf.Header);
    @assert_eq(h.magic, Elf.MAGIC, "invalid magic. expected an elf program");
    @assert(h.program_header_num != 0, "no program headers. expected an executable");
    @assert(h.program_header_entsize == size_of(Elf.ProgramHeader).trunc(), "phentsize");
    
    ph := bytes.rest(h.program_header_off).peek_type(Elf.ProgramHeader);
    ph: []Elf.ProgramHeader = ph.slice(h.program_header_num.zext());
    
    hi, lo := (0, MAX_i64);
    each ph { it |
        ::enum(@type it.type);
        if it.type == .Load {
            hi = max(hi, it.vaddr + it.mem_size);
            lo = min(lo, it.vaddr);
        }
    };
    @assert(hi > lo, "no load headers found");
    RW :i64= bit_or(Posix.PROT.WRITE, Posix.PROT.READ);
    
    // reserve memory that fits all the segments with the correct spacing (all inaccesable for now)
    total_virtual := hi - lo;
    @eprintln("reserving % virtual bytes", total_virtual);
    virtual := my_mmap(total_virtual, 0);
    
    executable := list([]u8, temp());
    stack: []u8 = empty();
    each ph { it |
        if it.type == .Load {
            dest := virtual.subslice(it.vaddr - lo, it.mem_size);
            
            if it.file_size != 0 {
                @assert(u8.int_from_ptr(dest.ptr).mod(page_size()) == 0, "not divisible by page size");
                src := bytes.subslice(it.offset, it.file_size);

                res := Syscall'mprotect(u8.raw_from_ptr(dest.ptr), dest.len, RW); 
                @assert_eq(res.value, 0, "mprotect failed %", @if(::is_linking_libc(), Posix'errno()[], "??"));
                dest.copy_from(src);
            }
            
            if it.prot.bit_and(Elf.PF_X) != 0 {
                executable&.push(dest);
            }
            
            prot := prot_elf_to_posix(it.prot);
            Syscall'mprotect(u8.raw_from_ptr(dest.ptr), dest.len, prot); 
        }
        if it.type == .Stack {
            prot := prot_elf_to_posix(it.prot);
            stack = my_mmap(it.mem_size, prot);
        }
    };
    @assert(stack.len > 0, "missing STACK program header");
    
    entry := virtual.index(h.entry - lo);
    {
        ok := false;
        for executable { it |
            ok = ok || it.contains_address(entry);
        };
        @assert(ok, "entry point is not in executable memory");
    };
    sp := stack.index_unchecked(stack.len);
    @println("calling entry point: %", entry);
    call_in_stack(sp, entry);
    unreachable();
}

my_mmap :: fn(size: i64, prot: i64) []u8 = {
    flag: i64 = bit_or(Posix'MAP'PRIVATE, Posix'MAP'ANON);
    mem := Posix'mmap(rawptr_from_int 0, size, prot, flag, (fd = -1), 0);
    mem := mem.Ok; // null if err
    @assert(!mem.is_null(), "mmap failed");
    u8.ptr_from_raw(mem).slice(size)
}

prot_elf_to_posix :: fn(prot: u32) i64 = {
    flag := 0;
    if prot.bit_and(Elf.PF_X) != 0 {
        flag = flag.bit_or(Posix.PROT.EXEC);
    }
    if prot.bit_and(Elf.PF_W) != 0 {
        flag = flag.bit_or(Posix.PROT.WRITE);
    }
    if prot.bit_and(Elf.PF_R) != 0 {
        flag = flag.bit_or(Posix.PROT.READ);
    }
    flag
}

Elf :: import("@/backend/elf/bits.fr");
#use("@/lib/sys/fs.fr");

call_in_stack :: AsmFunction(fn(sp: *u8, callee: *u8) void = (), @const_slice(
    add_im(.X64, sp, x0, @as(u12) 0, 0b0),  // setup new stack 
    br(x1, 0b1),  // call a user function
    brk(0x1234),  // crash
), (fn(out) = @asm_x64(
    encode_bin(PrimaryOp.MovReg, X86Reg.rsp, X86Reg.rdi),  // setup new stack
    encode_call_reg(ModrmMode.Direct, X86Reg.rsi),  // call a user function
    PrimaryOp.Int3,  // crash
) out));

#use("@/backend/amd64/bits.fr");
#use("@/backend/arm64/bits.fr");
