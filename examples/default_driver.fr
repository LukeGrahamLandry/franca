//! For large programs, you'll probably want to write your own driver to have more control, 
//! and to ensure that all information required to build your program is contained in the code of your program
//! (rather than in a seperate mass of shell scripts or whatever). 
//! However, for smaller programs where you just want to try something out, 
//! its a pain to have to write an extra program just to build it, so you can use this one instead. 

// - TODO: make llvm main function return 0 at the end so it doesn't make my terminal red. 
// - TODO: think about how to make cli args less painful cause if you run a jit thing, it gets all the args for the driver too,
//         and it seems kinda annoying to make you deal with that in every program. 
// - TODO: -S -o -O
// - TODO: declaritive way to add libraries. 
// - TODO: rename this? its not the default really. its not what the compiler uses to load your driver program for example. 

#include_std("examples/qbe.fr");

Options :: @struct(
    use_v2 := false,
    jit := true,
    llvm := false,
    wasm := false,
    qbe := false,
    keep_names := false,
    deduplicate := true,
    debug_info := false,
    target_x86 := false,
    cranelift := false,
    show_asm := false,
    blink := false,
);

Action  :: @enum(i64) (run, build, test); ::enum(Action);
Command :: @struct(cfg: Options, action: Action, file: Str, child_args: []Str);

forever :: todo_allocator;
fn driver(vtable: *ImportVTable) void = {
    cmd := parse_cli_args();
    build_options := vtable.default_build_options();
    build_options.retain_function_names = cmd.cfg.keep_names;
    build_options.deduplicate_bytecode = cmd.cfg.deduplicate;
    build_options.debug_info = cmd.cfg.debug_info;
    if cmd.cfg.cranelift {
        build_options.comptime_jit = .Cranelift;
    };
    os := Os.macos; // TODO
    comptime_arch := query_current_arch().expect("known arch");
    arch := comptime_arch;
    if cmd.cfg.blink {
        os = .linux;
        arch = .x86_64;
    };
    if cmd.cfg.target_x86 {
        arch = .x86_64;
    };
    if cmd.cfg.wasm {
        arch = .wasm32;
    };
    
    usage_msg :: "USAGE: franca examples/default_driver.fr % [filepath.fr]\n       %";
    @match(cmd.action) {
        fn build() => {
            if(cmd.file == "", => @panic(usage_msg, "build", "creates an executable that runs 'main'"));
            if cmd.cfg.wasm {
                build_options.wasm32 = true;
            };
            c := load_file(cmd.file, vtable, build_options);
            fid := c.get_unique_named("main");
            fid := fid.expect("did not find exactly one function called 'main'");
            if cmd.cfg.jit {
                println("Compiled successfully but selected jit backend so no artifact was produced.");
            } else {
                assert(cmd.cfg.llvm, "Not Yet Implemented: build main with -aot=qbe");
                c.compile_with_llvm(fid, .ExportWithNames, cmd.cfg.debug_info, arch, os, cmd.cfg.show_asm);
                println("[built a.out]");  // TODO: say the right path if its wasm
            };
            exit(0);
        };
        fn run() => {
            if(cmd.file == "", => @panic(usage_msg, "run", "runs the function called 'main'"));
            assert(!cmd.cfg.show_asm, "can't run with -S, use build instead");
            c := load_file(cmd.file, vtable, build_options);
            fid := c.get_unique_named("main");
            fid := fid.expect("did not find exactly one function called 'main'");
            assert(!cmd.cfg.wasm, "cannot run wasm");
            if cmd.cfg.jit {
                assert(!cmd.cfg.show_asm, "TODO: -S with jit");
                ptr := c.get_jitted(fid);
                f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
                // TODO: how to pass cli args
                f();
            } else {
                if cmd.cfg.llvm {
                    c.compile_with_llvm(fid, .ExportWithNames, cmd.cfg.debug_info, arch, os, false);
                } else {
                    assert(!cmd.cfg.show_asm, "TODO: -S with qbe");
                    assert(comptime_arch == arch, "TODO: not yet implemented. force qbe cross compile");
                    assert(cmd.cfg.qbe, "rn only two backends. update me as needed!");
                    //panic("TODO: impl swit ch on qbe");
                    c.compile_with_qbe(fid, .ExportWithNames, arch, os);
                };
                if cmd.cfg.blink {
                    args := cmd.child_args.clone(temp());
                    args&.insert(0, "./a.out");
                    run_cmd_blocking("blink", args.items());
                } else {
                    run_cmd_blocking("./a.out", cmd.child_args);
                };
            };
            exit(0);
        };
        fn test() => {
            assert(!cmd.cfg.show_asm, "TODO: test with -S");
            assert(!cmd.cfg.wasm, "cannot run wasm");
            if(cmd.file == "", => @panic(usage_msg, "test", "runs all functions marked '#test'"));
            c := load_file(cmd.file, vtable, build_options);
            
            tests := c.get_tagged("test");
            passed := 0;
            for tests { fid |
                if cmd.cfg.jit {
                    ptr := c.get_jitted(fid);
                    f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
                    @eprintln("[run %]", c.get_string(c.get_function_name(fid)));
                    f();
                    // TODO: do the fork stuff to report all even when some fail. 
                    passed += 1;
                } else {
                    if cmd.cfg.llvm {
                        c.compile_with_llvm(fid, .TestRunnerMain, cmd.cfg.debug_info, arch, os, cmd.cfg.show_asm);
                    } else {
                        assert(!cmd.cfg.show_asm, "TODO: -S with qbe");
                        assert(comptime_arch == arch, "TODO: not yet implemented. force qbe cross compile"); // TODO: this doesn't catch rosetta but it doesn't use it 
                        assert(cmd.cfg.qbe, "rn only two backends. update me as needed!");
                        c.compile_with_qbe(fid, .TestRunnerMain, arch, os);
                    };
                    @eprintln("[run %]", c.get_string(c.get_function_name(fid)));
                    success := if cmd.cfg.blink {
                        run_cmd_blocking("blink", @slice("./a.out"))
                    } else {
                        run_cmd_blocking("./a.out", empty())
                    };
                    if success {
                        passed += 1;
                    };
                };
            };
            @eprintln("[Passed %/% tests]", passed, tests.len);
            exit(if(passed == tests.len, => 0, => 1));
        };
    };
}

fn compile_with_llvm(c: CompCtx, fid: FuncId, entry: ProgramEntry, debug_info: bool, arch: Arch, os: Os, show_asm: bool) void = {
    ::if(Arch);
    ir_text := c.emit_llvm(temp(), @slice (fid), entry, arch, os);
    out := open_temp_file();
    for ir_text& { bucket |
        out.fd&.write(bucket);
    };
    if show_asm {
        @println("Llvm ir output in %  Skipping build", out&.s_name());
        return();  
    };
    triple := target_triple(arch, os);
    wasm := arch == .wasm32;
    
    path := if(wasm, => "a.wasm", => "a.out");
    args: List(Str) = @list("-x", "ir", out&.s_name(), "-o", path) temp();
    if wasm {
        // https://surma.dev/things/c-to-webassembly/
        args&.push_all(@slice(
            "--target=wasm32", "-nostdlib", "-Wl,--no-entry", "-Wl,--no-entry", "-Wl,--export-all", "-Wl,-z,stack-size=8388608"
        ));
        // also we want to just pretend we have a libc (and trust that js will provide it) 
        args&.push_all(@slice("-Wl,-undefined", "-Wl,dynamic_lookup", "-Wl,--allow-undefined"));
    } else {
        args&.push_all(@slice("-target", triple));
    };
    if debug_info {
        args&.push_all(@slice ("-O0", "-g"));
    } else {
        args&.push("-Os");
    };
    linux := os == .linux;
    if linux {
        args&.push("-c");
    };
    @eprintln("[run clang] %", args.items());
    success := run_cmd_blocking("clang", args.items());
    assert(success, "clang failed");
    out.remove(); // TODO: defer 
    
    // todo: dont assume so much. this is for running with blinkenlights
    if linux {
        success := run_cmd_blocking("zig", @slice("cc", "-static", "-target", triple, "-Wl,-z,common-page-size=65536,-z,max-page-size=65536", "a.out"));
        assert(success, "link failed");
    };
}

QBE_PATH :: "bindings/qbe/qbe";
fn compile_with_qbe(c: CompCtx, fid: FuncId, entry: ProgramEntry, arch: Arch, os: Os) void = {
    env: TargetEnv = (arch = arch, os = os);
    ir_text := emit_qbe(c, @slice(fid), entry, env&);
    // TODO: clean up this hack for inline asm
    ::?List(u8);
    inline_asm_functions := ir_text&.pop_current_bucket().unwrap();
    
    ir_out := open_temp_file();
    for(ir_text&){bucket|
        ir_out.fd&.write(bucket).unwrap();
    };
    ir_out.fd.close(); // ?
    asm_out :: "target/franca_qbe_temp.s"; // TODO: the version of tmp file that lets you have an extension because it wants the .s
    
    args: List(Str) = list(temp());
    args&.push("-o");
    args&.push(asm_out);
    args&.push(ir_out&.s_name());
    @println("Run qbe %", args.items());
    success := run_cmd_blocking(QBE_PATH, args.items());
    assert(success, "qbe failed");
    
    // TODO: it would be easier if i could use exec_and_catch but it hangs forever waiting on a few tests???
    //       TODO: check again. i think i fixed that -- Sep 19
    ok := append_to_file(asm_out, inline_asm_functions.items());
    assert(ok, "failed to append file");

    args: List(Str) = list(temp());
    args&.clear();
    args&.push(asm_out);
    args&.push("-o");
    args&.push("a.out");
    @println("Run assembler %", args.items());
    success := run_cmd_blocking("clang", args.items()); 
    assert(success, "as failed");
    ir_out.remove();   
}

fn load_file(path: Str, vtable: *ImportVTable, build_options: *BuildOptions) CompCtx = {
    the_code := temp().read_to_string(path);
    src := "#include_std(\"lib/core.fr\");".clone(forever);
    src&.push_all(the_code.items());
    comp := vtable.new_with_src(src.items(), build_options);
    // TODO: libs
    vtable.with(comp)
}

fn find_first_fr_file(args: []Str) Str = {
    for args { arg | 
        // TODO: caring about the file extension is so stupid. 
        if arg.ends_with(".fr") {|  // :file_extension
            return(arg);
        };
    };
    ""
}

fn find_args_after_double_dash(args: []Str) []Str = {
    enumerate args { i, arg | 
        if arg[] == "--" {
            return(args.slice(i, args.len));
        }; 
    };
    empty()
}

// TODO: think about if its a good idea to use reflection for this. 
fn parse_cli_args() Command = {
    cfg: Options = ();
    args := cli_args();
    args := args.slice(1, args.len); // skip exe
    extra_args: List(Str) = list(forever);
    for args { arg |
        arg := arg.str();
        
        @switch(arg) {
            @case("-v2") => { 
                cfg.use_v2 = true;
            };
            @case("-aot=llvm") => {
                cfg.jit = false; cfg.llvm = true;
                assert(!cfg.qbe, "choose one backend");
            };
            @case("-aot=llvm-wasm") => {
                cfg.jit = false; cfg.llvm = true; cfg.wasm = true;
                assert(!cfg.qbe, "choose one backend");
            };
            @case("-aot=qbe") => {
                cfg.jit = false; cfg.qbe = true;
                assert(!cfg.llvm, "choose one backend");
            };
            @case("-jit=cranelift") => {
                cfg.cranelift = true;
                assert(cfg.jit, "cannot -aot with cranelift");
                assert(!cfg.llvm && !cfg.qbe, "choose one backend");
            };
            @case("-keep-names") => {
                cfg.keep_names = true;
            };
            @case("-no-deduplication") => {
                cfg.deduplicate = false;
            };
            @case("-debug-info") => {
                cfg.debug_info = true;
            };
            @case("-x86") => {
                cfg.target_x86 = true;
            };
            @case("-S") => {
                cfg.show_asm = true;
            };
            @case("-blink") => {
                cfg.blink = true;
            };
            @default => {
                extra_args&.push(arg);
            };
        };
    };
    
    choose_action :: "pass cli argument ['build', 'run', 'test'] and then the path to a '.fr' source file.";
    assert(!extra_args.is_empty(), choose_action);
    enumerate extra_args { i, arg |
        done :: fn(action: Action) => {
            args_after_action := extra_args.items().slice(i, extra_args.len);
            file := find_first_fr_file(args_after_action);
            return(cfg = cfg, action = action, file = file, child_args = find_args_after_double_dash(args_after_action));
        };
        
        @switch(arg[]) {
            @case("build") => done(.build);
            @case("run")   => done(.run);
            @case("test")  => done(.test);
            @default => ();
        };
    };
    panic(choose_action)
}
