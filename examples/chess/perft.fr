// Runs perft on the positions from examples/chess/data/perft
// TODO: CLI divide command like the fish (tho really thats part of uci)
// TODO: allow testing a different uci engine with myself as the oracle?
// TODO: cli argument to set the oracle (default to stockfish)

positionData :: include_bytes("examples/chess/data/perft");

doFishDebugOnFail :: true;  // #foreign("stockfish")

main :: fn() void = {
    Crash :: import("@/lib/crash_report.fr");
    //Crash'hook_backtrace();
    
    import("@/examples/chess/precalc.fr")'initTables(temp());
    perfts := parsePerfts(positionData, temp()).or(fn(e) => panic(e));
        
    {
        any := false;
        lists: ListPool = init(temp());
        check := false;
        for cli_args() { it |
            if fromFen(it.str()) { game |
                if check {
                    debugPerft(it.str(), 6);
                } else {
                    range(1, 7) { depth |
                        nodes := countPossibleGames(game&, depth, lists&);
                        @println("depth=% nodes=%", depth, nodes);
                    }
                };
                any = true;
            };
            check = it.str() == "-check";
        };
        if any {
            return();
        }
    };

    // For best parallelism, don't put the longest tasks at the end. You don't want time at the end where only one therad is working.
    sort :: import("@/lib/sort.fr")'quicksort(Perfts, fn(a, b) => 
        a.allCount >= b.allCount);  // ascending
    perfts.sort();

    if query_current_arch() == .wasm32 {
        it := zeroed Worker;
        taskIndex := 0;
        it.lists = init(temp());  // :DontStoreTheAllocator
        it.nextTask = taskIndex&;
        it.tasks = perfts;
        workerFn(it&);
        return();
    }
    
    cores := 1;
    taskIndex := 0;
    workers := temp().alloc_uninit(Worker, cores);
    enumerate workers { i, it |
        it.id = i;
        it.lists = init(temp());  // :DontStoreTheAllocator
        it.nextTask = taskIndex&;
        it.tasks = perfts;
        it.failedCount = 0;
        it.thread = start_thread(Worker, workerFn, it); // last!
    };
    
    failed := 0;
    each workers { it |
        it.thread.join();
        failed += it.failedCount;
    };

    if (failed == 0) {
        @print("Passed All %.\n", perfts.len);
    } else {
        @print("Failed %/%.\n", failed, perfts.len);
    }
}

Perfts :: @struct {
    fen: Str;
    levels: []Perft;
    allCount: i64; // for sorting
};

Perft :: @struct {
    nodes: i64;
    depth: i64;
};

Worker :: @struct {
    id: i64;
    thread: *Thread;
    lists: ListPool;
    nextTask: *i64;
    tasks: []Perfts;
    failedCount: i64;
};

fn next(self: *Worker) ?i64 = {
    nextTask := i64.atomic_inc(self.nextTask);
    @if(nextTask >= self.tasks.len) return(.None);
    (Some = nextTask)
}

fn workerFn(self: *Worker) void = {
    startTime := timestamp();
    totalNodes, passedCount := (0, 0);
    while => self.next() { nextTask |
        position := self.tasks[nextTask]&;
        game: Board = fromFen(position.fen).unwrap();
        break :: local_return;
        for position.levels { perft |
            nodes := countPossibleGames(game&, perft.depth, self.lists&);
            totalNodes += nodes;
            if (nodes != perft.nodes) {
                @print("[%/%] Failed % depth %. Expected % but found %.\n", nextTask + 1, self.tasks.len, position.fen, perft.depth, perft.nodes, nodes);
                self.failedCount += 1;
                if doFishDebugOnFail {
                    debugPerft(position.fen, perft.depth);
                }
                break(); // All deeper levels will also fail.
            } else {
                @print("[%/%] % depth % nodes %.\n", nextTask + 1, self.tasks.len, position.fen, perft.depth, nodes);
            }
        };
        passedCount += 1;
    }

    if (self.failedCount == 0) {
        endTime := timestamp();
        ms := endTime - startTime;
        @print("Thread % finished % perfts in %ms. % nodes / second.\n", self.id, passedCount, ms, totalNodes * 1000 / ms);
    }
}

// TODO: try using a memo table here as well. Obviously cheating if i'm just trying to brag about NPS numbers but would make the tests run faster and be an extra check for acidently making collissions more common.
fn countPossibleGames(game: *Board, remainingDepth: usize, lists: *ListPool) i64 = {
    @debug_assert_gt(remainingDepth, 0, "should early exit for depth 0");
    
    games := 0;
    allMoves := possibleMoves(game, game.nextPlayer, lists);
    if remainingDepth == 1 {
        games = allMoves.items().len();
    } else {
        for (allMoves.items()) { move |
            unMove := game.play(move);
            games += countPossibleGames(game, remainingDepth - 1, lists);
            game.unplay(unMove);
        }
    };
    
    lists.release(allMoves);  // :defer
    games
}

fn parsePerfts(s: Str, a: Alloc) Result([]Perfts, Str) = {
    all := Perfts.list(a);
    i := 0;
    while => i < s.len {
        continue :: local_return;
        while => i < s.len && s[i].is_ascii_whitespace() {
            i += 1;
        };
        if i+1 < s.len && s[i] == "/".ascii() && s[i+1] == "/".ascii() {
            while => i < s.len && s[i] != "\n".ascii() {
                i += 1;
            };
            continue()
        };
        if i >= s.len {
            continue();
        }
        
        start := i;
        while => i < s.len && s[i] != ";".ascii() {
            i += 1;
        };
        fen := s.slice(start, i);
        ::?Board;
        _: Board = fromFen(fen)
            || return(Err = "failed to parse fen");
        perfts := Perft.list(a);
        total := 0;
        
        while => i < s.len && s[i] == ";".ascii() {
            err :: fn() => return(Err = "expected ;D<depth> <nodes>");
            @if(s[i+1] != "D".ascii()) err();
            
            depth, s2 := convert_number_dyn(s.rest(i+2), 10);
            @if(s2.len == 0) err();
            i = s.len - s2.len;
            @if(s[i] != " ".ascii()) err();
            nodes, s3 := convert_number_dyn(s.rest(i+1), 10);
            @if(s3.len == 0) err();
            i = s.len - s3.len;
            i += 1;
            
            perfts&.push(depth = depth, nodes = nodes);
            total += nodes;
            
        }
        all&.push(fen = fen, levels = perfts&.shrink_to_fit(), allCount = total);
    };

    (Ok = all&.shrink_to_fit())
}

fn debugPerft(fen: Str, depth: i64) void = {
    @assert(query_current_arch() != .wasm32, "debugPerft() works by exec-ing another chess engine. this aint gonna work in wasm");
    
    ::imactuallygoingtolosemymind();
    mark := temp().mark();
    board: Board = fromFen(fen).unwrap();
    @print("===== Starting % \n", fen);
    fish: EngineProcess = init(temp());
    fish&.send(.uci);  // TODO: wait for uciok
    lists: ListPool = init(temp());
    foundProblems := 0;
    walkPerft(fish&, board&, depth, lists&, foundProblems&);
    if foundProblems == 0 {
        println("ERROR: Fish didn't find the problem. \nPerft failed but fish agrees on counts for all leaf nodes. \nThat means when I make a move I'm getting a different fen than it would have. \nLast time it was a castling rights mistake.\n");
    }
    fish&.send(.quit);
    // TODO: add a method to EngineProcess that force kills the process after a timeout
    @print("===== Finished %\n", fen);
    temp().reset(mark);
}

fn walkPerft(fish: *EngineProcess, board: *Board, depth: i64, lists: *ListPool, foundProblems: *i64) void = {
    @if (depth == 0) return();

    // First decide if this is the branch where we disagree about possible moves.
    // (run with full depth because if we agree on moves at this level, i use these counts to choose which branch to follow)
    fishMoves := runFishPerft(fish, board, depth);
    fishMoves := fishMoves.childCount;
    myMoves := possibleMoves(board, board.nextPlayer, lists);

    myMovesSet: HashMap(Move, void) = init(temp());
    done := false;
    
    // Do I have extra illegal moves?
    for myMoves { move |
        // Don't need to check that it's legal because comparing to stockfish will catch that mistake.
        prev := myMovesSet&.insert(move, ());
        if prev.is_some() {
            @print("ERROR: I have duplicate move! %\n", move);
            foundProblems[] += 1;
            done = true;
        };
        if fishMoves&.get(move).is_none() {
            @print("[%] Found! I have move % but fish doesn't. \n| %\n", depth, move, board.t_fen());
            foundProblems[] += 1;
            done = true;
        }
    }

    // Am I missing moves?
    for_keys fishMoves& { move |
        if myMovesSet&.get(move).is_none() {
            @print("[%] Found! Fish has move % but I don't. \n| %\n", depth, move, board.t_fen());
            foundProblems[] += 1;
            done = true;
        }
    };

    // If we disagreed on moves, this level is the problem, don't need to keep going.
    if done || depth == 1 {
        // depth=1 is unreachable in a sane world but the point of this is debugging when the program is broken
        lists.release(myMoves); // :defer
        return();
    }
    
    // We agree on which moves are possible from here but disagree on the total size of the tree.
    // Now need to decide which branch we disagree on by running both counts on a higher depth.
    // Recursively repeat this whole process for each child.
    for myMoves { myMove |
        unMove := board.play(myMove);
        myCount := countPossibleGames(board, depth - 1, lists);
        fishCount := fishMoves&.get(myMove).unwrap();
        if myCount != fishCount {
            // This branch is the problem.
            @print("Disagree on count at depth %: me:% vs fish:% \n| %\n", depth - 1, myCount, fishCount, board.t_fen());
            walkPerft(fish, board, depth - 1, lists, foundProblems);
        }
        board.unplay(unMove);
    }

    lists.release(myMoves); // :defer
}

fn t_fen(self: *Board) Str = {
    out := u8.list(temp());
    self.writeFen(out&);
    out.items()
}

FishResult :: @struct {
    childCount: HashMap(Move, i64);
};

fn runFishPerft(fish: *EngineProcess, board: *Board, depth: i64) FishResult = {
    fish.sync();
    fish.send(SetPositionMoves = (board = board));
    fish.send(Go = (perft = (Some = depth)));
    
    result: FishResult = (childCount = init(temp()));
    dowhile {
        continue :: local_return;
        // TODO: don't busy wait. use blockuntilrecieve
        msg := fish.recieve() || continue(true);
        @match(msg) {
            fn PerftDivide(info) => {
                result.childCount&.insert(info.move, info.count);
                true
            }
            fn PerftDone(info) => false;
            @default => true;
        }
    };
    result
}


// :compilerbug/ordering
fn imactuallygoingtolosemymind() void = {
    // note: not looking at action field because it's not set when parsing from uci 
    fn hash(h: *TrivialHasher, s: *Move) void = {
        h.hash(s.to&);
        h.hash(s.from&);
        xxx := s.promote.raw();
        h.hash(xxx&);
    }
    
    fn eq(a: *Move, b: *Move) bool = {
        a.to == b.to && a.from == b.from && a.promote == b.promote
    }
    
    fn display(a: Move, out: *List(u8)) void = {
        a.writeAlgebraic(out);
    }
}

#use("@/examples/chess/moves.fr");
#use("@/examples/chess/uci.fr");
#use("@/lib/collections/map.fr");
#use("@/lib/sys/threads.fr");
