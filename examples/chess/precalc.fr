//! Calculate good numbers to use in movegen lookup table hash functions.

// TODO: put it in ClearOnAotBake so you can use the chess stuff at comptime and runtime without bloating your binary
// This is immutable so multiple threads can share one.
tables :: @static(Tables);

// currently you can't forget to call this because you'll segfault on trying to index the AttackTable which is a bit rude but works out
fn initTables(a: Alloc) void = {
    rng: Random.Rng = (next = Random.xoshiro256SS, s = ZOIDBERG_SEED);
    each ZOIDBERG { it |
        it[] = rng&.next().bitcast();
    };
    
    tables[] = (
        rooks = makeSliderAttackTable(a, possibleRookTargets, magic.rook&),
        bishops = makeSliderAttackTable(a, possibleBishopTargets, magic.bishop&),
    );
}

Tables :: @struct {
    // Index is starting square. Key is bitboard of blocking pieces, (on both sides), (AttackTable.indexOf masks out irrelevant squares)
    // Value is bitboard of move targets, including on to pieces of either side (but not through them).
    // So key = allPieces & mask; targets = value & ~myPieces;
    rooks: AttackTable;
    bishops: AttackTable;

    // These are done at comptime because the data is smaller than the code to generate it. 
    //     TODO: measure that again in to make sure
    // Index is starting square. Value is bitboard of move targets.
    knights :: ast_alloc().alloc_init(i64, 64, possibleKnightTargets);
    kings :: ast_alloc().alloc_init(i64, 64, possibleKingTargets);
};

TargetSquares :: @Fn(i: i64, blockerFlag: i64, skipEdgeSquares: bool) i64;

// Use the hardcoded primes to build an attack table.
// Doesn't need to try increasing table sizes because the correct size for no collisions given that hasher is precalculated.
// Maps the arangement of blocking pieces to the squares you can move to. 64 of them, one for each starting square.
fn makeSliderAttackTable(alloc: Alloc, $possibleTargets: TargetSquares, magic: *Magic.BitBoardSeed) AttackTable = {
    result := @uninitialized AttackTable;
    totalSize := 0;
    range(0, 64) { i |
        table := fillSliderTable(i, magic.magic&[i], magic.size&[i], alloc, possibleTargets)
            || @panic("Table % had collisions. Precalculated size % was wrong. (invalid bitboards data file)", i, magic.size&[i]);
        result&[i] = table;
        totalSize += result&[i].buffer_len() * size_of(i64) / 1024;
    }
    // @print("Slider attack table size: % KB.\n", totalSize);
    result
}

main :: fn() void = {
    test_unblocked_rooks_can_move_14_squares();
    _ := Tables.kings;
    _ := Tables.knights;

    initTables(general_allocator());
    a := findBetterSliderAttackTable(magic.rook&, "ROOK", tables.rooks&);
    b := findBetterSliderAttackTable(magic.bishop&, "BISHOP", tables.bishops&);
    
    if a || b {
        print("\n---\n\n");
        printArrays(magic.rook&, "ROOK");
        printArrays(magic.bishop&, "BISHOP");
        
        ::[]@type magic[];
        bytes := magic.slice(1).interpret_as_bytes();
        #use("@/lib/sys/fs.fr");
        write_entire_file_or_crash("examples/chess/data/bitboards", bytes);
        // TODO: if you franca examples/chess/precalc.fr multiple times, 
        //       you won't get your updated file unless you FRANCA_NO_CACHE=1 
        //       because read_entire_file_or_crash doesn't talk to the compiler about caching :FUCKED
    } else {
        @print("Didn't find anything good.\n");
    }
}

// TODO: for aesthetics, at the end try if any of the bits can be made zero or if any numbers can be reused for other indices. 
// TODO: allow it being long running. just go until you click enter maybe. 
// TODO: i could save 64 bytes of data file for BitBoardSeed.size since all the sizes are <16 but then have to unpack back to u8

// Since the attack table for each square has different sizes and different mask bits of the keys they care about (the unblocked targets),
// they have different best numbers for the hash function avoiding collisions.
// If it finds any improvements, it logs them so I can update the hardcoded ones going forward.
fn findBetterSliderAttackTable(new: *Magic.BitBoardSeed, name: Str, old: *AttackTable) bool = {
    foundAny := false;

    ::Random;
    rng := Random.xoshiro256SS.new_seeded();
    arena: Arena.Allocator = init(general_allocator(), 1.shift_left(16));
    
    range(0, 1000) { _ |
        newMagic := rng&.next().bitcast();
        range(0, 64) { i |
            break :: local_return;
            // See how good this number is. Don't care if its just equal to the old one.
            bits := new.size&[i] - 1;
            while => bits > 1 {
                arena&.reset_retaining_capacity();
                _ := fillSliderTableFast(i, newMagic, bits, arena&.borrow(), old)
                    || break();
                
                // new magic is better than the old one!
                @println("%[%] (%, %) -> (%, %)", name, i, @as(u64) new.magic&[i].bitcast(), new.size&[i], @as(u64) newMagic.bitcast(), bits);
                new.magic&[i] = newMagic;
                new.size&[i] = bits;
                foundAny = true;
                
                // See if its actually even better than that and allows a smaller table.
                bits -= 1;
            }
        }
    }
    arena&.deinit();

    foundAny
}

// this lets me export any better numbers i find to my previous (zig) chess engine. 
fn printArrays(self: *Magic.BitBoardSeed, name: Str) void = {
    out := u8.list(temp());
    @fmt(out&, "pub const %_HASH_MUL = [64] u64 {", name);
    for self.magic& { it |
        @fmt(out&, " %,", @as(u64) it.bitcast());
    }
    @fmt(out&, " };\n");
    @fmt(out&, "pub const %_SIZES = [64] u7 {", name);
    for self.size& { it |
        @fmt(out&, " %,", it);
    }
    @fmt(out&, " };\n");
    print(out.items());
}

fn fillSliderTable(sqI: i64, magic: i64, bits: u8, alloc: Alloc, $possibleTargets: TargetSquares) ?OneTable = {
    @debug_assert_lt(bits, 20, "too many bits in fillSliderTable");
    baseTargets := possibleTargets(sqI, 0, true);
    result: OneTable = init(alloc, bits, magic, baseTargets);
    for_subsets baseTargets { blockers |
        targets := possibleTargets(sqI, blockers, false);
        success := result&.set(blockers, targets);
        if !success {
            result.deinit(alloc);
            return(.None);
        }
    };
    (Some = result)
}

fn fillSliderTableFast(sqI: i64, magic: i64, bits: u8, alloc: Alloc, old: *AttackTable) ?OneTable = {
    @debug_assert_lt(bits, 20, "too many bits in fillSliderTable");
    baseTargets := old[sqI].mask;
    result: OneTable = init(alloc, bits, magic, baseTargets);
    for_subsets baseTargets { blockers |
        targets := old.index(sqI).get(blockers);
        success := result&.set(blockers, targets);
        if !success {
            result.deinit(alloc);
            return(.None);
        }
    };
    (Some = result)
}

fn possibleKingTargets(i: i64) i64 = {
    result := 0;
    rank, file := i.div_mod(8);
    f :: fn(cond, r, f) => {
        bit := cond.int().shift_left(r*8+f);
        result = result.bit_or(bit);
    };
    
    // forward
    f(file < 7, rank, file + 1);
    f(file < 7 && rank < 7, rank + 1, file + 1);
    f(file < 7 && rank > 0, rank - 1, file + 1);

    // back
    f(file > 0, rank, file - 1);
    f(file > 0 && rank < 7, rank + 1, file - 1);
    f(file > 0 && rank > 0, rank - 1, file - 1);
    
    // horizontal
    f(rank < 7, rank + 1, file);
    f(rank > 0, rank - 1, file);

    result
}

// Yield once for each combination of set bits in n.
// ie. n=(all ones) would yield each possible 64 bit number.
// https://www.chessprogramming.org/Traversing_Subsets_of_a_Set
fn for_subsets(d: i64, $body: @Fn(n: i64) void) = {
    n := 0;
    dowhile {
        body(n);
        n = bit_and(n - d, d);
        n != 0
    }
} 

// :DirectionsOrderMatters
fn possibleRookTargets(rookIndex: i64, blockerFlag: i64, $skipEdgeSquares: bool) i64 = {
    return possibleSlideTargets(rookIndex, blockerFlag, skipEdgeSquares, allDirections.slice(0, 4));
}

fn possibleBishopTargets(rookIndex: i64, blockerFlag: i64, $skipEdgeSquares: bool) i64 = {
    return possibleSlideTargets(rookIndex, blockerFlag, skipEdgeSquares, allDirections.slice(4, 8));
}

// The edge squares dont matter for the pieces mask because there's nothing more to block.
fn possibleSlideTargets(startIndex: i64, blockerFlag: i64, $skipEdgeSquares: bool, $directions: []Ty(i64, i64)) i64 = {
    result := 0;
    dir := -1;
    inline_for directions { $it |
        break :: local_return;
        dir += 1;
        checkRank, checkFile := startIndex.div_mod(8);
        // TODO: this is kinda lame. inline_for goes by reference and the compiler doesn't trust that its constant so backend doesn't hoist the load. 
        offset := @run it[];  
        loop {
            checkFile += offset._0;
            checkRank += offset._1;
            if (skipEdgeSquares) {
                // :DirectionsOrderMatters
                @if (dir >= 2 && (checkRank > 6 || checkRank < 1)) break();
                @if (dir < 2 && (checkFile > 6 || checkFile < 1)) break();
            }
            @if (checkFile > 7 || checkRank > 7 || checkFile < 0 || checkRank < 0) break();  // went off the board

            toFlag := 1.shift_left(checkRank * 8 + checkFile);
            result = result.bit_or(toFlag);
            @if (toFlag.bit_and(blockerFlag) != 0) break();  // hit something
        }
    }
    result
}

test_unblocked_rooks_can_move_14_squares :: fn() void = {
    range(0, 64) { i |
        b := possibleRookTargets(i, 0, false);
        @debug_assert_eq(b.count_ones(), 14);

        rank, file := i.div_mod(8);
        edgeCount := 4 
            - int(file == 0 || file == 7)
            - int(rank == 0 || rank == 7);
        b := possibleRookTargets(i, 0, true);
        @debug_assert_eq(b.count_ones().zext(), 14 - edgeCount);
    }
}

// :DirectionsOrderMatters
allDirections :: @const_slice(
    (1, 0),
    (-1, 0),
    (0, 1),
    (0, -1),
    (1, 1),
    (1, -1),
    (-1, 1),
    (-1, -1),
);

possibleKnightTargets :: fn(i: i64) i64 = {
    knightOffsets :: @const_slice(1, -1, 2, -2);

    result := 0;
    // might be worth inline for to be less branchy if this was in the hot movegen code, but it's just for generating a table. 
    for knightOffsets { x |
        for knightOffsets { y |
            if x != y && x != -y {
                checkFile := i.mod(8) + x;
                checkRank := i / 8 + y;
                invalid := checkFile > 7 || checkRank > 7 || checkFile < 0 || checkRank < 0;
                bit := int(!invalid).shift_left(checkRank * 8 + checkFile);
                result = result.bit_or(bit);
            }
        }
    }

    @debug_assert(result.count_ones() <= 8, "knight has too many moves");
    result
}

AttackTable :: Array(OneTable, 64);

OneTable :: @struct {
    buffer: *i64;
    bitsInv: u8;
    magic: i64;  // brute forced by findBetterSliderAttackTable
    mask: i64;  // bitboard of relevant blockers. same as move targets, assuming no blocking pieces, and skipEdgeSquares=true.
    EMPTY :: -1;
};

fn init(a: Alloc, bits: u8, magic: i64, mask: i64) OneTable = 
    (bitsInv = 64 - bits, buffer = allocOnes(a, bits), magic = magic, mask = mask);

fn buffer_len(self: OneTable) i64 =
    1.shift_left(64 - self.bitsInv.zext());

fn deinit(self: OneTable, a: Alloc) void = 
    a.dealloc(i64, self.buffer.slice(self.buffer_len()));

// Zero is a possible value since there might be no possible moves so have the default be all ones
// (nobody can teleport to all squares of the board), so I can detect it while building the map.
fn allocOnes(a: Alloc, bits: u8) *i64 = {
    it := a.alloc_uninit(i64, 1.shift_left(bits.zext()));
    it.interpret_as_bytes().set_bytes(0xFF);
    it.ptr
}

// Returns false on collision. Only used while building the table at the very start.
fn set(self: *OneTable, key: i64, value: i64) bool = {
    @debug_assert(key.bit_and(self.mask) == key);
    prev := self.get(key);
    // if they collide but the values happen to be the same that's fine.
    // idk if that happens often. feels like it should because of extra dudes past the one that actually blocked you?
    @if(prev != OneTable.EMPTY && prev != value) return(false);
    self.buffer.offset(self.indexOf(key))[] = value;
    true
}

fn indexOf(self: *OneTable, unmasked_key: i64) i64 = {
    // apply the mask that removes impossible targets from the key!
    // The rest assumes they key will be in the table and that there are no bucket collisions.
    // All the keys are known ahead of time when the table is built and looking up an invalid key is a bug.
    hash := unmasked_key.bit_and(self.mask);
    
    // xor to mix the bits around so more of them have an effect on the index 
    hash = hash.bit_xor(hash.shift_right_logical(self.bitsInv.zext()));  
    all := self.magic * hash;
    index := all.shift_right_logical(self.bitsInv.zext());
    index
}

fn get(self: *OneTable, key: i64) i64 =
    self.buffer.offset(self.indexOf(key))[];

// For movegen lookup tables. Generated by precalc.zig by trying random numbers.
// HASH_MUL is the multiplier to use in the hash function.
// SIZE is the number of bits required for the index for that number to get no collisions.
// The calculated ones are saved in data/bitboards
Magic :: @struct {
    rook: BitBoardSeed;
    bishop: BitBoardSeed;
    
    BitBoardSeed :: @struct {
        magic: Array(i64, 64);
        size: Array(u8, 64);
    };
}

magic :: Magic.include_bytes("examples/chess/data/bitboards");

// TODO: are there better numbers? experimentally run a bunch of games until I find the ones with least collissions?
/// Magic numbers for Zobrist hashing. I think I'm so funny.
/// https://en.wikipedia.org/wiki/Zobrist_hashing
// TODO: make sure i use bss for this!
// TODO: put it in ClearOnAotBake so you can use the chess stuff at comptime and runtime without bloating your binary
ZOIDBERG :: @static(Array(i64, 781 + 128));  // arbitrary numbers filled in at runtime
// TODO: how did i pick these numbers? can i just make it 4 or whatever...?
// TODO: ugly... compiler shouldn't complain about u64 literal with high bit set :compilerbug
ZOIDBERG_SEED :Array(u64, 4): (@as(u64) 11196532868861123662.bitcast(), @as(u64) 6132230720027805519.bitcast(), @as(u64) 14166148882366595784.bitcast(), @as(u64) 2320488099995370816.bitcast());
