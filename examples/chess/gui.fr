
// choose between using images or letters to represent pieces. 
// UGLY=false: takes an extra 600ms to compile my c compiler and stb_image to load the png file. 
// UGLY=true: removes the dependency on stb_image. makes this program more self contained.
// TODO: make the import_module caching work well enough that its less embarrassing. 
// TODO: fetch dependencies in the web demo so this can be pretty. 
UGLY :: false || GRAPHICS_TARGET_WEB;

State :: @struct(
    pipe: Sgl.Pipeline,
    pass_action: Sg.PassAction,
    text: Sdtx.Self,
    draw: Sgl.Self,
    sg: Sg.Self,
    pieces_image: Sg.Image,  // only used when UGLY=false

    search: Search.SearchGlobals,
    board: BoardView,
    dirty: bool,
);

fn on_init(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    allocator := general_allocator();
    Chess'Precalc'initTables(allocator);
    sapp.set_window_title("Chess");
    
    state.draw&.setup(
        allocator = allocator,
        sg = sg,
    );
    
    // TODO: my png is super blury. maybe i need to find an svg renderer. 
    //       also i like the idea of text file of lines to draw more than blob of compressed pixels. 
    //       plus the svg puts the attribution text in the image file which seems more elegant than in a comment here. 
    @if(!UGLY) {
        // The binary is smaller if it just includes the png+stb_image and decompresses at runtime, 
        // but sometimes it's more fun to flex that this works at comptime :)
        p, w, h := @run {
            // The same textures every other low effort chess game in the universe found by googling for free chess icons.
            // https://commons.wikimedia.org/wiki/File:Chess_Pieces_Sprite.svg jurgenwesterhof (adapted from work of Cburnett), CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0, via Wikimedia Commons
            data := include_bytes("examples/chess/data/pieces.png");
            src_w :i32= 0;
            src_h :i32= 0;
            bytes_per_pixel :i32= 4; 
            pixels := Stb'stbi_load_from_memory(data.ptr, data.len.intcast(), src_w&, src_h&, zeroed(*i32), bytes_per_pixel);
            (pixels.slice(intcast(src_w*src_h*bytes_per_pixel)), src_w, src_h)
        };
    
        state.pieces_image = sg.make(
            width = w,
            height = h,
            pixel_format = .RGBA8,
            label = "chess-pieces",
            data = (
                subimage = (
                    (p, ..""), 
                    ..zeroed(Array([]u8, 16)),
                ),
            ),
        );
    };
    
    state.text&.setup(
        allocator = allocator,
        fonts = @slice(Sdtx.font.kc854),
        sg = sg,
    );
    
    init_pipeline(state.draw&, state.pipe&, sg, (colors = (
        (blend = (  // This makes transparency work
            enabled = true,
            src_factor_rgb = .SRC_ALPHA,
            dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,
        )),
        ..,
    )));
    
    state.pass_action.colors&[0] = (
        load_action = .CLEAR,
        clear_value = (r = 0.3, g = 0.3, b = 0.3, a = 1.0),
    );
    
    state.search = init(100, general_allocator());
    state.board = (
        board = initial(),
        lists = init(allocator),
        click_index = .None,
        pos = vec2(100.0),
        size = 600.0,
        window_size = zeroed Vec2,
        show_square_labels = false,
    );
    
    state.dirty = true;
};
  
fn on_render(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    @if(Easy'should_skip_frame(sapp, state.dirty&)) return();

    sgl := state.draw&;
    sdtx := state.text.default_context&;
    
    sgl.defaults();
    sgl.viewport(0.intcast(), 0.intcast(), sapp.width().intcast(), sapp.height().intcast(), true);
    sgl.load_pipeline(state.pipe);
    
    state.board.window_size = vec2(sapp.width().float().cast(), sapp.height().float().cast());
    sgl.texture(state.pieces_image, (id = Sg.INVALID_ID));
    
    draw(state.board&, sgl, sdtx);
    
    Easy'glue_begin_pass(sapp, sg, state.pass_action);
    
    sgl.draw_layer(sg, 0);
    sdtx.draw_layer(0);
    
    sg.end_pass();
    sg.commit();
};

fn on_event(state: *State, sapp: *Sapp.Self, event: *Sapp.Event) void = {
    if event.type == .MOUSE_DOWN && event.mouse_button == .LEFT {
        state.dirty = true;
        valid_move := click(state.board&, vec2(event.mouse_x, event.mouse_y));
        if valid_move && state.board.board.nextPlayer == .Black {
            state.play_computer_move();
        }
    }
    if event.type == .KEY_DOWN && !event.key_repeat {
        @match(event.key_code) {
            fn SPACE() => {
                state.board.show_square_labels = !state.board.show_square_labels;
            }
            fn MINUS() => {
                state.board.size *= 0.9;
            }
            fn EQUAL() => {
                state.board.size *= 1.1;
            }
            @default => return();
        }
        state.dirty = true;
    }
    if @is(event.type, .RESIZED) {
        state.dirty = true;
    }
};

// TODO: do the search on another thread
fn play_computer_move(state: *State) void = {
    // TODO:
    // ugh. has to be a pointer to make it easy to access fields 
    // and @static defaults to zeroing if it thinks its being called with one argument 
    // so you can't use () to get default fields :compiler
    // and all the `if opts.whatever` in search.fr need a @run now because backend doesn't know that the memory is constant :(
    opts :: @static(Search.StratOpts) { xxx: Search.StratOpts = (); xxx };  
    
    move := bestMove(opts, state.search&, state.board.board&, 4);
    if move { move |
        _ := state.board.board&.play(move);
    };
}

BoardView :: @struct {
    pos: Vec2;
    size: f32;
    window_size: Vec2;
    show_square_labels: bool;
    
    board: Chess.Board;
    lists: Chess.ListPool;
    click_index: ?i64;
};

fn draw(self: *BoardView, sgl: *Sgl.Self, sdtx: *Sdtx.Context) void = {
    sgl.begin(.QUADS);
    
    square :: fn(pos: Vec2, size: Vec2, colour: u32) void => 
        square_uv(pos, size, colour, vec2(0), vec2(0));
    
    square_uv :: fn(pos: Vec2, size: Vec2, colour: u32, u: Vec2, v: Vec2) void => {
        sgl.color = colour;
        w, h := (self.window_size.x, self.window_size.y);
        
        x1 := pos.x.sub(0.0).div(w).sub(1.0);
        x2 := pos.x.add(size.x).div(w).sub(1.0);
        y1 := pos.y.sub(0.0).div(h.neg()).add(1.0);
        y2 := pos.y.add(size.y).div(h.neg()).add(1.0);
        
        (u1: f32, u2: f32, v1: f32, v2: f32) := (u.x, u.y, v.x, v.y);
        sgl.v2f_t2f(x1, y1, u1, v1);
        sgl.v2f_t2f(x2, y1, u2, v1);
        sgl.v2f_t2f(x2, y2, u2, v2);
        sgl.v2f_t2f(x1, y2, u1, v2);
    };
    
    sgl.load_identity();
    
    base := self.pos;
    c := true;
    s: f32 = self.size / 8;
    
    L, D := (pack_rgba(1.0, 0.808, 0.620, 1.0), pack_rgba(0.820, 0.545, 0.278, 1.0));
    // solid background
    square(base, vec2(s*8, s*8), D);  
    // add in every other square
    c := true;
    range(0, 8) { file |
        range(0, 8) { rank |
            if c {
                pos := to_pixels(file, rank);
                square(base + pos, vec2(s, s), L);
            }
            c = !c;
        }
        c = !c;
    }
    
    set_font_scale :: fn(label_scale: f32) => {
        sdtx.desc.char_width = s * label_scale;
        sdtx.desc.char_height = s * label_scale;
        sdtx.canvas(self.window_size.x * 2, self.window_size.y * 2);
    };
    
    set_text_position :: fn(pos: Vec2) => {
        sdtx.pos.x = pos.x / sdtx.desc.char_width;
        sdtx.pos.y = pos.y / sdtx.desc.char_height;
    };
    
    to_pixels :: fn(file, rank) => 
        vec2(s * file.int().float().cast(), s * (7-rank).int().float().cast());
    
    result := self.board&.gameOverReason(self.lists&);
    if result != .Continue {
        set_font_scale(0.8);
        set_text_position(base + vec2(0, -sdtx.desc.char_height));
        sdtx.color = pack_rgba(1.0, 0.0, 1.0, 1.0);
        sdtx.put(@tfmt("%", result));
    };
    
    set_font_scale(0.2);
    msg := zeroed(Array(u8, 2));
    @if(self.show_square_labels)
    iter { rank, file, pos, p |
        ::import("@/examples/chess/uci.fr");
        msg&[0] = fileToLetter(file.trunc()).ascii_to_upper();
        msg&[1] = rankToLetter(rank.trunc());
        set_text_position(pos + base);
        sdtx.color = pack_rgba(0.0, 0.0, 1.0, 1.0);
        sdtx.put(msg&.items());
    };
    
    if self.show_square_labels {
        set_font_scale(0.2);
        set_text_position(base + vec2(0, self.size + sdtx.desc.char_height));
        sdtx.color = pack_rgba(1.0, 0.0, 1.0, 1.0);
        sdtx.put(@tfmt("%", self.board&.t_fen()));
    };
    
    note :: fn(i: u8, colour: u32) void => {
        scale: f32 = 0.60;
        rank, file := i.div_mod(8);
        pos := to_pixels(file, rank);
        square(base + pos + vec2((1.0 - scale) / 2 * s), vec2(s * scale), colour);
    };
    
    if self.click_index { i |
        break :: local_return;
        rank, file := i.div_mod(8);
        p := self.board&.get(file, rank);
        if p.kind() == .Empty {
            break();
        };
        
        // TODO: only generate moves from the one piece, not all of them!
        moves := possibleMoves(self.board&, p.colour(), self.lists&);
        
        note(i.trunc(), pack_rgba(1.0, 1.0, 0.0, 1.0));
        for moves { move |
            if move.from == i.trunc() {
                note(move.to, pack_rgba(0.678, 0.847, 0.902, 1.0));
            }
        };
        
        self.lists&.release(moves);
    };
    
    if UGLY {
        set_font_scale(0.5);
        iter { rank, file, pos, p |
            set_text_position(pos + base + vec2(s/4));
            msg&[0] = p.toChar();
            sdtx.color = @if(p.colour() == .White, pack_rgba(1.0, 1.0, 1.0, 1.0), pack_rgba(0.0, 0.0, 0.0, 1.0));
            sdtx.put(msg&.items().slice(0, 1));
        };
    } else {
        sgl.end();
        sgl.begin(.QUADS);
        sgl.texturing_enabled = true;
        
        iter { rank, file, pos, p |
            if p.kind() != .Empty {
                (w: f32, h: f32) := (1.0 / 6.0, 1.0 / 2.0);
                x: f32 = p.kind().raw().int().sub(1).float().cast();
                y: f32 = p.colour().eq(.Black).int().float().cast();
                // TODO: how much do i care about the outline? 
                //       i could just have one row in the image file 
                //       and invert the colours for the other side. 
                square_uv(base + pos, vec2(s, s), 0xFFFFFFFF, vec2(x*w, x*w + w), vec2(y*h, y*h + h));
            }
        };
        
        sgl.end();
        sgl.begin(.QUADS);
    };
    
    sgl.end();
    
    iter :: fn($body: @Fn(rank: i64, file: i64, pos: Vec2, p: Chess.Piece) void) void => {
        range(0, 8) { file |
            range(0, 8) { rank |
                p := self.board&.get(file, rank);
                body(rank, file, to_pixels(file, rank), p);
            };
        };
    }    
}

fn click(self: *BoardView, pos: Vec2) bool = {
    // TODO: why are these off by a factor of two compared to the rendering ones? is it high_dpi related?
    pos *= 2;
    pos -= self.pos;
    if pos.x < 0 || pos.y < 0 || pos.x > self.size || pos.y > self.size {
        return(false)
    };
    pos /= self.size / 8;
    rank, file := (7 - pos.y.cast().int(), pos.x.cast().int());
    new := rank * 8 + file;

    if self.click_index { old |
        if infer_play_move(self.board&, old, new, self.lists&) {
            self.click_index = .None;
            return(true);
        }
    };
    self.click_index = (Some = new);
    false
}

// TODO: be able to ask for promotion
fn infer_play_move(self: *Chess.Board, from: i64, to: i64, lists: *Chess.ListPool) bool = {
    // TODO: seperate out the infer (from, to) -> Move logic
    // TODO: only generate moves from the one piece, not all of them!
    moves := possibleMoves(self, lists);
    
    for moves { move |
        if move.from == from.trunc() && move.to == to.trunc() {
            unmove := self.play(move);
            lists.release(moves);  // :defer
            return true;
        }
    };
    
    lists.release(moves);  // :defer
    false
}

main :: fn() void = 
    Easy'start(State);

driver :: fn(vtable: *ImportVTable) void = 
    Easy'build_for_graphics(vtable, @source_file_name()); 

Chess :: import("@/examples/chess/moves.fr");
Search :: import("@/examples/chess/search.fr");
#include_std("graphics/lib.fr");

Stb :: {
    root := Foreign'stb();
    Ffi  :: import("@/examples/import_c/ffi.fr");
    c_source := @tfmt("""
        #define STB_IMAGE_IMPLEMENTATION
        #define STBI_ONLY_PNG
        #define STBI_NO_SIMD
        #define STBI_NO_STDIO
        #include "%/stb_image.h"
    """, root);
    Ffi'include(current_compiler_context(), c_source)
}
