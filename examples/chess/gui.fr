
// choose between using images or letters to represent pieces. 
// UGLY=false: takes an extra 600ms to compile my c compiler and stb_image to load the png file. 
// UGLY=true: removes the dependency on stb_image. makes this program more self contained.
// TODO: make the import_module caching work well enough that its less embarrassing. 
UGLY :: false;

State :: @struct(
    pipe: Sgl.Pipeline,
    pass_action: Sg.PassAction,
    text: Sdtx.Self,
    draw: Sgl.Self,
    sg: Sg.Self,
    pieces_image: Sg.Image,  // only used when UGLY=false

    board: BoardView,
    dirty: bool,
);

fn on_init(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    allocator := general_allocator();
    Chess'Precalc'initTables(allocator);
    sapp.set_window_title("Chess");
    
    state.draw&.setup(
        allocator = allocator,
        sg = sg,
    );
    
    // TODO: my png is super blury. maybe i need to find an svg renderer. 
    //       also i like the idea of text file of lines to draw more than blob of compressed pixels. 
    @if(!UGLY) {
        // The binary is smaller if it just includes the png+stb_image and decompresses at runtime, 
        // but sometimes it's more fun to flex that this works at comptime :)
        p, w, h := @run {
            // The same textures every other low effort chess game in the universe found by googling for free chess icons.
            // https://commons.wikimedia.org/wiki/File:Chess_Pieces_Sprite.svg jurgenwesterhof (adapted from work of Cburnett), CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0, via Wikimedia Commons
            data := include_bytes("examples/chess/data/pieces.png");
            src_w :i32= 0;
            src_h :i32= 0;
            bytes_per_pixel :i32= 4; 
            pixels := Stb'stbi_load_from_memory(data.ptr, data.len.intcast(), src_w&, src_h&, zeroed(*i32), bytes_per_pixel);
            (pixels.slice(intcast(src_w*src_h*bytes_per_pixel)), src_w, src_h)
        };
    
        state.pieces_image = sg.make(
            width = w,
            height = h,
            pixel_format = .RGBA8,
            label = "chess-pieces",
            data = (
                subimage = (
                    (p, ..""), 
                    ..zeroed(Array([]u8, 16)),
                ),
            ),
        );
    };
    
    state.text&.setup(
        allocator = allocator,
        fonts = @slice(Sdtx.font.kc854),
        sg = sg,
    );
    
    init_pipeline(state.draw&, state.pipe&, sg, (colors = (
        (blend = (  // This makes transparency work
            enabled = true,
            src_factor_rgb = .SRC_ALPHA,
            dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,
        )),
        ..,
    )));
    
    state.pass_action.colors&[0] = (
        load_action = .CLEAR,
        clear_value = (r = 0.3, g = 0.3, b = 0.3, a = 1.0),
    );
    
    state.board = (
        board = initial(),
        lists = init(allocator),
        click_index = .None,
        pos = vec2(100.0),
        size = 600.0,
        window_size = zeroed Vec2,
        show_square_labels = false,
    );
    
    state.dirty = true;
};
  
fn on_render(state: *State, sapp: *Sapp.Self, sg: *Sg.Self) void = {
    @if(Easy'should_skip_frame(sapp, state.dirty&)) return();

    sgl := state.draw&;
    sdtx := state.text.default_context&;
    
    sgl.defaults();
    sgl.viewport(0.intcast(), 0.intcast(), sapp.width().intcast(), sapp.height().intcast(), true);
    sgl.load_pipeline(state.pipe);
    
    state.board.window_size = vec2(sapp.width().float().cast(), sapp.height().float().cast());
    sgl.texture(state.pieces_image, (id = Sg.INVALID_ID));
    
    draw(state.board&, sgl, sdtx);
    
    Easy'glue_begin_pass(sapp, sg, state.pass_action);
    
    sgl.draw_layer(sg, 0);
    sdtx.draw_layer(0);
    
    sg.end_pass();
    sg.commit();
};

fn on_event(state: *State, sapp: *Sapp.Self, event: *Sapp.Event) void = {
    ::enum(@type event.mouse_button);
    if event.type == .MOUSE_DOWN && event.mouse_button == .LEFT {
        state.dirty = true;
        click(state.board&, vec2(event.mouse_x, event.mouse_y));
    }
    if event.type == .KEY_DOWN && event.key_code == .SPACE && !event.key_repeat {
        state.dirty = true;
        state.board.show_square_labels = !state.board.show_square_labels;
    }
    if @is(event.type, .RESIZED) {
        state.dirty = true;
    }
};

BoardView :: @struct {
    pos: Vec2;
    size: f32;
    window_size: Vec2;
    show_square_labels: bool;
    
    board: Chess.Board;
    lists: Chess.ListPool;
    click_index: ?i64;
};

fn draw(self: *BoardView, sgl: *Sgl.Self, sdtx: *Sdtx.Context) void = {
    sgl.begin(.QUADS);
    
    square :: fn(pos: Vec2, size: Vec2, colour: u32) void => 
        square_uv(pos, size, colour, vec2(0), vec2(0));
    
    square_uv :: fn(pos: Vec2, size: Vec2, colour: u32, u: Vec2, v: Vec2) void => {
        sgl.color = colour;
        w, h := (self.window_size.x, self.window_size.y);
        
        x1 := pos.x.sub(0.0).div(w).sub(1.0);
        x2 := pos.x.add(size.x).div(w).sub(1.0);
        y1 := pos.y.sub(0.0).div(h.neg()).add(1.0);
        y2 := pos.y.add(size.y).div(h.neg()).add(1.0);
        
        (u1: f32, u2: f32, v1: f32, v2: f32) := (u.x, u.y, v.x, v.y);
        sgl.v2f_t2f(x1, y1, u1, v1);
        sgl.v2f_t2f(x2, y1, u2, v1);
        sgl.v2f_t2f(x2, y2, u2, v2);
        sgl.v2f_t2f(x1, y2, u1, v2);
    };
    
    sgl.load_identity();
    
    base := self.pos;
    c := true;
    s: f32 = self.size / 8;
    
    L, D := (pack_rgba(1.0, 0.808, 0.620, 1.0), pack_rgba(0.820, 0.545, 0.278, 1.0));
    // solid background
    square(base, vec2(s*8, s*8), D);  
    // add in every other square
    c := true;
    range(0, 8) { file |
        range(0, 8) { rank |
            if c {
                pos := to_pixels(file, rank);
                square(base + pos, vec2(s, s), L);
            }
            c = !c;
        }
        c = !c;
    }
    
    set_font_scale :: fn(label_scale: f32) => {
        sdtx.desc.char_width = s * label_scale;
        sdtx.desc.char_height = s * label_scale;
        sdtx.canvas(self.window_size.x * 2, self.window_size.y * 2);
    };
    
    set_text_position :: fn(pos: Vec2) => {
        sdtx.pos.x = pos.x / sdtx.desc.char_width;
        sdtx.pos.y = pos.y / sdtx.desc.char_height;
    };
    
    to_pixels :: fn(file, rank) => 
        vec2(s * file.int().float().cast(), s * (7-rank).int().float().cast());
    
    set_font_scale(0.2);
    msg := zeroed(Array(u8, 2));
    @if(self.show_square_labels)
    iter { rank, file, pos, p |
        #use("@/examples/chess/uci.fr");
        msg&[0] = fileToLetter(file.trunc()).ascii_to_upper();
        msg&[1] = rankToLetter(rank.trunc());
        set_text_position(pos + base);
        sdtx.color = pack_rgba(0.0, 0.0, 1.0, 1.0);
        sdtx.put(msg&.items());
    };
    
    note :: fn(i: u8, colour: u32) void => {
        scale: f32 = 0.50;
        rank, file := i.div_mod(8);
        pos := to_pixels(file, rank);
        square(base + pos + vec2((1.0 - scale) / 2 * s), vec2(s * scale), colour);
    };
    
    if self.click_index { i |
        break :: local_return;
        rank, file := i.div_mod(8);
        p := self.board&.get(file, rank);
        ::enum(@type p.kind());
        if p.kind() == .Empty {
            break();
        };
        
        // TODO: only generate moves from the one piece, not all of them!
        moves := possibleMoves(self.board&, p.colour(), self.lists&);
        
        for moves { move |
            if move.from == i.trunc() {
                note(move.to, pack_rgba(0.678, 0.847, 0.902, 1.0));
            }
        };
        
        self.lists&.release(moves);
    };
    
    if UGLY {
        set_font_scale(0.5);
        iter { rank, file, pos, p |
            set_text_position(pos + base + vec2(s/4));
            msg&[0] = p.toChar();
            sdtx.color = @if(p.colour() == .White, pack_rgba(1.0, 1.0, 1.0, 1.0), pack_rgba(0.0, 0.0, 0.0, 1.0));
            sdtx.put(msg&.items().slice(0, 1));
        };
    } else {
        sgl.end();
        sgl.begin(.QUADS);
        sgl.texturing_enabled = true;
        
        iter { rank, file, pos, p |
            if p.kind() != .Empty {
                (w: f32, h: f32) := (1.0 / 6.0, 1.0 / 2.0);
                x: f32 = p.kind().raw().int().sub(1).float().cast();
                y: f32 = p.colour().eq(.Black).int().float().cast();
                // TODO: how much do i care about the outline? 
                //       i could just have one row in the image file 
                //       and invert the colours for the other side. 
                square_uv(base + pos, vec2(s, s), 0xFFFFFFFF, vec2(x*w, x*w + w), vec2(y*h, y*h + h));
            }
        };
        
        sgl.end();
        sgl.begin(.QUADS);
    };
    
    sgl.end();
    
    iter :: fn($body: @Fn(rank: i64, file: i64, pos: Vec2, p: Chess.Piece) void) void => {
        range(0, 8) { file |
            range(0, 8) { rank |
                p := self.board&.get(file, rank);
                body(rank, file, to_pixels(file, rank), p);
            };
        };
    }    
}

fn click(self: *BoardView, pos: Vec2) void = {
    // TODO: why are these off by a factor of two compared to the rendering ones? is it high_dpi related?
    pos *= 2;
    pos -= self.pos;
    if pos.x < 0 || pos.y < 0 || pos.x > self.size || pos.y > self.size {
        return()
    };
    pos /= self.size / 8;
    rank, file := (7 - pos.y.cast().int(), pos.x.cast().int());
    new := rank * 8 + file;

    if self.click_index { old |
        if infer_play_move(self.board&, old, new, self.lists&) {
            self.click_index = .None;
            return();
        }
    };
    self.click_index = (Some = new);
}

// TODO: be able to ask for promotion
fn infer_play_move(self: *Chess.Board, from: i64, to: i64, lists: *Chess.ListPool) bool = {
    // TODO: seperate out the infer (from, to) -> Move logic
    // TODO: only generate moves from the one piece, not all of them!
    moves := possibleMoves(self, lists);
    
    for moves { move |
        if move.from == from.trunc() && move.to == to.trunc() {
            unmove := self.play(move);
            lists.release(moves);  // :defer
            return true;
        }
    };
    
    lists.release(moves);  // :defer
    false
}

fn main() void = 
    Easy'start(State);

fn driver(vtable: *ImportVTable) void = 
    Easy'build_for_graphics(vtable, "examples/chess/gui.fr"); 

Chess :: import("@/examples/chess/moves.fr");
#include_std("graphics/lib.fr");

Stb :: {
    get  :: import("@/examples/testing.fr").fetch_or_crash;
    root := get("https://github.com/nothings/stb/archive/f0569113c93ad095470c54bf34a17b36646bbbb5.zip", 1754150, "b62be3009cb9d4b6385bd4854bddf72d8e91f4e19d1347d6cf9589b19f70d45d", "stb-f0569113c93ad095470c54bf34a17b36646bbbb5");
    Ffi  :: import("@/examples/import_c/ffi.fr");
    c_source := @tfmt("""
        #define STB_IMAGE_IMPLEMENTATION
        #define STBI_ONLY_PNG
        #define STBI_NO_SIMD
        #define STBI_NO_STDIO
        #include "%/stb_image.h"
    """, root);
    Ffi'include(current_compiler_context(), c_source)
}
