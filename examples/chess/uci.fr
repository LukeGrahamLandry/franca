// Universal Chess Interface: https://gist.github.com/DOBRO/2592c6dad754ba67e6dcaec8c90165bf

fn fromFen(s: Str) ?Board = {
    b: Board = blank();
    if !fromFenNoUpdateChecks(b&, s) {
        return(.None)
    }
    b.checks = getChecksInfo(b&, b.nextPlayer);
    b.pastBoardHashes&[0] = b.zoidberg;
    (Some = b)
}

// note: not atomic. failed parse will write junk on the board. 
fn fromFenNoUpdateChecks(self: *Board, s: Str) bool = {
    err :: fn(cond) => @if(cond) return(false);

    err(s.len < 15);
    self.zoidberg = 1;
    file, rank, i := (0, 7, 0);
    while => i < s.len && s[i] != " ".ascii() {
        letter := s[i]; i += 1;
        if letter.dec_digit() { count |
            file += count;
        } else {
            if letter == "/".ascii() {
                err(file != 8);
                file = 0;
                err(rank == 0); // This assumes no trailing '/'
                rank -= 1;
            } else {
                ::?Piece;
                piece: Piece = fromChar(letter) || return(false);
                self.set(file, rank, piece);
                file += 1;
                err(rank > 8);
            }
        };
    }
    err(file != 8);
    err(i + 2 >= s.len);
    err(s[i] != " ".ascii()); i += 1;
    player := s[i]; i += 1;

    self.nextPlayer = @switch(player) {
        @case("w".ascii()) => .White;
        @case("b".ascii()) => .Black;
        @default => return(false);
    };
    
    // These fields are less important so are optional.
    self.castling = CastlingRights.NONE;
    self.frenchMove = .none;
    self.halfMoveDraw = 0;
    self.fullMoves = 1;
    
    @if(i == s.len) return(true);
    err(s[i] != " ".ascii()); i += 1;
    while => i < s.len && s[i] != " ".ascii() {
        @switch(s[i]) {
            @case("K".ascii()) => self.castling&.set(.White, false, true);
            @case("Q".ascii()) => self.castling&.set(.White, true, true);
            @case("k".ascii()) => self.castling&.set(.Black, false, true);
            @case("q".ascii()) => self.castling&.set(.Black, true, true);
            @case("-".ascii()) => ();  // nobody can castle
            @default => err(true);
        };
        i += 1;
    };
    
    @if(i == s.len) return(true);
    err(s[i] != " ".ascii()); i += 1;
    
    // TODO: update zoidberg for turn index / french move / castling ?
    
    if s[i] != "-".ascii() {
        err(i + 1 >= s.len);
        targetRank := @if(self.nextPlayer == .White, "6".ascii(), "3".ascii());
        // The target must be on the right rank given the player that just moved.
        err(s[i + 1] != targetRank);
        ::?u8;
        self.frenchMove = (file = letterToFile(s[i]) || return(false));
        i += 1;
    }
    // else, no french move is possible.
    i += 1;

    @if(i == s.len) return(true);
    err(s[i] != " ".ascii()); i += 1;
    
    halfMoveDraw := advance_number(s, i&) 
        || return(false);
    self.halfMoveDraw = halfMoveDraw.trunc();
    
    @if(i == s.len) return(true);
    err(!s[i].is_ascii_digit());  // because advance_number eats trailing whitespace
    
    fullMoves := advance_number(s, i&) 
        || return(false);
    self.fullMoves = fullMoves.trunc();

    true
}

fn letterToFile(letter: u8) ?u8 = {
    @if (letter < "a".ascii() || letter > "h".ascii()) return(.None);
    (Some = letter - "a".ascii())
}

fn letterToRank(letter: u8) ?u8 = {
    @if (letter < "1".ascii() || letter > "8".ascii()) return(.None);
    (Some = letter - "1".ascii())
}

fn fromChar(letter: u8) ?Piece = {
    (Some = new(
        colour = @if(letter.ascii_is_upper(), .White, .Black),
        kind = @switch(letter.ascii_to_upper()) {
            @case("P".ascii()) => .Pawn;
            @case("B".ascii()) => .Bishop;
            @case("N".ascii()) => .Knight;
            @case("R".ascii()) => .Rook;
            @case("Q".ascii()) => .Queen;
            @case("K".ascii()) => .King;
            @default => return(.None);
        },
    ))
}

fn toUnicode(self: Piece) Str = {
    // for empty, i want something that looks monospace even in a proportional font.
    // underscore seems to work better than space or . or ⋅
    letters :: "_♔♕♗♘♖♙_♚♛♝♞♜♟";  // :PieceKindOrderMatters
    off :: @const_slice(@as(u8) 0, 1, 4, 7, 10, 13, 16, 19, 20, 23, 26, 29, 32, 35, 38);  // TODO: use decode_utf8 at comptime
    i := int(self.kind().raw() + self.colour().raw() * 7);
    lo, hi := (off[i].int(), off[i + 1].int());
    letters.slice(lo, hi)
}

fn toChar(self: Piece) u8 = {
    letters :: " kqbnrp";  // :PieceKindOrderMatters
    ::enum(Kind);
    letter := letters[self.kind().raw().int()];
    @match(self.colour()) {
        fn White() => letter.ascii_to_upper();
        fn Black() => letter;
    }
}

max_fen_length :: 8*8 +8+1+4+1+2+1+3+1+3;

fn writeFen(self: *Board, out: *List(u8)) void = {
    out.reserve(max_fen_length);
    range(0, 8) { rank |
        empty := 0;
        range(0, 8) { file |
            continue :: local_return;
            p := self.get(file, 7 - rank);
            if p.is_empty() {
                empty += 1;
                continue();
            }
            if empty > 0 {
                @fmt(out, "%", empty);
                empty = 0;
            }
            out.push(p.toChar());
        }
        @if(empty > 0) @fmt(out, "%", empty);
        @if(rank < 7)  @fmt(out, "/");
    }

    @fmt(out, " % ", @if(self.nextPlayer == .White, "w", "b"));

    @if(self.castling.get(.White, false)) @fmt(out, "K");
    @if(self.castling.get(.White,  true)) @fmt(out, "Q");
    @if(self.castling.get(.Black, false)) @fmt(out, "k");
    @if(self.castling.get(.Black,  true)) @fmt(out, "q");
    @if(!self.castling.any()) @fmt(out, "-");

    @match(self.frenchMove) {
        fn none() => @fmt(out, " - ");
        fn file(file) => {
            @fmt(out, " ");
            out.push(fileToLetter(file));
            @fmt(out, "% ", @if(self.nextPlayer == .White, "6", "3"));
        };
    }

    @fmt(out, "% %", self.halfMoveDraw, self.fullMoves);
}

fn fileToLetter(file: u8) u8 = {
    @debug_assert(file < 8);
    "a".ascii() + file
}

fn rankToLetter(rank: u8) u8 = {
    @debug_assert(rank < 8);
    "1".ascii() + rank
}

// TODO: make sure this does the right thing for castling
//       e1g1 means white short castling -- https://gist.github.com/DOBRO/2592c6dad754ba67e6dcaec8c90165bf
fn writeAlgebraic(move: Move, out: *List(u8)) void = {
    out.reserve(4 + int(move.action == .promote));
    
    fromRank, fromFile := move.from.div_mod(8);
    toRank, toFile := move.to.div_mod(8);
    out.push(fileToLetter(fromFile));
    out.push(rankToLetter(fromRank));
    out.push(fileToLetter(toFile));
    out.push(rankToLetter(toRank));
    
    if move.action == .promote {
        p: Piece = new(kind = move.promote, colour = .Black /*lower case*/);
        out.push(p.toChar());
        @debug_assert(@is(p.kind(), .Queen, .Knight, .Rook, .Bishop));
    }
}

// GUI -> Engine
Command :: @tagged(
    uci: void, // Init,
    isready, // AreYouReady,
    ucinewgame, // NewGame,
    quit,
    stop,
    ponderhit,
    register, // TODO
    debug: bool,
    // TODO: this doesn't work for sending. board state doesn't represent the game correctly because of repitition draws. 
    //       (its fine for the engine recieving because playing the moves to build the board fills the pastBoardHashes array)
    SetPosition: @struct(board: *Board), // lifetime! don't save these pointers!
    Go: Go,
    SetOption: @struct(name: Str, value: Str),
    Unknown: Str,
);

// field names matter!
Go :: @struct {
    movetime: ?i64 = .None;  // maxSearchTimeMs
    depth: ?i64 = .None;  // maxDepthPly
    perft: ?i64 = .None;
    winc: ?i64 = .None;
    binc: ?i64 = .None;
    wtime: ?i64 = .None;
    btime: ?i64 = .None;
    mate: ?i64 = .None;
    nodes: ?i64 = .None;
    movestogo: ?i64 = .None;
    infinite := false;
    ponder := false;
    searchmoves: ?[]Move = .None;
};

// Engine -> GUI
Response :: @tagged(
    uciok: void, // InitOk,
    readyok,
    Info: UciInfo,
    BestMove: @struct {
        best: ?Move;
        ponder: ?Move;
    },
    PerftDivide: PerftNode,
    PerftDone: @struct(total: i64),
    copyprotection: Str,
    id: @struct(key: Str, value: Str),
    Unknown: Str,
);

UciInfo :: @struct {
    depth: ?i64 = .None;
    seldepth: ?i64 = .None;
    multipv: ?i64 = .None;
    nodes: ?i64 = .None;
    nps: ?i64 = .None;
    hashfull: ?i64 = .None;
    tbhits: ?i64 = .None;
    sbhits: ?i64 = .None;
    time: ?i64 = .None;
    curmove: ?Move = .None;
    curmovenumber: ?i64 = .None;
    string: ?Str = .None;
    
    mate: ?i64 #prefix("score") = .None;
    cp: ?i64 #prefix("score") = .None;
    // TODO: score lowerbound/upperbound
    
    // note: when i parse these, action won't be set so you have to compare it to freshly generated moves from the board. 
    pv: ?[]Move = .None;
    refutation: ?[]Move = .None;
    currline: ?[]Move = .None;
};

PerftNode :: @struct(move: Move, count: i64);

// :compilerbug/ordering it doesn't like when 'display' overload set references UciCommand->Board,
//      probably same :BitFieldsCompileError i was having before. so Board->Piece->@bit_fields
fn displayXXX(cmd: *Command, out: *List(u8)) void = {
    @match(cmd) {
        fn Go(args) => {
            @fmt(out, "go");
            display_fields(Go, args, out);
        }
        fn SetPosition(state) => {
            @fmt(out, "position fen ");
            writeFen(state.board, out);
        }
        fn SetOption(option) => {
            @fmt(out, "setoption name % value %", option.name, option.value);
        }
        fn Unknown(s) => @fmt(out, "%", s);
        @default => @fmt(out, "%", cmd.tag());
    }
    @fmt(out, "\n");
}

// TODO: this sucks. use read_punct?
// SetPosition allocates the board pointer, caller owns it now.
fn parse(s: Str, a: Alloc, lists: *ListPool) Command = {
    i := 0;
    cmd := advance_word(s, i&);
    simple :: @const_slice(Command.Tag().uci, .isready, .ucinewgame, .quit, .stop, .ponderhit);
    inline_for simple { $it |
        if cmd == it.name.str() {
            return it;
        }
    };
    
    if cmd == "debug" {
        return(debug = @switch(advance_word(s, i&)) {
            @case("on") => true;
            @case("off") => false;
            @default => return(Unknown = s);
        });
    }
    
    if cmd == "position" {
        word := advance_word(s, i&);
        fen := @switch(word) {
            @case("fen") => advance_word(s, i&);
            @case("startpos") => INIT_FEN;
            @default => return(Unknown = s);
        };
        board: Board = fromFen(fen) 
            || return(Unknown = s);
        
        word := advance_word(s, i&);
        if word == "moves" {
            moves := advance_moves(s, i&, temp());
            for moves { it |
                inferPlayMove(board&, it, lists) ||
                    return(Unknown = s);  // TODO: different error for illegal move? 
            };
            // TODO: maybe i want to return the moves instead?
            //       this is destroying information and since the @tagged doesn't have it, you can't send a message that includes previous moves. 
            return(SetPosition = board);
        }
    }
    if cmd == "go" {
        result := parse_fields(Go, s, i&, a);
        return(Go = result);
    }

    // TODO: the rest
    (Unknown = s)
}

// note: action field is unset
fn readAlgebraic(s: Str) ?Move = {
    @if(s.len < 4) return(.None);
    fromFile := letterToFile(s[0]) || return(.None);
    fromRank := letterToRank(s[1]) || return(.None);
    toFile := letterToFile(s[2]) || return(.None);
    toRank := letterToRank(s[3]) || return(.None);

    (Some = (
        from = fromRank * 8 + fromFile,
        to = toRank * 8 + toFile,
        action = .none,
        promote = @if(s.len > 4, {
            ::?Piece;
            p: Piece = fromChar(s[4]) || return(.None);
            p.kind()
        }, .Empty),
    ))
}

// TODO: this sucks. use read_punct?
fn parse(s: Str) Response = {
    i := 0;
    cmd := advance_word(s, i&);
    simple :: @const_slice(Response.Tag().uciok, .readyok);
    inline_for simple { $it |
        @if(cmd == it[].name_str()) {
            result := zeroed Response;
            result&.tag_ptr()[] = it[];
            return result;
        }
    };
    
    if cmd == "info" {
        result := parse_fields(UciInfo, s, i&, temp());
        return(Info = result);
    }
    if cmd == "id" {
        key := advance_word(s, i&);
        return(id = (key = key, value = s.rest(i)));
    }
    /* // TODO
    if (std.mem.startsWith(u8, str, "bestmove")) {
        var words = std.mem.splitScalar(u8, str, ' ');
        std.debug.assert(std.mem.eql(u8, words.next().?, "bestmove"));
        const first = words.next() orelse return error.UnknownUciStr;
        if (std.mem.eql(u8, first, "(none)")) || first == "0000" {
            return .{ .BestMove = null };
        } else if (first.len <= 5) {
            var move = std.mem.zeroes([5]u8);
            @memcpy(move[0..first.len], first);
            return .{ .BestMove = move };
        }
    } 
    */
    
    i := 0;
    if ((s.len > 4 && s[4] == ":".ascii()) || (s.len > 5 && s[5] == ":".ascii())) { // perft
        while => s[i] != ":".ascii() {
            i += 1;
        };
        move: Move = readAlgebraic(s.slice(0, i)) 
            || @panic("TODO: readAlgebraic error");
        
        i += 1;
        while => s[i].is_ascii_whitespace() {
            i += 1;
        };
        
        // TODO: sane way of detecting if there was no number to parse
        value, _ := convert_number_dyn(s.rest(i), 10);
        
        return(PerftDivide = (move = move, count = value));
    } 
    if s.starts_with("Nodes searched:") {
        i += "Nodes searched:".len();
        while => s[i].is_ascii_whitespace() {
            i += 1;
        };
        
        // TODO: sane way of detecting if there was no number to parse
        value, _ := convert_number_dyn(s.rest(i), 10);
        return(PerftDone = (total = value));
    };

    (Unknown = s)
}

fn display(cmd: *Response, out: *List(u8)) void = {
    @match(cmd) {
        fn uciok() => @fmt(out, "uciok");
        fn readyok() => @fmt(out, "readyok");
        fn BestMove(move) => {
            @fmt(out, "bestmove ");
            if move { move |
                writeAlgebraic(move[], out);
            } else {
                @fmt(out, "(none)"); // TODO: should this be "0000" instead? 
            }
        }
        fn Info(info) => {
            @fmt(out, "info");
            display_fields(UciInfo, info, out);
        }
        fn id(it) => @fmt(out, "id % %", it.key, it.value);
        fn PerftDivide() => panic("TODO: write PerftDivide");
        fn PerftDone() => panic("TODO: write PerftDone");
        fn Unknown(s) => @fmt(out, "%", s);
    }
    @fmt(out, "\n");
}

// An external engine controlled by uci via stdio. 
EngineProcess :: @struct {
    process: RunningProcess; // /TODO
    output: List(u8);
    cursor: i64;
};

fn init(a: Alloc) EngineProcess = {
    // TODO: helpful error message if stockfish isnt installed.
    initOther(@slice(@fmt_cstr("stockfish"), zeroed CStr), a)
}

fn initOther(command: []CStr, a: Alloc) EngineProcess = {
    p := sys_capture_exec(command);
    if p&.is_err() {
        @panic("TODO: EngineProcess init error: %", p.Err);
        // TODO: i feel like you shouldn't handle init errors, they should just be folded in to process error while running, 
        //       because why have seperate codepaths for an error now vs an error 0.00001ms later?  
    };
    
    (process = p.Ok, output = list(a), cursor = 0)
}

fn deinit(self: *EngineProcess) void = {
    _ = try self.process.kill();
}

fn send(self: *EngineProcess, cmd: Command) void = {
    input := u8.list(temp());
    displayXXX(cmd&, input&);
    //@print("[SEND] %", input.items());  // TODO: cli flag somewhere to log uci messages for debugging
    
    // TODO: annoying that i don't have a way to send input without also reading output
    error := u8.list(temp());
    input := input.items();
    status := poll(self.process&, @slice(self.output&, error&), true, input&, false, false);
    
    if error.len != 0 || status&.is_err() || status.Ok.is_some() || input.len != 0 {
        @panic("TODO: finish EngineProcess.send");
        // aaaa..... i just want to debug my perft, this doesn't matter yet. 
    }
}

fn recieve(self: *EngineProcess) ?Response = {
    while => self.cursor < self.output.len && self.output[self.cursor].is_ascii_whitespace() {
        self.cursor += 1;
    };

    i := self.cursor;
    while => i < self.output.len && self.output[i] != "\n".ascii() {
        i += 1;
    };
    
    if i == self.output.len {
        error := u8.list(temp());
        input := "";
        status := poll(self.process&, @slice(self.output&, error&), true, input&, false, false);
    
        // TODO: process the new stuff in self.output before these errors tho. 
        
        { // TODO: ugh
            // for now just forward debug logging
            // TODO: do i want to add fake entries to UciResult for that? 
            if error.len() != 0 {
                eprint(error.items());
            };
            // TODO: this should clearly be part of the UciResult tho. 
            //       eventually i want to make a gui for this and probably want to show logs in it somewhere. 
            //       tho you do need to treat io errors as different from parsing errors since one could be helped by restarting the engine. 
            if status&.is_err() {
                @eprintln("UCI engine error: %", status.Err);
                return(Some = (Unknown = "error"));
            };
            if status.Ok { status |
                @eprintln("UCI engine exit status: %", status);
                return(Some = (Unknown = "error"));
            };
        };
    };
    
    while => i < self.output.len && self.output[i] != "\n".ascii() {
        i += 1;
    };
    command := self.output.items().slice(self.cursor, i);
    if command.len == 0 {
        return(.None);
    }
    if i == self.output.len || self.output[i] != "\n".ascii() {
        // don't have a full command yet
        return(.None);
    }
    self.cursor = i;  // can't shift out old output here because the parsed command can point to it, TODO: shift out at the beginning i guess
    while => self.cursor < self.output.len && self.output[self.cursor].is_ascii_whitespace() {
        self.cursor += 1;
    };
    
    //@println("[RECIEVE] %", command);  // TODO: cli flag somewhere to log uci messages for debugging
    result: Response = parse(command);
    (Some = result)
}

fn sync(self: *EngineProcess) void = {
    self.send(.isready);
    // TODO: don't busy wait.
    dowhile {
        continue :: local_return;
        msg := self.recieve() || continue(true);
        !msg&.is(.readyok)
    };
}

parse_fields :: fn($T: Type, s: Str, i: *i64, a: Alloc) T #generic = {
    result: T = ();
    
    while => i[] < s.len {
        continue :: local_return;
        word := advance_word(s, i);

        inline_for get_fields(T) { $field |
            it := T.get_field_ptr(result&, field);
            
            if has_tag(field, @symbol "prefix", Str) { prefix |
                // TODO: this is wrong. really you want to unwind at the end of the loop body if this field didn't match
                //       since there's multiple with the same prefix and also skip this field if the prefix doesn't match. 
                if word == prefix {
                    word = advance_word(s, i);
                };
            };
            
            name :: field[].name.str();
            if word == name {
                @inline_switch(field[].ty) {
                    @case(?i64) => {
                        value := advance_number(s, i) ||  
                            continue(); // TODO: error?
                        it[] = (Some = value);
                        continue();
                    };
                    @case(bool) => {
                        it[] = true;
                    };
                    @case(?[]Move) => {
                        moves := advance_moves(s, i, a);
                        it[] = (Some = moves.items());
                    };
                    @case(?Move) => {
                        word := advance_word(s, i);
                        move := readAlgebraic(word) 
                            || continue(); // TODO: error
                        it[] = (Some = move);
                    };
                    @case(?Str) => {
                        it[] = (Some = s.rest(i[]));
                        i[] = s.len;
                    };
                    @default => @run compile_error(@tfmt("parse_fields: unhandled Uci field type. %: %", name, field[].ty.typename().str()), @source_location());
                };
            }
        };
        
        // TODO: error?
    };
    
    result
}

display_fields :: fn($T: Type, self: *T, out: *List(u8)) void #generic = {
    inline_for T.get_fields() { $field |
        name :: field[].name.str();
        @inline_switch(field[].ty) {
            @case(?i64) => if T.get_field_ptr(self, field) { value |
                if has_tag(field, @symbol "prefix", Str) { prefix |
                    @fmt(out, " %", prefix);
                };
                @fmt(out, " % %", name, value);
            };
            @case(bool) => if T.get_field_ptr(self, field)[] {
                @fmt(out, " %", name);
            };
            @case(?[]Move) => if Go.get_field_ptr(self, field)[] { moves | 
                @fmt(out, " %", name);
                for moves { it |
                    @fmt(out, " ");
                    writeAlgebraic(it, out);
                };
            };
            @case(?Move) => if Go.get_field_ptr(self, field)[] { it | 
                @fmt(out, " % ", name);
                writeAlgebraic(it, out);
            };
            @case(?Str) => if Go.get_field_ptr(self, field)[] { it | 
                @fmt(out, " % %", name, it);
            };
            @default => @run compile_error(@tfmt("display_fields: unhandled Uci field type. %: %", name, field[].ty.typename().str()), @source_location());
        }
    };
}

has_tag :: fn(field: *Field, name: Symbol, $T: Type) ?T #fold #generic = {
    @if(field.nullable_tag.is_null()) return(.None);
    each field.nullable_tag { it | 
        @if(it.name == name) return(Some = T.const_eval(it.args));
    };
    .None
}

// algebraic notation moves seperated by spaces
advance_moves :: fn(s: Str, i: *i64, a: Alloc) List(Move) = {
    out := Move.list(temp());
    while => i[] < s.len {
        prev := i[];
        word := advance_word(s, i);
        if readAlgebraic(word) { move |
            out&.push(move);
        } else {
            i[] = prev;
            return out;
        }
    }
    out
}

advance_number :: fn(s: Str, i: *i64) ?i64 = {
    n, remaining := convert_number_dyn(s.rest(i[]), 10);
    new_i := s.len - remaining.len;
    @if(i[] == new_i) return(.None);  // no valid digits
    i[] = new_i;
    advance_whitespace(s, i);
    (Some = n)
}

advance_word :: fn(s: Str, i: *i64) Str = {
    advance_whitespace(s, i);
    start := i[];
    while => i[] < s.len && !s[i[]].is_ascii_whitespace() {
        i[] += 1;
    };
    word := s.slice(start, i[]);
    advance_whitespace(s, i);
    word
}

advance_whitespace :: fn(s: Str, i: *i64) void = {
    while => i[] < s.len && s[i[]].is_ascii_whitespace() {
        i[] += 1;
    };
}

#use("@/lib/sys/subprocess.fr");

// dead code but handy for debugging
fn printBitBoard(bb: i64) void = {
    out := u8.list(temp());
    @fmt(out&, "%\n", @as(u64) bb.bitcast());

    range(0, 8) { i |
        @fmt(out&, "|");
        range(0, 8) { j |
            rank, file := (7 - i, j);
            mask := BIT(rank * 8 + file);
            char := @if(mask.bit_and(bb) != 0, "X", " ");
            @fmt(out&, "%|", char);
        }
        @fmt(out&, "\n");
    }
    print(out.items());
}

#use("@/examples/chess/moves.fr");

