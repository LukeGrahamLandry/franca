// TODO: should replace #macro with @macro(Prefix) @macro(Bang) @macro(Func)

// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
#macro #outputs(AstExpr)
fn literal(arg: AstExpr, target: AstExpr) AstExpr = @{
    value: @[arg] = @[target];
    literal_ast(@[arg], raw_from_ptr(@[arg], value&))
};


// Same as the two argument version but infers the type. 
// TODO: assert that arg isn't 'void' because then its ambigous with the two argument version. -- Apr 21
#macro #outputs(AstExpr)
fn literal(arg: AstExpr) AstExpr = @{
    value := @[arg];
    literal_ast(@type value, raw_from_ptr(@type value, value&))
};

// TODO: it does that by name tho! so its a very bad idea to shadow this with another macro. HACK
fn as(T: Type, expr: FatExpr) FatExpr = @{ @as(@[@literal(T)]) @[expr] };

// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
// TODO: should always inline the bodies, even if no captures? 
#macro 
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    stmts := target.expr.Block.body.items();
    arg = compile_ast(arg);
    enum_type := arg.ty;
    info := get_type_info_raw(enum_type);
    
    is_ptr := false;
    if info&.is(.Ptr) {|
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_raw(enum_type);
        is_ptr = true;
    };
    ptr_ty := *enum_type;
   
    assert(info&.is(.Tagged), "@match expected argument type to be @tagged");
    info := info.Tagged;
    
    varients := info.cases.items();
    
    // TODO: why can't i call 'as'? ffi unique? 
    body: FatExpr = @{ panic("matched on invalid tag") }; 
    
    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: infer function argument type since we know it must match the enum payload,
    //       but allow no arg if you just want to use it as a switch. 
    // TODO: use default arguments as value eq guards. 
    
    ::if(FatExpr);
    @{
        arg_val := @[if(is_ptr, => @{ @as(void)unit }, => arg)];
        arg_ptr := @[if(is_ptr, =>arg, => @{ arg_val& })];
        :: tagged(@[@literal enum_type]);
        tag_val := arg_ptr.tag().ordinal();
        @[{
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            while(=> i.ge(0)) {|
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {| 
                        closure := handler_body.expr.Closure&;
                        index := tag_value(enum_type, closure.name); // they're always sequential (TODO: assert on the enum type)
                        (name, ty) := varients.get(index);
                        assert(name.eq(closure.name), "ICE: bad enum index");
                        
                        if(is_ptr){|
                            p: TypeInfo = (Ptr = ty);
                            ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
                        };
                
                        // If they didn't say the argument type, we can fill it in based on the varient name. 
                        // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
                        bindings := closure.arg.bindings.items();
                        if(bindings.len.eq(1)){|
                            first := bindings[0]&;
                            infer := first.ty&.is(.Infer);
                            no_name := first.name&.is(.None); 
                            if  infer.or(no_name) {|
                                first.ty = (Finished = ty);
                            };
                        };
                        case_access := 'arg_ptr.___';
                        case_access.expr.FieldAccess.name = name;  // (3)
                        tag := @{ tag_value(@[@literal(Type) enum_type], @[@literal(name)]) };
                        if(is_ptr){|
                            case_access = @{ @[case_access]& };
                        };
                        count = count.add(1);
                        body = @{ @if(eq(tag_val, @[tag]), => @[handler_body[]](@[case_access]), => @[body]) };
                    } {| // else
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        assert(handler_body.expr&.is(.PrefixMacro), "expected @default");
                        branch := handler_body.expr.PrefixMacro&;
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default"); // TODO: bring back safety checks on tagged field access. 
                        name := macro.expr.GetNamed; // TODO: ^ allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        body = @{ @[action]() };
                        had_default = true;
                    };
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            if(count.ne(varients.len).and(not(had_default))) {|
                print("warning: wrong number of @match cases (did you forget to wrap them in brackets?). ");
                print("expected ");
                print(varients.len);
                print(" but found ");
                println(count);
            };
            assert(not(had_default).or(count.lt(varients.len)), "@default but too many @match cases");
            body
        }]
    }
}

fn if_let(arg: FatExpr, handler: FatExpr) FatExpr #macro = @{
    @match(@[arg]) {
        @[handler];
        @default => ();
    }
};

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> => <body> }
/// - @case(v): calls <body> if value.eq(v)
#macro 
fn switch(arg: FatExpr, handlers: FatExpr) FatExpr = {
    handlers := handlers.expr.Block.body.items();
    arg = compile_ast(arg);
    inspected_ty: Type = arg.ty; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    body := @{ panic("unhandled switch case") };
    first := true;
    i := handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    @{
        arg_var := @[arg];
        @[{
            while(=> i.ge(0)) {|
                stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if stmt.stmt&.is(.Eval) {|
                    handler_body := stmt.stmt.Eval&;
                    branch := handler_body.expr.PrefixMacro&;
                    macro := branch.handler;
                    // TODO: better error message that shows more context on how you got to a certain type in the nested exprression. 
                    //       it took me so long to figure out you don't need .GetNamed[0][] to index through the first single element tuple because it gets flattened. -- Apr 21 
                    name := (@as(*Symbol) macro.expr.GetNamed&)[]; // TODO: allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                    arg := branch.arg;
                    action := branch.target[];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.eq(@symbol case)) {|
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        cond := @{ eq(arg_var, @[as(inspected_ty, arg[])]) };
                        body = @{ @if(@[cond], =>@[action](), =>@[body]) };
                    } {|
                        if(name.eq(@symbol default)) {|
                            if(first) {|
                                // TODO: dont pass it if the function wants void arg.
                                // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                                body = @{ @[action](arg_var) };
                            }{|
                                panic("@default must be the last handler in @switch");
                            };
                        }{|
                            if(name.eq(@symbol inclusive)) {|
                                cond := @{
                                    (min, max) := @[as(Ty(inspected_ty, inspected_ty), arg[])];
                                    arg_var.ge(min).and(arg_var.le(max))
                                };
                                body = @{ @if(@[cond], =>@[action](), =>@[body]) };
                            }{|
                                // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                                //n: Str = name.str(); // TODO: this broke when I started renumbering in bind_const_arg -- Apr 23. 
                                // TODO: make concat less painful. 
                                //println(n);
                                panic("unhandled prefix in @switch");
                            };
                        };
                    };
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }]
    }
}

// TODO: remove when the below works. -- Jun 1
#macro #outputs(u32) fn bits(arg: AstExpr) AstExpr = BITS(arg);

// TODO: fix this with new strict casting rules. -- Jun 1
// TODO: implicit range assertions because we get the bit count from the type of the ints. 
#macro #outputs(u32)
fn __bits(arg: AstExpr) AstExpr = {
    zero := 0;
    parts := arg.expr.Tuple.items();
    expr := '@as(u32) 0.trunc()';
    shift := 32;
    each(parts, fn(part) => {
        int := get_type_int(part[]);
        // TODO: fix inference + overloading. 
        //       you only need this annotation if you include instructions.fr so there's another definition of `fn sub`
        //       So it doesn't infer through the field lookup but even without that it should notice that
        //       it can't possibly be the one that takes like 6 arguments. 
        bc: i64 = int.bit_count;
        shift = sub(shift, bc);
        assert(ge(shift, 0), "expected 32 bits. TODO: other sizes.");  // TODO: str(i64) for negative numbers
        
        ::if(FatExpr);
        next := if(int.signed, 
            => {
                part_ast := as(i64, part[]);
                @{ signed_truncate(@[part_ast], @[@literal(i64) int.bit_count]) }
            },
            => as(u32, part[])
        );
        next := @{ shift_left(@[next], @[@literal(shift)]) };
        expr = @{ bit_or(@[expr], @[next]) };
    });
    
    // TODO: want to be able to just have a version of assert that does this but there's a weird dependency. 
    if(shift.ne(0)){|
        @println("% != 0; expected 32 bits. TODO: other sizes.", shift);
        //msg := concat(str(shift), " != 0; expected 32 bits. TODO: other sizes.");
        //msg: Str = msg&.items();
        //panic(msg);
    };
    
    as(u32, expr)
}

/// :blessed: The parser desugars stuff into calls to these functions. 
/// But it just refers to them by name. If you cause that to resolve to your own function, you can change the operator's behaviour. 
#macro #outputs(void) fn operator_plus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, add);
#macro #outputs(void) fn operator_minus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, sub);
#macro #outputs(void) fn operator_star_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, mul);
#macro #outputs(void) fn operator_slash_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, div);
#macro fn operator_index(container: FatExpr, i: FatExpr) FatExpr = '@[container].index(@[i])[]';

/// All the  'a _= b' operators logically expand to 'a = _(a, b)'.
/// Like normal assignment, the left hand side can be a variable name or a pointer dereference. 
/// However, in the latter case, the expression that produces the pointer is only evaluated once. 
/// Most of the time it doesn't matter but it's legal to put a function call with side effects in that position and this behaviour feels more intuitive. 
// NOTE: don't use these operators in the dependency chain of this function or life gets real confusing, real fast!
// TODO: should allow a mutating fn add_assign(*Self, v) if you have one. like it would be nice for owned strings. 
// TODO: this should work when inlined. the problem is i dont handle DeclVarPattern of large values by address. -- May 7
#inline
fn assignment_operator(place: FatExpr, value: FatExpr, f: OverloadSet) FatExpr = {
    kind := place.expr&.tag();
    // TODO: generate a typed enum for the tag so this could be kind.eq(.GetVar).or(kind.eq(.GetNamed))
    is_var_access := 
        place.expr&.is(.GetVar)
        .or(place.expr&.is(.GetNamed))
        .or(place.expr&.is(.FieldAccess)); // TODO: once field access is allowed on r-values, it can have side effects.  
    
    ::if(FatExpr); // TODO: auto template instantiation. 
    
    if(is_var_access){|
        // This type of macro can't return a stmt, so it has to be wrapped in a block. Maybe we should use the other kind once that exists. 
        @{ @[place] = @[@literal(f)](@[place], @[value]); }
    } {|
        // TODO: nice report_compile_error api that lets you attatch the Span so you get useful error message rendering. 
        assert(kind != .PrefixMacro, "TODO: support macro expansion in place expr");
        is_deref := and kind == .SuffixMacro {()bool|
            name := place.expr.SuffixMacro.name;
            name.eq(@symbol(deref))
        };
        assert(is_deref, "_= operator left hand side must be a place expr.");
        // we know the lhs is 'whatever[]', but we want to just access the pointer and add the deref later. 
        ptr_expr := place.expr.SuffixMacro.arg[];
        @{ ptr := @[ptr_expr]; ptr[] = @[@literal(f)](ptr[], @[value]); }
    }
}

/// The compiler defines the two argument version where you specify a type and values. 
/// This version can be used when you just want sequential integers. 
#macro #outputs(Type)
fn enum(names: FatExpr) FatExpr = {
    assert(names.expr&.is(.Tuple), "expected @enum(name1, name2, etc)"); // TODO: single element should be legal i guess. 

    fn binding(name: Symbol, value: i64) Binding = {
        template := '(a = 0)';
        all := template.expr.StructLiteralP.bindings.items();
        out := all.get(0);
        out.name = (Ident = name);
        out.default = (Some = @literal(value));
        out
    }
    
    cases: List(Binding) = list(ast_alloc());
    parts := names.expr.Tuple.items();
    enumerate(parts) {i, part|
        // TODO: really need @default on match cause this is annoying. 
        @switch(part[].expr&.tag()) {
            @case(.GetNamed) => {
                name := (@as(*Symbol) part.expr.GetNamed&)[];
                bind := binding(name, i);
                cases&.push(bind);
            };
            @case(.GetVar) => {
                name: Symbol = part.expr.GetVar.name;
                cases&.push(binding(name, i));
            };
            // TODO: dont require the default arg in @switch. 
            @default() fn(_: i64) => panic("Expected symbol in @enum"); // TODO: this should work as not a closure
        };
    };

    varients := '(a = 1)';
    cases := cases.items();
    varients.expr.StructLiteralP.bindings = (cap = cases.len, ptr = cases.ptr, len = cases.len);
    
    @{ @enum(i64) @[varients] }
}

// TODO: @comptime_var which is like this but a constant at runtime. 
#macro fn static(T: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: @[t].ptr_from_raw(@as(rawptr) malloc(@[t].size_of())) }
}

// TODO: instead of this, you should be able to take the address of a normal :: constant,
//       but i should know which pointers are const. 
//       but that doesn't fix the problem of needing the constant to be ready so you can use it in functions that it contains pointers to. 
//       need !rec to work for anything, not just types?    -- Jun 18
#macro fn static(T: FatExpr, value: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: {
        ptr := @[t].ptr_from_raw(@as(rawptr) malloc(@[t].size_of()));
        ptr[] = @[value];
        ptr
    }}
}

// @array(1, 2, 3) creates an Array(i64, 3)
// because its a pain to make a constant one otherwise. 
// NOTE: this doesn't make a constant one unless you explicitly use '::'.
#macro fn array(elements: FatExpr) FatExpr = {
    assert(elements.expr&.is(.Tuple), "Expected @array(a, b, c, d)");
    parts := elements.expr.Tuple.items();
    len := parts.len;
    first := compile_ast(parts[0]);
    parts.set(0, first);
    @{ @as(Array(@[@literal parts[0].ty], @[@literal len])) init(@slice @[elements]) }
}

fn is();
fn tag();
fn tag_ptr();
fn ordinal();

// TODO: have @tagged auto call this
// TODO: seperate out the parts that could work on any sequential enum. 
// TODO: move these to like meta.fr maybe? enum.fr? 
fn tagged($Tagged: Type) void = {
    // TODO: assert its really a tagged type.
    
    // assert_eq(size_of(Tagged.Tag()), size_of(i64)); // TODO: ?? doesn't type check. happening too early? -- Jul 1
    
    T :: Tagged.Tag();
    
    
    fn tag(self: *Tagged) T #inline = self.tag_ptr()[];
    fn tag_ptr(self: *Tagged) *T #unsafe_noop_cast;  // SAFETY: The compiler puts the tag at the front of the struct. 
    
    fn is(self: *Tagged, check: T) bool #inline = self.tag().eq(check);
    
    :: enum(T);
}

fn enum($T: Type) void = {
    @late {
        info := get_type_info(T);
        assert(info&.is(.Enum), "expected enum type");
        assert(info.Enum.sequential, "expected enum elements to be sequential");
    };
    
    fn eq(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    fn ne(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    
    fn ordinal(e: T) i64 #unsafe_noop_cast; // :tag_enums_are_sequential
    
    fn display(self: T, out: *List(u8)) void = {
        // TODO: without the extra force comptime eval, it wrongly thinks calling this function needs compctx.  -- Jul 1
        names :: @run get_enum_names(T); // :tag_enums_are_sequential
        out.push_all(names[self.ordinal()]);
    }
}

// :blessed: This is also a builtin_prefix_macro. It lets you disable code while bootstrapping up to having the type for FatExpr.
// See bootstrap_compiler_environment 
fn late(e: FatExpr) FatExpr #macro = e;

// TODO: define the syntax as a call to this function. maybe get rid of the syntax. cause its a pain.
//       then this can just be an export_ffi that calls immediate_eval_expr, but that requores passing expected type to macros. 
fn run(e: FatExpr) FatExpr #macro = @{ :: @[e] };

// TODO: this is useless because you can't unquote inside. 
//       tho actually, it does get here, you could handle the unquoting in here... maybe. 
fn quote(e: FatExpr) FatExpr #macro = 
    @literal e;

/// @expand @quote X === X
fn expand(e: FatExpr) FatExpr #macro = 
    (const_eval(FatExpr)(e));

fn inline_for(container: FatExpr, body: FatExpr) FatExpr #macro = {
    container := compile_ast(@{ :: @[container] });
    len := (const_eval(i64)(@{ v := @[container]; v.len() }));
    
    actions: List(FatExpr) = list(ast_alloc());
    range(0, len) { i | 
        actions&.push(@{ @[body](:: @[container].index(@[@literal i])) });
    };
    container.expr = (Tuple = actions.rs());
    container.ty = UnknownType; 
    container.done = false;
    container
}

// TODO: this is kinda copy-paste from normal match. try to factor some stuff out? -- Jul 5
fn inline_match(container: FatExpr, target: FatExpr) FatExpr #macro = {
    container := compile_ast(@{ :: @[container] });
    
    stmts := target.expr.Block.body.items();
    enum_type := container.ty;
    info := get_type_info_raw(enum_type);
    
    is_ptr := false;
    tag_expr := @literal unit;
    if info&.is(.Ptr) {|
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_raw(enum_type);
        is_ptr = true;
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a[]); a.tag().ordinal() } };
    } {|
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a); a&.tag().ordinal() } };
    };
    ptr_ty := *enum_type;
   
    assert(info&.is(.Tagged), "@match expected argument type to be @tagged");
    info := info.Tagged;
    tag_val := const_eval(i64)(tag_expr);
    
    varients := info.cases.items();
    
    each stmts { stmt |
        continue :: local_return;
        @match(stmt.stmt&) {
            (fn Eval(handler_body) => {
                @match(handler_body.expr&) {
                    (fn Closure(closure) => {
                        index := tag_value(enum_type, closure.name); // they're always sequential
                        (name, ty) := varients.get(index);
                        assert(name.eq(name), "ICE: bad enum index");
                        if index != tag_val {|
                            continue();
                        };
                        
                        if(is_ptr){|
                            p: TypeInfo = (Ptr = ty);
                            ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
                        };
                
                        // If they didn't say the argument type, we can fill it in based on the varient name. 
                        // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
                        bindings := closure.arg.bindings.items();
                        if(bindings.len.eq(1)){|
                            first := bindings[0]&;
                            infer := first.ty&.is(.Infer);
                            no_name := first.name&.is(.None); 
                            if  infer.or(no_name) {|
                                first.ty = (Finished = ty);
                            };
                        };
                        // TODO: allow non-ptr
                        case_access := '@[container][].___';
                        case_access.expr.FieldAccess.name = name;  // (3)
                        if(is_ptr){|
                            case_access = @{ @[case_access]& };
                        };
                        return(@{ @[handler_body[]](@[case_access]) });
                    });
                    (fn PrefixMacro(branch) => {
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default");
                        name := macro.expr.GetNamed; 
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @inline_match");
                        return(@{ @[action]() });
                    });
                    @default => panic("expected @default");
                };
            });
            @default => (); // TODO: warn
        };
    };
    panic("inline_match not matched!")
}

/*
`if :: true {| do_something_super_important(); };`
is a footgun because it parses as a declaration not a comptime evaluation of the condition, 
what's worse is that the body is only evaluated if the variable is referenced so if you don't try to call 'if' 
later in that scope it won't even be an error that you can't call true with a trailing lambda. 
*/

SafetyCheck :: @enum(i64) (
    Bounds,
    _
);

fn safety(kind: FatExpr, code: FatExpr) FatExpr #macro = {
    kind := (const_eval(SafetyCheck))(kind);
    @{ if(!@[code], => safety_check_failed()) }
    //@literal unit
}

// TODO: its sad that it makes the compiler binary ~5% smaller to manually out-line this instead of just calling assert. should work on that. -- Jul 5
fn safety_check_failed() Never #noinline = {
    panic("Safety Check Failed.")
}
