// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
#macro #outputs(FatExpr)
fn literal(arg: FatExpr, target: FatExpr) FatExpr = @{
    make_literal(@[arg], @[target])
};

// TODO: implement the single arg version with this somehow. it looks easy but no
//       i made the macros before i had a type system that could do this. 
make_literal :: fn($T: Type, value: T) FatExpr #generic = {  
    literal_ast(T, raw_from_ptr(T, value&))
};

fn if(cond: FatExpr, do: FatExpr) FatExpr #macro = {
    @{ @if(@[cond], @[do], ()) }
}

// Same as the two argument version but infers the type. 
// TODO: assert that arg isn't 'void' because then its ambigous with the two argument version. -- Apr 21
#macro #outputs(FatExpr)
fn literal(arg: FatExpr) FatExpr = @{
    value := @[arg];
    T :: @type value;
    literal_ast(T, raw_from_ptr(T, value&))
};

fn as(T: Type, expr: FatExpr) FatExpr = as(@literal T, expr);

// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
#macro 
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    loc := arg.loc;
    stmts := target.expr.Block.body.items();
    arg = compile_ast(arg);
    enum_type := arg.ty;
    info := get_type_info_ref(enum_type);
    
    un_raw := enum_type.get_type_info_ref();
    if un_raw.is(.Enum) {
        // TODO: use new switch expression -- Jul 26
        return(match_on_enum(arg, un_raw, stmts));
    };
    
    is_ptr := false;
    if info.is(.Ptr) {
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        is_ptr = true;
    };
    ptr_ty := *enum_type;  // this is unfortunate syntax. we're creating a pointer ~type~
    
    @ct_assert(!info.is(.Enum), arg.loc, "to @match on an @enum, dereference the pointer"); // TODO: just do it
    @ct_assert(info.is(.Tagged), arg.loc, "@match expected argument type to be @tagged");
    info := info.Tagged;
    
    varients := info.cases.items();

    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: infer function argument type since we know it must match the enum payload,
    //       but allow no arg if you just want to use it as a switch. 
    // TODO: use default arguments as value eq guards. 
    
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    
    ::if(FatExpr);
    @{
        arg_val := @[if(is_ptr, => @{ @as(void)unit }, => arg)];
        arg_ptr := @[if(is_ptr, =>arg, => @{ arg_val& })];
        :: tagged(@[@literal enum_type]);
        tag_val := arg_ptr.tag().ordinal();
        // TODO: when safety checks are on don't do the default branch even for garbage tag.
        //       in fast mode tho make that UB.  -- Jul 9
        @[{
            // If there's no @default, this is hit by invalid tags. 
            // TODO: when enabled just used @safety? so the message isn't different when you have a @default branch. 
            default: FatExpr = if(safety_check_enabled(.InvalidTag), => @{ 
                // TODO: make this a build option / safety check. all could have None/Abort/Panic/Verbose
                @println("tag=%, expected 0..<%", tag_val, @[@literal varients.len]);
                panic("matched on invalid tag! Uninitialized memory?") 
            }, => @{ unreachable() }); // TODO: tell llvm unreachable_unchecked when the safety check is off?
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            
            while(=> i.ge(0)) {
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    index := tag_value(enum_type, closure.name); // they're always sequential (TODO: assert on the enum type)
                    name, ty := varients.get(index);
                    assert(name.eq(closure.name), "ICE: bad enum index");
                    
                    if(is_ptr){
                        p: TypeInfo = (Ptr = ty);
                        ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
                    };
            
                    // If they didn't say the argument type, we can fill it in based on the varient name. 
                    // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
                    bindings := closure.arg.bindings.items();
                    if(bindings.len.eq(1)){
                        first := bindings[0]&;
                        infer := first.ty&.is(.Infer);
                        no_name := first.name&.is(.None); 
                        if infer.or(no_name) {
                            first.ty = (Finished = ty);
                        };
                    };
                    loc := closure.loc;
                    case_access := @{ arg_ptr.___ };
                    case_access := case_access.expr.Block.result[];
                    case_access.expr.FieldAccess.name = name;  // (3)
                    tag := @{ tag_value(@[@literal(Type) enum_type], @[@literal(name)]) };
                    if(is_ptr){
                        case_access = @{ @[case_access]& };
                        // :FuckedJunkPointerExpr
                        // HACK :FUCKED Sep 17
                        // it doesn't work on linux if you don't do this 
                        // but it was fine on macos arm and x64. 
                        // what the actual fuck
                        // and like... this is the only thing
                        // changing this made it self compile... and reproducible build. 
                        // so like this line is the only thing in the whole compiler that is different on linux.    
                        case_access = case_access.expr.Block.result[];
                    };
                    case_access.loc = loc;
                    count = count.add(1);
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (index, @{ @[callable](@[case_access]) } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {| 
                        expand_case_body(handler_body.expr.Closure);
                    } {| // else
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        assert(handler_body.expr&.is(.PrefixMacro), "expected @default");
                        branch := handler_body.expr.PrefixMacro&;
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default"); // TODO: bring back safety checks on tagged field access. 
                        name := macro.expr.GetNamed; // TODO: ^ allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {
                            default = @{ 
                                @safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), loc, "wrong number of @match cases",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), loc, "@default but too many @match cases");
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn make_switch(value: FatExpr, default: FatExpr, cases: List(Ty(i64, FatExpr))) FatExpr = {
    default_box := ast_alloc().alloc(FatExpr, 1);
    default_box.ptr[] = default;
    value_box := ast_alloc().alloc(FatExpr, 1);
    value_box.ptr[] = value;
    switch: FatExpr = (expr = (Switch = (value = value_box.ptr, default = default_box.ptr, cases = cases.rs())), loc = value.loc, ty = UnknownType, done = false); 
    switch
}

fn match_on_enum(arg: FatExpr, info: *TypeInfo, stmts: [] FatStmt) FatExpr = {
    info := info.Enum;
    
    varients := info.fields.items();
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    
    // TODO: why can't i call 'as'? ffi unique? 
    
    ::if(FatExpr);
    @{
        tag_val := @[arg].raw();
        @[{
            default: FatExpr = @{ @panic("matched on invalid tag???") }; 
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            while(=> i.ge(0)) {
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    index := tag_value(arg.ty, closure.name);  // just make sure the name exists
                    count = count.add(1);
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (index, @{ @[callable]() } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {| 
                        expand_case_body(handler_body.expr.Closure);
                    } {| // else
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        assert(handler_body.expr&.is(.PrefixMacro), "expected @default");
                        branch := handler_body.expr.PrefixMacro&;
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default"); // TODO: bring back safety checks on tagged field access. 
                        name := macro.expr.GetNamed; // TODO: ^ allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {
                            default = @{ 
                                @safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), arg.loc, "wrong number of @match cases",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), arg.loc, "@default but too many @match cases");
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn ct_assert(arg: FatExpr) FatExpr #macro = {
    assert(arg.expr&.is(.Tuple), "@assert___ expected multiple args");
    parts := arg.expr.Tuple.items();
    assert(parts.len >= 3, "not enough arguments");
    cond := parts[0];
    span := compile_ast(parts[1]);
    if !(span.ty == Span) {
        compile_error("Expected type 'Span' for error location", span.loc);
    };
    
    @{
        if !@[cond]{ #cold |
            out: List(u8) = list(temp());
            @[if(parts.len == 3, => @{
                out&.push_all(@[parts[2]]);
            }, => @{()} )];
            @[if(parts.len > 3, => {
                format_into(@{ out& }, parts.rest(2), arg.loc)
            }, => @{()} )];
            compile_error(out.items(), @[span]);
        };
    }
}

fn if_let(arg: FatExpr, handler: FatExpr) FatExpr #macro = @{
    @match(@[arg]) {
        @[handler];
        @default => ();
    }
};

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> => <body> }
/// - @case(v): calls <body> if value.eq(v)
#macro 
fn switch(arg: FatExpr, handlers: FatExpr) FatExpr = {
    handlers := handlers.expr.Block.body.items();
    arg = compile_ast(arg);
    inspected_ty: Type = arg.ty; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    body := @{ panic("unhandled switch case") };
    first := true;
    i := handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    @{
        arg_var := @[arg];
        @[{
            while(=> i.ge(0)) {
                stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if stmt.stmt&.is(.Eval) {
                    handler_body := stmt.stmt.Eval&;
                    branch := handler_body.expr.PrefixMacro&;
                    macro := branch.handler;
                    // TODO: better error message that shows more context on how you got to a certain type in the nested exprression. 
                    //       it took me so long to figure out you don't need .GetNamed[0][] to index through the first single element tuple because it gets flattened. -- Apr 21 
                    name := (@as(*Symbol) macro.expr.GetNamed&)[]; // TODO: allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                    arg := branch.arg;
                    action := branch.target[];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.eq(@symbol case)) {
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        cond := @{ eq(arg_var, @[as(inspected_ty, arg[])]) };
                        body = @{ @if(@[cond], @[action](), @[body]) };
                    } {
                        if(name.eq(@symbol default)) {
                            if(first) {
                                // TODO: dont pass it if the function wants void arg.
                                // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                                assert(action.expr&.is(.Closure), "@switch @default: expected closure");
                                
                                assert(action.expr.Closure.arg.bindings.len == 1, "@switch @default: expected single arg. (parser treats (fn name() ..) as having unnamed arg automatically)");
                                arg := action.expr.Closure.arg.bindings[0]&;
                                :: tagged(Name);
                                if arg.name&.is(.None) {
                                    body = @{ @[action]() };
                                } else {
                                    body = @{ @[action](arg_var) };
                                };
                                
                            }{
                                compile_error("@default must be the last handler in @switch", stmt.loc);
                            };
                        }{
                            if(name.eq(@symbol inclusive)) {
                                cond := @{
                                    min, max := @[as(Ty(inspected_ty, inspected_ty), arg[])];
                                    arg_var.ge(min).and(arg_var.le(max))
                                };
                                body = @{ @if(@[cond], @[action](), @[body]) };
                            }{
                                // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                                compile_error("unhandled prefix in @switch", stmt.loc);
                            };
                        };
                    };
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }]
    }
}

fn get_type_int(e: FatExpr) IntTypeInfo = {
    inner :: fn(ty: Type, loc: Span) IntTypeInfo = {
        @match(get_type_info_ref(ty)) {
            fn Int(i) => i[];
            fn Enum(f) => inner(f.raw, loc);
            fn Named(f) => inner(f._0, loc);
            @default => {
                debug_log_type(ty);
                compile_error("Expected integer.", loc)
            };
        }
    };
    e = compile_ast(e);
    inner(e.ty, e.loc)
}

/// The compiler defines the two argument version where you specify a type and values. 
/// This version can be used when you just want sequential integers. 
#macro #outputs(Type)
fn enum(names: FatExpr) FatExpr = {
    @ct_assert(names.expr&.is(.Tuple), names.loc, "expected @enum(name1, name2, etc)"); // TODO: single element should be legal i guess. 

    fn binding(name: Symbol, value: i64) Binding = {
        template := @{ (a = 0) };
        template := template.expr.Block.result[];
        all := template.expr.StructLiteralP.bindings.items();
        out := all.get(0);
        out.name = (Ident = name);
        out.default = (Some = @literal(value));
        out
    }
    
    cases: List(Binding) = list(ast_alloc());
    parts := names.expr.Tuple.items();
    enumerate(parts) {i, part|
        name := @match(part[].expr&.tag()) {
            fn GetNamed() => part.expr.GetNamed;
            fn GetVar()   => part.expr.GetVar.name;
            @default         => compile_error("Expected symbol in @enum", names.loc); // TODO: this should work as not a closure
        };
        cases&.push(binding(name, i));
    };

    varients := @{ (a = 1) };
    varients := varients.expr.Block.result[];
    cases := cases.items();
    varients.expr.StructLiteralP.bindings = (cap = cases.len, ptr = cases.ptr, len = cases.len);
    
    @{ @enum(i64) @[varients] }
}

// TODO: @comptime_var which is like this but a constant at runtime. 
#macro fn static(T: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: {
        mem := ast_alloc().alloc(@[t], 1);
        mem.ptr
    }}
}

// TODO: instead of this, you should be able to take the address of a normal :: constant,
//       but i should know which pointers are const. 
//       but that doesn't fix the problem of needing the constant to be ready so you can use it in functions that it contains pointers to. 
//       need !rec to work for anything, not just types?    -- Jun 18
#macro fn static(T: FatExpr, value: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: {
        mem := ast_alloc().alloc(@[t], 1);
        mem.ptr[] = @[value];
        mem.ptr
    }}
}

// @array(1, 2, 3) creates an Array(i64, 3)
// because its a pain to make a constant one otherwise. 
// NOTE: this doesn't make a constant one unless you explicitly use '::'.
#macro fn array(elements: FatExpr) FatExpr = {
    @ct_assert(elements.expr&.is(.Tuple), elements.loc, "Expected @array(a, b, c, d)");
    parts := elements.expr.Tuple.items();
    len := parts.len;
    first := compile_ast(parts[0]);
    parts.set(0, first);
    @{ @as(Array(@[@literal parts[0].ty], @[@literal len])) init(@slice @[elements]) }
}

fn is();
fn tag();
fn tag_ptr();
fn ordinal();

// TODO: have @tagged auto call this
// TODO: seperate out the parts that could work on any sequential enum. 
// TODO: move these to like meta.fr maybe? enum.fr? 
fn tagged($Tagged: Type) void = {
    // TODO: assert its really a tagged type.
    
    // assert_eq(size_of(Tagged.Tag()), size_of(i64)); // TODO: ?? doesn't type check. happening too early? -- Jul 1
    
    T :: Tagged.Tag();
    
    // :tag_is_always_i64
    :: enum(T);
    fn tag(self: *Tagged) T #inline = self.tag_ptr()[];
    fn tag_ptr(self: *Tagged) *T #unsafe_noop_cast;  // SAFETY: The compiler puts the tag at the front of the struct. 
    
    fn is(self: *Tagged, check: T) bool #inline = self.tag().eq(check);
    
}

fn raw();
fn from_raw();

fn expect_enum(T: Type) void = {
    info := get_type_info(T);
    // TODO: this doesn't compile with trying to eq on **FnBody ?????! :FUCKED
    //assert(info&.is(.Enum), "expected enum type");
    //assert(info.Enum.sequential, "expected enum elements to be sequential");
}

fn is_fake_int(T: *TypeInfo) bool = {
    T.is(.Int) && T.Int.bit_size != 64 && T.Int.bit_size != 32 && T.Int.bit_size != 16 && T.Int.bit_size != 8
}

fn enum_basic($T: Type) void = {
    @late T.expect_enum();
        
    // TODO: need to do the garbage fake ints hack in the other resolve for this to work.
    //fn eq(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    //fn ne(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    fn eq(a: T, b: T) bool = a.raw() == b.raw();
    fn ne(a: T, b: T) bool = a.raw() != b.raw();
    
    RAW :: { i := get_type_info_ref(T); i.Enum.raw };
    
    // TODO: this breaks -go-rebuild-yo-self on blink???? (it infinite loops) :fucked havent tried other linux yet.   -- Sep 20
    // fn raw(e: T) RAW #unsafe_noop_cast;
    fn raw(e: T) RAW = {
        ptr_cast_unchecked(T, RAW, e&)[]
    }
}

fn enum($T: Type) void = {
    enum_basic(T);
    
    fn ordinal(e: T) i64 = e.raw().int(); // :tag_enums_are_sequential
    
    fn display(self: T, out: *List(u8)) void = {
        // TODO: without the extra force comptime eval, it wrongly thinks calling this function needs compctx.  -- Jul 1
        names :: @run get_enum_names(T); // :tag_enums_are_sequential
        i := self.ordinal();
        if i < 0 || i > names.len() {
            @fmt(out, "<invalid enum:%>", i);
        } else {
            out.push_all(names[i]);
        };
    }
    
    fn display(self: *T, out: *List(u8)) void #inline = {
        self[].display(out);
    }
    
    fn name(self: T) Symbol = {
        names :: @run get_enum_names_symbols(T); 
        names[self.ordinal()]
    }
}

// TODO: fix infinite loop from ?i64 if this is in fn enum. -- Jul 8
fn from_raw($T: Type) void = {
    @late T.expect_enum();
    
    fn from_raw(raw: i64) ?T = {
        ::if(?T);
        // Note: this relies on it being sequentual. 
        if(raw.lt(0).or(raw >= @run T.enum_cases().len()), => .None) {
            value := bit_cast_unchecked(i64, T, raw);
            (Some = value)
        }
    } 
}


fn enum_cases(T: Type) [] Ty(Symbol, Values) = {
    info := get_type_info(T);
    assert(info&.is(.Enum), "expected enum type");
    info.Enum.fields.items()
}

// :blessed: This is also a builtin_prefix_macro. It lets you disable code while bootstrapping up to having the type for FatExpr.
// See bootstrap_compiler_environment 
fn late(e: FatExpr) FatExpr #macro = e;

// TODO: define the syntax as a call to this function. maybe get rid of the syntax. cause its a pain.
//       then this can just be an export_ffi that calls immediate_eval_expr, but that requores passing expected type to macros. 
fn run(e: FatExpr) FatExpr #macro = @{ :: @[e] };

// TODO: this is useless because you can't unquote inside. 
//       tho actually, it does get here, you could handle the unquoting in here... maybe. 
fn quote(e: FatExpr) FatExpr #macro = 
    @literal e;

/// @expand @quote X === X
fn expand(e: FatExpr) FatExpr #macro = 
    (const_eval(FatExpr)(e));

fn inline_for(container: FatExpr, body: FatExpr) FatExpr #macro = {
    container := compile_ast(@{ :: @[container] });
    len := (const_eval(i64)(@{ v := @[container]; v.len() }));
    
    actions: List(FatExpr) = list(ast_alloc());
    range(0, len) { i | 
        actions&.push(@{ @[body](:: (@[container].index(@[@literal i]))) });
    };
    // TODO: dumpster fire garbage error message if you try to make a single length tuple
    //       "Expr::Tuple should have struct type"
    if actions.len == 1 {
        container.expr = actions[0].expr;
    } else {
        container.expr = (Tuple = actions.rs());
    };
    container.ty = UnknownType; 
    container.done = false;
    container
}

fn inline_range(min_max: FatExpr, body: FatExpr) FatExpr #macro = {
    min, max := (const_eval(Ty(i64, i64))(min_max));
    
    actions: List(FatExpr) = list(ast_alloc());
    range(min, max) { i | 
        actions&.push(@{ @[body](@[@literal i]) });
    };
    // TODO: dumpster fire garbage error message if you try to make a single length tuple
    //       "Expr::Tuple should have struct type"
    if actions.len == 1 {
        min_max.expr = actions[0].expr;
    } else {
        min_max.expr = (Tuple = actions.rs());
    };
    min_max.ty = UnknownType; 
    min_max.done = false;
    min_max
}

// TODO: this is kinda copy-paste from normal match. try to factor some stuff out? -- Jul 5
fn inline_match(container: FatExpr, target: FatExpr) FatExpr #macro = {
    loc := container.loc;
    container := compile_ast(@{ :: @[container] });
    
    stmts := target.expr.Block.body.items();
    enum_type := container.ty;
    info := get_type_info_ref(enum_type);
    
    is_ptr := false;
    tag_expr := @literal unit;
    if info.is(.Ptr) {
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        is_ptr = true;
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a[]); a.tag().ordinal() } };
    } {
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a); a&.tag().ordinal() } };
    };
    ptr_ty := *enum_type;
   
    @ct_assert(info.is(.Tagged), loc, "@match expected argument type to be @tagged");
    info := info.Tagged;
    tag_val := const_eval(i64)(tag_expr);
    
    varients := info.cases.items();
    
    each stmts { stmt |
        continue :: local_return;
        expand_case_body :: fn(closure: *Func) FatExpr => {
            index := tag_value(enum_type, closure.name); // they're always sequential
            name, ty := varients.get(index);
            @ct_assert(name == closure.name, closure.loc, "ICE: bad enum index");
            if index != tag_val {
                continue();
            };
            
            if(is_ptr){
                p: TypeInfo = (Ptr = ty);
                ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
            };
    
            // If they didn't say the argument type, we can fill it in based on the varient name. 
            // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
            bindings := closure.arg.bindings.items();
            if(bindings.len.eq(1)){
                first := bindings[0]&;
                infer := first.ty&.is(.Infer);
                no_name := first.name&.is(.None); 
                if  infer.or(no_name) {
                    first.ty = (Finished = ty);
                };
            };
            // TODO: allow non-ptr
            case_access := @{ @[container][].___ };
            case_access := case_access.expr.Block.result[];
            case_access.expr.FieldAccess.name = name;  // (3)
            if(is_ptr){
                case_access = @{ @[case_access]& };
                // :FuckedJunkPointerExpr
                // the need for this (in addition to normal match) when self-compiling was added in "or syntax, remove tag bits, etc"
                case_access = case_access.expr.Block.result[];
            };
            callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
            @{ @[callable](@[case_access]) }
        };
        
        @match(stmt.stmt&) {
            fn DeclFunc(f) => {
                return(expand_case_body(f[]));
            }
            fn Eval(handler_body) => {
                @match(handler_body.expr&) {
                    (fn Closure(closure) => {
                        return(expand_case_body(closure[]));
                    });
                    (fn PrefixMacro(branch) => {
                        macro := branch.handler;
                        @ct_assert(macro.expr&.is(.GetNamed), macro.loc, "expected @default (TODO: allow GetVar?)");
                        name := macro.expr.GetNamed; 
                        arg := branch.arg;
                        action := branch.target[];
                        @ct_assert(name == @symbol default, macro.loc, "unhandled prefix in @inline_match");
                        return(@{ @[action]() });
                    });
                    @default => {
                        debug_log_ast(handler_body[]);
                        compile_error("expected @default or a closure", handler_body.loc);
                    };
                };
            }
            @default => (); // TODO: warn
        };
    };
    compile_error("inline_match not matched!", loc)
}

/*
`if :: true {| do_something_super_important(); };`
is a footgun because it parses as a declaration not a comptime evaluation of the condition, 
what's worse is that the body is only evaluated if the variable is referenced so if you don't try to call 'if' 
later in that scope it won't even be an error that you can't call true with a trailing lambda. 
*/

fn safety(kind: FatExpr, code: FatExpr) FatExpr #macro = {
    kind := (const_eval(SafetyCheck))(kind);
    ::if(FatExpr);
    if safety_check_enabled(kind) {
        @{ if(!@[code], => safety_check_failed()) }
    } else {
        @{}
    }
}

// TODO: its sad that it makes the compiler binary ~5% smaller to manually out-line this instead of just calling assert. should work on that. -- Jul 5
// TODO: see if thats still true with panic marked #cold and that pass enabled
// For now this is a kinda cool that you can see #cold doing something, it moves this function to the end with the other things in jail like _OUTLINED_FUNCTION
// i'm not convinced its measurably faster I just think it's neat. 
fn safety_check_failed() Never #cold = {
    panic("Safety Check Failed.")
}

fn if_else(handlers: FatExpr) FatExpr #macro  = {
    @ct_assert(handlers.expr&.is(.Block), handlers.loc, "@if_else expected block"); // TODO: add this check to @match
    handlers := handlers.expr.Block.body.items();
    
    no_else :: "@if_else must have @else as last branch";
    want_if :: "Expected `@if(cond) => value`";
    
    while => handlers.last().expect(no_else)[].stmt&.is(.Noop) {
        handlers.len -= 1;
    };
    
    else := handlers.last().expect(no_else);
    @ct_assert(else.stmt&.is(.Eval), else.loc, no_else);
    else := else.stmt.Eval&;
    @ct_assert(else.expr&.is(.PrefixMacro), else.loc, no_else);
    else := else.expr.PrefixMacro&;
    ::AutoEq(?Symbol); ::RefEq(?Symbol);
    @ct_assert(else.handler.ident() == (Some = @symbol else), else.handler.loc, no_else);
    body := @{ @[else.target[]]() }; // TODO: this will get confusing if compiler swaps unit target with arg sooner. 
    handlers.len -= 1;
    
    i := handlers.len - 1;
    while => i >= 0 {
        stmt: *FatStmt = handlers.index(i); 
        if stmt.stmt&.is(.Eval) {
            handler_body := stmt.stmt.Eval&;
            branch := handler_body.expr.PrefixMacro&;
            name := branch.handler.ident() || compile_error(want_if, branch.handler.loc);
            @ct_assert(name == (@symbol if), branch.handler.loc, want_if);
            body = @{ @if(@[branch.arg[]], @[branch.target[]](), @[body]) };
        } else {
            @ct_assert(stmt.stmt&.is(.Noop), stmt.loc, "bad stmt in @if_else");
        };
        i = i.sub(1);
    };
    body
}

// TODO: use this in @match/@switch
fn ident(self: *FatExpr) ?Symbol = {
    @match(self.expr&) {
        fn GetVar(v) => (Some = v.name);
        fn GetNamed(v)  => (Some = v[]);
        fn String(v) => (Some = v[]);
        @default => .None;
    }
}
