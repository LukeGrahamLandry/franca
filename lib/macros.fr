// TODO: should replace #macro with @macro(Prefix) @macro(Bang) @macro(Func)

// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
#macro #outputs(AstExpr)
fn literal(arg: AstExpr, target: AstExpr) AstExpr = '{
    var value: <arg> = <target>;
    literal_ast(<arg>, @as(rawptr) value&)
}';

// Same as the two argument version but infers the type. 
// TODO: assert that arg isn't 'Unit' because then its ambigous with the two argument version. -- Apr 21
#macro #outputs(AstExpr)
fn literal(arg: AstExpr) AstExpr = '{
    var value = <arg>;
    literal_ast(@type value, @as(rawptr) value&)
}';

/// Ast<?> -> Ast<T>
fn as(T: Type, expr: FatExpr) FatExpr = '@(<@literal(as)>)(<@literal(T)>) <expr>';

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
// TODO: allow a catch all default if last func has no name. 
// TODO: should always inline the bodies, even if no captures? 
#macro 
fn match(var arg: FatExpr, var target: FatExpr) FatExpr = {
    stmts: Slice(FatStmt) = target.expr.Block.body;
    arg = compile_ast(arg);
    enum_type := arg.ty;
    info := get_type_info_raw(enum_type);
    
    kind := info&!tag[];
    is_ptr := false;
    if(eq(kind, tag_value(TypeInfo, @symbol(Ptr)))){|
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_raw(enum_type);
        is_ptr = true;
    };
    ptr_ty := *enum_type;
    
    assert(eq(info&!tag[], tag_value(TypeInfo, @symbol(Tagged))), "@match expected argument type to be @tagged");
    info : Tagged!builtin = info.Tagged;
    
    // TODO: single element structs suck ass
    info := (@as(rawptr) info&).ptr_to_int();
    info := info.int_to_ptr();
    varients : *Slice(Ty(Symbol, Type)) = info;
    
    // TODO: compile error to not handle all and not have a default branch
    // TODO: why can't i call 'as'? ffi unique? 
    var body: FatExpr = 'panic("unhandled match case")';
    
    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: infer function argument type since we know it must match the enum payload,
    //       but allow no arg if you just want to use it as a switch. 
    // TODO: use default arguments as value eq guards. 
    
    ::if(FatExpr);
    '{
        var arg_val = <if(is_ptr, =>'@as(Unit)unit', => arg)>;
        var arg_ptr = <if(is_ptr, =>arg, =>'arg_val&')>;
        let tag_val = arg_ptr!tag[];
        <{
            count := 0;
            each(stmts) { (stmt) | 
                if(eq(stmt[].stmt&!tag[], tag_value(Stmt, @symbol(Eval)))) {|  // (1)
                    var handler_body = stmt.stmt.Eval&;
                    closure := handler_body.expr.Closure&;
                    name: Symbol = closure.name; // (2)
                    index := tag_value(enum_type, name); // they're always sequential
                    name_ty := varients[].get(index);
                    assert(name_ty._0.eq(name), "ICE: bad enum index");
                    
                    ty := name_ty._1;
                    if(is_ptr){|
                        p: TypeInfo = (Ptr = ty);
                        ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
                    };
            
                    // If they didn't say the argument type, we can fill it in based on the varient name. 
                    // If they don't put an argument, just ignore the value. Have to set the type because it defaults to Unit. 
                    bindings: Slice(Binding) = closure.arg.bindings;
                    if(bindings.len.eq(1)){|
                        first := bindings[0]&;
                        infer := first.ty&!tag[].eq(tag_value(LazyType, @symbol Infer));
                        Name :: Name!builtin;
                        no_name := first.name&!tag[].eq(tag_value(Name, @symbol None)); 
                        if (infer.or(no_name)){|
                            first.ty = (Finished = ty);
                        };
                    };
                    var case_access = 'arg_ptr.___';
                    case_access.expr.FieldAccess._1 = name;  // (3)
                    let tag = 'tag_value(<@literal(Type) enum_type>, <@literal(name)>)';
                    if(is_ptr){|
                        case_access = '<case_access>&';
                    };
                    count = count.add(1);
                    body = '(eq(tag_val, <tag>), => <handler_body[]>(<case_access>), => <body>)!if';
                };
            };
            if(count.ne(varients.len)) {|
                print("warning: wrong number of @match cases (did you forget to wrap them in brackets?). ");
                print("expected ");
                print(varients.len);
                print(" but found ");
                println(count);
            };
            body
        }>
    }'
}

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> => <body> }
/// - @case(v): calls <body> if value.eq(v)
#macro 
fn switch(var arg: FatExpr, var handlers: FatExpr) FatExpr = {
    handlers: Slice(FatStmt) = handlers.expr.Block.body;
    arg = compile_ast(arg);
    inspected_ty: Type = arg.ty; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    var body = 'panic("unhandled switch case")';
    var first = true;
    var i = handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    '{
        var arg_var = <arg>;
        <{
            while(=> i.ge(0)) {|
                stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if(eq(stmt[].stmt&!tag[], tag_value(Stmt, @symbol(Eval)))) {|
                    var handler_body = stmt.stmt.Eval&;
                    branch := handler_body.expr.PrefixMacro&;
                    macro := branch.handler;
                    // TODO: better error message that shows more context on how you got to a certain type in the nested exprression. 
                    //       it took me so long to figure out you don't need .GetNamed[0][] to index through the first single element tuple because it gets flattened. -- Apr 21 
                    name := (@as(*Symbol) macro.expr.GetNamed&)[]; // TODO: allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                    arg := branch.arg;
                    action := branch.target[];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.eq(@symbol(case)), => {
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        cond := 'eq(arg_var, <as(inspected_ty, arg[])>)';
                        body = '(<cond>, =><action>(), =><body>)!if';
                    }, =>if(name.eq(@symbol(default)), => {
                        if(first) {|
                            // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                            body = '<action>(arg_var)';
                        }{|
                            panic("@default must be the last handler in @switch");
                        };
                    }, =>{
                        // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                        //let n: Str = name.str(); // TODO: this broke when I started renumbering in bind_const_arg -- Apr 23. 
                        // TODO: make concat less painful. 
                        //println(n);
                        panic("unhandled prefix in @switch");
                    }));
                    
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }>
    }'
}

// TODO: There are implicit range assertions because we get the bit count from the type of the ints. 
#macro #outputs(i64)
fn bits(var arg: AstExpr) AstExpr = {
    var zero = 0;
    var parts: Slice(AstExpr) = arg.expr.Tuple;
    var expr = '@as(u32) 0';
    var shift = 32;
    each(parts, fn(part) => {
        var int = get_type_int(part[]);
        // TODO: fix inference + overloading. 
        //       you only need this annotation if you include instructions.fr so there's another definition of `fn sub`
        //       So it doesn't infer through the field lookup but even without that it should notice that
        //       it can't possibly be the one that takes like 6 arguments. 
        let bc: i64 = int.bit_count;
        shift = sub(shift, bc);
        assert(ge(shift, 0), "expected 32 bits. TODO: other sizes.");  // TODO: str(i64) for negative numbers
        
        ::if(FatExpr);
        let next = if(int.signed, 
            => {
                let part_ast = as(i64, part[]);
                'signed_truncate(<part_ast>, <@literal(i64) int.bit_count>)'
            },
            => as(u32, part[])
        );
        let next = 'shift_left(<next>, <@literal(shift)>)';
        expr = 'bit_or(<expr>, <next>)';
    });
    
    // TODO: want to be able to just have a version of assert that does this but there's a weird dependency. 
    if(shift.ne(0)){|
        @println("% != 0; expected 32 bits. TODO: other sizes.", shift);
        //var msg = concat(str(shift), " != 0; expected 32 bits. TODO: other sizes.");
        //let msg: Str = msg&.items();
        //panic(msg);
    };
    
    as(u32, expr)
}

/// The parser desugars stuff into calls to these blessed functions. 
/// But it just refers to them by name. If you cause that to resolve to your own function, you can change the operator's behaviour. 
#macro #outputs(Unit) fn operator_plus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, add);
#macro #outputs(Unit) fn operator_minus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, sub);
#macro #outputs(Unit) fn operator_star_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, mul);
#macro #outputs(Unit) fn operator_slash_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, div);
#macro fn operator_index(container: FatExpr, i: FatExpr) FatExpr = '<container>.index(<i>)[]';

/// All the  'a _= b' operators logically expand to 'a = _(a, b)'.
/// Like normal assignment, the left hand side can be a variable name or a pointer dereference. 
/// However, in the latter case, the expression that produces the pointer is only evaluated once. 
/// Most of the time it doesn't matter but it's legal to put a function call with side effects in that position and this behaviour feels more intuitive. 
// NOTE: don't use these operators in the dependency chain of this function or life gets real confusing, real fast!
// TODO: should allow a mutating fn add_assign(*Self, v) if you have one. like it would be nice for owned strings. 
// TODO: this should work when inlined. the problem is i dont handle DeclVarPattern of large values by address. -- May 7
#inline
fn assignment_operator(var place: FatExpr, value: FatExpr, f: OverloadSet) FatExpr = {
    kind := place.expr&!tag[];
    // TODO: generate a typed enum for the tag so this could be kind.eq(.GetVar).or(kind.eq(.GetNamed))
    is_var_access := 
        eq(kind, tag_value(Expr, @symbol(GetVar)))
        .or(eq(kind, tag_value(Expr, @symbol(GetNamed))))
        .or(eq(kind, tag_value(Expr, @symbol(FieldAccess)))); // TODO: once field access is allowed on r-values, it can have side effects.  
    
    ::if(FatExpr); // TODO: auto template instantiation. 
    
    if(is_var_access){|
        // This type of macro can't return a stmt, so it has to be wrapped in a block. Maybe we should use the other kind once that exists. 
        '{ <place> = <@literal(f)>(<place>, <value>); }'
    } {|
        // TODO: nice report_compile_error api that lets you attatch the Span so you get useful error message rendering. 
        assert(kind.ne(tag_value(Expr, @symbol(PrefixMacro))), "TODO: support macro expansion in place expr");
        is_deref := kind.eq(tag_value(Expr, @symbol(SuffixMacro))).and {()bool|
            name := place.expr.SuffixMacro._0;
            name.eq(@symbol(deref))
        };
        assert(is_deref, "_= operator left hand side must be a place expr.");
        // we know the lhs is 'whatever[]', but we want to just access the pointer and add the deref later. 
        ptr_expr := place.expr.SuffixMacro._1[];
        '{ let ptr = <ptr_expr>; ptr[] = <@literal(f)>(ptr[], <value>); }'
    }
}

/// The compiler defines the two argument version where you specify a type and values. 
/// This version can be used when you just want sequential integers. 
#macro #outputs(Type)
fn enum(var names: FatExpr) FatExpr = {
    kind := names.expr&!tag[];
    assert(eq(kind, tag_value(Expr, @symbol(Tuple))), "expected @enum(name1, name2, etc)"); // TODO: single element should be legal i guess. 

    fn binding(name: Symbol, value: i64) Binding = {
        template := '(a = 0)';
        all : Slice(Binding) = template.expr.StructLiteralP.bindings; 
        out := all.get(0);
        out.name = (Ident = name);
        out.default._0 = 0; // Some 
        out.default._1 = @literal(value);
        out
    }
    
    cases : List(Binding) = list();
    parts : Slice(FatExpr) = names.expr.Tuple;
    enumerate(parts) {(i: i64, part: *FatExpr)|
        // TODO: really need @default on match cause this is annoying. 
        @switch(part[].expr&!tag[]) {
            @case(tag_value(Expr, @symbol GetNamed)) => {
                name := (@as(*Symbol) part.expr.GetNamed&)[];
                cases&.push(binding(name, i));
            };
            @case(tag_value(Expr, @symbol GetVar)) => {
                name: Symbol = part.expr.GetVar.name;
                cases&.push(binding(name, i));
            };
            @default() fn(_: i64) => panic("Expected symbol in @enum"); // TODO: this should work as not a closure
        };
    };

    varients := '(a = 1)';
    cases := cases.items();
    varients.expr.StructLiteralP.bindings = @as(Ty(*Binding, i64)) cases;
    
    '@enum(i64) <varients>'
}

// TODO: this is still a massive hack. it still looks for @as specifically by name. -- May 5
// #macro fn as(T: FatExpr, e: FatExpr) FatExpr = '(<T>, <e>)!as';
