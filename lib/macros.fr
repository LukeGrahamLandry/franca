// TODO: some are hard to use because need brackets or treated as annotation on noop stmt. need to give warning at least. 
//       should replace @annotation with @macro(Prefix) @macro(Bang) @macro(Func)

// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
@annotation @pub
fn literal(arg: AstExpr, target: AstExpr) AstExpr = {
    var lit_fn: OverloadSet = literal_ast; 
    let lit_fn: VoidPtr = lit_fn&;
    let lit_fn = literal_ast(OverloadSet, lit_fn);
    var void_ast = VoidPtr;
    let void_ast: VoidPtr = void_ast&;
    let void_ast = literal_ast(Type, void_ast);
    
    // TODO: typecheck. let _: arg = target; 
    (@with_var(value, target!unquote) {
        lit_fn!unquote(arg!unquote, @as(void_ast!unquote) value&)
    })!quote
}

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
// TODO: allow a catch all default if last func has no name. 
@annotation @pub
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Slice(FatStmt) = target&.expr.Block.body[];
    // TODO: write this as compile_expr and &.ty[] and get rid of infer_raw_deref_type?
    let enum_type: TypeInfo = infer_raw_deref_type(arg);
    var enum_type: Type = intern_type(enum_type);
    
    let panic_fn = @literal(OverloadSet) panic;
    // TODO: compile error to not handle all and not have a default branch
    var body = panic_fn!unquote("unhandled match case")!quote
    let eq_fn = @literal(OverloadSet) eq;
    let i64_t = @literal(Type) i64;
    let tag_value_fn = @literal(OverloadSet) tag_value;
    
    for(stmts) { (stmt: *FatStmt) | 
        // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
        if(eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol))) {|
            var handler_body = stmt.stmt.Eval[];
            // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. 
            var name = handler_body&.expr.Closure[].name[];
            var case_access = (arg_var&.___)!quote;
            case_access&.expr.FieldAccess[1][] = name;
            // TODO: check that no duplicate handlers
            // TODO: error message here if invalid name instead of it showing up later in the generated code. 
            //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
            // TODO: infer function argument type since we know it must match the enum payload,
            //       but allow no arg if you just want to use it as a switch. 
            
            // TODO: giving in an having unquote syntax is probably worth it. is $(expr) that much better than expr!unquote? this is a bit illegable. 
            // TODO: its too hacky that you only have to call clone_ast when there's no placeholders
            var cond = eq_fn!unquote(tag_val, @as(i64_t!unquote) tag_value_fn!unquote(
                (@literal(Type) enum_type)!unquote, 
                (@literal(Symbol) name)!unquote
            ))!quote;
            
            body = (cond!unquote,
                fn= (handler_body!unquote)(case_access!unquote!deref), 
                fn= body!unquote
            )!if!quote;
            
        };
    };
    
    // TODO: Declaring variables is weird because name resolution has already run.
    (@with_var(arg_var, arg!unquote) @with_var(tag_val, arg_var&!tag!deref) body!unquote)!quote
}

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> fn= <body> }
/// - @case(v): calls <body> if value.eq(v)
@annotation @pub
fn switch(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Slice(FatStmt) = target&.expr.Block.body[];
    arg = compile_ast(arg);
    let arg_type = @literal(Type) arg&.ty[];
    
    let panic_fn = @literal(OverloadSet) panic;
    let eq_fn = @literal(OverloadSet) eq;
    var body = panic_fn!unquote("unhandled switch case")!quote;
    var first = true;
    
    // TODO: reverse order because i build out from the inside
    var i = stmts.len().sub(1);
    
    while(fn = i.ge(0)) {|
        let stmt: *FatStmt = stmts.index(i); 
        // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
        if(eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol))) {|
            var handler_body = stmt.stmt.Eval[];
            
            let branch: *PrefixMacro = handler_body&.expr.PrefixMacro;
            let name = branch.name[0][];
            let arg = branch.arg[];
            let action = branch.target[][];
            
            // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
            if(name.int().eq(case!symbol.int()), fn = {
                // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                let cond = (eq_fn!unquote(arg_var, @as(arg_type!unquote) arg[]!unquote))!quote;
                body = ((cond!unquote, fn= action!unquote(), fn=body!unquote)!if)!quote;
            }, fn=if(name.int().eq(default!symbol.int()), fn = {
                if(first) {|
                    // If expansion err here: forgot argument for default branch handler?
                    body = (action!unquote(arg_var))!quote;
                }{|
                    panic("@default must be the last handler in @switch");
                };
            }, fn={
                // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                let n: Str = name.str();
                // TODO: make concat less painful. 
                println(n);
                panic("unhandled prefix in @switch");
            }));
            
            first = false;
        };
        i = i.sub(1);
    };
    
    // TODO: Declaring variables is weird because name resolution has already run.
    (@with_var(arg_var, arg!unquote) body!unquote)!quote
}

// TODO: There are implicit range assertions because we get the bit count from the type of the ints. 
@annotation @pub
fn bits(arg: AstExpr, target: AstExpr) AstExpr = {
    let fn_trunc = @literal(OverloadSet) signed_truncate;
    let fn_shift = @literal(OverloadSet) shift_left;
    let fn_or = @literal(OverloadSet) bit_or;
    var zero = 0;
    var i64_ast = @literal(Type) i64;

    var parts: Slice$AstExpr = arg&.expr.Tuple[];
    var expr = @literal(i64) 0;
    var shift = 32;
    for(parts, fn(part: *AstExpr) Unit = {
        var int: IntTypeInfo = get_type_int(part[]);
        // TODO: fix inference + overloading. 
        //       you only need this annotation if you include instructions.fr so there's another definition of `fn sub`
        //       So it doesn't infer through the field lookup but even without that it should notice that
        //       it can't possibly be the one that takes like 6 arguments. 
        let bc: i64 = int&.bit_count[];
        shift = sub(shift, bc);
        assert(ge(shift, 0), "expected 32 bits. TODO: other sizes.");  // TODO: str(i64) for negative numbers
        let part_ast = (@as(i64_ast!unquote) part[]!unquote)!quote;
        let next = (int&.signed[], 
            fn() AstExpr = new_call_ast(fn_trunc, new_pair_ast(part_ast, @literal(i64) int&.bit_count[])),
            fn() AstExpr = part_ast
        )!if;
        let next = new_call_ast(fn_shift, new_pair_ast(next, @literal(i64) shift));
        expr = new_call_ast(fn_or, new_pair_ast(expr, next));
    });
    
    // TODO: want to be able to just have a version of assert that does this but there's a weird dependency. 
    if(shift.ne(0)){|
        var msg = concat(str(shift), " != 0; expected 32 bits. TODO: other sizes.".str());
        let msg: Str = msg&.items();
        panic(msg.str());
    };
    
    (@as(i64_ast!unquote) expr!unquote)!quote
}

// Seems like a fairly crippling design problem the range at which adding new code can mess you up. 
// But that should get better with a stricter module system that lets you import into a namespace. 
// Prior art: 
// - https://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching/
// - https://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/
