
// TODO: hard to use because need brackets or treated as annotation on noop stmt. need to give warning at least. 
//       should replace @annotation with @macro(Prefix) @macro(Bang) @macro(Func)
@annotation @pub
fn if(arg: AstExpr, target: AstExpr) AstExpr = 
    (arg!unquote, fn() Unit = target!unquote, fn()=())!if!quote;

// TODO: stop using __ names with @with_var in other places, it only does get_named so don't need to avoid collissions. 
// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
@annotation @pub
fn literal(arg: AstExpr, target: AstExpr) AstExpr = {
    var lit_fn: OverloadSet = literal_ast;
    let lit_fn = literal_ast(OverloadSet, lit_fn&);
    
    (@with_var(value, target!unquote) 
        lit_fn!unquote(arg!unquote, value&)
    )!quote
}

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
@annotation @pub
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Slice(FatStmt) = target&.expr.Block.body[];
    let enum_type: TypeInfo = infer_raw_deref_type(arg);
    var enum_type: Type = intern_type(enum_type);
    
    let panic_fn = @literal(OverloadSet) panic;
    var body = panic_fn!unquote("unhandled match case")!quote
    
    foreach(stmts, fn(stmt: Ptr(FatStmt)) Unit = {
        // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
        (eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol)), fn()={
            var handler_body: FatExpr = stmt.stmt.Eval[];
            // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. 
            var name: Symbol = handler_body&.expr.Closure[].name[];
            
            var case_access: FatExpr = clone_ast((arg_var&.___)!quote);
            let name_ptr = case_access&.expr.FieldAccess[1];
            name_ptr[] = name;
            
            // TODO: giving in an having unquote syntax is probably worth it. is $(expr) that much better than expr!unquote? this is a bit illegable. 
            // TODO: its too hacky that you only have to call clone_ast when there's no placeholders
            var cond = eq(tag_val, tag_value(
                (@literal(Type) enum_type)!unquote, 
                (@literal(Symbol) name)!unquote
            ))!quote;
            
            body = (cond!unquote,
                fn() = (handler_body!unquote)(case_access!unquote!deref), 
                fn() = body!unquote
            )!if!quote;
            
        }, fn()=())!if;
    });
    
    // TODO: Declaring variables is weird because name resolution has already run.
    (@with_var(arg_var, arg!unquote) @with_var(tag_val, arg_var&!tag!deref) body!unquote)!quote
}

// TODO: There are implicit range assertions because we get the bit count from the type of the ints. 
@annotation @pub
fn bits(arg: AstExpr, target: AstExpr) AstExpr = {
    let fn_trunc = @literal(OverloadSet) signed_truncate;
    let fn_shift = @literal(OverloadSet) shift_left;
    let fn_or = @literal(OverloadSet) bit_or;
    var zero = 0;
    var i64_ast = @literal(Type) i64;

    var parts: Slice(AstExpr) = arg&.expr.Tuple[];
    var expr = @literal(i64) 0;
    var shift = 32;
    foreach(parts, fn(part: Ptr(AstExpr)) Unit = {
        var int: IntType = get_type_int(part[]);
        // TODO: fix inference + overloading. 
        //       you only need this annotation if you include instructions.fr so there's another definition of `fn sub`
        //       So it doesn't infer through the field lookup but even without that it should notice that
        //       it can't possibly be the one that takes like 6 arguments. 
        let bc: i64 = int&.bit_count[];
        shift = sub(shift, bc);
        assert(ge(shift, 0), "expected 32 bits. TODO: other sizes.");  // TODO: str(i64) for negative numbers
        let part_ast = (@as(i64_ast!unquote) part[]!unquote)!quote;
        let next = (int&.signed[], 
            fn() AstExpr = new_call_ast(fn_trunc, new_pair_ast(part_ast, literal_ast(i64, int&.bit_count))),
            fn() AstExpr = part_ast
        )!if;
        let next = new_call_ast(fn_shift, new_pair_ast(next, @literal(i64) shift));
        expr = new_call_ast(fn_or, new_pair_ast(expr, next));
        
    });
    assert(eq(shift, 0), concat(str(shift), " != 0; expected 32 bits. TODO: other sizes."));
    (@as(i64_ast!unquote) expr!unquote)!quote
}

// Seems like a fairly crippling design problem the range at which adding new code can mess you up. 
// But that should get better with a stricter module system that lets you import into a namespace. 
// Prior art: 
// - https://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching/
// - https://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/
