// TODO: some are hard to use because need brackets or treated as annotation on noop stmt. need to give warning at least. 
//       should replace @annotation with @macro(Prefix) @macro(Bang) @macro(Func)

// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
@annotation 
fun literal(arg: AstExpr, target: AstExpr) AstExpr = {
    var lit_fn: OverloadSet = literal_ast; 
    let lit_fn: VoidPtr = lit_fn&;
    let lit_fn = literal_ast(OverloadSet, lit_fn);
    var void_ast = VoidPtr;
    let void_ast: VoidPtr = void_ast&;
    let void_ast = literal_ast(Type, void_ast);
    var as_fn = as;
    let as_fn: VoidPtr = as_fn&;
    let as_fn = literal_ast(OverloadSet, as_fn);
    
    '{
        var value: <arg> = <target>;
        <lit_fn>(<arg>, @(<as_fn>)(<void_ast>) value&)
    }'
}

// Same as the two argument version but infers the type. 
@annotation 
fun literal(arg: AstExpr) AstExpr = {
    // TODO: assert that arg isn't 'Unit' because then its ambigous with the two argument version. -- Apr 21
    const lit_fn = @literal(OverloadSet) literal_ast; 
    const void_ast = @literal(Type) VoidPtr; 
    const as_fn = @literal(OverloadSet) as;
    '{
        var value = <arg>;
        <lit_fn>(value!type, @(<as_fn>)(<void_ast>) value&)
    }'
}

/// Ast<?> -> Ast<T>
fun as(T: Type, expr: FatExpr) FatExpr = '@(<@literal(as)>)(<@literal(T)>) <expr>';

// TODO: need to have an actual clone method because just relying on stack copy will share heap ptrs. 
// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
// TODO: allow a catch all default if last func has no name. 
@annotation 
fun match(arg: FatExpr, target: FatExpr) FatExpr = {
    let stmts: Slice(FatStmt) = target&.expr.Block.body[];
    arg = compile_ast(arg);
    let enum_type = arg&.ty[];
    
    // TODO: compile error to not handle all and not have a default branch
    // TODO: why can't i call 'as'? ffi unique? 
    var body: FatExpr = '<@literal(panic)>("unhandled match case")';
    
    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: infer function argument type since we know it must match the enum payload,
    //       but allow no arg if you just want to use it as a switch. 
    // TODO: use default arguments as value eq guards. 
    
    '{
        var arg_var = <arg>;
        let tag_val = arg_var&!tag[];
        <{
            for(stmts) { (stmt: *FatStmt) | 
                if(eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol))) {|  // (1)
                    var handler_body = stmt.stmt.Eval[];
                    var name = handler_body&.expr.Closure[].name[]; // (2)
                    var case_access = 'arg_var&.___';
                    case_access&.expr.FieldAccess[1][] = name;  // (3)
                    let tag = '<@literal(tag_value)>(<@literal(Type) enum_type>, <@literal(name)>)';
                    let cond = '<@literal(eq)>(tag_val, <tag>)';
                    body = '(<cond>, fn = <handler_body>(<case_access>[]), fn = <body>)!if';
                };
            };
            body
        }>
    }'
}

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> fn= <body> }
/// - @case(v): calls <body> if value.eq(v)
@annotation 
fun switch(arg: FatExpr, handlers: FatExpr) FatExpr = {
    let handlers: Slice(FatStmt) = handlers&.expr.Block.body[];
    arg = compile_ast(arg);
    let inspected_ty: Type = arg&.ty[]; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    var body = '<@literal(panic)>("unhandled switch case")';
    var first = true;
    var i = handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    '{
        var arg_var = <arg>;
        <{
            while(fn = i.ge(0)) {|
                let stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if(eq(stmt.stmt!tag[], tag_value(Stmt, Eval!symbol))) {|
                    var handler_body = stmt.stmt.Eval[];
                    let branch = handler_body&.expr.PrefixMacro;
                    let macro = branch.handler[];
                    // TODO: better error message that shows more context on how you got to a certain type in the nested exprression. 
                    //       it took me so long to figure out you don't need .GetNamed[0][] to index through the first single element tuple because it gets flattened. -- Apr 21 
                    let name: Symbol = macro.expr.GetNamed[]; // TODO: allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                    let arg = branch.arg[];
                    let action = branch.target[][];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.int().eq(case!symbol.int()), fn = {
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        let cond = '<@literal(eq)>(arg_var, <as(inspected_ty, arg[])>)';
                        body = '(<cond>, fn=<action>(), fn=<body>)!if';
                    }, fn=if(name.int().eq(default!symbol.int()), fn = {
                        if(first) {|
                            // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                            body = '<action>(arg_var)';
                        }{|
                            panic("@default must be the last handler in @switch");
                        };
                    }, fn={
                        // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                        let n: Str = name.str();
                        // TODO: make concat less painful. 
                        println(n);
                        panic("unhandled prefix in @switch");
                    }));
                    
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }>
    }'
}

// TODO: There are implicit range assertions because we get the bit count from the type of the ints. 
@annotation 
fun bits(arg: AstExpr) AstExpr = {
    var zero = 0;
    var parts: Slice$AstExpr = arg&.expr.Tuple[];
    var expr = @literal(0);
    var shift = 32;
    for(parts, fn(part: *AstExpr) Unit = {
        var int = get_type_int(part[]);
        // TODO: fix inference + overloading. 
        //       you only need this annotation if you include instructions.fr so there's another definition of `fn sub`
        //       So it doesn't infer through the field lookup but even without that it should notice that
        //       it can't possibly be the one that takes like 6 arguments. 
        let bc: i64 = int&.bit_count[];
        shift = sub(shift, bc);
        assert(ge(shift, 0), "expected 32 bits. TODO: other sizes.");  // TODO: str(i64) for negative numbers
        let part_ast = as(i64, part[]);
        let next = (int&.signed[], 
            fn = '<@literal(signed_truncate)>(<part_ast>, <@literal(i64) int&.bit_count[]>)',
            fn = part_ast
        )!if;
        let next = '<@literal(shift_left)>(<next>, <@literal(shift)>)';
        expr = '<@literal(bit_or)>(<expr>, <next>)';
    });
    
    // TODO: want to be able to just have a version of assert that does this but there's a weird dependency. 
    if(shift.ne(0)){|
        var msg = concat(str(shift), " != 0; expected 32 bits. TODO: other sizes.".str());
        let msg: Str = msg&.items();
        panic(msg.str());
    };
    
    as(i64, expr)
}


// Seems like a fairly crippling design problem the range at which adding new code can mess you up. 
// But that should get better with a stricter module system that lets you import into a namespace. 
// Prior art: 
// - https://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching/
// - https://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/
