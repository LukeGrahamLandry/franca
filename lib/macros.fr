// TODO: should replace #macro with @macro(Prefix) @macro(Bang) @macro(Func)

// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
#macro #outputs(AstExpr)
fn literal(arg: AstExpr, target: AstExpr) AstExpr = @{
    value: @[arg] = @[target];
    literal_ast(@[arg], raw_from_ptr(@[arg], value&))
};

fn if(cond: FatExpr, do: FatExpr) FatExpr #macro = {
    @{ @if(@[cond], @[do], ()) }
}

// Same as the two argument version but infers the type. 
// TODO: assert that arg isn't 'void' because then its ambigous with the two argument version. -- Apr 21
#macro #outputs(AstExpr)
fn literal(arg: AstExpr) AstExpr = @{
    value := @[arg];
    literal_ast(@type value, raw_from_ptr(@type value, value&))
};

// TODO: it does that by name tho! so its a very bad idea to shadow this with another macro. HACK
fn as(T: Type, expr: FatExpr) FatExpr = @{ @as(@[@literal(T)]) @[expr] };


// TODO: once i have an asm backend, this can become a jump table which is pretty cool. 
// TODO: this has a referential transparency problem
#macro 
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    loc := arg.loc;
    stmts := target.expr.Block.body.items();
    arg = compile_ast(arg);
    enum_type := arg.ty;
    info := get_type_info_ref(enum_type);
    
    un_raw := enum_type.get_type_info_ref();
    if un_raw.is(.Enum) {|
        // TODO: use new switch expression -- Jul 26
        return(match_on_enum(arg, un_raw, stmts));
    };
    
    is_ptr := false;
    if info.is(.Ptr) {|
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        is_ptr = true;
    };
    ptr_ty := *enum_type;
    
    @ct_assert(!info.is(.Enum), arg.loc, "to @match on an @enum, dereference the pointer"); // TODO: just do it
    @ct_assert(info.is(.Tagged), arg.loc, "@match expected argument type to be @tagged");
    info := info.Tagged;
    
    varients := info.cases.items();

    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: infer function argument type since we know it must match the enum payload,
    //       but allow no arg if you just want to use it as a switch. 
    // TODO: use default arguments as value eq guards. 
    
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    
    ::if(FatExpr);
    @{
        arg_val := @[if(is_ptr, => @{ @as(void)unit }, => arg)];
        arg_ptr := @[if(is_ptr, =>arg, => @{ arg_val& })];
        :: tagged(@[@literal enum_type]);
        tag_val := arg_ptr.tag().ordinal();
        // TODO: when safety checks are on don't do the default branch even for garbage tag.
        //       in fast mode tho make that UB.  -- Jul 9
        @[{
            // If there's no @default, this is hit by invalid tags. 
            // TODO: when enabled just used @safety? so the message isn't different when you have a @default branch. 
            default: FatExpr = if(safety_check_enabled(.InvalidTag), => @{ 
                // TODO: make this a build option / safety check. all could have None/Abort/Panic/Verbose
                @println("tag=%, expected 0..<%", tag_val, @[@literal varients.len]);
                panic("matched on invalid tag! Uninitialized memory?") 
            }, => @{ unreachable() }); // TODO: tell llvm unreachable_unchecked when the safety check is off?
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            while(=> i.ge(0)) {|
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    index := tag_value(enum_type, closure.name); // they're always sequential (TODO: assert on the enum type)
                    (name, ty) := varients.get(index);
                    assert(name.eq(closure.name), "ICE: bad enum index");
                    
                    if(is_ptr){|
                        p: TypeInfo = (Ptr = ty);
                        ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
                    };
            
                    // If they didn't say the argument type, we can fill it in based on the varient name. 
                    // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
                    bindings := closure.arg.bindings.items();
                    if(bindings.len.eq(1)){|
                        first := bindings[0]&;
                        infer := first.ty&.is(.Infer);
                        no_name := first.name&.is(.None); 
                        if  infer.or(no_name) {|
                            first.ty = (Finished = ty);
                        };
                    };
                    case_access := @{ arg_ptr.___ };
                    case_access := case_access.expr.Block.result[];
                    case_access.expr.FieldAccess.name = name;  // (3)
                    tag := @{ tag_value(@[@literal(Type) enum_type], @[@literal(name)]) };
                    if(is_ptr){|
                        case_access = @{ @[case_access]& };
                    };
                    count = count.add(1);
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (index, @{ @[callable](@[case_access]) } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {|
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {| 
                        expand_case_body(handler_body.expr.Closure);
                    } {| // else
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        assert(handler_body.expr&.is(.PrefixMacro), "expected @default");
                        branch := handler_body.expr.PrefixMacro&;
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default"); // TODO: bring back safety checks on tagged field access. 
                        name := macro.expr.GetNamed; // TODO: ^ allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {|
                            default = @{ 
                                @safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {|
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), loc, "wrong number of @match cases",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), loc, "@default but too many @match cases");
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn make_switch(value: FatExpr, default: FatExpr, cases: List(Ty(i64, FatExpr))) FatExpr = {
    default_box := ast_alloc().alloc(FatExpr, 1);
    default_box.ptr[] = default;
    value_box := ast_alloc().alloc(FatExpr, 1);
    value_box.ptr[] = value;
    switch: FatExpr = (expr = (Switch = (value = value_box.ptr, default = default_box.ptr, cases = cases.rs())), loc = value.loc, ty = UnknownType, done = false); 
    switch
}

fn match_on_enum(arg: FatExpr, info: *TypeInfo, stmts: [] FatStmt) FatExpr = {
    info := info.Enum;
    
    varients := info.fields.items();
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    
    // TODO: why can't i call 'as'? ffi unique? 
    default: FatExpr = @{ panic("matched on invalid tag???") }; 
    
    ::if(FatExpr);
    @{
        tag_val := @[arg].raw();
        @[{
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            while(=> i.ge(0)) {|
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    index := tag_value(arg.ty, closure.name);  // just make sure the name exists
                    count = count.add(1);
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (index, @{ @[callable]() } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {|
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {| 
                        expand_case_body(handler_body.expr.Closure);
                    } {| // else
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        assert(handler_body.expr&.is(.PrefixMacro), "expected @default");
                        branch := handler_body.expr.PrefixMacro&;
                        macro := branch.handler;
                        assert(macro.expr&.is(.GetNamed), "expected @default"); // TODO: bring back safety checks on tagged field access. 
                        name := macro.expr.GetNamed; // TODO: ^ allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {|
                            default = @{ 
                                @safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {|
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), arg.loc, "wrong number of @match cases",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), arg.loc, "@default but too many @match cases");
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn ct_assert(arg: FatExpr) FatExpr #macro = {
    assert(arg.expr&.is(.Tuple), "@assert___ expected multiple args");
    parts := arg.expr.Tuple.items();
    assert(parts.len >= 3, "not enough arguments");
    cond := parts[0];
    span := compile_ast(parts[1]);
    if !(span.ty == Span) {|
        compile_error("Expected type 'Span' for error location", span.loc);
    };
    
    @{
        if !@[cond]{ #cold |
            out: List(u8) = list(temp());
            @[if(parts.len == 3, => @{
                out&.push_all(@[parts[2]]);
            }, => @{()} )];
            @[if(parts.len > 3, => {
                format_into(@{ out& }, parts.rest(2), arg.loc)
            }, => @{()} )];
            compile_error(out.items(), @[span]);
        };
    }
}

fn if_let(arg: FatExpr, handler: FatExpr) FatExpr #macro = @{
    @match(@[arg]) {
        @[handler];
        @default => ();
    }
};

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> => <body> }
/// - @case(v): calls <body> if value.eq(v)
#macro 
fn switch(arg: FatExpr, handlers: FatExpr) FatExpr = {
    handlers := handlers.expr.Block.body.items();
    arg = compile_ast(arg);
    inspected_ty: Type = arg.ty; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    body := @{ panic("unhandled switch case") };
    first := true;
    i := handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    @{
        arg_var := @[arg];
        @[{
            while(=> i.ge(0)) {|
                stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if stmt.stmt&.is(.Eval) {|
                    handler_body := stmt.stmt.Eval&;
                    branch := handler_body.expr.PrefixMacro&;
                    macro := branch.handler;
                    // TODO: better error message that shows more context on how you got to a certain type in the nested exprression. 
                    //       it took me so long to figure out you don't need .GetNamed[0][] to index through the first single element tuple because it gets flattened. -- Apr 21 
                    name := (@as(*Symbol) macro.expr.GetNamed&)[]; // TODO: allow GetVar becuase they might have shadowed 'case' and 'default'? or should we respect their shadowing once you're allowed to expand custom macros in there. even then should give warning cause its confusing.  
                    arg := branch.arg;
                    action := branch.target[];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.eq(@symbol case)) {|
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        cond := @{ eq(arg_var, @[as(inspected_ty, arg[])]) };
                        body = @{ @if(@[cond], @[action](), @[body]) };
                    } {|
                        if(name.eq(@symbol default)) {|
                            if(first) {|
                                // TODO: dont pass it if the function wants void arg.
                                // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                                assert(action.expr&.is(.Closure), "@switch @default: expected closure");
                                
                                assert(action.expr.Closure.arg.bindings.len == 1, "@switch @default: expected single arg. (parser treats (fn name() ..) as having unnamed arg automatically)");
                                arg := action.expr.Closure.arg.bindings[0]&;
                                :: tagged(Name);
                                if arg.name&.is(.None) {|
                                    body = @{ @[action]() };
                                } else {|
                                    body = @{ @[action](arg_var) };
                                };
                                
                            }{|
                                compile_error("@default must be the last handler in @switch", stmt.loc);
                            };
                        }{|
                            if(name.eq(@symbol inclusive)) {|
                                cond := @{
                                    (min, max) := @[as(Ty(inspected_ty, inspected_ty), arg[])];
                                    arg_var.ge(min).and(arg_var.le(max))
                                };
                                body = @{ @if(@[cond], @[action](), @[body]) };
                            }{|
                                // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                                compile_error("unhandled prefix in @switch", stmt.loc);
                            };
                        };
                    };
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }]
    }
}

// TODO: implicit range assertions because we get the bit count from the type of the ints. 
fn bits(arg: FatExpr) FatExpr #macro = {
    @ct_assert(arg.expr&.is(.Tuple), arg.loc, "Expected @Bits(Tuple...)");
    parts := arg.expr.Tuple;

    new_args: List(FatExpr) = list(parts.len() * 3, ast_alloc());
    shift := 32;
    out := @{ 0 };
    each parts { int |
        ty := get_type_int(int[]); // TODO: this shallow copy is sketchy.

        shift -= ty.bit_count;
        @ct_assert(shift >= 0, arg.loc, "expected 32 bits not >%. TODO: other sizes.", shift.abs() + 32);
        
        ::if(FatExpr);
        // TODO: HACK. this will get more sane when weird int sizes are represented as the next one up instead of always i64.
        real_int: FatExpr = if ty.bit_count.eq(16).or(ty.bit_count == 32).or(ty.bit_count == 8) {|
            @{ @as(i64) @[int[]].zext() }
        } else {|
            // note: we're using the pointer into the array as the box because we know it leaks so its fine. 
            (expr = (Cast = int), loc = arg.loc, ty = i64, done = false)
        };
        
        if ty.signed {|
            real_int = @{ @as(i64) signed_truncate(@[real_int], @[@literal(i64) ty.bit_count]).zext() }
        };
        
        out = @{ @[out].bit_or(@[real_int].shift_left(@[@literal shift])) };
    };

    if shift != 0 {|
        compile_error("shift != 0; expected 32 bits. TODO: other sizes.", arg.loc);
    };
    
    @{ @as(u32) @[out].trunc() }
}

/// :blessed: The parser desugars stuff into calls to these functions. 
/// But it just refers to them by name. If you cause that to resolve to your own function, you can change the operator's behaviour. 
#macro #outputs(void) fn operator_plus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, add);
#macro #outputs(void) fn operator_minus_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, sub);
#macro #outputs(void) fn operator_star_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, mul);
#macro #outputs(void) fn operator_slash_equal(place: FatExpr, value: FatExpr) FatExpr = assignment_operator(place, value, div);
#macro fn operator_index(container: FatExpr, i: FatExpr) FatExpr = @{ @[container].index(@[i])[] };

/// All the  'a _= b' operators logically expand to 'a = _(a, b)'.
/// Like normal assignment, the left hand side can be a variable name or a pointer dereference. 
/// However, in the latter case, the expression that produces the pointer is only evaluated once. 
/// Most of the time it doesn't matter but it's legal to put a function call with side effects in that position and this behaviour feels more intuitive. 
// NOTE: don't use these operators in the dependency chain of this function or life gets real confusing, real fast!
// TODO: should allow a mutating fn add_assign(*Self, v) if you have one. like it would be nice for owned strings. 
// TODO: this should work when inlined. the problem is i dont handle DeclVarPattern of large values by address. -- May 7
#inline
fn assignment_operator(place: FatExpr, value: FatExpr, f: OverloadSet) FatExpr = {
    kind := place.expr&.tag();
    // TODO: generate a typed enum for the tag so this could be kind.eq(.GetVar).or(kind.eq(.GetNamed))
    is_var_access := 
        place.expr&.is(.GetVar)
        .or(place.expr&.is(.GetNamed))
        .or(place.expr&.is(.FieldAccess)); // TODO: once field access is allowed on r-values, it can have side effects.  
    
    ::if(FatExpr); // TODO: auto template instantiation. 
    
    if(is_var_access){|
        // This type of macro can't return a stmt, so it has to be wrapped in a block. Maybe we should use the other kind once that exists. 
        @{ @[place] = @[@literal(f)](@[place], @[value]); }
    } {|
        if kind == .PrefixMacro {|
            compile_error("TODO: support macro expansion in place expr", place.loc);
        };
        is_deref := kind == .Deref;
        if !is_deref {|
            compile_error("_= operator left hand side must be a place expr.", place.loc);
        };
        // we know the lhs is 'whatever[]', but we want to just access the pointer and add the deref later. 
        ptr_expr := place.expr.Deref[];
        @{ ptr := @[ptr_expr]; ptr[] = @[@literal(f)](ptr[], @[value]); }
    }
}

/// The compiler defines the two argument version where you specify a type and values. 
/// This version can be used when you just want sequential integers. 
#macro #outputs(Type)
fn enum(names: FatExpr) FatExpr = {
    @ct_assert(names.expr&.is(.Tuple), names.loc, "expected @enum(name1, name2, etc)"); // TODO: single element should be legal i guess. 

    fn binding(name: Symbol, value: i64) Binding = {
        template := @{ (a = 0) };
        template := template.expr.Block.result[];
        all := template.expr.StructLiteralP.bindings.items();
        out := all.get(0);
        out.name = (Ident = name);
        out.default = (Some = @literal(value));
        out
    }
    
    cases: List(Binding) = list(ast_alloc());
    parts := names.expr.Tuple.items();
    enumerate(parts) {i, part|
        name := @switch(part[].expr&.tag()) {
            @case(.GetNamed) => part.expr.GetNamed;
            @case(.GetVar)   => part.expr.GetVar.name;
            @default         => compile_error("Expected symbol in @enum", names.loc); // TODO: this should work as not a closure
        };
        cases&.push(binding(name, i));
    };

    varients := @{ (a = 1) };
    varients := varients.expr.Block.result[];
    cases := cases.items();
    varients.expr.StructLiteralP.bindings = (cap = cases.len, ptr = cases.ptr, len = cases.len);
    
    @{ @enum(i64) @[varients] }
}

// TODO: @comptime_var which is like this but a constant at runtime. 
#macro fn static(T: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: @[t].ptr_from_raw(@as(rawptr) malloc(@[t].size_of())) }
}

// TODO: instead of this, you should be able to take the address of a normal :: constant,
//       but i should know which pointers are const. 
//       but that doesn't fix the problem of needing the constant to be ready so you can use it in functions that it contains pointers to. 
//       need !rec to work for anything, not just types?    -- Jun 18
#macro fn static(T: FatExpr, value: FatExpr) FatExpr = {
    t := @literal const_eval_type(T);
    @{ :: {
        ptr := @[t].ptr_from_raw(@as(rawptr) malloc(@[t].size_of()));
        ptr[] = @[value];
        ptr
    }}
}

// @array(1, 2, 3) creates an Array(i64, 3)
// because its a pain to make a constant one otherwise. 
// NOTE: this doesn't make a constant one unless you explicitly use '::'.
#macro fn array(elements: FatExpr) FatExpr = {
    @ct_assert(elements.expr&.is(.Tuple), elements.loc, "Expected @array(a, b, c, d)");
    parts := elements.expr.Tuple.items();
    len := parts.len;
    first := compile_ast(parts[0]);
    parts.set(0, first);
    @{ @as(Array(@[@literal parts[0].ty], @[@literal len])) init(@slice @[elements]) }
}

fn is();
fn tag();
fn tag_ptr();
fn ordinal();

// TODO: have @tagged auto call this
// TODO: seperate out the parts that could work on any sequential enum. 
// TODO: move these to like meta.fr maybe? enum.fr? 
fn tagged($Tagged: Type) void = {
    // TODO: assert its really a tagged type.
    
    // assert_eq(size_of(Tagged.Tag()), size_of(i64)); // TODO: ?? doesn't type check. happening too early? -- Jul 1
    
    T :: Tagged.Tag();
    
    // :tag_is_always_i64
    :: enum(T);
    fn tag(self: *Tagged) T #inline = self.tag_ptr()[];
    fn tag_ptr(self: *Tagged) *T #unsafe_noop_cast;  // SAFETY: The compiler puts the tag at the front of the struct. 
    
    fn is(self: *Tagged, check: T) bool #inline = self.tag().eq(check);
    
}

fn raw();
fn from_raw();

fn expect_enum(T: Type) void = {
    info := get_type_info(T);
    // TODO: this doesn't compile with trying to eq on **FnBody ?????! :FUCKED
    //assert(info&.is(.Enum), "expected enum type");
    //assert(info.Enum.sequential, "expected enum elements to be sequential");
}

fn enum($T: Type) void = {
    @late T.expect_enum();
    
    fn eq(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    fn ne(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    
    fn ordinal(e: T) i64 = e.raw(); // :tag_enums_are_sequential
    
    RAW :: { i := get_type_info(T); i.Enum.raw };
    
    fn raw(e: T) RAW = {
        ptr_cast_unchecked(T, RAW, e&)[]
    }
    
    fn display(self: T, out: *List(u8)) void = {
        // TODO: without the extra force comptime eval, it wrongly thinks calling this function needs compctx.  -- Jul 1
        names :: @run get_enum_names(T); // :tag_enums_are_sequential
        out.push_all(names[self.ordinal()]);
    }
    
    fn display(self: *T, out: *List(u8)) void #inline = {
        self[].display(out);
    }
    
    fn name(self: T) Symbol = {
        names :: @run get_enum_names_symbols(T); 
        names[self.ordinal()]
    }
}

// TODO: fix infinite loop from ?i64 if this is in fn enum. -- Jul 8
fn from_raw($T: Type) void = {
    @late T.expect_enum();
    
    fn from_raw(raw: i64) ?T = {
        ::if(?T);
        // Note: this relies on it being sequentual. 
        if(raw.lt(0).or(raw >= @run T.enum_cases().len()), => .None) {|
            value := bit_cast_unchecked(i64, T, raw);
            (Some = value)
        }
    } 
}


fn enum_cases(T: Type) [] Ty(Symbol, Values) = {
    info := get_type_info(T);
    assert(info&.is(.Enum), "expected enum type");
    info.Enum.fields.items()
}

// :blessed: This is also a builtin_prefix_macro. It lets you disable code while bootstrapping up to having the type for FatExpr.
// See bootstrap_compiler_environment 
fn late(e: FatExpr) FatExpr #macro = e;

// TODO: define the syntax as a call to this function. maybe get rid of the syntax. cause its a pain.
//       then this can just be an export_ffi that calls immediate_eval_expr, but that requores passing expected type to macros. 
fn run(e: FatExpr) FatExpr #macro = @{ :: @[e] };

// TODO: this is useless because you can't unquote inside. 
//       tho actually, it does get here, you could handle the unquoting in here... maybe. 
fn quote(e: FatExpr) FatExpr #macro = 
    @literal e;

/// @expand @quote X === X
fn expand(e: FatExpr) FatExpr #macro = 
    (const_eval(FatExpr)(e));

fn inline_for(container: FatExpr, body: FatExpr) FatExpr #macro = {
    container := compile_ast(@{ :: @[container] });
    len := (const_eval(i64)(@{ v := @[container]; v.len() }));
    
    actions: List(FatExpr) = list(ast_alloc());
    range(0, len) { i | 
        actions&.push(@{ @[body](:: (@[container].index(@[@literal i]))) });
    };
    // TODO: dumpster fire garbage error message if you try to make a single length tuple
    //       "Expr::Tuple should have struct type"
    if actions.len == 1 {|
        container.expr = actions[0].expr;
    } else {|
        container.expr = (Tuple = actions.rs());
    };
    container.ty = UnknownType; 
    container.done = false;
    container
}

// TODO: this is kinda copy-paste from normal match. try to factor some stuff out? -- Jul 5
fn inline_match(container: FatExpr, target: FatExpr) FatExpr #macro = {
    loc := container.loc;
    container := compile_ast(@{ :: @[container] });
    
    stmts := target.expr.Block.body.items();
    enum_type := container.ty;
    info := get_type_info_ref(enum_type);
    
    is_ptr := false;
    tag_expr := @literal unit;
    if info.is(.Ptr) {|
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        is_ptr = true;
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a[]); a.tag().ordinal() } };
    } {|
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a); a&.tag().ordinal() } };
    };
    ptr_ty := *enum_type;
   
    @ct_assert(info.is(.Tagged), loc, "@match expected argument type to be @tagged");
    info := info.Tagged;
    tag_val := const_eval(i64)(tag_expr);
    
    varients := info.cases.items();
    
    each stmts { stmt |
        continue :: local_return;
        expand_case_body :: fn(closure: *Func) FatExpr => {
            index := tag_value(enum_type, closure.name); // they're always sequential
            (name, ty) := varients.get(index);
            @ct_assert(name == closure.name, closure.loc, "ICE: bad enum index");
            if index != tag_val {|
                continue();
            };
            
            if(is_ptr){|
                p: TypeInfo = (Ptr = ty);
                ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
            };
    
            // If they didn't say the argument type, we can fill it in based on the varient name. 
            // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
            bindings := closure.arg.bindings.items();
            if(bindings.len.eq(1)){|
                first := bindings[0]&;
                infer := first.ty&.is(.Infer);
                no_name := first.name&.is(.None); 
                if  infer.or(no_name) {|
                    first.ty = (Finished = ty);
                };
            };
            // TODO: allow non-ptr
            case_access := @{ @[container][].___ };
            case_access := case_access.expr.Block.result[];
            case_access.expr.FieldAccess.name = name;  // (3)
            if(is_ptr){|
                case_access = @{ @[case_access]& };
            };
            callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
            @{ @[callable](@[case_access]) }
        };
        
        @match(stmt.stmt&) {
            fn DeclFunc(f) => {
                return(expand_case_body(f[]));
            }
            fn Eval(handler_body) => {
                @match(handler_body.expr&) {
                    (fn Closure(closure) => {
                        return(expand_case_body(closure[]));
                    });
                    (fn PrefixMacro(branch) => {
                        macro := branch.handler;
                        @ct_assert(macro.expr&.is(.GetNamed), macro.loc, "expected @default (TODO: allow GetVar?)");
                        name := macro.expr.GetNamed; 
                        arg := branch.arg;
                        action := branch.target[];
                        @ct_assert(name == @symbol default, macro.loc, "unhandled prefix in @inline_match");
                        return(@{ @[action]() });
                    });
                    @default => compile_error("expected @default", handler_body.loc);
                };
            }
            @default => (); // TODO: warn
        };
    };
    compile_error("inline_match not matched!", loc)
}

/*
`if :: true {| do_something_super_important(); };`
is a footgun because it parses as a declaration not a comptime evaluation of the condition, 
what's worse is that the body is only evaluated if the variable is referenced so if you don't try to call 'if' 
later in that scope it won't even be an error that you can't call true with a trailing lambda. 
*/

fn safety(kind: FatExpr, code: FatExpr) FatExpr #macro = {
    kind := (const_eval(SafetyCheck))(kind);
    if safety_check_enabled(kind) {|
        @{ if(!@[code], => safety_check_failed()) }
    } else {|
        @literal unit
    }
}

// TODO: its sad that it makes the compiler binary ~5% smaller to manually out-line this instead of just calling assert. should work on that. -- Jul 5
fn safety_check_failed() Never #noinline = {
    panic("Safety Check Failed.")
}
