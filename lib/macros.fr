// TODO: make calling literal_ast less painful. The problem is can't use generics in compiler ffi 
//       so have to pass by void ptr but currently can't just make lvalue refernce like rust. 
//       can't decide if this macro is good enough or want ^ as more general solution. 
#macro #outputs(FatExpr)
fn literal(arg: FatExpr, target: FatExpr) FatExpr = @{
    make_literal(@[arg], @[target])
};

// TODO: implement the single arg version with this somehow. it looks easy but no
//       i made the macros before i had a type system that could do this. 
make_literal :: fn($T: Type, value: T) FatExpr #generic = {  
    literal_ast(T, raw_from_ptr(T, value&))
};

fn if(cond: FatExpr, do: FatExpr) FatExpr #macro = {
    @{ @if(@[cond], @[do], ()) }
}

// Same as the two argument version but infers the type. 
// TODO: assert that arg isn't 'void' because then its ambigous with the two argument version. -- Apr 21
#macro #outputs(FatExpr)
fn literal(arg: FatExpr) FatExpr = @{
    value := @[arg];
    T :: @type value;
    literal_ast(T, raw_from_ptr(T, value&))
};

fn as(T: Type, expr: FatExpr) FatExpr = as(@literal T, expr);

// TODO: this has a referential transparency problem
// TODO: maybe @inline_match shouldn't be a thing and this should just notice and do the right thing. 
#macro 
fn match(arg: FatExpr, target: FatExpr) FatExpr = {
    loc := arg.loc;
    stmts := target.expr.Block.body.items();
    arg = compile_ast(arg);
    enum_type := arg.ty;
    info := get_type_info_ref(enum_type);
    
    if info.is(.Enum) {
        // TODO: use new switch expression -- Jul 26
        return(match_on_enum(arg, info, stmts));
    };
    
    want_pointer := false;
    if info.is(.Ptr) {
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        want_pointer = true;
    };
    
    @ct_assert(!info.is(.Enum), arg.loc, "to @match on an @enum, dereference the pointer"); // TODO: just do it
    
    if info.is(.Struct) {
        count, name, out := (0, zeroed Symbol, UnknownType);
        find_used_tagged(enum_type, count&, name&, out&);
        @ct_assert(count == 1, arg.loc, "tried to @match on a @struct (this would be valid if there was a #use on exactly one @enum/@tagged field)");
        arg = make_field_access(arg, name, loc, want_pointer);
        enum_type = out;
        info = get_type_info_ref(enum_type);
    };
    
    @ct_assert(info.is(.Tagged), arg.loc, "@match expected argument type to be @tagged.");
    info := info.Tagged;
    varients := info.cases.items();

    // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. (1)
    // TODO: when unptr_ty wasn't getting raw type, the error message was at the return value instead of here. (2)
    // TODO: check that no duplicate handlers
    // TODO: give error message here if invalid name instead of it showing up later in the generated code. (3)
    //       maybe add a 'fn compile_error(Span, Str)' instead of making you use panic so its more clear and you can attach context.
    // TODO: use default arguments as value eq guards. 
    
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    ::if(FatExpr);
    crash :: fn(tag: i64, max: i64) Never = {
        @if(::safety_check_enabled(.InvalidTag), { 
            // TODO: make this a build option / safety check. all could have None/Abort/Panic/Verbose
            @println("tag=%, expected 0..<%", tag, max);
            panic("matched on invalid tag! Uninitialized memory?") 
        }, unreachable())
    }
    @{
        arg_val := @[if(want_pointer, => @{}, => arg)];
        arg_ptr := @[if(want_pointer, =>arg, => @{ arg_val& })];
        :: tagged(@[@literal enum_type]);
        tag_val := arg_ptr.tag().raw();
        // TODO: when safety checks are on don't do the default branch even for garbage tag.
        //       in fast mode tho make that UB.  -- Jul 9
        @[{
            
            // If there's no @default, this is hit by invalid tags. 
            // TODO: when enabled just used @safety? so the message isn't different when you have a @default branch. 
            default: FatExpr = @{ crash(tag_val, @[@literal varients.len]) };
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            
            while(=> i.ge(0)) {
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    // for now we don't let users specifiy the tag type so we know the enum will be sequential
                    case_value := varients.index_of(fn(it) => it._0 == closure.name) || {
                        debug_log_str(closure.name.str());
                        compile_error("bad name in @match", closure.loc)
                    };
                    name, ty := varients[case_value];
                    
                    if want_pointer {
                        p: TypeInfo = (Ptr = ty);
                        ty = intern_type(p); // :UpdateBoot should work to pass @as(TypeInfo) (Ptr = ty) directly
                    };
            
                    // If they didn't say the argument type, we can fill it in based on the varient name. 
                    // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
                    bindings := closure.arg.bindings.items();
                    if bindings.len == 1 {
                        first := bindings[0]&;
                        infer := first.ty&.is(.Infer);
                        no_name := first.name&.is(.None); 
                        if infer.or(no_name) {
                            first.ty = (Finished = ty);
                        };
                    };
                    loc := closure.loc;
                    case_access := make_field_access(@{ arg_ptr }, name, loc, want_pointer);
                    count = count + 1;
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (case_value, @{ @[callable](@[case_access]) } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {
                        expand_case_body(handler_body.expr.Closure);
                    } else {
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        
                        branch := handler_body.expr.PrefixMacro&;
                        name := macro_at_default_helper(handler_body);
                        arg := branch.arg;
                        action := branch.target[];
                        if !name.eq(@symbol default) {
                            debug_log_ast(handler_body[]);
                            println(name.str()); // TODO
                            compile_error("unhandled prefix in @match", branch.handler.loc);
                        };
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {
                            default = @{ 
                                @safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), loc, "wrong number of @match cases",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), loc, "@default but too many @match cases");
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn find_used_tagged(type: Type, count: *i64, s: *Symbol, out: *Type) void = {
    info := get_type_info_ref(type);
    info.is(.Struct) || return();
    each info.Struct.fields { it |
        ::ptr_utils(Annotations);
        has_use := !it.nullable_tag.is_null() && it.nullable_tag.items().contains(fn(it) => it.name == @symbol use);
        if has_use {
            if get_type_info_ref(it.ty).is(.Tagged) {
                out[] = it.ty;
                count[] = count[] + 1;
                s[] = it.name;
            } else {
                find_used_tagged(it.ty, count, s, out)
            }
        };
    };
};

fn make_field_access(e: FatExpr, name: Symbol, loc: Span, want_pointer: bool) FatExpr = {
    e := @{ @[e].___ };
    e := e.expr.Block.result[];
    e.expr.FieldAccess.name = name;  // (3)
    if want_pointer {
        e = @{ @[e]& };
    };
    e.loc = loc;
    e
}

fn macro_at_default_helper(handler_body: *FatExpr) Symbol = {
    msg :: "Expected expression to be @default";
    if !handler_body.expr&.is(.PrefixMacro) {
        compile_error(msg, handler_body.loc);
    };
    handler := handler_body.expr.PrefixMacro.handler;
    name := handler.ident() || compile_error(msg, handler.loc);
    name
}

fn make_switch(value: FatExpr, default: FatExpr, cases: List(Ty(i64, FatExpr))) FatExpr = {
    default_box := ast_alloc().alloc(FatExpr, 1);
    default_box.ptr[] = default;
    value_box := ast_alloc().alloc(FatExpr, 1);
    value_box.ptr[] = value;
    switch: FatExpr = (expr = (Switch = (value = value_box.ptr, default = default_box.ptr, cases = cases.as_raw())), loc = value.loc, ty = UnknownType, done = false); 
    switch
}

fn match_on_enum(arg: FatExpr, info: *TypeInfo, stmts: [] FatStmt) FatExpr = {
    info := info.Enum;
    
    varients := info.fields.items();
    cases: List(Ty(i64, FatExpr)) = list(ast_alloc());
    
    // TODO: why can't i call 'as'? ffi unique? 
    
    ::if(FatExpr);
    crash :: fn() Never #noinline = panic("@match invalid tag");
    @{
        @[{
            default: FatExpr = @{ crash() }; 
            count := 0;
            i := stmts.len.sub(1);
            first := true;
            had_default := false;
            while(=> i.ge(0)) {
                continue :: local_return;
                stmt: *FatStmt = stmts.index(i); 
                i -= 1;
                
                expand_case_body :: fn(closure: *Func) void => {
                    index := tag_value(arg.ty, closure.name);  // just make sure the name exists
                    count = count.add(1);
                    callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
                    case := (index, @{ @[callable]() } );
                    cases&.push(case);
                };
                
                // This allows you to leave off the extra brackets! easy now that i delay hositing constants. which in hindsight was a change i made a long time ago. 
                if stmt.stmt&.is(.DeclFunc) {
                    // TODO: warn if it looks like they're trying to add to an overload set? -- Jul 5
                    f := stmt.stmt.DeclFunc;
                    expand_case_body(f);
                    stmt.stmt = .Noop;
                };
                
                if stmt.stmt&.is(.Eval) {|  // (1)
                    handler_body := stmt.stmt.Eval&;
                    if handler_body.expr&.is(.Closure) {
                        expand_case_body(handler_body.expr.Closure);
                    } else {
                        // TODO: better error message if its a call because they forgot a semi-colon. 
                        //debug_log_ast(handler_body[]);
                        name := macro_at_default_helper(handler_body);
                        branch := handler_body.expr.PrefixMacro&;
                        arg := branch.arg;
                        action := branch.target[];
                        assert(name.eq(@symbol default), "unhandled prefix in @match");
                        assert(first, "@default must be the last handler in @match");
                        // Note: we throw away the starting body
                        if safety_check_enabled(.InvalidTag) {
                            default = @{ 
                                // TODO: to do this you need a var for it but then you can't get free fold away in sema because it never
                                //       knows the arg is constant. 
                                //@safety(.InvalidTag) tag_val < @[@literal varients.len];
                                @[action]() 
                            };
                        } else {
                            default = @{ @[action]() };
                        };
                        had_default = true;
                    };
                    stmt.stmt = .Noop;
                };
            };
            // TODO: check that the handlers are unique! this just checks that its the right number of them. 
            @ct_assert(!count.ne(varients.len).and(not(had_default)), arg.loc, "wrong number of @match cases.",);
            @ct_assert(not(had_default).or(count.lt(varients.len)), arg.loc, "@default but too many @match cases");
            make_switch(@{ @[arg].raw() }, default, cases)
        }]
    }
}

fn ct_assert(arg: FatExpr) FatExpr #macro = {
    assert(arg.expr&.is(.Tuple), "@assert___ expected multiple args");
    parts := arg.expr.Tuple.items();
    assert(parts.len >= 3, "not enough arguments");
    cond := parts[0];
    span := compile_ast(parts[1]);
    if !(span.ty == Span) {
        compile_error("Expected type 'Span' for error location", span.loc);
    };
    
    @{
        if !@[cond]{
            out: List(u8) = list(temp());
            @[if(parts.len == 3, => @{
                out&.push_all(@[parts[2]]);
            }, => @{()} )];
            @[if(parts.len > 3, => {
                format_into(@{ out& }, parts.rest(2), arg.loc)
            }, => @{()} )];
            compile_error(out.items(), @[span]);
        };
    }
}

fn if_let(arg: FatExpr, handler: FatExpr) FatExpr #macro = @{
    @match(@[arg]) {
        @[handler];
        @default => ();
    }
};

/// Similar to @match but operates on values instead of enum payloads. 
/// @switch(value) { @<specifier> => <body> }
/// - @case(v): calls <body> if value.eq(v)
#macro 
fn switch(arg: FatExpr, handlers: FatExpr) FatExpr = {
    handlers := handlers.expr.Block.body.items();
    arg = compile_ast(arg);
    inspected_ty: Type = arg.ty; // TODO: if you dont have the type hint you get confusing error message trying to call fn as(Type, Ast) becuase its the unique ffi TypeId type. -- Apr 21 
    body := @{ panic("unhandled switch case") };
    first := true;
    i := handlers.len().sub(1);
    
    // Declaring variables is weird because name resolution has already run. 
    // All the references to it need to be in its lexical scope, so the whole code is in an unquote. 
    @{
        arg_var := @[arg];
        @[{
            while(=> i.ge(0)) {
                stmt: *FatStmt = handlers.index(i); 
                // TODO: typecheck err message (forgot to deref !tag) points at the wrong location in the expression. 
                if stmt.stmt&.is(.Eval) {
                    handler_body := stmt.stmt.Eval&;
                    branch := handler_body.expr.PrefixMacro&;
                    macro := branch.handler;
                    name := macro_at_default_helper(handler_body);
                    arg := branch.arg;
                    action := branch.target[];
                    
                    // Sadly this can't use @switch (unless I do a weird bootstrapping thing on a much more granular level). 
                    if(name.eq(@symbol case)) {
                        // TODO: probably want to require arg to be constant so it could eventually become a jump table. 
                        // TODO: improve error message if you try to pass the ast of a type instead of the type. alas I chose the same name as the as macro so it still tpyechecks. -- Apr 21
                        cond := @{ eq(arg_var, @[as(inspected_ty, arg[])]) };
                        body = @{ @if(@[cond], @[action](), @[body]) };
                    } {
                        if(name.eq(@symbol default)) {
                            if(first) {
                                // TODO: dont pass it if the function wants void arg.
                                // If expansion err here: forgot argument for default branch handler?  // TODO: give error message
                                assert(action.expr&.is(.Closure), "@switch @default: expected closure");
                                
                                assert(action.expr.Closure.arg.bindings.len == 1, "@switch @default: expected single arg. (parser treats (fn name() ..) as having unnamed arg automatically)");
                                arg := action.expr.Closure.arg.bindings[0]&;
                                :: tagged(Name);
                                if arg.name&.is(.None) {
                                    body = @{ @[action]() };
                                } else {
                                    body = @{ @[action](arg_var) };
                                };
                                
                            } else {
                                compile_error("@default must be the last handler in @switch", stmt.loc);
                            };
                        }{
                            if name == @symbol inclusive {
                                cond := @{
                                    min, max := @[as(Ty(inspected_ty, inspected_ty), arg[])];
                                    arg_var.ge(min).and(arg_var.le(max))
                                };
                                body = @{ @if(@[cond], @[action](), @[body]) };
                            } else {
                                // TODO: try expanding the macro, maybe its a user added one and would create valid branches. 
                                compile_error("unhandled prefix in @switch", stmt.loc);
                            };
                        };
                    };
                    first = false;
                };
                i = i.sub(1);
            };
            body
        }]
    }
}

#macro fn inline_switch(arg: FatExpr, target: FatExpr) FatExpr = {
    @ct_assert(target.expr&.is(.Block), target.loc, "@inline_switch expected Block of handlers");
    handlers := target.expr.Block.body.items();
    inspected := compile_ast(@{ :: @[arg] });
    each handlers { stmt |
        continue :: local_return;
        if(stmt.stmt&.is(.Noop), => continue());
        @ct_assert(stmt.stmt&.is(.Eval), stmt.loc, "@inline_switch expected @case");
        handler_body := stmt.stmt.Eval&;
        branch       := handler_body.expr.PrefixMacro&;
        name := macro_at_default_helper(handler_body);
        matches := @switch(name) {
            // TODO: still typechecks if you don't have the [] on arg! :FUCKED fn typchk_unquote()
            @case(@symbol case) => const_eval(bool)(@{ @[inspected] == @[branch.arg[]] });
            // TODO: assert this is the last one
            // TODO: pass the value as arg like normal @switch
            @case(@symbol default) => true; 
            @default => compile_error(@tfmt("expected @case / @default but found %", name.str()), stmt.loc); 
        }
        if matches {
            return @{ @[branch.target[]]() };
        }
    };
    compile_error("@inline_switch no match and no @default branch", target.loc)
}

fn get_type_int(e: FatExpr) IntTypeInfo = {
    inner :: fn(ty: Type, loc: Span) IntTypeInfo = {
        t := get_type_info_ref(ty);
        @if(t.tag() == .Int) return(t.Int);
        @if(t.tag() == .Enum) return(inner(t.Enum.raw, loc));
        @if(t.tag() == .Named) return(inner(t.Named._0, loc));
        debug_log_type(ty);
        compile_error("Expected integer.", loc)
    };
    e = compile_ast(e);
    inner(e.ty, e.loc)
}

/// The compiler defines the two argument version where you specify a type and values. 
/// This version can be used when you just want sequential integers. 
#macro #outputs(Type)
fn enum(names: FatExpr) FatExpr = {
    @ct_assert(names.expr&.is(.Tuple), names.loc, "expected @enum(name1, name2, etc)"); // TODO: single element should be legal i guess. 

    fn binding(name: Symbol, value: i64) Binding = {
        template := @{ (a = 0) };
        template := template.expr.Block.result[];
        all := template.expr.StructLiteralP.bindings.items();
        out := all.get(0);
        out.name = (Ident = name);
        out.default = @literal(value);
        out
    }
    
    cases: List(Binding) = list(ast_alloc());
    parts := names.expr.Tuple.items();
    enumerate(parts) {i, part|
        name := part.ident() || compile_error("Expected symbol in @enum", names.loc); // TODO: this should work as not a closure
        cases&.push(binding(name, i));
    };

    varients := @{ (a = 1) };
    varients := varients.expr.Block.result[];
    cases := cases.items();
    varients.expr.StructLiteralP.bindings = (cap = cases.len, ptr = cases.ptr, len = cases.len);
    
    @{ @enum(i64) @[varients] }
}

// TODO: @comptime_var which is like this but a constant at runtime. 
#macro fn static(T: FatExpr) FatExpr = {
    t := @literal const_eval(Type)(T);
    // TODO: you really shouldn't be reading before writing anyway but it doesn't work with ast_alloc being todo_allocator without the zeroed(). 
    @{ :: box_zeroed(ast_alloc(), @[t]) }
}

// TODO: instead of this, you should be able to take the address of a normal :: constant,
//       but i should know which pointers are const. 
//       but that doesn't fix the problem of needing the constant to be ready so you can use it in functions that it contains pointers to. 
//       need !rec to work for anything, not just types?    -- Jun 18
#macro fn static(T: FatExpr, value: FatExpr) FatExpr = {
    t := @literal const_eval(Type)(T);
    @{ :: {
        mem := ast_alloc().box(@[t]);
        mem[] = @[value];
        mem
    }}
}

// @array(1, 2, 3) creates an Array(i64, 3)
// because was a pain to make a constant one before you could coerce from tuple. 
// NOTE: this doesn't make a constant one unless you explicitly use '::'.
#macro fn array(elements: FatExpr) FatExpr = {
    @ct_assert(elements.expr&.is(.Tuple), elements.loc, "Expected @array(a, b, c, d)");
    parts := elements.expr.Tuple.items();
    len := parts.len;
    first := compile_ast(parts[0]);
    parts.set(0, first);
    // :UpdateBoot Expr::Tuple coerces to array now 
    @{ @as(Array(@[@literal parts[0].ty], @[@literal len])) 
        @if(IS_BOOTSTRAPPING, init(@slice @[elements]), @[elements]) }
}

// TODO: have @tagged auto call this
// TODO: seperate out the parts that could work on any sequential enum. 
// TODO: move these to like meta.fr maybe? enum.fr? 
fn tagged($Tagged: Type) void = {
    // TODO: assert its really a tagged type.
    
    // assert_eq(size_of(Tagged.Tag()), size_of(i64)); // TODO: ?? doesn't type check. happening too early? -- Jul 1
    
    T :: Tagged.Tag();
    
    // :tag_is_always_i64
    :: enum(T);
    fn tag(self: *Tagged) T #inline = self.tag_ptr()[];
    fn tag_ptr(self: *Tagged) *T #unsafe_noop_cast;  // SAFETY: The compiler puts the tag at the front of the struct. 
    
    fn is(self: *Tagged, check: T) bool #inline = self.tag().eq(check);
}

fn expect_enum(T: Type) void = {
    info := get_type_info_ref(T);
    // TODO: this doesn't compile with trying to eq on **FnBody ?????! :FUCKED
    //assert(info.is(.Enum), "expected enum type");
    //assert(info.Enum.sequential, "expected enum elements to be sequential");
}

fn is_fake_int(T: *TypeInfo) bool = {
    T.is(.Int) && T.Int.bit_size != 64 && T.Int.bit_size != 32 && T.Int.bit_size != 16 && T.Int.bit_size != 8
}

fn enum_basic($T: Type) void = {
    ::@late T.expect_enum();
        
    // TODO: need to do the garbage fake ints hack in the other resolve for this to work.
    //fn eq(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    //fn ne(a: T, b: T) bool #redirect(Ty(i64, i64), bool);
    fn eq(a: T, b: T) bool #inline = a.raw() == b.raw();
    fn ne(a: T, b: T) bool #inline = a.raw() != b.raw();
    
    RAW :: { i := get_type_info_ref(T); i.Enum.raw };
    
    // TODO: this (the top one) breaks -go-rebuild-yo-self on blink???? (it infinite loops) :fucked havent tried other linux yet.   -- Sep 20
    fn raw(e: T) RAW #unsafe_noop_cast;
    fn raw(e: *T) *RAW #unsafe_noop_cast;
    //fn raw(e: T) RAW = {
        //ptr_cast_unchecked(T, RAW, e&)[]
    //}
}

fn enum($T: Type) void = {
    ::enum_basic(T);
    
    fn ordinal(e: T) i64 #inline = {
        :: ?i64;
        e&.try_ordinal().unwrap()
    }
    
    fn display(self: T, out: *List(u8)) void #inline = 
        display(self&, out);
    
    fn display(self: *T, out: *List(u8)) void = {
        @if(:: T.get_type_info_ref()[].Enum.sequential) 
            return(enum_display_from_ordinal(self[].raw().int(), packed_enum_names(T), out));
        
        // TODO: without the extra force comptime eval, it wrongly thinks calling this function needs compctx.  -- Jul 1
        i := or self.try_ordinal() {
            @fmt(out, "<invalid enum value: %>", self[].raw().int());  // TODO: don't assume it's an int
            return()
        };
        out.push_all(self[].name_str());
    }
}

enum_display_from_ordinal :: fn(i: i64, names: *PackedStrings, out: *List(u8)) void = {
    packed, offs := names[];
    if i.ult(offs.len) {
        out.push_all(packed.subslice(offs[i*2].zext(), offs[i*2+1].zext()));
    } else {
        @fmt(out, "<invalid enum value: %>", i);  // TODO: don't assume it's an int
    }
};

IsEnum :: fn(T: Type) bool = T.get_type_info_ref().is(.Enum);

fn name_str(self: ~T) Str #where(IsEnum) = {
    ::enum(T);
    T.enum_name_from_ordinal(self.ordinal())
}

// This is equivalent to: (::get_enum_names(E))[ord]
// But instead of (16 bytes + 1 relocation) per name, this is (4 bytes + 0 relocations) per name. 
// TODO: However, from_name() has another copy of the strings now because i don't handle internal pointers in constants well. -- Mar 12, 2025
fn enum_name_from_ordinal($E: Type, i: i64) Str #inline = {
    packed, offs := packed_enum_names(E)[];
    packed.subslice(offs[i*2].zext(), offs[i*2+1].zext())
}

packed_enum_names :: fn($E: Type) *PackedStrings #fold = 
    @static(PackedStrings) pack_strings(get_enum_names(E));

PackedStrings :: Ty(Str, []u16);
pack_strings :: fn(names: []Str) PackedStrings = {
    offs  := ast_alloc().alloc(u16, names.len * 2);
    total := 0;
    enumerate names { i, n |
        offs[i*2] = total.trunc();
        offs[i*2 + 1] = n.len.trunc();
        total += n.len;
    };
    @assert_lt(total, MAX_u16, "TODO: deal with @enum with more than 65k bytes of names.\nbut like also, did you really mean to do that?");
    bytes := ast_alloc().alloc(u8, total);
    enumerate names { i, n |
        bytes.subslice(offs[i*2].zext(), offs[i*2 + 1].zext()).copy_from(n[]);
    };
    // TODO: should be able to .sym().str() on bytes but that breaks a test in a very confusing way.  -- Mar 12, 2025
    (bytes, offs)
};

fn try_ordinal(self: ~RefT) ?i64 #where(PointerTo(IsEnum)) #inline = {
    T :: Deref(RefT);
    @if(:: T.get_type_info_ref()[].Enum.sequential, {
        i := self[].raw().int();
        @if(i < 0 || i >= T.enum_count(), .None, (Some = i))
    }, {
        values :: get_cases(T);
        // :SLOW // TODO: could make this a comptime hashmap for large enums with hashable backing type. 
        range(0, values.len()) { i |
            if(self.raw() == values.index(i).raw(), => return(Some = i));
        };
        .None
    })
}

// TODO: fix infinite loop from ?i64 if this is in fn enum. -- Jul 8
fn from_raw($T: Type) void = {
    ::@late T.expect_enum();
    
    fn from_raw(raw: i64) ?T = {
        ::if(?T);
        // Note: this relies on it being sequentual. 
        if(raw < 0 || raw >= @run T.enum_cases().len(), => .None) {
            value := bit_cast_unchecked(i64, T, raw);
            (Some = value)
        }
    } 
}

fn enum_cases(T: Type) []Ty(Symbol, Values) = {
    info := get_type_info_ref(T);
    assert(info.is(.Enum), "expected enum type");
    info.Enum.fields.items()
}

// :blessed: This is also a builtin_prefix_macro. It lets you disable code while bootstrapping up to having the type for FatExpr.
// See bootstrap_compiler_environment 
fn late(e: FatExpr) FatExpr #macro = e;

// TODO: define the syntax as a call to this function. maybe get rid of the syntax. cause its a pain.
//       then this can just be an export_ffi that calls immediate_eval_expr, but that requores passing expected type to macros. 
fn run(e: FatExpr) FatExpr #macro = @{ :: @[e] };

// TODO: this is useless because you can't unquote inside. 
//       tho actually, it does get here, you could handle the unquoting in here... maybe. 
fn quote(e: FatExpr) FatExpr #macro = 
    @literal e;

/// @expand @quote X === X
fn expand(e: FatExpr) FatExpr #macro = 
    (const_eval(FatExpr)(e));

fn inline_for(container: FatExpr, body: FatExpr) FatExpr #macro = {
    container := compile_ast(@{ :: @[container] });
    len := (const_eval(i64)(@{ v := @[container]; v.len() }));
    if len == 0 {
        return(@{});
    };
    
    ::if(FatExpr);
    // Yikes this is ugly. but's sadly index() has hella overloads 
    // so it's noticeably slow to do every time (for large collections like in do_fold_old())
    element := (const_eval(Type)(@{ @[if is_ptr(container.ty) {
        @{Deref(@[@literal container.ty]) }
    } else {
        @literal container.ty
    }].Element }));
    indexer := @literal resolve_overload(operator_index, Ty(container.ty, i64), *element, container.loc);
    
    actions: List(FatExpr) = list(len, ast_alloc());
    range(0, len) { i | 
        actions&.push(@{ @[body](:: @[indexer](@[container], @[@literal i])) });
    };
    // TODO: dumpster fire garbage error message if you try to make a single length tuple
    //       "Expr::Tuple should have struct type"
    container.expr = @if(actions.len == 1, actions[0].expr, (Tuple = actions.as_raw()));
    container.ty = UnknownType; 
    container.done = false;
    container
}

fn inline_range(min_max: FatExpr, body: FatExpr) FatExpr #macro = {
    min, max := const_eval(Ty(i64, i64))(min_max);
    
    actions: List(FatExpr) = list(ast_alloc());
    range(min, max) { i | 
        actions&.push(@{ @[body](@[@literal i]) });
    };
    // TODO: dumpster fire garbage error message if you try to make a single length tuple
    //       "Expr::Tuple should have struct type"
    if actions.len == 1 {
        min_max.expr = actions[0].expr;
    } else {
        min_max.expr = (Tuple = actions.as_raw());
    };
    min_max.ty = UnknownType; 
    min_max.done = false;
    min_max
}

fn inline_match(container: FatExpr, target: FatExpr) FatExpr #macro = {
    loc := container.loc;
    container := compile_ast(@{ :: @[container] });
    
    stmts := target.expr.Block.body.items();
    enum_type := container.ty;
    info := get_type_info_ref(enum_type);
    
    is_ptr := false;
    tag_expr := @literal ();
    if info.is(.Ptr) {
        enum_type = (@as(*Type) info.Ptr&)[];
        info = get_type_info_ref(enum_type);
        is_ptr = true;
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a[]); a.tag().raw() } };
    } else {
        tag_expr = @{ :: { a := @[container]; :: tagged(@type a); a&.tag().raw() } };
    };
    ptr_ty := *enum_type;
   
    @ct_assert(info.is(.Tagged), loc, "@match expected argument type to be @tagged");
    info := info.Tagged;
    tag_val := const_eval(i64)(tag_expr);
    
    varients := info.cases.items();
    
    each stmts { stmt |
        continue :: local_return;
        expand_case_body :: fn(closure: *Func) FatExpr => {
            index := tag_value(enum_type, closure.name); // they're always sequential
            name, ty := varients.get(index);
            @ct_assert(name == closure.name, closure.loc, "ICE: bad enum index");
            if index != tag_val {
                continue();
            };
            
            if is_ptr {
                p: TypeInfo = (Ptr = ty);
                ty = intern_type(p); // TODO: should work to pass @as(TypeInfo) (Ptr = ty) directly
            };
    
            // If they didn't say the argument type, we can fill it in based on the varient name. 
            // If they don't put an argument, just ignore the value. Have to set the type because it defaults to void. 
            bindings := closure.arg.bindings.items();
            if bindings.len == 1 {
                first := bindings[0]&;
                if first.ty&.is(.Infer) || first.name&.is(.None) {
                    first.ty = (Finished = ty);
                };
            };
            // TODO: allow non-ptr
            case_access := make_field_access(@{ @[container][] }, name, loc, is_ptr);
            callable: FatExpr = (expr = (Closure = closure), loc = closure.loc, ty = UnknownType, done = false); 
            @{ @[callable](@[case_access]) }
        };
        
        @match(stmt.stmt&) {
            fn DeclFunc(f) => return(expand_case_body(f[]));
            fn Eval(handler_body) => {
                @match(handler_body.expr&) {
                    fn Closure(closure) => return(expand_case_body(closure[]));
                    fn PrefixMacro(branch) => {
                        macro := branch.handler;
                        name := macro.ident() || compile_error("expected @default.", handler_body.loc);
                        arg := branch.arg;
                        action := branch.target[];
                        @ct_assert(name == @symbol default, macro.loc, "unhandled prefix in @inline_match");
                        return(@{ @[action]() });
                    }
                    @default => {
                        debug_log_ast(handler_body[]);
                        compile_error("expected @default or a closure", handler_body.loc);
                    };
                };
            }
            @default => (); // TODO: warn
        };
    };
    compile_error("inline_match not matched!", loc)
}

/*
`if :: true {| do_something_super_important(); };`
is a footgun because it parses as a declaration not a comptime evaluation of the condition, 
what's worse is that the body is only evaluated if the variable is referenced so if you don't try to call 'if' 
later in that scope it won't even be an error that you can't call true with a trailing lambda. 
*/

fn safety(kind: FatExpr, code: FatExpr) FatExpr #macro = {
    kind := (const_eval(SafetyCheck))(kind);
    ::if(FatExpr);
    if safety_check_enabled(kind) {
        @{ if(!@[code], => safety_check_failed()) }
    } else {
        @{}
    }
}

// TODO: its sad that it makes the compiler binary ~5% smaller to manually out-line this instead of just calling assert. should work on that. -- Jul 5
fn safety_check_failed() Never = 
    panic("Safety Check Failed.");

fn if_else(handlers: FatExpr) FatExpr #macro = {
    @ct_assert(handlers.expr&.is(.Block), handlers.loc, "@if_else expected block"); // TODO: add this check to @match
    handlers := handlers.expr.Block.body.items();
    
    no_else :: "@if_else must have @else as last branch";
    want_if :: "Expected `@if(cond) => value`";
    
    while => handlers.last().expect(no_else)[].stmt&.is(.Noop) {
        handlers.len -= 1;
    };
    
    else := handlers.last().expect(no_else);
    @ct_assert(else.stmt&.is(.Eval), else.loc, no_else);
    else := else.stmt.Eval&;
    @ct_assert(else.expr&.is(.PrefixMacro), else.loc, no_else);
    else := else.expr.PrefixMacro&;
    ::AutoEq(?Symbol); ::RefEq(?Symbol);
    @ct_assert(else.handler.ident() == (Some = @symbol else), else.handler.loc, no_else);
    body := @{ @[else.target[]]() }; // TODO: this will get confusing if compiler swaps unit target with arg sooner. 
    handlers.len -= 1;
    
    i := handlers.len - 1;
    while => i >= 0 {
        stmt: *FatStmt = handlers.index(i); 
        if stmt.stmt&.is(.Eval) {
            handler_body := stmt.stmt.Eval&;
            branch := handler_body.expr.PrefixMacro&;
            name := branch.handler.ident() || compile_error(want_if, branch.handler.loc);
            @ct_assert(name == (@symbol if), branch.handler.loc, want_if);
            body = @{ @if(@[branch.arg[]], @[branch.target[]](), @[body]) };
        } else {
            @ct_assert(stmt.stmt&.is(.Noop), stmt.loc, "bad stmt in @if_else");
        };
        i = i.sub(1);
    };
    body
}

:: @if(::has_feature("@franca/fewer_builtins")) {
    fn symbol(e: FatExpr) FatExpr #macro #outputs(Symbol) = 
        @literal e&.ident().unwrap();
    
    // TODO: this is so unserious, i should just have nice var-args
    fn Ty(a: Type, b: Type, c: Type) Type #fold =
        Ty(@slice(a, b, c));
    
    fn Ty(a: Type, b: Type, c: Type, d: Type) Type #fold =
        Ty(@slice(a, b, c, d));
};

// this can't use @match because we want to use it from the implementation of @match
fn ident(self: *FatExpr) ?Symbol = {
    if(self.expr&.is(.GetVar),          => return(Some = self.expr.GetVar.name));
    if(self.expr&.is(.GetNamed),        => return(Some = self.expr.GetNamed));
    if(self.expr&.is(.String),          => return(Some = self.expr.String));
    if(self.expr&.is(.ContextualField), => return(Some = self.expr.ContextualField));
    if(self.expr&.is(.UndeclaredVar),   => return(Some = self.expr.UndeclaredVar.name));
    .None
}

// build a bit mask to check if an enum(int) or tagged is in a comptime known set. 
// if the options are sequential it uses <=&&=> instead.
fn is(arg: FatExpr) FatExpr #macro #outputs(bool) = {
    USAGE :: "expected @is(inspected, O1, O2, ..., On)";
    @ct_assert(arg.expr&.is(.Tuple), arg.loc, USAGE);
    opts := arg.expr.Tuple&.items();
    @ct_assert(opts.len >= 2, arg.loc, USAGE);
    
    inspect  := compile_ast(opts[0]);
    type     := inspect.ty;
    
    info := get_type_info_ref(type);
    needs_deref := false;  // enum.raw doesn't want a pointer but tagged.tag does. 
    @if_let(info) fn Ptr(it) => {
        needs_deref = true;
        type = it[];
        info = get_type_info_ref(type);
    };
    @if_let(info) fn Tagged(it) => {
        needs_deref = false;
        type = it.tag;
        inspect = @{ @[inspect].tag() };
        info = get_type_info_ref(type);
    };
    if needs_deref {
        inspect = @{ @[inspect][] };
    };
    @ct_assert(info.is(.Enum), arg.loc, "@is only works on @enum or @tagged");
    @ct_assert(get_type_info_ref(info.Enum.raw).is(.Int), arg.loc, "@is requires integer as backing type");
    if opts.len == 2 {
        return(@{ @[inspect] == @[opts[1]]});
    };
    type_ast := @literal type;
    
    values := i64.list(opts.len - 1, temp());
    count  := enum_count(type);
    low    := MAX_i64;
    high   := MIN_i64;
    for opts.slice(1, opts.len) { o | 
        o   := const_eval(i64)(@{ (@as(@[type_ast])@[o]).raw().int() });  // :slow don't resolve these overloads every time
        values&.add_unique(o);
        high = high.max(o);
        low  = low.min(o);
    };
    @ct_assert(values.len == opts.len - 1, arg.loc, "redundant entry in @is");
    @ct_assert(low >= 0, arg.loc, "@is doesn't handle negative numbers");
    if high - low == values.len - 1 {  // they're tightly packed
        return(@{
            k: i64 = @[inspect].raw().int();
            k >= @[@literal low] && k <= @[@literal high]
        });
    };
    
    if high - low < 64 {
        fits_mask := count < 64 && is_sequential_enum(type);
        mask := 0;
        for values { o | 
            mask = mask.bit_or(1.shift_left(o - low));
        };
        return(@{ 
            key: i64 = @[inspect].raw().int() - @[@literal low];
            k := 1.shift_left(key);
            bounds := @[@if(fits_mask, @literal true, @{ key >= 0 && key < 64 })];
            bounds && bit_and(k, @[@literal mask]) == k
        });
    };
    
    body := @{false};
    for opts.slice(1, opts.len) { o | 
        body = @{ @[body] || @[inspect] == @[o] };
    };
    body
}

fn items(e: *FatExpr) []FatExpr = {
    if e.expr&.is(.Tuple) {
        return(e.expr.Tuple.items());
    };
    (ptr = e, len = 1)
}

fn make_block(owned_stmts: List(FatStmt), result: FatExpr) FatExpr = {
    body := @{};
    @debug_assert(body.expr&.is(.Block));
    body.expr.Block.body = owned_stmts.as_raw();
    body.expr.Block.result[] = result;
    body.loc = result.loc;
    body
}

fn get_from_pattern(e: *FatExpr, name: Symbol) ?*FatExpr = {
    @if_let(e.expr&) fn StructLiteralP(it) => each it.bindings { it |
        if it.ident() { check |
            if check == name {
                return(Some = it.default&);
            };
        };
    };
    .None
}

fn generic_match(arg: FatExpr) FatExpr #macro = {
    e := arg&.items();
    @ct_assert(e.len == 2, arg.loc, "@generic_match expected (value, fn(_) => body)"); 
    value, body := (compile_ast(e[0]), e[1]);
    type := value.ty;
    info := get_type_info_ref(type);
    @if_let(info) fn Ptr(t) => { // TODO: require
        type = t[];
        info = get_type_info_ref(type);
    };
    @ct_assert(info.is(.Tagged), arg.loc, "@generic_match expected @tagged type"); 
    @{
        arg_ptr := @[value];
        :: tagged(@[@literal type]);
        tag_val := arg_ptr.tag().raw();
        @[{
            default := @{ unreachable() };
            
            cases := Ty(i64, FatExpr).list(info.Tagged.cases.len, ast_alloc());
            enumerate info.Tagged.cases { i, case |
                case_access := @{ arg_ptr.___ };
                case_access := case_access.expr.Block.result[];
                case_access.expr.FieldAccess.name = case._0; 
                //if is_ptr {
                    case_access = @{ @[case_access]& };
                    case_access = case_access.expr.Block.result[];
                //};
                case := (i, @{ @[body](@[case_access]) } );
                cases&.push(case);
            };
            make_switch(@{ tag_val }, default, cases)
        }]
    }
}

fn is_raw_unit(self: *FatExpr) bool = {
    eq(self.ty, void) && self.expr&.is(.Value) // :get_or_create_type
}

// TODO: a version of this that doesn't require you to know all arguments (just constant ones)
// When running at comptime (like in a macro), you can call a function with a runtime argument as though it were constant. 
fn invoke_specialized($Arg: Type, $Ret: Type, f: Fn(Arg, Ret), arg: Arg) Ret #generic = 
    const_eval(Ret)(@{ @[@literal f](@[@literal arg]) });

fn import_symbol(arg: FatExpr) FatExpr #macro = {
    a    := arg&.items();
    name := const_eval(Str)(a[0]).sym();
    lib  := @if(a.len > 1, const_eval(Str)(a[1]).sym(), Symbol.zeroed());
    // TODO: infer the type instead 
    // `done=true` because you want to give sema.fr a chance to poke in a comptime address for it. 
    (expr = (DataSymbol = (name = name, lib = lib, comptime = 0, weak = false)), loc = arg.loc, ty = rawptr, done = false) 
}

// TODO: see if there's anywhere else that should use this
// Put `e` in a local variable and pass that as an expression to `body`. 
// This allows you to use the value of `e` multiple times while only 
// running its side effects once.  
fn as_var(e: FatExpr, $body: @Fn(e: FatExpr) FatExpr) FatExpr = @{
    var := @[e];
    @[body(@{ var })]
};

fn or(arg: FatExpr) FatExpr #macro = {
    @ct_assert(arg.expr&.is(.Tuple), arg.loc, "Expected @or(Tuple...)");
    parts := arg.expr.Tuple;
    bit_or := resolve_overload(bit_or, Ty(i64, i64), i64, arg.loc);
    // :SLOW
    out := @{ 0 }; 
    for parts { int |
        out = @{ @[@literal bit_or](@[out], @[int]) };
    };
    out
}

// SAFETY: don't use this in a loop (the pointer will NOT stay live across iterations)
// TODO: I think my policy is that stack frame is valid for the whole function regardless 
//       of if the block ends. are we sure that's what i want to commit to? 
//       tho since that's not true for loops it's kinda incoherent to make it true for 
//       other blocks i guess? :Compiler
// 
// TODO: give macros access to the inferred result type so you don't have to always use @as
fn ref(value: FatExpr) FatExpr #macro = @{
    value := @[value];
    value&
};

//
// This is used on a call expression: `@must_return f(a)`; 
// It (statically) prevents the callee from using non-local returns that skip the 
// rest of the enclosing function. This is useful for ensuring some cleap up code gets run. 
// Note: this does NOT apply to dynamically returning Never like exit(), panic(), longjmp(), etc. 
// TODO: maybe this should be replaced by a defer/finally thing that lets you 
//       run code even when returning past it instead of preventing returning past it. 
//       but that feels a bit invasive. 
// 
fn must_return(call: FatExpr) FatExpr #macro = {
    @ct_assert(call.expr&.is(.Call), call.loc, "@must_return expected a call expression");
    it := call.expr.Call&;
    it.flags = it.flags.bit_or(1.shift_left(@as(i64) CallFlags.MustReturn));
    call
}
