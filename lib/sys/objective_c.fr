// https://opensource.apple.com/source/objc4/objc4-709/runtime/runtime.h.auto.html
// https://opensource.apple.com/source/objc4/objc4-706/runtime/objc.h.auto.html

ObjCClass    :: @struct(_: rawptr);
ObjCObject   :: @struct(isa: ObjCClass);
ObjCId       :: *ObjCObject;
ObjCSelector :: @struct(_: rawptr);
ObjCProtocol :: @struct(_: rawptr);
ObjCIVar :: @struct(_: rawptr);
fn id(classname: Str) Type = ObjCId;

ObjCSuper :: @struct(receiver: ObjCId, super_class: ObjCClass);

// TODO: fix loop trying to compile if no driver to supply a #import (TODO: have i done this by now?)

// If you look at apple's objc/message.h, these function signetures have a `...`
// as though they used the c variadic call abi, don't let this fool you! 
// It's actually something totally different! You use it by casting the function pointer 
// to the signeture you want. The abi is the same as if you were calling a normal c function
// with the signeture of the target method (shifted by 2 for self, sel) NOT a varargs call. 
// On the sysv abi they happen to be the same but apple's arm64 abi is different. 
// TODO: do i actually have to call the _stret versions for it to know the args are shifted one extra? 
//       it's very possible i've just gotten lucky so far. 
// TODO: since we're lying about the arg types, it freaks out when it tries to inline the shim.
//       so the #noinline (which should mean nothing to an #import) HACKs around that. :NoInlineImport
//       like i guess this does fix the problem because most of the time you super want to inline that shim, 
//       but it just looks stupid to have annotations that are clearly redundant (but aren't). 
// :TodoDontZeroX0WhenVoid
objc_msgSend :: fn(self: ObjCId, /* sel, ... good luck */) void #import("objc") #noinline; 
objc_msgSendSuper :: fn(self: *ObjCSuper, /* sel, ... good luck */) void #import("objc") #noinline;  

fn objc_getClass(name: CStr) ObjCClass #import("objc");
fn sel_getUid(name: CStr) ObjCSelector #import("objc");
fn objc_allocateClassPair(superclass: ObjCClass, name: CStr, extraBytes: i64) ObjCClass #import("objc");
fn objc_registerClassPair(cls: ObjCClass) void #import("objc");
// imp is a function pointer (reciever, selector, <any other args>)
fn class_addMethod(cls: ObjCClass, name: ObjCSelector, imp: rawptr, types: CStr) bool #import("objc"); 
fn objc_autoreleasePoolPush() rawptr #import("objc");
fn objc_autoreleasePoolPop(ctx: rawptr) void #import("objc");
fn class_addIvar(class: ObjCClass, name: CStr, size: i64, align_log2: u8, types: CStr) bool #import("objc");
fn object_setInstanceVariable(obj: ObjCId, name: CStr, value: rawptr) ObjCIVar #import("objc");
fn object_getInstanceVariable(obj: ObjCId, name: CStr, out_value: *rawptr) ObjCIVar #import("objc");
fn objc_getProtocol(name: CStr) ObjCProtocol #import("objc");
fn class_addProtocol(class: ObjCClass, protocol: ObjCProtocol) void #import("objc");

// This makes a point of forcing all selectors (method + param names) to be constant,
// so the calls to sel_getUid could (in theory) be batched at program startup. 
fn objc(ret_reciever_arg_pattern: FatExpr) FatExpr #macro = 
    objc_call_impl(ret_reciever_arg_pattern, false);

// DONT FORGET self is a *ObjCSuper
fn objc_super(ret_reciever_arg_pattern: FatExpr) FatExpr #macro = 
    objc_call_impl(ret_reciever_arg_pattern, true);

fn objc_call_impl(a: FatExpr, super: bool) FatExpr = {
    callee := @if(super, @as(rawptr) objc_msgSendSuper, @as(rawptr) objc_msgSend);
    args_type: List(Type) = list(temp());
    args: List(FatExpr) = list(ast_alloc());
    selector: List(u8) = list(ast_alloc());
    placeholder := @{ panic("this will be replaced with the selector uid") };
    
    ret_ty := ObjCId; // default when you use call syntax. works for void as well because you can just ignore it.
    if true {
        break :: local_return;
        loop {
            @match(a.expr&) {
                fn Call(it) => {
                    name := it.f.ident() || compile_error("@objc call f must be named", it.f.loc);
                    no_args := !@is(it.arg.expr&, .Tuple, .StructLiteralP);
                    @match(it.arg.expr&) {
                        fn Tuple(it) => {
                            @ct_assert(it.len == 2, a.loc, "objc message send with multiple arguments needs names");
                            it[0] = compile_ast(it[0]);
                            if super {
                                @ct_assert(it[0].ty == *ObjCSuper, a.loc, "@objc_super first arg needs to be an ObjCSuper");
                            };
                            args_type&.push(it[0].ty);
                            args_type&.push(ObjCSelector);
                            args&.push(it[0]);
                            args&.push(placeholder);
                            @fmt(selector&, "%:", name.str());
                            
                            @if_let(it[1].expr&) fn StructLiteralP(it) => {
                                b := it.bindings&;
                                
                                e := compile_ast(b[0].default);
                                args_type&.push(e.ty);
                                args&.push(e);
                                
                                range(1, b.len) { i |
                                    b := b.index(i);
                                    name := or b.ident() {
                                        compile_error("Expected param name", a.loc)
                                    };
                                    value := b.default;
                                    @fmt(selector&, "%:", name.str());
                                    value := compile_ast(value);
                                    args&.push(value);
                                    args_type&.push(value.ty);
                                };
                                
                                break()
                            };
                            
                            it[1] = compile_ast(it[1]);
                            args_type&.push(it[1].ty);
                            args&.push(it[1]);
                            break();
                        }
                        fn StructLiteralP(_) => compile_error("@objc reciever can't have name", it.arg.loc);
                        @default => {
                            reciever := compile_ast(it.arg[]);
                            args_type&.push(reciever.ty);
                            args_type&.push(ObjCSelector);
                            args&.push(reciever);
                            args&.push(placeholder);
                            selector&.push_all(name.str());
                            break();
                        };
                    };
                }
                fn PrefixMacro(it) => {
                    loc := it.handler.loc;
                    msg :: "@objc expected @as";
                    handler := it.handler.ident() || compile_error(msg, loc);
                    @ct_assert(handler == @symbol as, loc, msg);
                    ret_ty = const_eval(Type)(it.arg[]);
                    a = it.target[];
                    // continue
                }
                @default => compile_error("@objc expected rec.m(args)", a.loc);
            };
        };
    };
    
    arg_ty := Ty(args_type.items());
    selector := selector.items().sym().c_str();
    args[1] = @{ SEL(@[@literal selector]) };  
    arg_pattern: FatExpr = (expr = (Tuple = args.as_raw()), ty = UnknownType, done = false, loc = a.loc);
    xx := @{
        f := @run assume_types_fn(@[@literal arg_ty], @[@literal ret_ty], @[@literal callee]);
        f(@[arg_pattern])
    };
    xx.loc = a.loc;
    xx
}

fn new($classname: Str) id(classname) #generic = 
    @objc init(@objc cls(classname).alloc());

// TODO: collect all the strings passed to this at comptime and load 
//       all the classes at startup so you don't have to check every time 
//       and don't have to worry about races. 
fn cls($name: Str) ObjCClass = {
    cache :: @static(ObjCClass) zeroed(ObjCClass);
    // TODO: This is not getting deduplicated properly? :FUCKED
    //       but it's also not one per callsite.     NSPasteboard,NSPasteboard are there twice
    //::println(name);
    if bit_cast_unchecked(ObjCClass, i64, cache[]) == 0 {
        cache[] = objc_getClass(::name.sym().c_str());
    }
    cache[]
}

// TODO: this being $ is a notable compile time cost somehow
fn SEL($name: CStr) ObjCSelector = {
    //sel_getUid(name)
    
    cache := @static(ObjCSelector);
    if bit_cast_unchecked(ObjCSelector, i64, cache[]) == 0 {
        cache[] = sel_getUid(name);
    }
    cache[]
}

// @objc_set(self) (name = val, ...); where self: ObjCId; -> void; => @objc self.setName(val);
fn objc_set(self: FatExpr, pat: FatExpr) FatExpr #macro = as_var self { self |
    @debug_assert(pat.expr&.is(.StructLiteralP));
    body := @{};
    each pat.expr.StructLiteralP.bindings& { b |
        b.default = compile_ast(b.default);
        name := b.ident().unwrap().str();
        sel  := objc_property_name_to_selector(name);
        arg  := Ty(ObjCId, ObjCSelector, b.default.ty);
        body = @{
            @[body];
            f :: assume_types_fn(@[@literal arg], void, @as(rawptr) objc_msgSend);
            f(@[self], SEL(@[@literal sel]), @[b.default]);
        };
    };
    body
};

objc_property_name_to_selector :: fn(name: Str) CStr = {
    sel := u8.list(temp());
    sel&.push_all("set");
    sel&.push(@if(name[0] >= 97 && name[0] <= 122, name[0] - 32, name[0]));  // to upper
    sel&.push_all(name.rest(1));
    sel&.push_all(":");
    sel.items().sym().c_str()
};

// WHY IS THIS SO FUCKING DIFFICULT BUT EVERYTHING ELSE WAS SO NORMAL ?? am i missing something? 
// https://clang.llvm.org/docs/Block-ABI-Apple.html
fn new_global_block(a: Alloc, userdata: rawptr, callee: rawptr) rawptr = {
    b := a.box_zeroed(Block_literal_1);
    d := a.box_zeroed(Block_literal_1.Desc);
    d.size = size_of(Block_literal_1);
    b.descriptor = d;
    b.userdata = userdata;
    b.invoke = callee;
    b.flags = 0b0_101000_0000000000000000000000;  // BLOCK_HAS_SIGNATURE|BLOCK_IS_GLOBAL
    // runtime for objective c blocks is in libsystem not libobjc
    b.isa = @import_symbol("_NSConcreteGlobalBlock", "libc");
    d.signature = "@:@";
    Block_literal_1.raw_from_ptr(b)
}

Block_literal_1 :: @struct {
    isa: rawptr;
    flags: i32;
    reserved: i32;
    invoke: rawptr;
    descriptor: *Desc;
    userdata: rawptr;
    
    Desc :: @struct {
        reserved := 0;
        size: i64;
        copy_helper: rawptr;
        dispose_helper: rawptr;
        signature: CStr;
    };
};

//
// See @/graphics/macos/app.fr for example usage. 
//
// Provide some constant declarations to define the inheritance hierarchy. 
// - EXTENDS :: "NSObject";  // required
// - IMPLEMENTS :: @const_slice("WhateverProtocol");  // optional
// 
// Constant function declarations in the scope of `def` will become methods in the new class. 
// - parameter names matter because they're used to create the selector strings 
// - a parameter of type ObjCSelector is inserted automatically (because the 
//   runtime passes one) so your function declaration stays looking like it would in objc. 
//
// TODO: non-hacky ivars
// 
fn register_objc_class($def: Type) ObjCClass = {
    spec :: @static(ObjcClassReflect) fill_objc_reflect(def);
    register_objc_class_outlined(spec)
}

ObjcClassReflect :: @struct {
    name: CStr;
    methods: []ObjcMethodReflect;
    protocols: []Str;
    extends: CStr;
};
ObjcMethodReflect :: @struct(callable: rawptr, selector: CStr);

// Speed doesn't matter since this only runs at startup 
// so avoid code bloat by not specializing this code for each class. 
fn register_objc_class_outlined(spec: *ObjcClassReflect) ObjCClass = {
    prev := objc_getClass(spec.name);
    @debug_assert(prev._.is_null(), "tried to redeclare class %", spec.name);
    
    super := objc_getClass(spec.extends);
    @debug_assert(!super._.is_null(), "undeclared class % (super for %)", spec.extends, spec.name);
    class := objc_allocateClassPair(super, spec.name, 0);
    @debug_assert(!class._.is_null());
    
    for spec.protocols { it |
        p := objc_getProtocol(@fmt_cstr("%", it));
        @debug_assert(!p._.is_null(), "undeclared protocol %", it);
        class_addProtocol(class, p);
    };
    
    for spec.methods { it |
        // TODO: does the type string (last arg) ever matter? 
        //       maybe it's just fine for me because I'm always implementing 
        //       protocols so it already knows what the types are? 
        //       magic words: "objective c type encoding"
        class_addMethod(class, sel_getUid(it.selector), it.callable, "");
    };
    
    // TODO: reflect to ask for this instead of hardcoding. 
    //       the normal thing would be you just have the first field 
    //       be your super class and then you can offset to your own ivars directly 
    //       without going through the runtime but i think you're not supposed to 
    //       assume that the size of apple's classes is stable so you can support  
    //       multiple versions of macos without recompiling. 
    // must be before register()
    class_addIvar(class, "franca_sapp", 8, 3, "q"); 
    
    objc_registerClassPair(class);
    class
}

// outlined to avoid recompiling for every $def
fn fill_objc_reflect(def: Type) ObjcClassReflect #fold = {
    #use("@/compiler/ast_external.fr");  // TODO: putting this :HERE breaks var resolution :CompilerBug 
    ::?[]Str;
    @debug_assert_eq(size_of(def), 0, "TODO: use runtime fields as ivars");
    s := Type.scope_of(def);
    (
        // TODO: maybe you should just pass this in because relying on TypeMeta.inferred_name
        //       is kinda sketchy but also it's really annoying to type everything twice. 
        name = def.typename().c_str(), 
        extends = {
            // TODO: string literal is supposed to coerce to CStr :CompilerBug
            s := get_constant(Str, s, @symbol EXTENDS) 
                || @panic("objc class % must provide super class as a constant like `EXTENDS :: \"NSObject\"`");
            s.sym().c_str()
        },
        // TODO: why does this work as []CStr but that ^ doesn't? ... it doesn't super work tho, it seems to lose the terminator? 
        protocols = get_constant([]Str, s, @symbol IMPLEMENTS) || {
            @assert(get_constant(s, @symbol IMPLEMENTS).is_none(), "type error for objc IMPLEMENTS (want []Str)");
            empty()
        },
        methods = {
            names := get_constants(s);
            methods := ObjcMethodReflect.list(names.len, ast_alloc());
            for names { name |
                // TODO: this returns Self (a type constant) as well :FUCKED
                //       it's just based on size not a real type check
                @if(name != @symbol Self)
                if get_constant(FuncId, s, name) { fid |
                    // resolve_body=true so it doesn't get confused when we replace it 
                    // for debugging :InstrumentObjc
                    func := get_function_ast(fid, false, true, false, false);
                    sel := {
                        args := func.arg.bindings.items();
                        sel := u8.list(temp());
                        sel&.push_all(name.str());
                        // Note: we don't expect people to have a `sel: ObjCSelector` 
                        //       parameter, we insert that later. 
                        if args.len > 1 {  // self, ... 
                            sel&.push_all(":");
                        }
                        if args.len > 2 {
                            // grab the rest based on parameter names
                            each args.rest(2) { it |
                                // :HERE
                                sel&.push_all(it.name.unwrap().str());
                                sel&.push_all(":");
                            }
                        };
                        
                        sel.items().sym().c_str()
                    };
                    // the runtime passes you the selector as the second argument,
                    // (to avoid shifting all the arguments to objc_msgSend) 
                    // which is useless because you already know the selector since  
                    // it's the one you registered for. so i add a fake parameter 
                    // to just discard it for you. 
                    {
                        @debug_assert(func.finished_arg.is_none());
                        @debug_assert(!func.get_flag(.MadeVarsForRuntimeArgs));
                        // TODO: check that you only try to do this once
                        //       (but the assertion will fire if you do since we compile below)
                        b: Binding = (
                            name = (Ident = @symbol _SEL),
                            ty = (Finished = ObjCSelector),
                            default = binding_missing_default(func.loc),
                            kind = .Var,
                            nullable_tag = zeroed(*Annotations),
                        );
                        func.arg.bindings&.insert(1, b, ast_alloc());
                    };
                    
                    // TODO: get_jitted_ptr should set this 
                    func.set_flag(.TookPointerValue);
                    
                    // TODO: just get_constant again with rawptr should coerce :CompilerBug
                    c := current_compiler_context();
                    callable := c.get_jitted(fid); // get_constant(rawptr, s, name).unwrap();
                    push(methods&, (selector = sel, callable = callable));
                }; 
            };
            methods.items()
        },
    )
}
