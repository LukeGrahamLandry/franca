// TODO: better error handling. 
// TODO: use posix_spawnp instead? that makes it easier to return an error to the caller. using fork is a pain. 
fn run_cmd_blocking(path: Str, args: Slice(Str)) bool = {
    cargs := make_args_for_exec(path, args, temp());
    envp := tls(.environment_variables)[];
    exe := search_path(envp, cargs[0]);
    pid := Syscall'fork();
    if pid == 0 {
        exec(exe, cargs);
    };
    
    status: i32 = 0;
    res := Posix'waitpid(pid, status&, 0) 
        || return(false);
    status == 0
}

fn exec_and_catch(path: Str, args: Slice(Str), alloc: Alloc) Ty(bool, List(u8), List(u8)) = 
    exec_and_catch(path, args, alloc, "");

fn exec_and_catch(path: Str, args: Slice(Str), alloc: Alloc, input: []u8) Ty(bool, List(u8), List(u8)) = {
    cargs := make_args_for_exec(path, args, temp());
    out := u8.list(alloc);
    err := u8.list(alloc);
    ok := @match(sys_capture_exec(cargs)) {
        fn Err(msg) => {
            // TODO: kill the child? 
            err&.push_all(msg);
            report_exec_error(err&, cargs);
            false
        }
        fn Ok(p) => poll_until_exit(p&, out&, err&, input) == 0;
    };
    (ok, out, err)
}

fn poll_until_exit(p: *RunningProcess, out: *List(u8), err: *List(u8), input: Str) i32 = {
    buf := @slice(out, err);
    i32.loop() { $break |
        @match(poll(p, buf, true, input&, true, true)) {
            fn Ok(status) => {
                if status { status |
                    break(status);
                };
            }
            fn Err(msg) => {
                @fmt(err, "%", msg);
                break(MAX_i32);
            };
        };
    }
}

RunningProcess :: @struct {
    pipes: Array(Fd, 3);  // in, out, err
    pid: i32;
    status: ?i32 = .None;
};

// TODO: let caller set cwd
// TODO: handle sending input to the child process
// TODO: deal with being sent signals while waiting
// TODO: deal with waiting on multiple processes at once
// 
// tls.environment_variables:
// - used to resolve arg[0] in PATH if it doesn't contain / 
// - inherited by the child 
sys_capture_exec :: fn(args: []CStr) Result(RunningProcess, Str) = {
    if TODOWASM && query_current_arch() == .wasm32 {
        err := u8.list(temp());
        report_exec_error(err&, args);
        return(Err = err.items());
    };
    
    pipes := zeroed Array(Array(Fd, 2), 3);
    each pipes& { p |
        Syscall'pipe(p) 
            || return(Err = "libc::pipe() failed");
    };
    @debug_assert(args[args.len - 1].ptr.is_null());
    envp := tls(.environment_variables)[];
    exe := search_path(envp, args[0]);
    
    pid := Syscall'fork();
    if pid == 0 { // Child
        // The important thing is that the child closes it's copy of the write end of its standard-input
        // so when the parent closes its copy too, the child will read it as EOF so a program 
        // that does "while(stdin)" will know it's reached the end and terminate. 
        Syscall'close(pipes&[0]&[1]).unwrap();  // close write end
        Syscall'close(pipes&[1]&[0]).unwrap();  // close read end
        Syscall'close(pipes&[2]&[0]).unwrap();  // "
        
        Syscall'dup2(pipes&[0]&[0], STD_IN)
            || panic("failed to dup2(in)");
        Syscall'dup2(pipes&[1]&[1], STD_OUT)
            || panic("failed to dup2(out)");
        Syscall'dup2(pipes&[2]&[1], STD_ERR)
            || panic("failed to dup2(err)");
        
        exec(exe, args);
    };
    // else: Parent

    Syscall'close(pipes&[0]&[0]).unwrap();  // close the read end
    Syscall'close(pipes&[1]&[1]).unwrap();  // close the write end
    Syscall'close(pipes&[2]&[1]).unwrap();  // "
    
    (Ok = (pid = pid, pipes = @array(pipes&[0]&[1], pipes&[1]&[0], pipes&[2]&[0])))
};

exec :: fn(resolved_exe_path: CStr, args: []CStr) Never = {
    // execvpe is a glibc thing. macos doesn't have it. 
    execve :: fn(pathname: CStr, null_terminated_argv: *CStr, envp: *CStr) i32 #weak #libc;
    
    libc_exec: rawptr = execve;
    Syscall;
    use_sys := prefer_syscalls() || libc_exec.is_null();
    e: (@FnPtr(p: CStr, v: *CStr, e: *CStr) i32) = @if(use_sys, Syscall'execve, execve);
    envp := tls(.environment_variables)[];
    
    // HACK: it may appear that i am bad at my job... but so is everyone else... it just can't be done apparently?
    //       https://github.com/golang/go/commit/a4b2c5efbc259c7d23159d304f9cb4266cd64643
    i := 0;
    loop {
        never := e(resolved_exe_path, args.ptr, envp);
        error := @if(use_sys, -never, Posix'errno()[]);
        if query_current_os() != .linux || error != 26 || i >= 10 {
            err := u8.list(temp());
            @fmt(err&, "errno=%\n", error);
            report_exec_error(err&, args);
            eprintln(err.items());
            Syscall'exit(1);
        };
        usleep(10000);  // delay chosen by fair die roll
        i += 1;
    }
};

// TODO: allow using a hanging poll for when you're just calling this in a loop to collect everything
//       but need to do the right thing if the process dies while you're polling it so it never writes anything else. 
// This function should be called in a loop! 
// (which exec_and_catch will do for you if you want it to block until all done). 
// 
// buf = (out, err); it's legal for all to be the same list
fn poll(self: *RunningProcess, buf: []*List(u8), realloc: bool, input: *[]u8, last_input: bool, blocking: bool) Result(?i32, Str) #use("@/lib/sys/posix.fr") = {
    @debug_assert_eq(buf.len, 2);  // TODO: pass *Array.
    poll_data := @slice(@as(pollfd)
        (fd = self.pipes&[0], events = POLL.OUT, revents = 0),
        (fd = self.pipes&[1], events = POLL.IN, revents = 0),
        (fd = self.pipes&[2], events = POLL.IN, revents = 0)
    );
    if input.len == 0 {
        poll_data = poll_data.rest(1);
    };
    
    n := poll(poll_data, @if(blocking, -1, 0)) || return(Err = "libc::poll() failed");
    
    o_closed := poll_data[poll_data.len - 1].revents.bit_and(POLL.HUP) != 0;
    e_closed := poll_data[poll_data.len - 2].revents.bit_and(POLL.HUP) != 0;
    if o_closed && e_closed && self.status.is_none() {
        status: i32 = 0;
        done := waitpid(self.pid, status&, W.NOHANG)
            || return(Err = "libc::wait4 failed");
        if done > 0 {
            // TODO: shift for WEXITSTATUS
            self.status = (Some = status);
        };
    };
    
    if self.status.is_none() && n == 0 {
        @debug_assert(!blocking);
        return(Ok = .None);
    };
    
    // TODO: do i have to ask for it to be nonblocking when i create the pipe?
    if input.len > 0 {
        p := poll_data.index(0);
        if p.revents.bit_and(POLL.OUT) != 0 {
            written := Syscall'write(p.fd, input.ptr, input.len) 
                || return(Err = "libc::write failed");
            input[] = input[].rest(written);
            if input.len == 0 && last_input {  // make it read EOF
                Syscall'close(p.fd)
                    || return(Err = "failed to close input pipe");
                self.pipes&[0].fd = -1;
            };
        };
        poll_data = poll_data.rest(1);
    };
    
    full := false;
    enumerate poll_data { i, p |
        buf := buf[i];
        have_data := p.revents.bit_and(POLL.IN) != 0;
        @if(have_data) dowhile {
            space := buf.maybe_uninit.len - buf.len;
            if realloc && space == 0 {
                buf.reserve(1);
                space = buf.maybe_uninit.len - buf.len;
            };
            len := Syscall'read(p.fd, buf.maybe_uninit.ptr.offset(buf.len), space)
                || return(Err = "libc::read() failed");
            buf.len += len;
            full = full || buf.maybe_uninit.len == buf.len;
            
            // :BigOutputBuffer (see devlog May 9, 2025)
            system_pipe_buffer_capacity :: 65536;
            len == system_pipe_buffer_capacity && len < space
        };
    };
    
    @if(!full) if self.status { _ |
        Syscall'close(self.pipes&[0]);
        Syscall'close(self.pipes&[1]);
        Syscall'close(self.pipes&[2]);
        return(Ok = self.status);
    };
    
    (Ok = .None)
};

// better to do this before forking so you don't have to copy COW pages in the child. 
make_args_for_exec :: fn(path: Str, args: []Str, a: Alloc) []CStr = {
    cargs := CStr.list(args.len + 2, temp());
    cargs&.push(path.as_cstr());
    for(args, fn(it) => cargs&.push(it.as_cstr()));
    cargs&.push(zeroed CStr);
    cargs.items()
};

search_path :: fn(envp: *CStr, needle_c: CStr) CStr = {
    #use("@/lib/sys/fs.fr");
    needle := needle_c.str();
    if needle.contains("/") {
        return needle_c;
    };
    path := find_environment_variable(envp, "PATH") 
        || return(needle_c);
    i := 0;
    while => path.ptr.offset(i)[] != 0 {
        start := i;
        while => path.ptr.offset(i)[] != ":".ascii() && path.ptr.offset(i)[] != 0 {
            i += 1;
        };
        prefix := path.ptr.offset(start).slice(i - start);
        s := @tfmt("%/%\0", prefix, needle);
        if file_exists(s.slice(0, s.len - 1)) {
            return(ptr = s.ptr);
        };
        i += int(path.ptr.offset(i)[] != 0);
    };
    needle_c
};

report_exec_error :: fn(err: *List(u8), cargs: []CStr) void = {
    @fmt(err, "Failed to exec:\n");
    // don't try to print the null terminator
    for cargs.slice(0, cargs.len - 1) { it |
        @fmt(err, "% ", it);
    };
    @fmt(err, "\n");
};
