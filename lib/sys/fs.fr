
// TODO: it wont close the directory if you use an early return from the body!!
fn walk_directory(path: CStr, $body: @Fn(entry: *DirEnt) void) bool = {
    ::ptr_utils(Dir); ::ptr_utils(DirEnt);
    entry := DirEnt.zeroed();
    dir := opendir(path);
    ret :: return;
    if(dir.is_null(), => ret(false));
    
    out := entry&;
    loop {|
        readdir_r(dir, entry&, out&); // TODO: error handling
        if(out.is_null()) {|
            // TODO: have expr!defer that runs even if the `body` does an early return so you can use this like a normal loop without collecting the items. 
            closedir(dir); // TODO: error handling
            ret(true);
        };
        body(out);
    };
    
    unreachable()
}

fn name(self: *DirEnt) Str = (ptr = self.d_name&.as_ptr(), len = self.d_namlen.zext());

fn file_exists(path: Str) bool = {
    c := path.maybe_borrow_cstr(temp());
    access(c, @as(i64) AccessMode.Exists).is_ok()
}

// TODO: i think if im passing Create i also have to pass mode as an extra argument!!!
// TODO: @try for the libc result types. 
fn write_entire_file(path: Str, content: Str) bool = {
    flag := (@as(i64) OpenFlag.Write).bit_or(@as(i64) OpenFlag.Create).bit_or(@as(i64) OpenFlag.Truncate);
    path := maybe_borrow_cstr(path, temp());
    fd := open(path, flag);
    if(!fd.is_ok(), => return(false));
    fd := fd.unwrap();
    written := write(fd, content.ptr, content.len);
    if(!written.is_ok(), => return(false));
    // TODO: loop if we couldn't write the whole thing at once. 
    if(written.unwrap() != content.len, => return(false));
    fd.close();
    true
}


fn append_to_file(path: Str, content: Str) bool = {
    flag := (@as(i64) OpenFlag.Write).bit_or(@as(i64) OpenFlag.Create).bit_or(@as(i64) OpenFlag.Append);
    path := maybe_borrow_cstr(path, temp());
    fd := open(path, flag);
    if(!fd.is_ok(), => return(false));
    fd := fd.unwrap();
    written := write(fd, content.ptr, content.len);
    if(!written.is_ok(), => return(false));
    // TODO: loop if we couldn't write the whole thing at once. 
    if(written.unwrap() != content.len, => return(false));
    fd.close();
    true
}

PATH_SEP :: "/";

fn push_path_segment(self: *List(u8), name: []u8) void = {
    if !self.items().ends_with(PATH_SEP) {|
        self.push_all(PATH_SEP);
    };
    self.push_all(name);
}

fn pop_path_segment(self: *List(u8)) bool = {
    if !self.is_empty() && self.items().ends_with(PATH_SEP) {|
        self.pop();
    };
    self.pop_until_endswith(PATH_SEP)
}
