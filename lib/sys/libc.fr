//! The standard library often provides more ergonomic wrappers of these,
//! that will also be implemented on platforms that don't have a standard libc (like wasm in the browser). 

// TODO: use my own verions for the ones that are just code not magic platform shit apple wont let me do. 
fn malloc(size: usize) rawptr #libc;
fn free(ptr: rawptr) void #libc;
// easy to remove but I wonder if some c compilers bless the real one more than they would mine? 
// should also do cool simd stuff. 
fn memcpy(dest: rawptr, src: rawptr, len: i64) void #libc; 

Fd :: @struct(fd: i32); // fd is non-negative
fn open(null_terminated_path: CStr, flags: i64) FdResult #libc;
fn read(fd: Fd, buf: *u8, size: i64) i64Result #libc;
fn write(fd: Fd, buf: *u8, size: i64) i64Result #libc;
fn close(fd: Fd) voidResult #libc;
fn lseek(fd: Fd, offset: i64, whence: Whence) i64Result #libc;
fn remove(filepath: CStr) voidResult #libc;
fn opendir(path: CStr) *Dir #link_rename(append_inode64_on_applex8664) #libc; // TODO: nullable niche
fn readdir_r(dir: *Dir, entry: *DirEnt, result: **DirEnt) voidResult #link_rename(append_inode64_on_applex8664) #libc;  // TODO: nullable niche for result[]
fn closedir(dir: *Dir) voidResult #libc;
// TODO: mode is a bit flag of AccessMode
fn access(pathname: CStr, mode: i64) voidResult #libc;  // TODO: bit flags
fn getcwd(buf: [] u8) CStrResult #libc; // Note: this relies on my abi passing slices as (ptr, len) in registers like seperate args!

// Last 6 chars of template must be XXXXXX and they will be mutated to the temp filename. 
fn mkstemp(template: CStr) FdResult #libc;

DlHandle :: @struct(lib: rawptr);
fn dlopen(name: CStr, flag: DlFlag) DlHandle #libc;
fn dlsym(lib: DlHandle, name: CStr) rawptr #libc;
fn dlclose(lib: DlHandle) voidResult #libc;

fn mmap(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) rawptr #libc;
fn munmap(addr: rawptr, len: i64) voidResult #libc;
fn mprotect(addr: rawptr, len: i64, prot: i64) voidResult #libc;

fn exit(status: i64) Never #libc #cold;
fn abort() Never #libc #cold;
// This is probably shittier than something like execv that doesn't force you to concat the strings and deal with spaces
fn system(null_terminated_cmd: CStr) i64 #libc;
fn usleep(micro_seconds: u32) void #libc;
fn execv(pathname: CStr, null_terminated_argv: *CStr) i32 #libc;
fn execvp(pathname: CStr, null_terminated_argv: *CStr) i32 #libc;
fn uname(buf: *Utsname) voidResult #libc;

fn fork() i32 #libc;
/// wait for a child to stop. the return value is its pid. 
fn wait(status: *i32) i32 #libc;
fn waitpid(pid: i32, status: *i32, options: i64) i32 #libc; // TODO: i32 
fn pipe(pipefd: *Array(Fd, 2)) voidResult #libc;
fn dup2(oldfd: Fd, newfd: Fd) voidResult #libc;
fn chdir(path: CStr) voidResult #libc;
fn poll(fds: []PollFds, timeout: i32) i32Result #libc; // :slice_abi
fn rename(oldpath: CStr, newpath: CStr) voidResult #libc;

TimeSpec :: @struct(seconds: i64, nanoseconds: i64);
fn clock_gettime(clock_id: i64, time_spec: *TimeSpec) void #libc;

// TODO: use this instead of exporting functions from the compiler.
Terminos :: @struct(iflag: u64, oflag: u64, cflag: u64, lflag: u64, cc: Array(u8, 20), ispeed: u64, ospeed: u64);
fn tcgetattr(fd: Fd, out: *Terminos) void #libc;
fn tcsetattr(fd: Fd, optional_actions: i64, in: *Terminos) void #libc;

// TODO: #when(TARGET_ARCH.eq(.Aarch64))
// TODO: do this myself
// x86 doesn't need this and x86_64-unknown-linux-musl doesn't give me a fake one to link against
fn __clear_cache(beg: rawptr, beg: rawptr) void #libc #aarch64;

// TODO: #when(TARGET_OS.eq(.Macos))
fn __error() *i32 #libc;  // This has different names on different os-s. like __errno_location

// TODO: #when(TARGET_OS.eq(.Macos))
// thank you rust very cool: These functions are in crt_externs.h.
fn _NSGetArgc() *i64 #libc;
fn _NSGetArgv() **CStr #libc;

fn _NSGetExecutablePath(buf: *u8, len: *i64) voidResult #libc;

fn get_errno() i64 = __error()[].zext();

STD_IN  : Fd : (fd = 0.intcast());
STD_OUT : Fd : (fd = 1.intcast());
STD_ERR : Fd : (fd = 2.intcast());

// TODO: idk if these change on different os-es. probably? 
// START @generated by libc_constants.c
OpenFlag :: @enum(i64) (Read = 0, Write = 1, ReadWrite = 2, Create = 512, Truncate = 1024, Append = 8);
MapProt :: @enum(i64) (Exec = 4, Read = 1, Write = 2);
MapFlag :: @enum(i64) (Private = 2, Anonymous = 4096);
Whence :: @enum(i64) (Set = 0, Cur = 1, End = 2);
DlFlag :: @enum(i64) (Lazy = 1, Now = 2);
Dir :: @struct(opaque: Array(u8, 136)); // TODO: alignment
PATH_NAME_MAX :: 255;
DirEntType :: @enum(u8) (Directory = 4, File = 8, SymbolicLink = 10);
TermConstants :: @struct(_parsehack: void, $ICANON := 256, $ ECHO := 8, $VMIN := 16, $VTIME := 17, $ TCSANOW := 0, $TCSADRAIN := 1);
AccessMode :: @enum(i64) (Exists = 0, Readable = 4, Writable = 2, Executable = 1);
WaitPidOptions :: @enum(i64) (NoHang = 1);
PollEvents :: @enum(i64) (In = 1);
_SYS_NAMELEN :: 256;// todo: probably not standard
// END @generated by libc_constants.c

DirEnt :: @struct(
    d_ino: u64, 
    d_seekoff: u64, 
    d_reclen: u16, 
    d_namlen: u16, 
    d_type: DirEntType, 
    d_name: Array(u8, PATH_NAME_MAX)
);

PollFds :: @struct(
    fd: Fd,
    events: u16,
    revents: u16,
);

Utsname :: @struct(
    sysname: Array(u8, _SYS_NAMELEN),
    nodename: Array(u8, _SYS_NAMELEN),
    release: Array(u8, _SYS_NAMELEN),
    version: Array(u8, _SYS_NAMELEN),
    machine: Array(u8, _SYS_NAMELEN),
);

// TODO: be able to mark #must_use and have the driver program check if you don't unwrap them. 
// TODO: should the errors check errno and save the result for you?
//       but then you'd have to call wrappers instead of the real libc functions.

FdResult :: @struct(fd: i32); // fd is negative on error
fn unwrap(self: FdResult) Fd = {
    if(self.fd.lt(0.intcast()), => panic("Fd Error"));
    (fd = self.fd)
}
fn or(self: FdResult, $else: @Fn() Fd) Fd = {
    ::if(Fd);
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: FdResult) bool = !self.fd.lt(0.intcast());
i64Result :: @struct(value: i64);
fn unwrap(self: i64Result) i64 = {
    if(self.value.lt(0), => panic("Error"));
    self.value
}
fn or(self: i64Result, $else: @Fn() i64) i64 = {
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: i64Result) bool = !self.value.lt(0);
voidResult :: @struct(value: i64);
fn unwrap(self: voidResult) void = {
    if(self.value.ne(0), => panic("Error"));
}
fn or(self: voidResult, $else: @Fn() void) void = {
    if(self.is_ok(), => (), else)
}
fn is_ok(self: voidResult) bool = self.value.eq(0);
CStrResult :: @struct(value: CStr);
fn unwrap(self: CStrResult) CStr = {
    if(!self.is_ok(), => panic("Error"));
    self.value
}
fn or(self: CStrResult, $else: @Fn() CStr) CStr = {
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: CStrResult) bool = !self.value.ptr.is_null();
i32Result :: @struct(value: i32);
fn unwrap(self: i32Result) i32 = {
    // :sema_regression shouldn't need cast 
    if(self.value.lt(@as(i32)0), => panic("Error"));
    self.value
}
fn or(self: i32Result, $else: @Fn() i32) i32 = {
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: i32Result) bool = !self.value.lt(0);

// :link_rename
// https://github.com/rust-lang/libc/issues/414 
append_inode64_on_applex8664 :: fn(req: *LinkRenameArg) void = {
    req.out.push_all(req.old_name);
    if req.target.arch == .X86_64 && req.target.os == .Macos { 
        req.out.push_all("$INODE64");
    };
};
