//! The standard library often provides more ergonomic wrappers of these,
//! that will also be implemented on platforms that don't have a standard libc (like wasm in the browser). 

Fd :: @struct(fd: i32); // fd is non-negative
// TODO: be able to mark #must_use and have the driver program check if you don't unwrap them. 
FdResult :: @struct(fd: i32); // fd is negative on error
fn unwrap(self: FdResult) Fd = {
    if(self.fd.lt(0.intcast()), => panic("Fd Error"));
    (fd = self.fd)
}
i64Result :: @struct(value: i64);
fn unwrap(self: i64Result) i64 = {
    if(self.value.lt(0), => panic("Error"));
    self.value
}
voidResult :: @struct(value: i64);
fn unwrap(self: voidResult) Unit = {
    if(self.value.ne(0), => panic("Error"));
}

fn open(null_terminated_path: CStr, flags: i64) FdResult #libc;
fn read(fd: Fd, buf: Ptr(u8), size: i64) i64Result #libc;
fn write(fd: Fd, buf: Ptr(u8), size: i64) i64Result #libc;
fn close(fd: Fd) voidResult #libc;
fn lseek(fd: Fd, offset: i64, whence: Whence) i64Result #libc;
fn remove(filepath: CStr) voidResult #libc;

// Last 6 chars of template must be XXXXXX and they will be mutated to the temp filename. 
fn mkstemp(template: CStr) FdResult #libc;

DlHandle :: @struct(lib: rawptr);
fn dlopen(name: CStr, flag: DlFlag) DlHandle #libc;
fn dlsym(lib: DlHandle, name: CStr) rawptr #libc;
fn dlclose(lib: DlHandle) voidResult #libc;

fn malloc(size: usize) rawptr #libc;
fn free(ptr: rawptr) Unit #libc;
fn mmap(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) rawptr #libc;
fn munmap(addr: rawptr, len: i64) voidResult #libc;
fn mprotect(addr: rawptr, len: i64, prot: i64) voidResult #libc;

fn exit(status: i64) Never #libc;
fn abort() Never #libc;
fn system(null_terminated_cmd: CStr) i64 #libc;
fn rand() i64 #libc;
fn usleep(micro_seconds: u32) Unit #libc;
fn execv(pathname: CStr, null_terminated_argv: *CStr) i32 #libc;
fn fork() i32 #libc;
/// wait for a child to stop. the return value is its pid. 
fn wait(status: *i32) i32 #libc; 
fn waitpid(pid: i32, status: *i32, options: i32) i32 #libc; 

// The c backend emits calls to this for large var assignments. 
// TODO: This one offends me because its not doing os magic, I could write one myself. 
//       but I wonder if some c compilers bless the real one more than they would mine? 
fn memcpy(dest: rawptr, src: rawptr, len: i64) Unit #libc;

TimeSpec :: @struct(seconds: i64, nanoseconds: i64);
fn clock_gettime(clock_id: i64, time_spec: *TimeSpec) Unit #libc;

// TODO: use this instead of exporting functions from the compiler.
Terminos :: @struct(iflag: u64, oflag: u64, cflag: u64, lflag: u64, cc: Array(u8, 20), ispeed: u64, ospeed: u64);
fn tcgetattr(fd: Fd, out: *Terminos) Unit #libc;
fn tcsetattr(fd: Fd, optional_actions: i64, in: *Terminos) Unit #libc;

// TODO: #when(TARGET_ARCH.eq(.Aarch64))
fn __clear_cache(beg: rawptr, beg: rawptr) Unit #libc #aarch64;

// TODO: #when(TARGET_OS.eq(.Macos))
fn _NSGetArgc() *i64 #libc;
fn _NSGetArgv() **CStr #libc;

// TODO: idk if these change on different os-es. probably? 
// START @generated by libc_constants.c
OpenFlag :: @enum(i64) (Read = 0, Write = 1, ReadWrite = 2, Create = 512, Truncate = 1024);
MapProt :: @enum(i64) (Exec = 4, Read = 1, Write = 2);
MapFlag :: @enum(i64) (Private = 2, Anonymous = 4096);
Whence :: @enum(i64) (Set = 0, Cur = 1, End = 2);
DlFlag :: @enum(i64) (Lazy = 1, Now = 2);
// END @generated by libc_constants.c
