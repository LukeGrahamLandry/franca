//!
//! The standard library often provides more ergonomic wrappers of these,
//! that will also be implemented on platforms that don't have a standard libc (like wasm in the browser). 
//!
//! When targetting macos, there is no stable syscall abi, so #libc functions will be dynamically linked. 
//!
//! Some old syscalls are trivially replaced by specific arguments to more general new ones,
//! (ie. `open` becomes `openat` of `AT_FDCWD`), and are not implemented on all architectures (*cough* arm64 *cough*). 
//! In those cases, a body is provided to do the translation so you don't have to link a libc for something boring. 

Syscall   :: import("@/lib/sys/syscall.fr");
MacosLibc :: import("@/lib/sys/macos.fr");
LinuxLibc :: import("@/lib/sys/linux.fr");

fn LibcType(os: Os) ScopeId #fold = @match(os) {
    fn macos() => MacosLibc;
    fn linux() => LinuxLibc;
    fn wasip1() => panic("TODO: libc type wasi:");
}

// TODO: use my own verions for the ones that are just code not magic platform shit apple wont let me do. 
fn malloc(size: usize) rawptr #libc;
fn free(ptr: rawptr) void #libc;
fn calloc(num: i64, size: i64) rawptr #libc;

fn puts(ptr: CStr) void #libc; // nice for testing when everythings broken

Fd :: @struct(fd: i32); // fd is non-negative (except for when it's not)
// Last 6 chars of template must be XXXXXX and they will be mutated to the temp filename. 
fn mkstemp(template: CStr) FdResult #libc;

fn remove(path: CStr) voidResult #libc;
fn chmod(pathname: CStr, mode: FileMode) voidResult #libc;

fn mmap_anon(addr: rawptr, len: i64, prot: i64, offset: i64) rawptr = {
    fd: Fd = (fd = 1.neg().intcast());
    flag: i64 = bit_or(Posix'MAP'PRIVATE, Posix'MAP'ANON);  // TODO: subtyping so working with enum flags sucks less. 
    result := Posix'mmap(addr, len, prot, flag, fd, offset);
    result.Ok // null if err
};

fn mmap_jit(addr: rawptr, len: i64, prot: i64, offset: i64) rawptr = {
    fd: Fd = (fd = 1.neg().intcast());
    flag: i64 = bit_or(Posix'MAP'PRIVATE, Posix'MAP'ANON).bit_or(Posix'MAP'JIT);
    Posix'mmap(addr, len, prot, flag, fd, offset)
};

fn usleep(micro_seconds: u32) voidResult = {
    s, us := div_mod(@as(i64) micro_seconds.zext(), US_PER_S);
    t: TimeSpec = (seconds = s, nanoseconds = us * NS_PER_US);
    Syscall'nanosleep(t&, TimeSpec.ptr_from_int(0))
}

fn execv(pathname: CStr, null_terminated_argv: *CStr) i32 #libc;
fn execvp(pathname: CStr, null_terminated_argv: *CStr) i32 #libc;

fn fork() i32 #libc;
/// wait for a child to stop. the return value is its pid. 
fn wait(status: *i32) i32 #libc;
fn waitpid(pid: i32, status: *i32, options: i64) i32 #libc; // TODO: i32 
fn pipe(pipefd: *Array(Fd, 2)) voidResult #libc;
fn poll(fds: []PollFds, timeout: i32) i32Result #libc; // :slice_abi

fn rename(oldpath: CStr, newpath: CStr) voidResult = {
    d := Posix'AT'FDCWD();
    Syscall'renameat(d, oldpath, d, newpath)
}

TimeSpec :: @struct(seconds: i64, nanoseconds: i64);

fn display(self: TimeSpec, out: *List(u8)) void = {
    @fmt(out, "(%s + %ns)", self.seconds, self.nanoseconds)
}

Posix :: import("@/lib/sys/posix.fr");

// TODO: i think this is an ioctl
Terminos :: @struct(iflag: u64, oflag: u64, cflag: u64, lflag: u64, cc: Array(u8, 20), ispeed: u64, ospeed: u64);
fn tcgetattr(fd: Fd, out: *Terminos) void #libc;
fn tcsetattr(fd: Fd, optional_actions: i64, in: *Terminos) void #libc;

STD_IN  : Fd : (fd = 0.intcast());
STD_OUT : Fd : (fd = 1.intcast());
STD_ERR : Fd : (fd = 2.intcast());


// START @generated by libc_constants.c
MapProt :: @enum(i64) (Exec = 4, Read = 1, Write = 2);
Whence :: @enum(i64) (Set = 0, Cur = 1, End = 2);
DirEntType :: @enum(u8) (Directory = 4, File = 8, SymbolicLink = 10);
// TODO: :Linux
TermConstants :: @struct(_parsehack: void, $ICANON := 256, $ECHO := 8, $VMIN := 16, $VTIME := 17, $ TCSANOW := 0, $TCSADRAIN := 1);
AccessMode :: @enum(i64) (Exists = 0, Readable = 4, Writable = 2, Executable = 1);
WaitPidOptions :: @enum(i64) (NoHang = 1);
PollEvents :: @enum(i64) (In = 1);
FileMode :: @enum(u16) (
    OwnerAll = 448, OwnerRead = 256, OwnerWrite = 128, OwnerExecute = 64, 
    GroupAll = 56, GroupRead = 32, GroupWrite = 16, GroupExecute = 8, 
    OthersAll = 7, OthersRead = 4, OthersWrite = 2, OthersExecute = 1,
    AnyoneExecute = 73,
);
// END @generated by libc_constants.c

PollFds :: @struct(
    fd: Fd,
    events: u16,
    revents: u16,
);

pid_t :: i32;
uid_t :: u32;
sigset_t :: u32;

// TODO: be able to mark #must_use and have the driver program check if you don't unwrap them. 
// TODO: should the errors check errno and save the result for you?
//       but then you'd have to call wrappers instead of the real libc functions.

FdResult :: @struct(fd: i32); // fd is negative on error
fn unwrap(self: FdResult) Fd = {
    if(self.fd.lt(0.intcast()), => panic("Fd Error"));
    (fd = self.fd)
}
fn or(self: FdResult, $else: @Fn() Fd) Fd = {
    ::if(Fd);
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: FdResult) bool = !self.fd.lt(0.intcast());
i64Result :: @struct(value: i64);
fn unwrap(self: i64Result) i64 = {
    if(self.value.lt(0), => panic("Error"));
    self.value
}
fn or(self: i64Result, $else: @Fn() i64) i64 = {
    if(self.value >= 0, => self.value, else)
}
fn is_ok(self: i64Result) bool = !self.value.lt(0);
voidResult :: @struct(value: i64);
fn unwrap(self: voidResult) void = {
    if(self.value.ne(0), => panic("Error"));
}
fn or(self: voidResult, $else: @Fn() void) void = {
    if(self.is_ok(), => (), else)
}
fn is_ok(self: voidResult) bool = self.value.eq(0);
fn is_err(self: *voidResult) bool = !self[].is_ok();
fn unwrap_err(self: voidResult) void = {
    @assert(self&.is_err(), "expected err");
}

CStrResult :: @struct(value: CStr);
fn unwrap(self: CStrResult) CStr = {
    if(!self.is_ok(), => panic("Error"));
    self.value
}
fn or(self: CStrResult, $else: @Fn() CStr) CStr = {
    @if(self.is_ok(), self.unwrap(), else())
}
fn is_ok(self: CStrResult) bool = !self.value.ptr.is_null();
i32Result :: @struct(value: i32);
fn unwrap(self: i32Result) i32 = {
    // :sema_regression shouldn't need cast 
    if(self.value.lt(@as(i32)0), => panic("Error"));
    self.value
}
fn or(self: i32Result, $else: @Fn() i32) i32 = {
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: i32Result) bool = !self.value.lt(0);

glibc_dylib_paths :: @const_slice("libc.so.6", "libdl.so.2", "libpthread.so.0", "libm.so.6");
macos_dylib_paths :: @const_slice("/usr/lib/libc.dylib");
fn find_os_libc_dylib() []Str = {
    @match(query_current_os()) {
        fn macos() => macos_dylib_paths;
        fn linux() => glibc_dylib_paths; // TODO: what about other libcs? we need more information about the target (or to snoop around?)
        fn wasip1() => empty();
    }
}

// TODO: now that im trying to do runtime dispatch for everything, i can't use `_` because the compiler denies that 
//       if it thinks it could be reachable (which it always will be if not using #target_os). I think the sane thing 
//       to do is make #syscall not a magic compiler thing. 
NOSYS :: 9999;

/* these exist if you really want them but depending on libc heavily isn't great
FILE :: @struct();
fn fdopen(fd: Fd, mode: CStr) *FILE #libc;
fn fopen(filename: CStr, mode: CStr) *FILE #libc;
fn fwrite(ptr: rawptr, size: i64, nmemb: i64, stream: *FILE) i64 #libc;
fn fclose(stream: *FILE) voidResult #libc;
fn write(stream: *FILE, bytes: []u8) voidResult = {
    written := fwrite(u8.raw_from_ptr(bytes.ptr), 1, bytes.len, stream);
    if written < bytes.len {
        return(value = -1);
    };
    (value = 0)
}
*/

time_t :: @struct(seconds: i64);
fn localtime(time_in: *time_t) *BigTime #libc;
fn time(out: *time_t) time_t #libc;

BigTime :: @struct(
    sec: i32,   // 0-60 // ???
    min: i32,   // 0-59
    hour: i32,  // 0-23
    mday: i32,  // 1-31
    mon: i32,   // 0-11
    year: i32,  // since 1900
    wday: i32,  // 0-6 since sunday
    yday: i32,  // 0-365
    isdst: i32, // 0-1 Daylight Savings Time
    
    // these are "extra", it seems apple, glibc, and musl all have them
    gmtoff: i64, // offset from UTC in seconds
    zone: CStr,  // timezone abbreviation
);

fn symlink(target: CStr, linkpath: CStr) voidResult #libc; 
