//!
//! The standard library often provides more ergonomic wrappers of these,
//! that will also be implemented on platforms that don't have a standard libc (like wasm in the browser). 
//!
//! When targetting macos, there is no stable syscall abi, so #libc functions will be dynamically linked. 
//!
//! Some old syscalls are trivially replaced by specific arguments to more general new ones,
//! (ie. `open` becomes `openat` of `AT_FDCWD`), and are not implemented on all architectures (*cough* arm64 *cough*). 
//! In those cases, a body is provided to do the translation so you don't have to link a libc for something boring. 

Syscall   :: import("@/lib/sys/syscall.fr");
MacosLibc :: import("@/lib/sys/macos.fr");
LinuxLibc :: import("@/lib/sys/linux.fr");

Fd :: @struct(fd: i32); // fd is non-negative (except for when it's not)
// Last 6 chars of template must be XXXXXX and they will be mutated to the temp filename. 
fn mkstemp(template: CStr) FdResult #weak #libc;

fn remove(path: CStr) Posix'SysResult(void) = 
    Posix'remove(path);

fn mmap_anon(addr: rawptr, len: i64, prot: i64, offset: i64) rawptr = {
    fd: Fd = (fd = 1.neg().intcast());
    flag: i64 = bit_or(Posix'MAP'PRIVATE, Posix'MAP'ANON);  // TODO: subtyping so working with enum flags sucks less. 
    result := Posix'mmap(addr, len, prot, flag, fd, offset);
    result.Ok // null if err
};

fn mmap_jit(addr: rawptr, len: i64, prot: i64, offset: i64) rawptr = {
    fd: Fd = (fd = 1.neg().intcast());
    flag: i64 = bit_or(Posix'MAP'PRIVATE, Posix'MAP'ANON).bit_or(Posix'MAP'JIT);
    Posix'mmap(addr, len, prot, flag, fd, offset)
};

fn usleep(micro_seconds: u32) voidResult = {
    s, us := div_mod(@as(i64) micro_seconds.zext(), US_PER_S);
    t: TimeSpec = (seconds = s, nanoseconds = us * NS_PER_US);
    @if(SLOW_USERSPACE_THREADS) return(import("@/lib/sys/sync/green.fr")'sleep(t&));
    Syscall'nanosleep(t&, TimeSpec.ptr_from_int(0))
}

fn rename(oldpath: CStr, newpath: CStr) voidResult = {
    d := Posix'AT'FDCWD();
    Syscall'renameat(d, oldpath, d, newpath)
}

TimeSpec :: @struct(seconds: i64, nanoseconds: i64);

fn from_ms(ms: i64) TimeSpec = {
    s, ms_extra := ms.div_mod(MS_PER_S);
    (seconds = s, nanoseconds = ms_extra * NS_PER_MS)
}

fn display(self: TimeSpec, out: *List(u8)) void = {
    @fmt(out, "(");
    @if(self.seconds != 0) @fmt(out, "%s + ", self.seconds);
    ms, rest := self.nanoseconds.udiv_mod(NS_PER_MS);
    @if(ms != 0) @fmt(out, "%ms+", ms);
    us, ns := rest.udiv_mod(NS_PER_US);
    @if(us != 0) @fmt(out, "%us+", us);
    @if(ns != 0) @fmt(out, "%ns", ns);
    out.len -= int(out.items().ends_with("+"));
    @fmt(out, ")");
}

Posix :: import("@/lib/sys/posix.fr");

STD_IN  : Fd : (fd = 0.intcast());
STD_OUT : Fd : (fd = 1.intcast());
STD_ERR : Fd : (fd = 2.intcast());

MapProt :: @enum(i64) (Exec = 4, Read = 1, Write = 2);
Whence :: @enum(i64) (Set = 0, Cur = 1, End = 2);
DirEntType :: @enum(u8) (Directory = 4, File = 8, SymbolicLink = 10);
AccessMode :: @enum(i64) (Exists = 0, Readable = 4, Writable = 2, Executable = 1);
FileMode :: @enum(u16) (
    OwnerAll = 448, OwnerRead = 256, OwnerWrite = 128, OwnerExecute = 64, 
    GroupAll = 56, GroupRead = 32, GroupWrite = 16, GroupExecute = 8, 
    OthersAll = 7, OthersRead = 4, OthersWrite = 2, OthersExecute = 1,
    AnyoneExecute = 73,
);

pid_t :: i32;
uid_t :: u32;
sigset_t :: u32;

// TODO: be able to mark #must_use and have the driver program check if you don't unwrap them. 
// TODO: should the errors check errno and save the result for you?
//       but then you'd have to call wrappers instead of the real libc functions.

FdResult :: @struct(fd: i32); // fd is negative on error
fn unwrap(self: FdResult) Fd = {
    if(self.fd.lt(0.intcast()), => panic("Fd Error"));
    (fd = self.fd)
}
fn or(self: FdResult, $else: @Fn() Fd) Fd = {
    ::if(Fd);
    if(self.is_ok(), => self.unwrap(), else)
}
fn is_ok(self: FdResult) bool = !self.fd.lt(0.intcast());
i64Result :: @struct(value: i64);
fn unwrap(self: i64Result) i64 = {
    if(self.value.lt(0), => panic("Error"));
    self.value
}
fn or(self: i64Result, $else: @Fn() i64) i64 = {
    if(self.value >= 0, => self.value, else)
}
fn is_ok(self: i64Result) bool = !self.value.lt(0);
voidResult :: @struct(value: i64);
fn unwrap(self: voidResult) void = {
    if(self.value.ne(0), => panic("Error"));
}
fn or(self: voidResult, $else: @Fn() void) void = {
    if(self.is_ok(), => (), else)
}
fn is_ok(self: voidResult) bool = self.value.eq(0);
fn is_err(self: *voidResult) bool = !self[].is_ok();
fn unwrap_err(self: voidResult) void = {
    @assert(self&.is_err(), "expected err");
}

CStrResult :: @struct(value: CStr);
fn unwrap(self: CStrResult) CStr = {
    if(!self.is_ok(), => panic("Error"));
    self.value
}
fn or(self: CStrResult, $else: @Fn() CStr) CStr = {
    @if(self.is_ok(), self.unwrap(), else())
}
fn is_ok(self: CStrResult) bool = !self.value.ptr.is_null();

glibc_dylib_paths :: @const_slice("libc.so.6", "libdl.so.2", "libpthread.so.0", "libm.so.6");
macos_dylib_paths :: @const_slice("/usr/lib/libc.dylib");
fn find_os_libc_dylib() []Str = {
    @match(query_current_os()) {
        fn macos() => macos_dylib_paths;
        fn linux() => glibc_dylib_paths; // TODO: what about other libcs? we need more information about the target (or to snoop around?)
    }
}

// TODO: now that im trying to do runtime dispatch for everything, i can't use `_` because the compiler denies that 
//       if it thinks it could be reachable (which it always will be if not using #target_os). I think the sane thing 
//       to do is make #syscall not a magic compiler thing. 
NOSYS :: 9999;

time_t :: @struct(seconds: i64);
fn localtime_r(time_in: *time_t, time_out: *BigTime) *BigTime #weak #libc;
fn time(out: *time_t) time_t #weak #libc;

BigTime :: @struct(
    sec: i32,   // 0-60 // ???
    min: i32,   // 0-59
    hour: i32,  // 0-23
    mday: i32,  // 1-31
    mon: i32,   // 0-11
    year: i32,  // since 1900
    wday: i32,  // 0-6 since sunday
    yday: i32,  // 0-365
    isdst: i32, // 0-1 Daylight Savings Time
    
    // these are "extra", it seems apple, glibc, and musl all have them
    gmtoff: i64, // offset from UTC in seconds
    zone: CStr,  // timezone abbreviation
);
