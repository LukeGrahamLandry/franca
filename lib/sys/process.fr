fn cli_args() []CStr #target_os = (fn($os) => @match(os){
    fn macos() => {
        argc := _NSGetArgc()[];
        argv := _NSGetArgv()[];
        // Safety: the os wouldn't lie to us... hopefully.
        slice(argv, argc)
    }
    fn linux() => {
        // TODO: uhg, its not ok to allocate here! :slow
        //       if we're gonna be slow we might as well be super slow
        // can't use read_to_string because you can't seek the magic /proc things? 
        out: List(u8) = list(4096, page_allocator); // :Leak
        path :: "/proc/self/cmdline".sym().c_str();
        f := open_read(path).unwrap();
        loop {
            continue :: local_return;
            read_len := read(f, out.maybe_uninit.ptr.offset(out.len), out.maybe_uninit.len - out.len);
            if read_len.is_ok() {
                len := read_len.unwrap();
                out.len += len;
                if len != 0 {
                    continue();
                };
            }; // else i sure hope we're done... TODO: return error? unwrap it?
            
            close(f); // TODO: defer
            
            // if we're gonna be slow we might as well be super slow fixme fixme fixme
            args: List(CStr) = list(4096, page_allocator); // :Leak
            
            while => out.len != 0 {
                s: CStr = (ptr = out.maybe_uninit.ptr);
                args&.push(s);
                len := s.str().len() + 1;
                out.maybe_uninit.ptr = out.maybe_uninit.ptr.offset(len);
                out.len -= len;
            }; 
            
            return(args.items());
        }
    }
});

// TODO: add 'fn int_to_float' so i can return answer in seconds like other lang versions
fn timestamp() i64 = {
    NS_TO_MS :: 1000.mul(1000);
    CLOCK_REALTIME :: 0;
    time_spec: TimeSpec = (seconds = 0, nanoseconds = 0);
    clock_gettime(CLOCK_REALTIME, time_spec&);
    time_spec.seconds.mul(1000).add(time_spec.nanoseconds.div(NS_TO_MS))
}

// TODO: /proc/self/exe :Linux readlink

fn get_executable_path(a: Alloc) Str #target_os = (fn($os) => @match(os){
    fn macos() => {
        size := 0;
        // use this to check the length so we allocate the right amount. 
        _NSGetExecutablePath(u8.ptr_from_int(0), size&);
        buf := a.alloc(u8, size);
        _NSGetExecutablePath(buf.ptr, size&).unwrap();
        buf
    }
    fn linux() => {
        path :: "/proc/self/exe".sym().c_str();
        out: List(u8) = list(128, a);
        loop {
            len := or readlink(path, out.maybe_uninit) {
                // TODO: return error!!
                panic("error readlink /proc/self/exe I really hope you're using a broken emulator")
            };
            
            if len < out.maybe_uninit.len {
                out.len = len;
                return(out.items());
            } else {
                out&.reserve(out.maybe_uninit.len);
                // continue();
            }
        }
    }
});

fn get_working_directory(a: Alloc) List(u8) = {
    out: List(u8) = list(512, a);
    s := getcwd(out.maybe_uninit).unwrap(); // TODO: return error?
    out.len = s.slow_len();
    out
}

// This asks the current operating system whats up. 
// If you run this at comptime, you get the arch you're compiling on! which might not be the target since we support cross compiling!
fn query_current_arch() ?Arch #target_os = (fn($os) => {
    data := LibcType(os).Utsname.zeroed();
    data&.uname().or(=> return(.None));
    machine: CStr = (ptr = data.machine&.as_ptr());
    machine.uname_machine_to_arch()
});

// surely we don't need to call uname... right... right...?
fn query_current_os() Os #target_os = (fn($os) => os);

fn uname_machine_to_arch(machine: CStr) ?Arch = {
    machine := machine.str();
    if(machine == "x86_64", => return(Some = .x86_64));
    if(machine == "arm64", => return(Some = .aarch64));
    .None
}
