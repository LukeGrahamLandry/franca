
// TODO: these are for musl. do other libcs use different lengths?
Utsname    :: @struct(
    sysname: Array(u8, 65),
    nodename: Array(u8, 65),
    release: Array(u8, 65),
    version: Array(u8, 65),
    machine: Array(u8, 65),
    __domainname: Array(u8, 65),
);
DirEnt :: @struct(
    d_ino: u64, 
    d_seekoff: u64, 
    d_reclen: u16, 
    d_type: DirEntType, 
    d_name: Array(u8, 256),
);
MapFlag :: @enum(i64) (Private = 2, Anonymous = 32, Jit = 0);
OpenFlag :: @enum(i64) (Read = 0, Write = 1, ReadWrite = 2, Create = 64, Truncate = 512, Append = 1024);
AT_FDCWD :: @as(Fd) (fd = -100);

MAP :: @struct {
    ANON    :: 32;
    JIT     :: 0;  // linux allows W+X memory so this is a no-op
};

O_arm :: @struct {
    CREAT     :: 0x0000040;
    EXCL      :: 0x0000080;
    NOCTTY    :: 0x0000100;  
    TRUNC     :: 0x0000200;
    APPEND    :: 0x0000400;
    DIRECTORY :: 0x0040000;
    NOFOLLOW  :: 0x0080000;
    CLOEXEC   :: 0x0800000; 
};

O_amd :: @struct {
    CREAT     :: 0x0000040;
    EXCL      :: 0x0000080;
    NOCTTY    :: 0x0000100;  
    TRUNC     :: 0x0000200;
    APPEND    :: 0x0000400;
    DIRECTORY :: 0x0010000;
    NOFOLLOW  :: 0x0020000;
    CLOEXEC   :: 0x0080000; 
};

// TODO: it would be more sane to mark this #libc but (compile bug)            HACK
//       i redeclare the symbol in the ir for aot with get_smuggled_libc_function if it doesn't match the target.  -- Sep 17
fn uname(buf: *Utsname) voidResult #redirect(*MacosLibc.Utsname, voidResult);

Stat :: @struct {
    st_dev: i64;
    st_ino: i64;
    st_nlink: i64;
    st_mode: u32;
    st_uid: u32;
    st_gid: u32;
    __: u32;
    st_rdev: i64;
    st_size: i64;
    st_blksize: i64;
    st_blocks: i64;
    st_atime: TimeSpec;
    st_mtime: TimeSpec;
    st_ctime: TimeSpec;
    _: Array(i64, 3);
};

StatArm64 :: @struct {
    st_dev: i64;
    st_ino: i64;
    st_mode: u32;
    st_nlink: u32;
    st_uid: u32;
    st_gid: u32;
    st_rdev: i64;
    __: i64;
    st_size: i64;
    st_blksize: u32;
    ___: u32;
    st_blocks: i64;
    st_atime: TimeSpec;
    st_mtime: TimeSpec;
    st_ctime: TimeSpec;
    _: Array(u32, 2);
};

fn fix(d: *Posix.Stat, s: *Stat) void = {
    d.st_dev = s.st_dev;
    d.st_mode = s.st_mode;  // TODO
    d.st_nlink = s.st_nlink;
    d.st_ino = s.st_ino;
    d.st_uid = s.st_uid;
    d.st_gid = s.st_gid;
    d.st_atime = s.st_atime;
    d.st_mtime = s.st_mtime;
    d.st_mtime = s.st_mtime;
    d.st_ctime = s.st_ctime;
    d.st_size = s.st_size;
    d.st_blocks = s.st_blocks;
    d.st_blksize = s.st_blksize;
}

fn fix(d: *Posix.Stat, s: *StatArm64) void = {
    d.st_dev = s.st_dev;
    d.st_mode = s.st_mode;  // TODO
    d.st_nlink = s.st_nlink.zext();
    d.st_ino = s.st_ino;
    d.st_uid = s.st_uid;
    d.st_gid = s.st_gid;
    d.st_atime = s.st_atime;
    d.st_mtime = s.st_mtime;
    d.st_mtime = s.st_mtime;
    d.st_ctime = s.st_ctime;
    d.st_size = s.st_size;
    d.st_blocks = s.st_blocks;
    d.st_blksize = s.st_blksize.zext();
}

Posix :: import("@/lib/sys/posix.fr");

fn slowly_get_cli_args_from_proc_self(alloc: Alloc) []CStr = { // :Leak
    // can't use read_to_string because you can't seek the magic /proc things? 
    out: List(u8) = list(4096, alloc); // :Leak
    path :: @as(CStr) "/proc/self/cmdline";
    f := open_read(path).unwrap();
    loop {
        continue :: local_return;
        read_len := read(f, out.maybe_uninit.ptr.offset(out.len), out.maybe_uninit.len - out.len);
        if read_len.is_ok() {
            len := read_len.unwrap();
            out.len += len;
            if len != 0 {
                continue();
            };
        }; // else i sure hope we're done... TODO: return error? unwrap it?
        
        close(f); // TODO: defer
        
        // if we're gonna be slow we might as well be super :slow fixme fixme fixme
        args: List(CStr) = list(4096, alloc); // :Leak
        
        while => out.len != 0 {
            s: CStr = (ptr = out.maybe_uninit.ptr);
            args&.push(s);
            len := s.str().len() + 1;
            out.maybe_uninit.ptr = out.maybe_uninit.ptr.offset(len);
            out.len -= len;
        }; 
        
        return(args.items());
    }
}

get_executable_path :: fn(a: Alloc) Str = {
    path :: @as(CStr) "/proc/self/exe";
    out: List(u8) = list(128, a);
    if !read_link(path, out&) {
        // TODO: return error!!
        panic("error readlink /proc/self/exe I really hope you're using a broken emulator")
    };
    return(out.items());
};

sys_clone :: fn(stack: []u8, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr, child_tid: *u32) i32 = {
    // beware! clone returns twice: once in the original thread and once in a newly created thread. 
    // the child thread's sp points at (the end of) the new stack, so you can't RET after SYSCALL (ret does a pop on amd). 
    // it as a custom wrapper so it doesn't have to worry about a race from the compiler trying to access a spilled 
    // value in the child by offsetting from the FP that's shared with the parent (kernel sets sp, but not fp, 
    // and the value wouldn't be on the new stack anyway). 
    // and the callee must terminate the thread when it's done.
    
    // CLONE_PTRACE is 0x2000 and i feel like i want it? but blink doesn't like it. 
    clone_flags :: 0x81250F00; // CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_THREAD | CLONE_VM | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID
    tid := perform_clone(clone_flags, stack.ptr.offset(stack.len), child_tid, callee, userdata);
    @assert_gt(tid, 0, "failed to clone thread");  // TODO: error handling
    tid
};

perform_clone :: AsmFunction(fn(clone_flags: i64, sp: *u8, tid_futex: *u32, callee: @FnPtr(it: rawptr) void, it: rawptr) i32 = (), {
    #use("@/backend/arm64/bits.fr");
    @const_slice(
        mov(.X64, x10, x3),  // save callee for later
        mov(.X64, x11, x4),  // ^
        
        // (flags, sp, parent_tid: *i32, tls: rawptr, child_tid: *i32)
        mov(.X64, x4, x2),   // tid_futex
        movz(.X64, x2, 0, .Left0),
        movz(.X64, x3, 0, .Left0),
        movz(.X64, x8, 220, .Left0),  // syscall number
        
        svc,
        cbnz(.X64, 5, x0),
        mov(.X64, x0, x11),
        movz(.X64, fp, 0, .Left0),  // don't try to trace_prev into the other thread's stack
        movz(.X64, lr, 0, .Left0),
        br(x10, 0b0),
        
        ret(),
    )
}, fn(out: *List(u8)) => { 
    // TODO: I'd rather do clone3 but blink doesn't implement it. 
    //       could do just do clone on amd and clone3 on arm but maybe consistancy is better. idk. 
    #use("@/backend/amd64/bits.fr");
    // RDI, RSI, RDX, RCX, R8
    //                R10
    @asm_x64(
        // save callee for later
        encode_op_reg(PrimaryOp.PushBase, X86Reg.r12),  // only need to restore on the parent
        encode_bin(PrimaryOp.MovReg, X86Reg.r9, X86Reg.rcx),
        encode_bin(PrimaryOp.MovReg, X86Reg.r12, X86Reg.r8),
        
        // (flags, sp, parent_tid: *i32, child_tid: *i32, tls: rawptr)
        encode_bin(PrimaryOp.MovReg, X86Reg.r10, X86Reg.rdx),  // tid_futex
        encode_imm(X86Reg.rdx, 0),
        encode_imm(X86Reg.r8, 0),
        encode_imm(X86Reg.rax, 56),  // syscall number
        
        0x0F, 0x05,  // syscall
        encode_cmp_imm32(X86Reg.rax, 0),
        encode_jmp(X86cc.ne, 13), // :DontShrinkInstructions
        encode_bin(PrimaryOp.MovReg, X86Reg.rdi, X86Reg.r12),  // 3
        encode_imm(X86Reg.rbp, 0),  // 7. don't try to trace_prev into the other thread's stack
        encode_jmp_reg(ModrmMode.Direct, X86Reg.r9), // 3
        
        encode_op_reg(PrimaryOp.PopBase, X86Reg.r12),  // restore
        PrimaryOp.Ret
    ) out;
}, fn(out: *List(u8)) => out.push_all(@const_slice(0x00, 0x00, 0x0B)) /* 0 locals. unreachable. end */, {
        #use("@/backend/rv64/bits.fr");
        mov :: fn(dest: RvReg, src: RvReg) u32 = 
            I(0, src.bits(), @as(u3) OpI.add, dest.bits(), .op_imm);  // syscall number
        li :: fn(dest: RvReg, i: i64) u32 = 
            I(@as(i12) i, 0b00000, @as(u3) OpI.add, dest.bits(), .op_imm);
            
 
        @const_slice(
            mov(.T0, .A3),
            mov(.T1, .A4),
            
            // (flags, sp, parent_tid: *i32, tls: rawptr, child_tid: *i32)
            mov(.A4, .A2),   // tid_futex
            li(.A2, 0),
            li(.A3, 0),
            li(.A7, 220),  // syscall number
            
            ecall,
            B(20, RvReg.Zero.bits(), RvReg.A0.bits(), @as(u3) Bcmp.bne, .bcmp),
            mov(.A0, .T1),
            li(.FP, 0),  // don't try to trace_prev into the other thread's stack
            li(.RA, 0), 
            jalr(.T0, 0, .Zero),
            
            jalr(.RA, 0, .Zero),
        )
    });

LandLock :: @struct {
    // TODO: have a nice BitFlags type like @bit_fields (then remove #flags below. it doesn't do anything)
    Fs :: @enum(i64) (
        Execute, WriteFile, 
        ReadFile, ReadDir, RemoveDir, RemoveFile, 
        MakeChar, MakeDir, MakeReg, MakeSock, MakeFifo, MakeBlock, MakeSym, 
        Refer, Truncate, IoctlDev,
    );
    Net   :: @enum(i64) (BindTcp, ConnectTcp);
    Scope :: @enum(i64) (AbstractUnixSocket, Signal);
    
    Create   :: @enum(u32) (Version, Errata);
    Restrict :: @enum(u32) (LogSameExecOff, LogSameExecOn, LogSubdomainsOff);

    // TODO: have a way for an @tagged so change it's calling convention to splat the tag out as a seperate argument
    PathBeneathAttr :: @struct(flags: i64 #flags(Fs), parent: Fd);
    NetPortAttr     :: @struct(flags: i64 #flags(Net), port: u64); 
    RuleAttr :: @union(path_beneath: PathBeneathAttr, net_port: NetPortAttr);
    RuleType :: @enum(u32) (PathBeneath = 1, NetPort = 2);
    
    RuleSetAttr :: @struct {
        handled_access_fs: i64 #flags(Fs);
        handled_access_net: i64 #flags(Net);
        scope: i64 #flags(Scope);
    };
    
    create_ruleset :: fn(attr: *RulesetAttr, size: i64, flags: u32 #flags(Create)) FdResult #syscall(444, 444, _);
    add_rule       :: fn(ruleset: Fd, rule_type: RuleType, rule_attr: *RuleAttr, flags: u32) voidResult #syscall(445, 445, _);
    restrict_self  :: fn(ruleset: Fd, flags: u32 #flags(Restrict)) voidResult #syscall(446, 446, _);
};

//
// Structs for signal handlers
//

SIG :: @struct {
     BUS :: 7;
    USR1 :: 10;
    USR2 :: 12;
     SYS :: 31;
};

SA :: @struct {
      ONSTACK :: 0x08000000;
      RESTART :: 0x10000000;
    RESETHAND :: 0x80000000;
    NOCLDSTOP :: 1;
      NODEFER :: 0x40000000;
    NOCLDWAIT :: 2;
      SIGINFO :: 4;
    
     RESTORER :: 0x04000000;
};

SigInfo :: @struct {
    si_signo: i32;
    si_errno: i32;
    si_code: i32;
    _: i32 = 0;
    // TODO: actually expose the information but it's in crazy union town so starting slow
    // clang says (sizeof(siginfo_t) == 128) on amd64 and arm64
    payload: Array(rawptr, 14);
};

KSigAction :: @struct {
    sa_handler: rawptr;
    sa_flags: i64;
    sa_restorer: rawptr;
    sa_mask: i64;
};

CSigAction :: @struct {
    sa_handler: rawptr;
    sa_mask: Array(i64, 16);
    sa_flags: i64;
    sa_restorer: rawptr;
};

stack_t :: @struct {
    sp: rawptr;
    flags: i64;
    size: i64;
};

UContextArm64 :: @rec @struct {
    flags: i64;
    link: *UContextArm64;
    stack: stack_t;
    sigmask: Array(i64, 16);
    mcontext: MContextArm64;
};

MContextArm64 :: @struct {
    addr: rawptr;
    gpr: Array(rawptr, 32);
    pc: rawptr;
    pstate: rawptr;
    fpr: Array(i64, 512) #align(16);
};

UContextAmd64 :: @rec @struct {
    flags: i64;
    link: *UContextAmd64;
    stack: stack_t;
    mcontext: MContextAmd64;
    sigmask: Array(i64, 16);
    fpregs_mem: Array(i64, 64);
};

MContextAmd64 :: @struct {
    gpr: Array(rawptr, 23);
    fpr: rawptr; // pointer to some struct i don't want to deal with yet
    _: Array(i64, 8);
};

UContextRiscv64 :: @rec @struct {
    flags: i64;
    link: *UContextRiscv64;
    stack: stack_t;
    sigmask: Array(i64, 16);
    mcontext: MContextRiscv64;
};

MContextRiscv64 :: @struct {
    gpr: Array(rawptr, 32);  // [0]=pc
    // note: the #align doesn't change layout of this struct 
    //       but makes it have align 16 which changes layout of ucontext
    fpr: Array(u8, 33*16) #align(16);
};

// 
// I looked at Zig's (lib/std/os/(linux.zig, linux/(x86_64.zig, aarch64.zig)) for 
// these flag numbers and struct layouts, so I feel I should include this string: 
// [The MIT License (Expat) Copyright (c) Zig contributors 
// https://github.com/ziglang/zig/commit/31bc6d5a9ddaf09511d8e5dc6017957adec0564b]. 
// But surely the linux kernel owns them, so idk what the rules are. 
// Zig doesn't say it's GPL-ed and I'm sure they know more about this than I do so it's probably fine. 
// 
