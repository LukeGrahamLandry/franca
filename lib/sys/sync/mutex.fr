// TODO: im not super convinced this works
// TODO: document re-entrancy

DEBUG_MY_MUTEX_BY_USING_PTHREAD :: false;

// :ThreadIdStartsAtOne so zero init is a correct starting state for this struct and doesn't confuse try_lock. 
Mutex :: @struct(
    u: @union(
        state: MutexState,
        pthread_debug: *PMutex,
    ),
    count:  u32,
    thread: u32,
);
MutexState :: @enum(u32) (unlocked, locked, waiting);

fn lock(self: *Mutex) void = {
    @if(!use_threads) return();
    @if(DEBUG_MY_MUTEX_BY_USING_PTHREAD) return(self.debug_lock());
    
    if !self.try_lock() {
        // Always update the value to .waiting so someone will wake us up when they unlock it. 
        while => MutexState.atomic_set(self.u.state&, .waiting) != .unlocked {
            self.wait();
        };
        my_thread: u32 = context(DefaultContext)[].thread_index.trunc();
        prev_thread := u32.atomic_set(self.thread&, my_thread);
        prev_count  := u32.atomic_set(self.count&, 1);
        @debug_assert(prev_thread == 0 && prev_count == 0, "memory ordering problem?");
    };
}

fn debug_lock(self: *Mutex) void = {
    my_thread: u32 = context(DefaultContext)[].thread_index.trunc();
    if self.thread != my_thread {
        ::ptr_utils(PMutex);
        if self.u.pthread_debug.is_null() {
            self.u.pthread_debug = general_allocator().box(PMutex);
            pthread_mutex_init(self.u.pthread_debug, 0).unwrap();
        };
        self.u.pthread_debug.lock();
        u32.atomic_set(self.thread&, my_thread);
    };
    self.count += 1;
}

fn try_lock(self: *Mutex) bool = {
    ::assert(!DEBUG_MY_MUTEX_BY_USING_PTHREAD, "TODO: DEBUG_MY_MUTEX_BY_USING_PTHREAD");
    @if(!use_threads) return(true);
    my_thread: u32 = context(DefaultContext)[].thread_index.trunc();
    
    // self.thread == my_thread 
    if u32.cas(self.thread&, my_thread, my_thread) == my_thread {  // TODO: this can't be what you're supposed to do? but it sure seems to help
        @debug_assert_ne(self.count, MAX_u32, "overflow mutex lock count"); 
        u32.atomic_add(self.count&, 1);
        return(true);
    };
    
    if MutexState.cas(self.u.state&, .unlocked, .locked) == .unlocked {
        @debug_assert_ne(my_thread, 0, ":ThreadIdStartsAtOne uninit dynamic context?");
        prev_thread := u32.atomic_set(self.thread&, my_thread);
        @debug_assert_eq(prev_thread, 0);
        u32.atomic_set(self.count&, 1);
        return(true);
    };
    false
}

fn unlock(self: *Mutex) void = {
    @if(!use_threads) return();
    my_thread: u32 = context(DefaultContext)[].thread_index.trunc();
    @debug_assert_eq(self.thread, my_thread, "tried to unlock someone else's mutex");
    @debug_assert_ne(self.count, 0, "tried to unlock an already unlocked mutex");
    ::enum(MutexState);
    u32.atomic_add(self.count&, MAX_u32);  // -1
    if self.count == 0 {
        u32.atomic_set(self.thread&, 0); // no thread has id 0
        
        @if(DEBUG_MY_MUTEX_BY_USING_PTHREAD) {
            self.u.pthread_debug.unlock();
            return();
        };

        prev := MutexState.atomic_set(self.u.state&, .unlocked);
        @match(prev) {
            fn locked()   => ();  // We're the only interested thread so we're done. 
            fn waiting()  => self.wake();  // There's another thread in the lock() loop. Tell it to try again. 
            fn unlocked() => panic("unlocked a mutex that was already unlocked");
        };
    };
}

Futex :: import("@/lib/sys/sync/futex.fr");

fn wake(self: *Mutex) void = 
    Futex'wake(self.u.state&.raw(), 1);
    
fn wait(self: *Mutex) void = 
    Futex'wait(self.u.state&.raw(), MutexState.waiting.raw());

fn with(self: *Mutex, $body: @Fn() void) void = {
    self.lock();
    body();
    self.unlock();  // TODO: defer
}

PMutex :: @struct(sig: i64, opaque: Array(u8, 56));

fn pthread_mutex_init(mutex: *PMutex, todo_attr_pass_zero_for_now: i64) voidResult #libc;
fn pthread_mutex_unlock(m: *PMutex) voidResult #libc;
fn pthread_mutex_lock(m: *PMutex) voidResult #libc;
fn pthread_mutex_destroy(m: *PMutex) voidResult #libc;

fn lock(self: *PMutex) void = {
    @if(!use_threads) return();
    pthread_mutex_lock(self).unwrap();
}

fn unlock(self: *PMutex) void = {
    @if(!use_threads) return();
    pthread_mutex_unlock(self).unwrap();
}

fn with(self: *PMutex, $body: @Fn() void) void = {
    self.lock();
    body();
    self.unlock();  // TODO: defer
}
