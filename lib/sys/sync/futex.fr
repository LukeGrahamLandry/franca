/// This is the core operating system primitive we use to implement mutex/cond/etc. 
/// The general usage pattern is you start with a cas so you stay in user-space when 
/// there's low contention. If the cas fails you know the current value and pass that to wait(). 
/// 

/// wake up `count` threads who are wait()-ing on `addr` 
wake :: fn(addr: *u32, count: u32) void = {
@if(SLOW_USERSPACE_THREADS) return(import("@/lib/sys/sync/green.fr")'wake(addr, count));
if query_current_arch() == .wasm32 {
    _ := wasm_atomic_notify(addr, count);
    return();
};
@match(query_current_os()) {
    fn macos() => {
        op := Syscall'ULockFlags.zeroed();
        op&.set(.op, 1); // UL_COMPARE_AND_WAIT
        op&.set(.no_errno, 1);
        
        ::enum(MacosLibc.ErrNo);
        result := Syscall'ulock_wake(op, addr, count);
        @assert(result != -MacosLibc.ErrNo.EINTR.raw(), "TODO: do i need a loop here? do THREAD_INTERRUPTED/THREAD_RESTART actually happen?"); 
    }
    fn linux() => {
        FUTEX_WAKE :: 1;
        // TODO: set the PRIVATE flag or whatever
        _ := Syscall'sys_futex(addr, FUTEX_WAKE, count, TimeSpec.ptr_from_int(0));
    }
    @default => unreachable();
};
};

/// If addr==expect, sleep the thread until wake() is called on the same addr. 
wait :: fn(addr: *u32, expect: u32) void = {
@if(SLOW_USERSPACE_THREADS) return(import("@/lib/sys/sync/green.fr")'wait(addr, expect));
if query_current_arch() == .wasm32 {
    _ := wasm_atomic_wait(addr, expect, -1);
    return();
};
@match(query_current_os()) {
    // Return values just tell you stuff about timeouts and spurious wake ups 
    // which we don't care about since we're calling it in a loop. 
    fn macos() => {
        op := Syscall'ULockFlags.zeroed();
        op&.set(.op, 1); // UL_COMPARE_AND_WAIT
        _ := Syscall'ulock_wait(op, addr, expect, 0);
    }
    fn linux() => {
        FUTEX_WAIT :: 0;
        // TODO: set the PRIVATE flag or whatever
        _ := Syscall'sys_futex(addr, FUTEX_WAIT, expect, TimeSpec.ptr_from_int(0));
    }
    @default => unreachable();
};
};

// returns the number that were woken
wasm_atomic_notify :: AsmFunctionWasmOnly(fn(addr: *u32, count: u32) i32 = (), fn(out) = {
    out.push(0x00);  // 0 locals
    out.push(0x20);  // local.get(0)
    out.push(0x00);  // ^
    out.push(0xA7);  // truncl (my pointers are 64 bit)
    out.push(0x20);  // local.get(1)
    out.push(0x01);  // ^
    out.push(0xFE);  // atomic.notify
    out.push(0x00);  // ^
    out.push(0x02);  // ^ align
    out.push(0x00);  // ^ off
    out.push(0x0B);  // end
});

WasmWaitResult :: @enum(u32) (Ok = 0, NotEqual = 1, TimedOut = 2);
// negative timeout means forever
wasm_atomic_wait :: AsmFunctionWasmOnly(fn(addr: *u32, expect: u32, timeout_nanoseconds: i64) WasmWaitResult = (), fn(out) = {
    out.push(0x00);  // 0 locals
    out.push(0x20);  // local.get(0)
    out.push(0x00);  // ^
    out.push(0xA7);  // truncl (my pointers are 64 bit)
    out.push(0x20);  // local.get(1)
    out.push(0x01);  // ^
    out.push(0x20);  // local.get(2)
    out.push(0x02);  // ^
    out.push(0xFE);  // atomic.wait(32)
    out.push(0x01);  // ^
    out.push(0x02);  // ^ align
    out.push(0x00);  // ^ off
    out.push(0x0B);  // end
});
