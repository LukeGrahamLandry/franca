
// TODO: i think this is an ioctl
Terminos :: @struct(iflag: u64, oflag: u64, cflag: u64, lflag: u64, cc: Array(u8, 20), ispeed: u64, ospeed: u64);
fn tcgetattr(fd: Fd, out: *Terminos) void #weak #libc;
fn tcsetattr(fd: Fd, optional_actions: i64, in: *Terminos) void #weak #libc;
// TODO: :Linux
TermConstants :: @struct(_parsehack: void, $ICANON := 256, $ECHO := 8, $VMIN := 16, $VTIME := 17, $ TCSANOW := 0, $TCSADRAIN := 1);

/// Magic escape sequences you can print. 
/// https://en.wikipedia.org/wiki/ANSI_escape_code
start_other  :: "\x1B[?1049h";
end_other    :: "\x1B[?1049l";
reset        :: "\x1B[2J";
unset_colour :: "\x1B[0m";
set_colour   :: "\x1B[38;2;%;%;%m";  // @fmt(_, _, r, g, b) 0-255
set_cursor   :: "\x1B[%;%H";  // @fmt(_, _, line, col) 

// :sigint TODO:
// this should set ISIG to something sane? or maybe a wrapper for read that 
// gives to a @tagged so you can handle it correctly (restore terminal state). 
// you want ctrl+c to quit the program, and that's what it defaults to, 
// but if i run my os in qemu and make it hang and have to force quit it,
// it leaks the not sending sigint so you get it as the byte 3. 
// but you can't tell that situation apart from if the caller set it up that way on purpose. 
// you don't want to just crash because the caller should get a chance to do cleanup stuff. 
// its a pain in the ass for everyone to need to do the hassle of a signal handler, 
// pressing a key isn't exactly an exceptional situation. 

// Get input on keypress immediately (instead of waiting for a whole line until <ENTER>).
start_raw :: fn(fd: Fd, blocking: bool) Terminos = {
    t :: TermConstants;
    term := Terminos.zeroed();
    tcgetattr(fd, term&);
    old := term;
    term.lflag = term.lflag.bit_and(t.ICANON.bit_or(t.ECHO).bit_not()); // dont read in lines | dont show what you're typing
    if blocking {
        // block until theres a byte to read. infinite timeout. 
        term.cc&[t.VMIN] = 1;
        term.cc&[t.VTIME] = 0;
    } else {
        // its ok for a read to return nothing so dont wait at all
        term.cc&[t.VMIN] = 0; 
        term.cc&[t.VTIME] = 0;
    }
    tcsetattr(fd, t.TCSANOW, term&);
    old
};

// term = the return value of start_raw
fn restore(fd: Fd, term: *Terminos) void = {
    t :: TermConstants;
    tcsetattr(fd, t.TCSANOW, term);
}

// TODO: improve this (support arrow keys)
// TODO: if the input spans multiple lines (just by being long) clear those as well. 
// TODO: optional timeout, return error
interactive_read_line :: fn(text: *List(u8)) void = {
    saved_term := start_raw(STD_IN, true);
    prompt := ">>> ";

    render_buffer: List(u8) = list(64, temp());
    loop {
        continue :: local_return;
        
        @fmt(render_buffer&, "\r");  // take it back now yall
        render_buffer&.push_all(prompt);
        render_buffer&.push_all(text.items());
        print(render_buffer.items());
        render_buffer&.clear();
        
        c: u8 = 0;
        len := Syscall'read(STD_IN, c&, 1).unwrap();
        if(len.eq(1)){
            @switch(c) {
                @case(127) => {  // backspace
                    if text.len > 0 {
                        // since we're printing a shorter string, the terminal will stay showing the last character. 
                        // so write over spaces so we don't show the old thing. 
                        // there's gotta be some ansi escaped thing for clearing a line but i don't care right now. 
                        @fmt(render_buffer&, "\r");
                        range(0, text.len + prompt.len) { _ |
                            render_buffer&.push_all(" ");
                        };
                        print(render_buffer.items());
                        render_buffer&.clear();
                        
                        // now remove a character. 
                        text.len -= 1;
                    };
                };
                @case(27) => {
                    // :TodoShareAnsiSkipLogic
                    // TODO: are some longer or shorter? (yes!)
                    c: u8 = 0;
                    dowhile {
                        Syscall'read(STD_IN, c&, 1).unwrap() == 0
                    }; // skip
                    dowhile {
                        Syscall'read(STD_IN, c&, 1).unwrap() == 0
                    };
                    // TODO: history for when you press the up arrow. 
                    // TODO: move the cursor around when you press left and right. 
                    @switch(c) {
                        @case("A".ascii()) => {
                            
                        };
                        @case("B".ascii()) => {
                            
                        };
                        @case("C".ascii()) => {
                            
                        };
                        @case("D".ascii()) => {
                            
                        };
                        @default => ();
                    };
                };
                @case(3) => panic("^c");  // :sigint
                @case(10) => {
                    // Pressed enter. 
                    restore(STD_IN, saved_term&);
                    return();
                };
                @default => text.push(c);
            };
        };
    };
};