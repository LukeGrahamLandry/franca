
Thread :: @struct {
    first_environment: StaticTls;  // must be the first field
    
    // These are only used when starting the thread. 
    userdata: rawptr;
    callee: @FnPtr(userdata: rawptr) void;
    
    // handles for joining the thread
    opaque: pthread_t;  // when using libc
    tid_futex: u32;  // when linux-syscalls
    tid: i32;
    
    stack_reserved_size: i64;
    stack: AlignedStack;  // free-ed on join
    first_temporary_allocator: Arena.Allocator;  // free-ed on join
    
    // used when running on my os with my libc. avoids an extra allocation for pthread_t
    // TODO: use it for green.fr as well
    runtime_data: Array(i64, 5);  
};

// size_of(Thread) is the same on macos and glibc.
// the others are always done by reference so just have to be the larger of the two sizes. 
pthread_t :: @struct(opaque: rawptr);
ThreadAttr :: @struct(sig: i64, opaque: Array(u8, 56));

// TODO: should i do reusing of stacks here?
// TODO: should provide something for setting up guard pages to catch stack overflows. 

fn start_thread_nodata(callee: @FnPtr() void) *Thread = {
    start_thread(
        @as(@FnPtr(userdata: rawptr) void) (fn(userdata: rawptr) void = { bit_cast_unchecked(rawptr, @FnPtr() void, userdata)(); }),
        bit_cast_unchecked(@FnPtr() void, rawptr, callee)
    )
}

fn start_thread_data($T: Type, userdata: *T, callee: @FnPtr(userdata: *T) void) *Thread #generic = 
    start_thread(T, callee, userdata);

// stack gets free-ed into the page_allocator on join
fn start_thread($T: Type, callee: @FnPtr(userdata: *T) void, userdata: *T) *Thread #generic = {
    callee := ptr_cast_unchecked(@type callee, @FnPtr(rawptr) void, callee&)[]; // TODO: make this less painful
    start_thread(callee, T.raw_from_ptr(userdata))
}

fn start_thread(callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) *Thread #noinline = {
    stack := allocate_stack(prefer_syscalls(), query_current_os());
    thread := init_thread_data(stack, callee, userdata);
    raw_create_thread(thread);
    thread
}

// this uses the first page of `stack` for the dynamic context. 
fn init_thread_data(stack: AlignedStack, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) *Thread = {
    macos_page_size :: 16384;  // TODO: don't assume this is the highest possible page size

    thread := bit_cast_unchecked(*u8, *Thread, stack.usable.ptr);
    @debug_assert_ult(size_of(Thread), macos_page_size);
    // TODO: put it at the end and offset forward to give the thread less memory so the stack grows left away from the context. instead of left towards the context. 
    c := thread.first_environment&;
    c[] = get_current_thread()[].first_environment;
    set_new_thread_id(c);
    
    thread.userdata = userdata;
    thread.callee = callee;
    thread.tid_futex = MAX_u32;
    thread.stack = stack;
    thread.first_temporary_allocator = init(page_allocator, 1.shift_left(20));
    c.temporary_allocator = thread.first_temporary_allocator&;
    c.temporary_allocator_i = c.temporary_allocator.borrow();
    thread.stack_reserved_size = macos_page_size;
    c.thread = Thread.raw_from_ptr(thread);
    thread
}

/// This assumes you've already done stuff to setup the context (and that the callee knows how to cope with that)
fn raw_create_thread(t: *Thread) void = {
    @if(SLOW_USERSPACE_THREADS) return(import("@/lib/sys/sync/green.fr")'raw_create_thread(t));
    
    callee :: franca_runtime_init_thread;
    stack := t.stack.usable.rest(t.stack_reserved_size);
    @assert_eq(u8.int_from_ptr(stack.ptr).mod(16), 0, "start_thread unaligned stack");  // TODO: return error
    userdata := Thread.raw_from_ptr(t);
    
    use_pthread :: fn(stack: []u8, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) pthread_t = {
        // TODO: check PTHREAD_STACK_MIN
        attr := @uninitialized ThreadAttr;
        out := pthread_t.zeroed();
        pthread_attr_init(attr&).unwrap();
        pthread_attr_setstack(attr&, stack.ptr, stack.len).unwrap(); 
        ok := pthread_create(out&, attr&, callee, userdata);
        assert(ok.is_ok(), "failed to create thread");
        out
    };
    
    // I don't care enough to figure out how to use bsdthread_create right now. 
    // There's something with pointer authentication in the sig field. idk man.
    // https://github.com/apple/darwin-libpthread/blob/main/src/pthread.c
    // https://github.com/apple/darwin-libpthread/blob/main/src/types_internal.h#L348 
    fence();
    if prefer_pthread() {
        t.opaque = use_pthread(stack, callee, userdata);
        @debug_assert(!t.opaque.opaque.is_null(), "failed to spawn thread");  // TODO: error handling
    } else {
        t.tid = LinuxLibc'sys_clone(stack, callee, userdata, t.tid_futex&);
    };
    fence();
}

fn prefer_pthread() bool = 
    !prefer_syscalls() || query_current_os() != .linux;

franca_runtime_init_thread :: fn(franca_userdata: rawptr) void = {
    thread := Thread.ptr_from_raw(franca_userdata);
    fence();
    set_legacy_dynamic_environment(franca_userdata);
    thread'callee(thread.userdata);
    @if(SLOW_USERSPACE_THREADS) import("@/lib/sys/sync/green.fr")'end_current_task();
    // not freeing the stack here, the sane thing is to free it on the joining side (since on amd64 you return by popping something off it). 
    if !prefer_pthread() {
        Syscall'exit_thread(0);
    };
};

fn join(t: *Thread) void = {
    @if(SLOW_USERSPACE_THREADS) return(import("@/lib/sys/sync/green.fr")'join(t));
    
    if prefer_pthread() {
        result := rawptr.zeroed();
        pthread_join(t.opaque, result&);
    } else {
        @debug_assert(query_current_os() == .linux);
        sys_join(t);
    };
    
    // TODO: reuse these
    t.first_temporary_allocator&.deinit();
    page_allocator.dealloc(u8, t.stack.padded);
}

fn sys_join(t: *Thread) void = {
    fence();
    value := t.tid_futex;
    tid: u32 = t.tid.bitcast();
    @debug_assert(tid != 0 && tid != MAX_u32);
    //          exited         running         not started
    @assert(value == 0 || value == tid || value == MAX_u32);
    // the kernel will zero this address because of CLONE_CHILD_CLEARTID
    while => value != 0 {
        Futex :: import("@/lib/sys/sync/futex.fr");
        Futex'wait(t.tid_futex&, value);
        value = t.tid_futex;
    };
}

fn get_current_thread() *Thread = {
    a := 0;
    base := i64.int_from_ptr(a&).bit_and(bit_not(1.shift_left(franca_required_stack_bits) - 1));
    Thread.ptr_from_int(base)
}

// TODO: guard page between the stack and tls. (careful to move it when allocate_signal_stack in examples/os)
AlignedStack :: @struct(padded: []u8, usable: []u8);
allocate_stack :: fn(prefer_sys: bool, os: Os) AlignedStack = {
    ::Syscall;
    RW := bit_or(@as(i64) MapProt.Read, @as(i64) MapProt.Write);
    NONE := 0;
    
    padded_size := 1.shift_left(franca_required_stack_bits + 1);
    flags := bit_or(0b00010, @if(os == .macos, 4096, 32));
    xxx := @as(Fd)(fd = -1);
    padded := @syscall(Syscall.mmap, prefer_sys, os, 
        zeroed(rawptr), padded_size, NONE, flags, xxx, 0);
    @assert(padded != 0, "failed to allocate stack");
    padded := u8.ptr_from_int(padded).slice(padded_size);
    
    base := u8.int_from_ptr(padded.ptr);
    a := base.bit_and(bit_not(1.shift_left(franca_required_stack_bits) - 1));
    b := a + 1.shift_left(franca_required_stack_bits);
    start := @if(a > base, a, b);
    usable := padded.subslice(start - base, 1.shift_left(franca_required_stack_bits));
    
    res := @syscall(Syscall.mprotect, prefer_sys, os, 
        u8.raw_from_ptr(usable.ptr), usable.len, RW);
    @assert(res.is_ok(), "failed to unprotect stack"); 
    
    (padded = padded, usable = usable)
};

// TODO: the NOSYS is a HACK to make -syscalls make a real static binary
fn pthread_attr_init(out: *ThreadAttr) voidResult #weak #libc #syscall(NOSYS, NOSYS, NOSYS);
fn pthread_create(out: *pthread_t, attr: *ThreadAttr, callee: @FnPtr(userdata: rawptr) void, userdata: rawptr) voidResult #weak #libc #syscall(NOSYS, NOSYS, NOSYS);
fn pthread_attr_setstack(attr: *ThreadAttr, ptr: *u8, len: i64) voidResult #weak #libc #syscall(NOSYS, NOSYS, NOSYS);
fn pthread_getcpuclockid(thread: pthread_t, clock_id_out: *i32) voidResult #weak #libc;
fn pthread_join(thread: pthread_t, value_ptr: *rawptr) voidResult #weak #libc;

#use("@/lib/sys/sync/atomics.fr");
