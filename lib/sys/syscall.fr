
read :: @S("read") fn(fd: Fd, buf: *u8, size: i64) i64Result #weak #libc #syscall(63, 0, 3);
write :: @S("write") fn(fd: Fd, buf: *u8, size: i64) i64Result #weak #libc #syscall(64, 1, 4);
close :: @S("close") fn(fd: Fd) voidResult #libc #syscall(57, 3, 6);
lseek :: @S("lseek") fn(fd: Fd, offset: i64, whence: Whence) i64Result #libc #syscall(62, 8, 199);
remove :: fn(filepath: CStr) voidResult #libc;
// TODO: mode is a bit flag of AccessMode
access :: @S("access") fn(pathname: CStr, mode: i64) voidResult #libc #syscall(NOSYS, 21, 33); // TODO: bit flags
// TODO: on linux the syscall version might be prefixed by "(unreachable)" which should be an error or something
getcwd :: @S("getcwd") fn(ptr: *u8, len: i64) CStrResult #weak #libc #syscall(17, 79, NOSYS);
readlink :: @S("readlink") fn(pathname: CStr, ptr: *u8, len: i64) i64Result #libc #syscall(NOSYS, 89, 58); 
fchmod :: @S("fchmod") fn(fd: Fd, mode: FileMode) voidResult #libc #syscall(52, 91, 124);

mmap :: @S("mmap") fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 #libc #syscall(222, 9, 197);
munmap :: @S("munmap") fn(addr: rawptr, len: i64) voidResult #libc #syscall(215, 11, 73);
mprotect :: @S("mprotect") fn(addr: rawptr, len: i64, prot: i64) voidResult #libc #syscall(226, 10, 74);

// linux: exit_group, not exit. exit just ends the calling thread. 
exit :: @S("exit") fn(status: i64) Never #libc #syscall(94, 231, 1);

nanosleep :: @S("nanosleep") fn(duration: *TimeSpec, nullable_remainder_out: *TimeSpec) voidResult #libc #syscall(101, 35, NOSYS);

dup2 :: @S("dup2") fn(oldfd: Fd, newfd: Fd) voidResult #libc #syscall(NOSYS, 33, 90);
dup3 :: @S("dup3") fn(oldfd: Fd, newfd: Fd, flags: i32) voidResult #libc #syscall(24, 292, NOSYS);
chdir :: @S("chdir") fn(path: CStr) voidResult #weak #libc #syscall(49, 80, 12);

renameat :: @S("renameat") fn(old_dir: Fd, old: CStr, new_dir: Fd, new: CStr) voidResult #libc #syscall(38, 264, 465);
clock_gettime :: @S("clock_gettime") fn(clock_id: i64, time_spec: *TimeSpec) void #libc #syscall(113, 228, NOSYS); // TODO: macos syscall

// not #libc because that's variadic, which we can do but is a bit annoying
// TODO: maybe that's the wrong choice for apple
openat :: @S("openat") fn(dirfd: Fd, pathname: CStr, flags: i64, mode: i64) i32 #syscall(56, 257, 463);
opendir :: fn(path: CStr) i64 #weak #libc;
@"opendir$INODE64" :: fn(path: CStr) i64 #weak #libc;
readdir :: fn(dir: rawptr) i64 #libc;
@"readdir$INODE64" :: fn(dir: rawptr) i64 #weak #libc;
mkdirat :: @S("mkdirat") fn(parent: Fd, path: CStr, mode: i64) i64 #libc #syscall(34, 258, 475);

SysStat :: @union(l: Linux.Stat, m: Macos.Stat);
fstatat :: @S("fstatat") fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #syscall(79, 262, 470) #libc;
@"fstatat$INODE64" :: fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #weak #libc;

// https://github.com/apple/darwin-xnu/blob/main/bsd/kern/sys_ulock.c
ulock_wait :: @S("ulock_wait") fn(op: ULockFlags, addr: *u32, only_wait_if_value_is: u32, timeout_ns_zero_is_forever: u32) i32 #syscall(NOSYS, NOSYS, 515);
ulock_wake :: @S("ulock_wake") fn(op: ULockFlags, addr: *u32, how_many_to_wake: u32) i32 #syscall(NOSYS, NOSYS, 516);
ULockFlags :: @(import("@/lib/bit_fields.fr").bit_fields)(
    op         := 8,
    wake_flags := 8,
    wait_flags := 8,
    no_errno   := 1,
    _          := 7,
);

// https://www.man7.org/linux/man-pages/man2/futex.2.html
sys_futex :: @S("sys_futex") fn(addr: *u32, futex_op: u32, val: u32, timeout: *TimeSpec) i64 #syscall(98, 202, NOSYS);

exit_thread :: @S("exit_thread") fn(status: i64) Never #syscall(93, 60, NOSYS);
clone :: @S("clone") fn(flags: i64, stack: *u8, p: i64, c: i64, t: i64) pid_t #syscall(220, 56, NOSYS) = {
    // HACK: this needs a body so it gets a return label so it can be inlined because the new thread can't return on its fresh stack
};
clone3 :: @S("clone3") fn(arg: *Clone3, size: i64) pid_t #syscall(435, 435, NOSYS) = {
    // HACK: this needs a body so it gets a return label so it can be inlined because the new thread can't return on its fresh stack
};
Clone3 :: @struct {
    flags: i64;
    pidfd: *i32;
    child_tid: *pid_t;
    parent_tid: *pid_t;
    exit_signal: i64;
    stack: []u8;
    tls: i64;
    set_tid: []pid_t;
    cgroup: i64;
};

Macos :: import("@/lib/sys/macos.fr");
Linux :: import("@/lib/sys/linux.fr");

S :: fn(name: FatExpr, fid: FatExpr) FatExpr #macro = {
    name := const_eval(Str)(name);
    fid := const_eval(FuncId)(fid);
    func := get_function_ast(fid, true, true, true, false);
    func.name = name.sym();

    @if(IS_BOOTSTRAPPING) {
        func.body = .Empty; // undo clone hack on old compilers where the syscall shim will be small enough to inline on its own
        return(@literal fid);
    };
    
    // TODO: factor out and share with objective_c.fr/objc_method_import_body()
    pars := func.arg.bindings&.items();
    args := FatExpr.list(pars.len + 1, ast_alloc());
    args&.push(@literal fid);
    get :: fn(b: *Binding) FatExpr => (expr = (GetVar = b.name.Var), ty = b.ty.Finished, loc = func.loc, done = false);
    each pars { it |
        args&.push(get(it));
    };

    spill :: fn() void #noinline = ();
    args := @as(FatExpr) (expr = (Tuple = args.as_raw()), ty = UnknownType, done = false, loc = func.loc);
    func.body = (Normal = @{
        result := @(Posix'syscall)(@[args]);
        spill();
        result
    });
    func.unset_flag(.BodyIsSpecial);
    
    // hack!
    if name == "clone" || name == "clone3" {
        func.set_flag(.Inline);
    };
    
    @literal fid
};
