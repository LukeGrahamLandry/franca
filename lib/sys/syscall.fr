
read :: fn(fd: Fd, buf: *u8, size: i64) i64Result #libc #syscall(63, 0, 3);
write :: fn(fd: Fd, buf: *u8, size: i64) i64Result #libc #syscall(64, 1, 4);
close :: fn(fd: Fd) voidResult #libc #syscall(57, 3, 6);
lseek :: fn(fd: Fd, offset: i64, whence: Whence) i64Result #libc #syscall(62, 8, 199);
remove :: fn(filepath: CStr) voidResult #libc;
// TODO: mode is a bit flag of AccessMode
access :: fn(pathname: CStr, mode: i64) voidResult #libc #syscall(NOSYS, 21, 33); // TODO: bit flags
// TODO: on linux the syscall version might be prefixed by "(unreachable)" which should be an error or something
getcwd :: fn(ptr: *u8, len: i64) CStrResult #libc #syscall(17, 79, NOSYS);
readlink :: fn(pathname: CStr, ptr: *u8, len: i64) i64Result #libc #syscall(NOSYS, 89, 58); 
fchmod :: fn(fd: Fd, mode: FileMode) voidResult #libc #syscall(52, 91, 124);

munmap :: fn(addr: rawptr, len: i64) voidResult #libc #syscall(215, 11, 73);
mprotect :: fn(addr: rawptr, len: i64, prot: i64) voidResult #libc #syscall(226, 10, 74);

// linux: exit_group, not exit. exit just ends the calling thread. 
exit :: fn(status: i64) Never #libc #cold #syscall(94, 231, 1);

nanosleep :: fn(duration: *TimeSpec, nullable_remainder_out: *TimeSpec) voidResult #libc #syscall(101, 35, NOSYS);

dup2 :: fn(oldfd: Fd, newfd: Fd) voidResult #libc #syscall(NOSYS, 33, 90);
dup3 :: fn(oldfd: Fd, newfd: Fd, flags: i32) voidResult #libc #syscall(24, 292, NOSYS);
chdir :: fn(path: CStr) voidResult #libc #syscall(49, 80, 12);

renameat :: fn(old_dir: Fd, old: CStr, new_dir: Fd, new: CStr) voidResult #libc #syscall(38, 264, 465);
clock_gettime :: fn(clock_id: i64, time_spec: *TimeSpec) void #libc #syscall(113, 228, NOSYS); // TODO: macos syscall

// not #libc because that's variadic, which we can do but is a bit annoying
// TODO: maybe that's the wrong choice for apple
openat :: fn(dirfd: Fd, pathname: CStr, flags: i64, mode: i64) i32 #syscall(56, 257, 463);
opendir :: fn(path: CStr) i64 #weak #libc;
@"opendir$INODE64" :: fn(path: CStr) i64 #weak #libc;
readdir :: fn(dir: rawptr) i64 #libc;
@"readdir$INODE64" :: fn(dir: rawptr) i64 #weak #libc;
mkdirat :: fn(parent: Fd, path: CStr, mode: i64) i64 #libc #syscall(34, 258, 475);
mmap :: fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 #libc #syscall(222, 9, 197);

SysStat :: @union(l: Linux.Stat, m: Macos.Stat);
fstatat :: fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #syscall(79, 262, 470) #libc;
@"fstatat$INODE64" :: fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #syscall(NOSYS, NOSYS, 470) #weak #libc;

// https://github.com/apple/darwin-xnu/blob/main/bsd/kern/sys_ulock.c
ulock_wait :: fn(op: ULockFlags, addr: *u32, only_wait_if_value_is: u32, timeout_ns_zero_is_forever: u32) i32 #syscall(NOSYS, NOSYS, 515);
ulock_wake :: fn(op: ULockFlags, addr: *u32, how_many_to_wake: u32) i32 #syscall(NOSYS, NOSYS, 516);
ULockFlags :: @(import("@/lib/bit_fields.fr").bit_fields)(
    op         := 8,
    wake_flags := 8,
    wait_flags := 8,
    no_errno   := 1,
    _          := 7,
);

// https://www.man7.org/linux/man-pages/man2/futex.2.html
sys_futex :: fn(addr: *u32, futex_op: u32, val: u32, timeout: *TimeSpec) i64 #syscall(98, 202, NOSYS);

exit_thread :: fn(status: i64) Never #syscall(93, 60, NOSYS);
clone :: fn(flags: i64, stack: *u8, p: i64, c: i64, t: i64) pid_t #syscall(220, 56, NOSYS);
clone3 :: fn(arg: *Clone3, size: i64) pid_t #syscall(435, 435, NOSYS);
Clone3 :: @struct {
    flags: i64;
    pidfd: *i32;
    child_tid: *pid_t;
    parent_tid: *pid_t;
    exit_signal: i64;
    stack: []u8;
    tls: i64;
    set_tid: []pid_t;
    cgroup: i64;
};

Macos :: import("@/lib/sys/macos.fr");
Linux :: import("@/lib/sys/linux.fr");
