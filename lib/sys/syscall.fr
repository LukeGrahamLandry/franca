
read :: @S("read") fn(fd: Fd, buf: *u8, size: i64) i64Result #weak #libc #syscall(63, 0, 3);
write :: @S("write") fn(fd: Fd, buf: *u8, size: i64) i64Result #weak #libc #syscall(64, 1, 4);
close :: @S("close") fn(fd: Fd) voidResult #libc #syscall(57, 3, 6);
lseek :: @S("lseek") fn(fd: Fd, offset: i64, whence: Whence) i64Result #libc #syscall(62, 8, 199);
remove :: Posix.remove;
// TODO: mode is a bit flag of AccessMode
access :: @S("access") fn(pathname: CStr, mode: i64) voidResult #libc #syscall(NOSYS, 21, 33); // TODO: bit flags
// TODO: on linux the syscall version might be prefixed by "(unreachable)" which should be an error or something
getcwd :: @S("getcwd") fn(ptr: *u8, len: i64) CStrResult #weak #libc #syscall(17, 79, NOSYS);
fchmod :: @S("fchmod") fn(fd: Fd, mode: FileMode) voidResult #libc #syscall(52, 91, 124);

mmap :: @S("mmap") fn(addr: rawptr, len: i64, prot: i64, flags: i64, fd: Fd, offset: i64) i64 #libc #syscall(222, 9, 197);
munmap :: @S("munmap") fn(addr: rawptr, len: i64) voidResult #libc #syscall(215, 11, 73);
mprotect :: @S("mprotect") fn(addr: rawptr, len: i64, prot: i64) voidResult #libc #syscall(226, 10, 74);

// linux: exit_group, not exit. exit just ends the calling thread. 
exit :: @S("exit") fn(status: i64) Never #libc #syscall(94, 231, 1);

nanosleep :: @S("nanosleep") fn(duration: *TimeSpec, nullable_remainder_out: *TimeSpec) voidResult #libc #syscall(101, 35, NOSYS);

// linux: dup3, flags=0 is the same as dup2, just don't pass oldfd=newfd. 
dup2 :: @S("dup2") fn(oldfd: Fd, newfd: Fd) FdResult #libc #syscall(24, 292, 90);
chdir :: @S("chdir") fn(path: CStr) voidResult #weak #libc #syscall(49, 80, 12);
fsync :: @S("fsync") fn(fd: Fd) voidResult #weak #libc #syscall(82, 74, 95);
execve :: @S("execve") fn(path: CStr, argv: *CStr, envp: *CStr) i32 #libc #syscall(221, 59, 59);

// renameat2 has an extra flags arg but my wrappers set it to zero so its fine to not list it here
renameat :: @S("renameat") fn(old_dir: Fd, old: CStr, new_dir: Fd, new: CStr) voidResult #libc #syscall(276, 316, 465);
clock_gettime :: @S("clock_gettime") fn(clock_id: i64, time_spec: *TimeSpec) i64 #libc #syscall(113, 228, NOSYS); // TODO: macos syscall

// not #libc because that's variadic, which we can do but is a bit annoying
// TODO: maybe that's the wrong choice for apple
openat :: @S("openat") fn(dirfd: Fd, pathname: CStr, flags: i64, mode: i64) i32 #syscall(56, 257, 463);

opendir :: fn(path: CStr) i64 #weak #libc;
@"opendir$INODE64" :: fn(path: CStr) i64 #weak #libc;
readdir :: fn(dir: rawptr) i64 #weak #libc;
@"readdir$INODE64" :: fn(dir: rawptr) i64 #weak #libc ;
// this is getdents64 which has d_type before the name instead of after
getdents :: @S("getdents") fn(dir: Fd, p: *u8, count: i64, macos: *i64) i64 #syscall(61, 217, 344);

mkdirat :: @S("mkdirat") fn(parent: Fd, path: CStr, mode: i64) i64 #libc #syscall(34, 258, 475);
unlinkat :: @S("unlinkat") fn(parent: Fd, path: CStr, mode: i64) i64 #libc #syscall(35, 263, 472);
readlinkat :: @S("readlinkat") fn(parent: Fd, path: CStr, ptr: *u8, len: i64) i64Result #libc #syscall(78, 267, 473); 

SysStat :: @union(l: Linux.Stat, m: Macos.Stat, la: Linux.StatArm64);
fstatat_nolibc :: @S("fstatat") fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #syscall(79, 262, 470);
fstatat :: @S("fstatat") fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #syscall(79, 262, 470) #libc;
@"fstatat$INODE64" :: fn(parent: Fd, path: CStr, out: *SysStat, flags: i64) i64 #weak #libc;

kill :: @S("kill") fn(pid: i32, signum: i64) i64 #libc #syscall(129, 62, NOSYS);
getpid :: @S("getpid") fn(_: i64) i32 #libc #syscall(172, 39, 20);

// TODO: the libc one is varargs
ioctl :: @S("ioctl") fn(fd: Fd, op: i64, argp: i64) i64 #syscall(29, 16, NOSYS);

ITIMER :: @enum(i64) (REAL, VIRTUAL, PROF);
ITimerVal :: @struct(interval: TimeVal, value: TimeVal);
TimeVal :: @struct(seconds: i64, microseconds: i64);
setitimer :: @S("setitimer") fn(which: ITIMER, new_value: *ITimerVal, old: *ITimerVal) i64 #libc #syscall(103, 38, 83);

// https://github.com/apple/darwin-xnu/blob/main/bsd/kern/sys_ulock.c
ulock_wait :: @S("ulock_wait") fn(op: ULockFlags, addr: *u32, only_wait_if_value_is: u32, timeout_ns_zero_is_forever: u32) i32 #syscall(NOSYS, NOSYS, 515);
ulock_wake :: @S("ulock_wake") fn(op: ULockFlags, addr: *u32, how_many_to_wake: u32) i32 #syscall(NOSYS, NOSYS, 516);
ULockFlags :: @(import("@/lib/bit_fields.fr").bit_fields)(
    op         := 8,
    wake_flags := 8,
    wait_flags := 8,
    no_errno   := 1,
    _          := 7,
);

// https://www.man7.org/linux/man-pages/man2/futex.2.html
sys_futex :: @S("sys_futex") fn(addr: *u32, futex_op: u32, val: u32, timeout: *TimeSpec) i64 #syscall(98, 202, NOSYS);

exit_thread :: @S("exit_thread") fn(status: i64) Never #syscall(93, 60, NOSYS);

rt_sigaction :: @S("rt_sigaction") fn(signum: i64, new: *Linux.KSigAction, old: *Linux.KSigAction, sigsetsize: i64) i64 #syscall(134, 13, /*49*/NOSYS);
rt_sigreturn :: @S("rt_sigreturn") fn() Never #syscall(139, 15, NOSYS);

wait4 :: @S("wait4") fn(pid: pid_t, status: *i32, options: i64, usage: *Posix.rusage) i32 #weak #libc #syscall(260, 61, 7);

// linux: pipe2 with flags=0 is the same as pipe (which doesn't exist on arm64)
// :TodoMacosSyscall
pipe :: @S("pipe") fn(pipefd: *Array(Fd, 2)) voidResult #weak #libc #syscall(59, 293, NOSYS/*42*/);

// Be very very careful using this to do anything other than exec a new process. 
// If you're running at comptime, you might not be done compiling and the child 
// will hang forever because fork() doesn't take threads with you (codegen runs 
// in a different thread). 
fork :: fn() i32 = {
    // macos: fork
    // linux: clone. low byte of flags is exit_signal, this lets you use it with wait4. 
    //  everything else 0 makes it not share with the parent. 
    //  @syscall pads with zeros until 6 args (don't need to set stack, etc.)
    SIGCHLD :: 17;
    fork :: @S("fork") fn(flags: i64) i32 #libc #syscall(220, 56, 2);
    fork(SIGCHLD)
};

Macos :: import("@/lib/sys/macos.fr");
Linux :: import("@/lib/sys/linux.fr");

S :: fn(name: FatExpr, fid: FatExpr) FatExpr #macro = {
    name := const_eval(Str)(name);
    fid := const_eval(FuncId)(fid);
    func := get_function_ast(fid, true, true, true, false);
    func.name = name.sym();

    @if(IS_BOOTSTRAPPING) {
        // #syscall used to be a magic builtin thing
        return(@literal fid);
    };
    
    // TODO: factor out and share with objective_c.fr/objc_method_import_body()
    pars := func.arg.bindings&.items();
    if func.finished_arg.Some == void {
        pars.len = 0;
    };
    args := FatExpr.list(pars.len + 1, ast_alloc());
    args&.push(@literal fid);
    get :: fn(b: *Binding) FatExpr => (expr = (GetVar = b.name.Var), ty = b.ty.Finished, loc = func.loc, done = false);
    each pars { it |
        args&.push(get(it));
    };

    args := @as(FatExpr) (expr = (Tuple = args.as_raw()), ty = UnknownType, done = false, loc = func.loc);
    func.body = (Normal = @{
        result := @syscall(@[args]);
        result
    });
    func.unset_flag(.BodyIsSpecial);
    
    @literal fid
};

// 
// usage: 
//      @syscall(func, arg0, ... argn);
//      func :: fn(arg0: A0, ..., argn: An) R #weak #libc #syscall(linux-arm64, linux-amd64, macos); 
// this will choose whether to call imported `func` from libc or make a syscall, 
// based on (prefer_syscalls, current_arch, current_os) ***AT RUNTIME***, 
// so all branches are always compiled and you don't have to re-sema for each target. 
//
// Linux is big on stable syscall interface, apple not so much. 
// - https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html
// - https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master
// - objdump -d /usr/lib/system/libsystem_kernel.dylib
//
// TODO: need to either do the SysResult wrapping here or return which 
//       implementation was used so you know if you need to check errno. 
// 
// TODO: this is very hacky for now. still deciding how i want it to work. 
// 
//       im not sure if it's better to treat this call as a macro which references the function declaration just 
//       as a data structure to let you type in name+numbers+signeture in one place, or commit all the way and 
//       have it generate the wrapper implementation like AsmFunction() does. or commit more and have the syscall numbers 
//       entirely as data and generate the whole scope. but it can't be exactly like AsmFunction because the inferred name 
//       won't be set yet. can make you write it redundantly in the overload set slot tho. 
//       
fn syscall(arg: FatExpr) FatExpr #macro = {
    loc := arg.loc;
    arg := arg&.items();
    
    fid := arg[0]; arg := arg.rest(1);
    fid := const_eval(FuncId)(fid);
    func := get_function_ast(fid, true, true, true, false);

    libc := false;
    can_syscall := false;
    sys := zeroed Array(i64, 3);
    each func.annotations { it |
        if it.name == (@symbol libc) {
            libc = true;
        };
        if it.name == (@symbol syscall) {
            can_syscall = true;
            sys = const_eval(Array(i64, 3))(it.args);
            if sys&[2] != NOSYS {
                // only needed on amd but it works fine on arm too and saves an extra bit of fucking around
                sys&[2] += 0x2000000;  // macos
            }
        };
    };
    
    inst := FatExpr.list(arg.len + 1, ast_alloc());
    each arg { e |
        e[] = compile_ast(e[]);
        inst&.push(@{
            T :: @[@literal e.ty];
            @if(size_of(T) == 8,
                bit_cast_unchecked(T, i64, @[e[]]),
                bit_cast_unchecked(T, u32, @[e[]]).zext(),
            )
        });
        
        if size_of(e.ty) > 8 {
            compile_error("syscall argument must fit in a register", loc);
        };
    };
    
    if arg.len > 6 {
        compile_error("syscall has too many arguments", loc);
    };
    
    // the zero padding is important becuase sometimes i use it for flags without explicitly 
    // mentioning the parameter. ie. fork->clone, dup2->3, 
    while => inst.len < 6 {
        inst&.push(@literal 0);
    };
    
    ::import("@/lib/sys/process.fr");
    crash :: fn() Never = panic("unimplemented syscall");
    
    if IS_BOOTSTRAPPING {
        can_syscall = false;
    };

    // TODO: this duplicates the expressions (3 times)! that's a crime! don't do that!!
    arg_expr := @as(FatExpr) (expr = (Tuple = arg.as_raw_list()), ty = UnknownType, done = false, loc = loc);
    if arg.len == 1 {
        arg_expr = arg[0];
    };
    if arg.len == 0 {
        arg_expr = @literal ();
    };
    
    arg, ret := (func.finished_arg.unwrap(), func.finished_ret.unwrap());
    // can't just call fid now that syscall.S is replacing the function body with ourself
    callee: FatExpr = (
        expr = (DataSymbol = (name = func.name, lib = @symbol libc, comptime = 0, weak = true)),
        loc = loc, ty = FnPtr(arg, ret), done = false,
    );
    
    if func.name.str().starts_with("clone") {
        compile_error("use perform_clone instead. it's special because it returns again in a different stack.", loc);
    };

    if !libc {
        callee = @{ zeroed(rawptr) };
    };
    arg_expr_padded := @as(FatExpr) (expr = (Tuple = inst.as_raw()), ty = UnknownType, done = false, loc = loc);
    return @{
        // TODO: the nice debloated one doesn't work on wasm. 
        //       if i keep it this way, i might as well always do the libc case here instead of also in choose_syscall? 
        @if(query_current_arch() == .wasm32, {
            @if(@[@literal !libc]) crash();
            @[callee](@[arg_expr])
        }, {
            // TODO: you really really want these to be read only
            // TODO: "You can't have a void pointer 6518175468 as a constant" :CompilerBug
            //        when doing a DataSymbol it doesn't have a FuncId to put in the pagemap. 
            //vtable := @static(SyscallVTable) (n = @[@literal sys], libc = ::@as(rawptr) @[callee]);
            vtable := @static(SyscallVTable) (n = @[@literal sys], libc = (it = zeroed rawptr));
            f := @as(rawptr) @[callee];
            vtable.libc.it = f;  // not a race, we're in a macro; one per customer
            args := @array(@[arg_expr_padded]);
            result := choose_syscall(args&, vtable);
            bit_cast_unchecked(i64, @[@literal ret], result)
        })
    };
}

SyscallVTable :: @struct {
    n: Array(i64, 3);
    libc: ClearOnAotBake(rawptr);  // HACK: shouldn't need the ClearOnAotBake
};

// TODO: this really needs to return if we did libc or sys so you know where to look for errno 
//       or maybe sys_ret should just get pulled into here as well? 
choose_syscall :: fn(a: *Array(i64, 6), info: *SyscallVTable) i64 = {
    want_syscall := prefer_syscalls() || info.libc.it.is_null();
    if want_syscall {
        sys_index := @if(query_current_os() == .macos, 2, @if(query_current_arch() == .aarch64 || query_current_arch() == .rv64, 0, 1));
        n := info.n&[sys_index];
        if n == NOSYS {
            panic("unimplemented syscall")
        };
        result, flag := perform_syscall(a, n);
        if flag.bit_and(1) == 1 && sys_index == 2 {
            result = -result;
        };
        result
    } else {
        // this relies on the native calling conventions not caring about the arity of functions (when passing 0 to 6 ints)
        F :: @FnPtr(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64) i64;
        f := bit_cast_unchecked(rawptr, F, info.libc.it);
        f(a[0], a[1], a[2], a[3], a[4], a[5])
    }
};

perform_syscall :: AsmFunction(fn(args: *Array(i64, 6), n: i64) Ty(i64, u8) = (), {
    #use("@/backend/arm64/bits.fr");
    @const_slice(
        mov(.X64, x8, x1),   // linux syscall number
        mov(.X64, x16, x1),  // macos syscall number
        
        // arguments
        ldp_so(.X64, x4, x5, x0, @as(i7) 4),
        ldp_so(.X64, x2, x3, x0, @as(i7) 2),
        ldp_so(.X64, x0, x1, x0, @as(i7) 0),
        
        svc,
        cset(.X64, x1, .LO), // macos sets carry flag on error
        ret(),
    )
}, fn(out: *List(u8)) => {
    #use("@/backend/amd64/bits.fr");
    
    ldr :: fn(o: *List(u8), d: X86Reg, s: X86Reg, off: i64) void = 
        encode_base_plus_offset(o, PrimaryOp.MovRegLoad, d, s, off);
    
    @asm_x64(
        encode_bin(PrimaryOp.MovReg, X86Reg.rax, X86Reg.rsi), // syscall number
        
        // arguments
        ldr(X86Reg.r9, X86Reg.rdi, 40),
        ldr(X86Reg.r8, X86Reg.rdi, 32),
        ldr(X86Reg.r10, X86Reg.rdi, 24),  // note: not rcx
        ldr(X86Reg.rdx, X86Reg.rdi, 16),
        ldr(X86Reg.rsi, X86Reg.rdi, 8),
        ldr(X86Reg.rdi, X86Reg.rdi, 0),
        
        0x0F, 0x05,  // syscall
        
        // macos sets carry flag on error
        @as(u8) pack_rex_si(false, X86Reg.rdx, X86Reg.rdx, X86Reg.rdx),  // Don't elide. See EncodedArgs.force_rex
        encode_2cc(TwoByteOp.SetCC, X86cc.b),
        @as(u8) pack_modrm(ModrmMode.Direct, X86Reg.rdx, X86Reg.rdx),
        
        PrimaryOp.Ret
    ) out;
}, fn(out: *List(u8)) => out.push_all(@const_slice(0x00, 0x00, 0x0B)) /* 0 locals. unreachable. end */, {
    #use("@/backend/rv64/bits.fr");
    @const_slice(
        I(0, RvReg.A1.bits(), @as(u3) OpI.add, RvReg.A7.bits(), .op_imm),  // syscall number
        
        load(.A5, .A0, 40, 8, false, false),
        load(.A4, .A0, 32, 8, false, false),
        load(.A3, .A0, 24, 8, false, false),
        load(.A2, .A0, 16, 8, false, false),
        load(.A1, .A0, 8, 8, false, false),
        load(.A0, .A0, 0, 8, false, false),
        
        ecall,
        jalr(.RA, 0, .Zero),
    )
});

fn prefer_syscalls() bool = {
    tls(.prefer_syscalls)[]
}
