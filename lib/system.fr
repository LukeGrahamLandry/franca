
@pub fn cli_args() Slice(Str);

@pub const CmdResult: Type;
@pub fn system(cmd: Slice(Str)) CmdResult;

@pub fn system_no_args(cmd: Str) CmdResult = { 
    let parts: Slice(Str) = slice(cmd!addr);
    var parts: List(Str) = list_clone(parts);   // TODO: Vec<String>::deserialize can't deal with stack addrs. 
    let parts: Slice(Str) = items(parts!addr);
    system(parts)
}


/*
@comptime @pub fn Result(ok: Type, err: Type) Type = {
    const Self = (Ok: ok, Err: err)!enum;
    @pub fn unwrap(r: Self) ok = r.ok[];

    Self
}
@enum @pub fn FileErr(NotExists: Unit, Other: Unit);

@env @pub fn write(path: Str, content: Str) Result(Unit, FileErr);
@env @pub fn read(path: Str) Result(Slice(u8), FileErr);
*/

// TODO: stack trace
@llvm @pub fn panic(msg: ""!type) Never = {
    println(msg);
    exit(1)
}

// TODO: stack trace
@no_interp @aarch64 @pub
fn panic(msg: ""!type) Never = {
    println(msg);
    exit(314)
}

// TODO: this doesn't do the 'ln'
@no_interp @pub fn println(msg: ""!type) Unit = {
    const STD_OUT: Fd = 1;
    let ptr: Ptr(u8) = msg&[0][];
    let len: usize = msg&[1][];
    // TODO: this will try to write a bunch of zeros because i dont have bytes as a data type yet. 
    let written: isize = write(STD_OUT, ptr, len.mul(8));
    // TODO: check errno. loop if not all written. 
}

@no_interp @pub fn alloc(const Element: Type, count: i64) VoidPtr = {
    let bytes = Element.size_of().mul(8).mul(count);
    malloc(bytes)
}

// This is only const because it has to match on all arches and it's reasonable for an implementation to want it const. 
@no_interp @pub fn dealloc(const Element: Type, ptr: VoidPtr, len: i64) Unit = free(ptr);
