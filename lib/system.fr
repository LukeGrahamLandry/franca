
PANIC_HOOK :: @static(@FnPtr(msg: Str) Never);
IS_PANICKING :: @static(bool);
::{ IS_PANICKING[] = false; };

fn panic(msg: Str) Never = {
    is_panicking := IS_PANICKING;
    if(is_panicking[], => { abort(); });
    is_panicking[] = true;
    
    hook := PANIC_HOOK;
    hook[](msg);
    unreachable()  // TODO: bc_to_asm handle fnptr returning never correctly -- May 23
}

fn unreachable() Never = panic("Entered unreachable code.");
fn unreachable(msg: Str) Never = {
    msg := concat("Entered unreachable code.", msg, libc_allocator);
    panic(msg.items())
}

fn unreachable_hack(const T: Type) T #generic = {
    unreachable();
    ()!uninitialized
}

fn print_and_abort(msg: Str) Never = {
    println(msg);
    abort()
}

fn print_trace_and_abort(msg: Str) Never = {
    @println("Panicked: %", msg);
    walk_backtrace{f|
        print("- ");
        @match(f) {
            (fn Rust(rs) => { 
                // TODO: why is *const u8 turning into *i8
                name: Str = (ptr = ptr_cast_unchecked(i8, u8, rs.owned_name), len = rs.name_len);
                if(rs.line.ne(1.neg())){|
                    @println("[line %] %", rs.line, name); 
                }{|
                    @println("[] %", name); 
                };
            });
            (fn Franca(f) => { @println("%", f.name); });
            (fn Unknown(ip) => { @println("[ip=%] ???", AsmInst.int_from_ptr(ip)); });
        };
    };
    abort()
}

fn print_stacktrace_on_panic() Unit = {
    PANIC_HOOK[] = (@resolve(@Fn(msg: Str) Never) print_trace_and_abort)!fn_ptr;
}

:: {
    PANIC_HOOK[] = (@resolve(@Fn(msg: Str) Never) print_and_abort)!fn_ptr;
};

fn println(var msg: Str) Unit = {
    print(msg);
    
    // TODO: extra syscall is sad
    new_line: u8 = 10.trunc();
    print(@as(Str) (ptr = new_line&, len=1));
}

fn print(var msg: Str) Unit = {
    STD_OUT: Fd : 1;
    written: i64 = write(STD_OUT, msg.ptr, @as(usize) msg.len);
    // TODO: check errno. loop if not all written. 
}

fn args() Slice(CStr) = {
    argc := _NSGetArgc()[];
    argv := _NSGetArgv()[];
    // Safety: the os wouldn't lie to us... hopefully.
    slice(@as(*CStr) argv, argc)
}

Terminos :: @struct(
    iflag: u64,
    oflag: u64,
    cflag: u64,
    lflag: u64,
    cc: Array(u8, 20),  // TODO: this doesn't work until i have byte sized fields in structs
    ispeed: u64,
    ospeed: u64,
);
