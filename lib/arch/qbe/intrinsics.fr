// TODO: UNUSED

//! https://c9x.me/compile/doc/il.html
// TODO: are the float cmp ordered or unordered? 

//////
/// Integers

#qbe #asm #c_call
fn add(a: i64, b: i64) i64 = """
    %out =l add %a, %b
    ret %out
""";

#qbe #asm #c_call
fn sub(a: i64, b: i64) i64 = """
    %out =l sub %a, %b
    ret %out
""";

#qbe #asm #c_call
fn mul(a: i64, b: i64) i64 = """
    %out =l mul %a, %b
    ret %out
""";

#qbe #asm #c_call
fn div(a: i64, b: i64) i64 = """
    %out =l div %a, %b
    ret %out
""";

#qbe #asm #c_call
fn eq(a: i64, b: i64) bool = """
    %out =w ceql %a, %b
    ret %out
""";

#qbe #asm #c_call
fn ne(a: i64, b: i64) bool = """
    %out =w cnel %a, %b
    ret %out
""";

#qbe #asm #c_call
fn le(a: i64, b: i64) bool = """
    %out =w cslel %a, %b
    ret %out
""";

#qbe #asm #c_call
fn ge(a: i64, b: i64) bool = """
    %out =w csgel %a, %b
    ret %out
""";

#qbe #asm #c_call
fn lt(a: i64, b: i64) bool = """
    %out =w csltl %a, %b
    ret %out
""";

#qbe #asm #c_call
fn gt(a: i64, b: i64) bool = """
    %out =w csgtl %a, %b
    ret %out
""";

//////
/// Bitwise

#qbe #asm #c_call
fn shift_left(value: i64, shift_amount: i64) i64 = """
    %out =l shl %value, %shift_amount
    ret %out
""";

// zero fill
#qbe #asm #c_call
fn shift_right_logical(value: i64, shift_amount: i64) i64 = """
    %out =l shr %value, %shift_amount
    ret %out
""";

// sign bit fill
#qbe #asm #c_call
fn shift_right_arithmetic(value: i64, shift_amount: i64) i64 = """
    %out =l sar %value, %shift_amount
    ret %out
""";

#qbe #asm #c_call
fn bit_or(a: i64, b: i64) i64 = """
    %out =l or %a, %b
    ret %out
""";

#qbe #asm #c_call
fn bit_not(a: i64) i64 = """
    %out =l xor %a, -1
    ret %out
""";

#qbe #asm #c_call
fn bit_and(a: i64, b: i64) i64 = """
    %out =l and %a, %b
    ret %out
""";

#qbe #asm #c_call
fn bit_xor(a: i64, b: i64) i64 = """
    %out =l xor %a, %b
    ret %out
""";

#qbe #asm #c_call
fn bit_xor(a: u64, b: u64) i64 = """
    %out =l xor %a, %b
    ret %out
""";

//////
/// Floats

#qbe #asm #c_call
fn add(a: f64, b: f64) f64 = """
    %out =d add %a, %b
    ret %out
""";

#qbe #asm #c_call
fn sub(a: f64, b: f64) f64 = """
    %out =d sub %a, %b
    ret %out
""";

#qbe #asm #c_call
fn mul(a: f64, b: f64) f64 = """
    %out =d mul %a, %b
    ret %out
""";

#qbe #asm #c_call
fn div(a: f64, b: f64) f64 = """
    %out =d div %a, %b
    ret %out
""";

#qbe #asm #c_call
fn eq(a: f64, b: f64) bool = """
    %out =w ceqd %a, %b
    ret %out
""";

#qbe #asm #c_call
fn ne(a: f64, b: f64) bool = """
    %out =w cned %a, %b
    ret %out
""";

#qbe #asm #c_call
fn le(a: f64, b: f64) bool = """
    %out =w cled %a, %b
    ret %out
""";

#qbe #asm #c_call
fn ge(a: f64, b: f64) bool = """
    %out =w cged %a, %b
    ret %out
""";

#qbe #asm #c_call
fn lt(a: f64, b: f64) bool = """
    %out =w cltd %a, %b
    ret %out
""";

#qbe #asm #c_call
fn gt(a: f64, b: f64) bool = """
    %out =w cgtd %a, %b
    ret %out
""";

//////
/// Other

// TODO: the arg names are based on a different body of the function (dif arch, which ever was seen first) so you can't rename them here.  -- Jun 16
#qbe #asm #c_call
fn offset(ptr: rawptr, bytes: i64) rawptr = """
    %out =l add %ptr, %bytes
    ret %out
""";

//////
/// Casts

// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: u64) u8 = """
    ret %v
""";
// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: u32) u8 = """
    ret %v
""";
// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: i64) u8 = """
    ret %v
""";
// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: i64) u16 = """
    ret %v
""";
// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: u64) u16 = """
    ret %v
""";
// TODO: do i have to and off the top?
#qbe #asm #c_call fn trunc(v: u64) u32 = """
    ret %v
""";
#qbe #asm #c_call fn trunc(v: u32) u16 = """
    ret %v
""";
#qbe #asm #c_call fn trunc(v: i64) u32 = """
    ret %v
""";
#qbe #asm #c_call fn trunc(v: u16) u8 = """
    ret %v
""";

#qbe #asm #c_call fn zext(v: u32) u64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: u8) u64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: u32) u64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: u8) u32 = """
    ret %v
""";
#qbe #asm #c_call fn zext(v: u16) u32 = """
    ret %v
""";
#qbe #asm #c_call fn zext(v: u32) i64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: u16) i64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: u16) u64 = """
    %out =l extuw %v
    ret %out
""";
#qbe #asm #c_call fn zext(v: i32) i64 = """
    %out =l extuw %v
    ret %out
""";

#qbe #asm #c_call fn intcast(v: i32) i64 = """
    %out =l extsw %v
    ret %out
""";

// TODO: this is probably wrong. 
#qbe #asm #c_call fn intcast(v: i64) i32 = """
    ret %v
""";

// preserves the value (not the bit pattern). rounds towards zero. 
#qbe #asm #c_call
fn int(a: f64) i64 = """
    %out =l dtosi %a
    ret %out
""";

// preserves the value (not the bit pattern). 
#qbe #asm #c_call
fn float(a: i64) f64 = """
    %out =d sltof %a
    ret %out
""";

// preserves the bit pattern (not the value)
#qbe #asm #c_call
fn bitcast(a: f64) i64 = """
    %out =l cast %a
    ret %out
""";

// preserves the bit pattern (not the value)
// TODO: do i really have to do it through memory?
#qbe #asm #c_call
fn bitcast(a: i64) f64 = """
    %out =d cast %a
    ret %out
""";

#qbe #asm #c_call
fn cast(v: f64) f32 = """
    %out =s truncd %v
    ret %out
""";

#qbe #asm #c_call
fn cast(v: f32) f64 = """
    %out =d exts %v
    ret %out
""";

#qbe #asm #c_call 
fn int_from_rawptr(ptr: rawptr) i64 = """
    ret %ptr
""";

#qbe #asm #c_call 
fn rawptr_from_int(ptr: i64) rawptr = """
    ret %ptr
""";
