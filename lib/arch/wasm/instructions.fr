//! Instruction encoding for wasm32. 
//! Magic numbers from https://webassembly.github.io/spec/core/binary/index.html
//! Abstraction will continue until moral improves. 

FuncIdx :: @struct(id: u32);
TypeIdx :: @struct(id: u32);
TableIdx :: @struct(id: u32);
LabelIdx :: @struct(id: u32);
LocalIdx :: @struct(id: u32);
GlobalIdx :: @struct(id: u32);

wasm_page_size :: 65536;
NumType        :: @enum(u8) (I32 = 0x7F, I64 = 0x7E, F32 = 0x7D, F64 = 0x7C);
BlockType      :: @tagged(Empty: void, Value: u8, Index: i33);
MemArg         :: @struct(offset: u32, align: u32);

Instr :: @enum(u8) (
    Unreachable = 0x00,
    Nop = 0x01,
    Block = 0x02,
    Loop = 0x03,
    If = 0x04,
    Else = 0x05,
    End = 0x0B,
    Br = 0x0C,
    BrIf = 0x0D,
    Return = 0x0F,
    Call = 0x10,
    CallIndirect = 0x11,
    Drop = 0x1A,
    LocalGet = 0x20,
    LocalSet = 0x21,
    LocalTee = 0x22,
    GlobalGet = 0x23,
    GlobalSet = 0x24,
    I64_Load = 0x29,
    F64_Load = 0x2B,
    I64_Store = 0x37,
    F64_Store = 0x39,
    I64_Const = 0x42,
    F64_Const = 0x44,
    I64_Eq = 0x46,
    I64_Add = 0x7C,
);

// TODO: better error message if you use '=' instead of ':'. 
Op :: @tagged(
    Call: FuncIdx,
    CallIndirect: (TypeIdx, TableIdx),
    Br: LabelIdx,
    BrIf: LabelIdx,
    LocalGet: LocalIdx,
    LocalSet: LocalIdx,
    LocalTee: LocalIdx,  // same as local set but returns the value as well
    GlobalGet: GlobalIdx,
    GlobalSet: GlobalIdx,
    I64_Const: i64,
    F64_Const: f64,
    I64_Load: MemArg,
);

Section :: @enum(u8) (
    Custom = 0,
    Type = 1,
    Import = 2,
    Function = 3,
    Table = 4,
    Memory = 5,
    Global = 6,
    Export = 7,
    Start = 8,
    Element = 9,
    Code = 10,
    Data = 11,
    DataCount = 12, 
);
:: enum(Section);

WasmModule :: @struct(
    types: List(), // [TypeIdx] function types
    // Functions are split into two parts. the types are seperate from the code. 
    functions: List(TypeIdx),  // [FuncIdx]
    code: List(WasmFunc),      // [FuncIdx]
);

WasmFunc :: @struct(locals: RsVec(WasmLocal), insts: RsVec(u8));
WasmLocal :: @struct(type: TypeIdx, count: i64);

fn dump(self: *WasmModule, out: *BucketArray(u8)) void = {
    out.push_all(@slice(0x00, 0x61, 0x73, 0x6D));  // magic
    out.push_all(@slice(0x01, 0x00, 0x00, 0x00));  // version
    
    buf: List(u8) = list(temp());
    
    out.leb128_unsigned(self.functions.len); // size of the section
    for self.functions { it | 
        out.leb128_unsigned(id.it.zext());
    };
    
    out.push(Section.Function.raw());
    out.leb128_unsigned(buf.len);
    out.push_all(buf);
    buf.clear();
    
}

//! https://en.wikipedia.org/wiki/LEB128

LEB_MORE :: 128;
MAX_u8 :: 255;
fn leb128_unsigned(out: *List(u8), i: i64) void = {
    dowhile {|
        byte := i.bit_and(MAX_u8);
        i = i.shift_right_logical(7);
        more := i != 0;
        if more {|
            byte = byte.bit_or(LEB_MORE);
        }; 
        out.push(@as(u8) byte.trunc());
        more
    };
}

fn leb128_signed(out: *List(u8), i: i64) void = {
    todo()
}
