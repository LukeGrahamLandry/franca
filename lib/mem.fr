Alloc :: @struct(data: rawptr, vptr: *AllocVTable);
AllocVTable :: @struct(
    alloc: FnPtr(Ty(rawptr, i64, u8), *u8), // TODO: return slice 
    free: FnPtr(Ty(rawptr, Slice(u8), u8), Unit),
);

libc_allocator: Alloc : (data = 0.int_to_ptr(), vptr = {
    vtable := @static(AllocVTable);
    // TODO: respect alignment. but im pretty sure malloc always gives you 16 bits and that's almost always good enough. 
    libc_alloc :: fn(_: rawptr, size: i64, log_align: u8) *u8 = @as(*u8) @as(rawptr) malloc(size); // (ptr = @as(*u8) @as(rawptr) malloc(size), len = size);
    libc_free :: fn(_: rawptr, buf: Slice(u8), log_align: u8) Unit = free(@as(rawptr) buf.ptr);
    vtable[] = (alloc = libc_alloc!fn_ptr, free = libc_free!fn_ptr);
    vtable
});

fn alloc(allocator: Alloc, const Element: Type, count: i64) rawptr = {
    let bytes = (:: Element.size_of()).mul(count);
    // TODO: the problem here (when alloc returns slice) is that you can't flat call through a function pointer. 
    alloc := allocator.vptr.alloc;
    mem := alloc(allocator.data, bytes, @as(u8) 4); // TODO: alignment
    @as(rawptr) mem
}

// This is only const because it has to match on all arches and it's reasonable for an implementation to want it const. 
fn dealloc(allocator: Alloc, const Element: Type, ptr: rawptr, len: i64) Unit = {
    let bytes = (:: Element.size_of()).mul(len);
    mem: Slice(u8) = (ptr = @as(*u8) ptr, len = bytes);
    free := allocator.vptr.free;
    free(allocator.data, mem, @as(u8) 4); // TODO: alignment
}

/// https://man7.org/linux/man-pages/man2/mmap.2.html
fn os_alloc(bytes: i64) Slice(u8) = {
    // TODO: subtyping so working with enum flags sucks less. 
    let prot = bit_or(@as(i64) MapProt.Write, @as(i64) MapProt.Read);
    let flag = bit_or(@as(i64) MapFlag.Private, @as(i64) MapFlag.Anonymous);
    let n1 = 1.neg();
    let fd: Fd = @as(Fd) n1;
    let addr = 0.int_to_ptr();
    let ptr = mmap(addr, bytes, prot, flag, fd, 0);
    if(ptr.ptr_to_int().eq(n1)) {|
        println(get_errno());  // TODO: ugly
        panic("mmap failed");
    };
    
    let ptr: *u8 = ptr;
    (ptr = ptr, len = bytes)
}

/// SAFETY: EASY: 'arr' must be from 'os_alloc', only passed to this function once, and never accessed again. 
///         HARD: If you're careful, its fine to split an allocation from 'os_alloc' and release seperate pages at different times. 
fn os_dealloc(var arr: Slice(u8)) Unit = {
    let ptr: rawptr = arr.ptr;
    let res = munmap(ptr, arr.len);
    assert(res.eq(0), "munmap failed");
}

const ExecSlice = Unique(@struct(ptr: rawptr, len: i64)); 

fn make_write(var arr: ExecSlice) Slice(u8) = {
    let ptr: rawptr = arr.ptr;
    let prot = bit_or(@as(i64) MapProt.Write, @as(i64) MapProt.Read);
    let res = mprotect(ptr, arr.len, prot);
    assert(res.eq(0), "mprotect failed");
    (ptr = ptr, len = arr.len)
}

/// SAFETY: 'arr' must be from 'os_alloc' and not written to until 'make_write' is called on it.   
fn make_exec(var arr: Slice(u8)) ExecSlice = {
    let ptr: rawptr = arr.ptr;
    let prot = bit_or(@as(i64) MapProt.Exec, @as(i64) MapProt.Read);
    let res = mprotect(ptr, arr.len, prot);
    assert(res.eq(0), "mprotect failed");
    (ptr = ptr, len = arr.len)
}

fn os_dealloc(arr: ExecSlice) Unit = {
    os_dealloc(make_write(arr)); // TODO: dont do an extra syscall just for type
}
