// TODO: allocator abstraction. but its annoying to pass one around. 

fun alloc(const Element: Type, count: i64) rawptr = {
    let bytes = (:: Element.size_of()).mul(count);
    malloc(bytes)
}

// This is only const because it has to match on all arches and it's reasonable for an implementation to want it const. 
fun dealloc(const Element: Type, ptr: rawptr, len: i64) Unit = free(ptr);

/// https://man7.org/linux/man-pages/man2/mmap.2.html
fn os_alloc(bytes: i64) Slice$u8 = {
    // TODO: subtyping so working with enum flags sucks less. 
    let prot = bit_or(@as(i64) MapProt.Write, @as(i64) MapProt.Read);
    let flag = bit_or(@as(i64) MapFlag.Private, @as(i64) MapFlag.Anonymous);
    let n1 = 1.neg();
    let fd: Fd = @as(Fd) n1;
    let addr = 0.int_to_ptr();
    let ptr = mmap(addr, bytes, prot, flag, fd, 0);
    if(ptr.ptr_to_int().eq(n1)) {|
        println(get_errno());  // TODO: ugly
        panic("mmap failed");
    };
    
    let ptr: *u8 = ptr;
    (ptr = ptr, len = bytes)
}

/// SAFETY: EASY: 'arr' must be from 'os_alloc', only passed to this function once, and never accessed again. 
///         HARD: If you're careful, its fine to split an allocation from 'os_alloc' and release seperate pages at different times. 
fn os_dealloc(var arr: Slice$u8) Unit = {
    let ptr: rawptr = arr.ptr;
    let res = munmap(ptr, arr.len);
    assert(res.eq(0), "munmap failed");
}

const ExecSlice = Unique$ @struct(ptr: rawptr, len: i64); 

fn make_write(var arr: ExecSlice) Slice$u8 = {
    let ptr: rawptr = arr.ptr;
    let prot = bit_or(@as(i64) MapProt.Write, @as(i64) MapProt.Read);
    let res = mprotect(ptr, arr.len, prot);
    assert(res.eq(0), "mprotect failed");
    (ptr = ptr, len = arr.len)
}

/// SAFETY: 'arr' must be from 'os_alloc' and not written to until 'make_write' is called on it.   
fn make_exec(var arr: Slice$u8) ExecSlice = {
    let ptr: rawptr = arr.ptr;
    let prot = bit_or(@as(i64) MapProt.Exec, @as(i64) MapProt.Read);
    let res = mprotect(ptr, arr.len, prot);
    assert(res.eq(0), "mprotect failed");
    (ptr = ptr, len = arr.len)
}

fn os_dealloc(arr: ExecSlice) Unit = {
    os_dealloc(make_write(arr)); // TODO: dont do an extra syscall just for type
}
