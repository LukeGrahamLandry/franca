
// TODO: maybe do a convoluted thing that adapts to size of list and sorted runs instead of just insertion sort. 
default :: fn($T: Type, self: []T, $my_le: @Fn(a: *T, b: *T) bool) void #generic = {
    range(0, self.len()) { j |
        i := j;
        while => i > 0 && !my_le(self.index(i-1), self.index(i)) {
            self.swap(i-1, i);
            i -= 1;
        }
    }
};

// sorts the list into two parts, items where put_at_front() 
// returns true are all together at the beginning of the list. 
// returns the number of items in the first part of the list. 
partition_unordered :: fn($T: Type, self: []T, $put_at_front: @Fn(a: *T) bool #duplicated) i64 #generic = {
    i := 0;
    j := self.len - 1;
    while => i <= j { 
        if put_at_front(self.index(i)) {
            i += 1;
        } else {
            self.swap(i, j);
            j -= 1;
        };
    };
    i
};

order_strings :: fn(a: *Str, b: *Str) bool = {
    if(a.len != b.len, => a.len < b.len) {
        range(0, a.len) { i |
            if(a[i] != b[i], => return(a[i] < b[i]));
        };
        true
    }
};
