// TODO: fix scope resolution for generics 
fn list() Unit = {unit};
fn push() Unit = {unit};
fn items() Unit = {unit};
fn drop() Unit = {unit};
fn addr() Unit = {unit};
fn subslice() Unit = {unit};
fn push_all() Unit = {unit};
fn list_clone() Unit = {unit};
fn slice_eq() Unit = {unit};
fn foreach() Unit = {unit};
fn enumerate() Unit = {unit};
fn index() Unit = {unit};
fn slice() Unit = {unit};
fn len() Unit = {unit};

// TODO: scope resolution for recursion. 
fn memcpy() Unit = {unit};

@comptime fn List(T: Type) Type = {
    const Self: Type = .{ maybe_uninit: Ptr(T), len: i64 }!struct;
    // TODO: it doesnt realize that arguments are const if its @comptime, 
    //       so it thinks fn vec runtime captures T so it uses emit_capturing_call
    const T = T;
    
    fn len(self: Ptr(T)) i64 = {
        div(raw_len(self), size_of(T))
    }
    
    fn get(self: Ptr(T), i: i64) T = {
        assert(lt(i, len(self)), "OOB");
        let v: Ptr(T) = index(self, i);  // TODO: fix so dont need useless binding 
        v[]
    }
    
    fn index(self: Ptr(T), i: i64) Ptr(T) = {
        assert(lt(i, len(self)), "OOB");
        subslice(self, i, 1)
    }
    
    fn set(self: Ptr(T), i: i64, v: T) Unit = {
        assert(lt(i, len(self)), "OOB");
        subslice(self, i, 1)[] = v
    }
    
    fn slice(ptr: Ptr(T), first: i64, past_last: i64) Ptr(T) = {
        let first = mul(first, size_of(T));
        let past_last = mul(past_last, size_of(T));
        raw_slice(ptr, first, past_last)
    }
    
    fn subslice(ptr: Ptr(T), first: i64, count: i64) Ptr(T) = {
        slice(ptr, first, add(first, count))
    }
    
    const P: Type = (i64, Ptr(T));  // TODO: the other fn type syntax so you can name the arguments in the closure as documentation. 
    fn enumerate(arr: Ptr(T), f: Fn(P, Unit)) Unit = {
        var i = 0;
        let l: i64 = len(arr);
        (fn() bool = lt(i, l), fn() Unit = {
            let e: Ptr(T) = subslice(arr, i, 1);
            f(i, e);
            i = add(i, 1);
        })!while;
    }
    
    fn foreach(arr: Ptr(T), f: Fn(Ptr(T), Unit)) Unit = {
        var i = 0;
        let l: i64 = len(arr);
        (fn() bool = lt(i, l), fn() Unit = {
            let e: Ptr(T) = subslice(arr, i, 1);
            f(e);
            i = add(i, 1);
        })!while;
    }
    
    fn memcpy(dest: Ptr(T), src: Ptr(T)) Unit = {
        assert(eq(len(dest), len(src)), "OOB");  // Note: not using `asser t_eq` because the vm tracks those for my tests
        const f = fn(i: i64, e: Ptr(T)) Unit = set(dest, i, e[]);
        enumerate(src, f);
    }

    fn list(cap: i64) Self = .{ maybe_uninit: alloc(T, cap), len: 0 };
    
    // Can't reuse the allocation because drop() will free it. TODO: COW
    fn list_clone(from: Ptr(T)) Self = {  // TODO: better error message if you put the = on the wrong side of the type
        let self: Self = list(len(from));
        push_all(self!addr, from);
        self
    }
    
    fn items(self: Ptr(Self)) Ptr(T) = {
        slice(self.maybe_uninit[], 0, self.len[])
    }
    
    fn addr(self: Ptr(Self), i: i64) Ptr(T) = {
        subslice(self.maybe_uninit[], i, 1)
    }
    
    fn get(self: Self, i: i64) T = {
        addr(self!addr, i)[]
    }
    
    fn reserve(self: Ptr(Self), extra: i64) Unit = {
        let total = add(self.len[], extra);
        let old_cap: i64 = len(self.maybe_uninit[]);
        (lt(old_cap, total), fn() = {
            let cap = max(max(add(old_cap, extra), mul(old_cap, 2)), 4);
            var new: Self = list(cap);
            (gt(self.len[], 0), fn() Unit = {  // TODO: it doesnt let you create a zero length slice in items()
                let dest: Ptr(T) = subslice(new.maybe_uninit[], 0, self.len[]);
                memcpy(dest, items(self));
                new.len[] = self.len[];
            }, fn() Unit = ())!if;
            drop(self);
            self[] = new;
        }, fn()=())!if
    }
    
    fn push(self: Ptr(Self), v: T) Unit = {
        reserve(self, 1);
        let last: Ptr(T) = slice(self.maybe_uninit[], self.len[], add(self.len[], 1)); 
        last[] = v;
        self.len[] = add(self.len[], 1);
    }
    
    fn push_all(self: Ptr(Self), new: Ptr(T)) = {
        reserve(self, len(new));
        let dest: Ptr(T) = subslice(self.maybe_uninit[], self.len[], len(new));
        memcpy(dest, new);
        self.len[] = add(self.len[], len(new));
    }
    
    fn drop(self: Ptr(Self)) = dealloc(T, self.maybe_uninit[]);
    
    // TODO: have eq be generic and do something sane but currently its just in the vm and does addr_eq which should be a seperate thing. 
    fn slice_eq(lhs: Ptr(T), rhs: Ptr(T)) bool = {
        (eq(len(lhs), len(rhs)), fn() bool = {
            var i = 0;
            var prev = true;  // TODO: this is weird because 'and' doesn't short circuit  
            (
                fn() bool = { 
                    and(lt(i, len(lhs)), prev) 
                }, 
                fn() Unit = { 
                
                    prev = eq(get(lhs, i), get(rhs, i)); 
                    i = add(i, 1); 
                },
            )!while;
            and(prev, eq(i, len(lhs)))
        }, fn() bool = false)!if
    }
    
    Self
}

// TODO: this is really inefficient if you already own 'a'
fn concat(a: Str, b: Str) Str = {
    var c: List(u8) = list(add(len(a), len(b)));
    push_all(c!addr, a);
    push_all(c!addr, b);
    items(c!addr)
}

fn split(haystack: Str, needle: Str) List(Str) = {
    assert(gt(len(needle), 0), "OOB");
    var lines: List(Str) = list(1);
    var i = 0;
    let last = min(10000, sub(len(haystack), len(needle))); // TODO: !!!
    var start = 0;
    (fn() bool = lt(i, last), fn() Unit = {
        (eq(get(haystack, i), get(needle, 0)), fn() Unit = {
            let check: Str = subslice(haystack, i, len(needle));
            (slice_eq(check, needle), fn() Unit = {
                let found: Str = subslice(haystack, start, sub(i, start));
                push(lines!addr, found);
                i = add(i, len(needle));
                start = i;
            }, fn() Unit = { i = add(i, 1); })!if
        }, fn() Unit = { i = add(i, 1); })!if
    })!while;
    let found: Str = subslice(haystack, start, max(0, sub(len(haystack), start)));
    push(lines!addr, found);
    lines
}

// TODO: better error message if you call this on Ptr(Str)
fn splitlines(s: Str) List(Str) = {
    var lf: Str = (10)!slice;  // TODO: string escapes
    let lines = split(s, lf);
    
    /*  this doesndent wordked :(
    var cr: Str = (13)!slice;
    var lines: List(Str) = list(1);
    let temp = split(s, lf);
    var i = 0;
    (fn() bool = lt(i, temp.len[]), fn() Unit = {   // TODO: split needs to take an array of things cause this is stupid 
        let x = split(get(temp, i), cr);
        let x: Ptr(Str) = items(x!addr);
        push_all(lines!addr, x);
        i = add(i, 1); 
    })!while;
    */
    
    lines
}

fn endswith(haystack: Str, needle: Str) bool = {
    (lt(len(haystack), len(needle)),
        fn() bool = false,
        fn() bool = {
            let start: Str = subslice(haystack, sub(len(haystack), len(needle)), len(needle));  // TODO: infer type
            slice_eq(start, needle)
        }
    )!if
}

// TODO: these should just be on Slice(T)
fn startswith(haystack: Str, needle: Str) bool = {
    (lt(len(haystack), len(needle)),
        fn() bool = { false },
        fn() bool = {
            let start: Str = subslice(haystack, 0, len(needle));  // TODO: infer type
            slice_eq(start, needle)
        }
    )!if
}

fn str() Unit = { unit };  // TODO: scope.rs support recursion. 

fn str(i: i64) Str = {
    var s: List(u8) = list(1);
    (and(ge(i, 0), lt(i, 10)), 
        fn() Unit = push(s!addr, add(48, i)),
        fn() Unit = {
            push_all(s!addr, str(div(i, 10))); // TODO: push to list
            push(s!addr, add(48, mod(i, 10)));
        }
    )!if;
    
    items(s!addr)
}

// TODO: error checking. 
fn hex_digit(c: i64) i64 = {
    (ge(c, 97), 
        fn() i64 =  { assert(lt(c, 107), "hex OOB"); add(sub(c, 97), 10) }, 
        fn() i64 = (ge(c, 65), 
            fn() i64 = { assert(lt(c, 75), "hex OOB"); add(sub(c, 65), 10) }, 
            fn() i64 = { assert(lt(c, 58), "hex OOB"); sub(c, 48)}
        )!if
    )!if
}

fn hex(s: Str) i64 = {
    var total = 0;
    var scale = 1;
    var i = sub(len(s), 1);
    var first = 0;
    
    // This prevents overflow for tracking scale for lots of leading zeros. 
    /* TODO: support fully const 
    while(fn() bool = eq(get(s, first), 48),
         fn() Unit = { first = add(first, 1) }
    );
    */
    
    (fn() bool = eq(get(s, first), 48),  
        fn() Unit = { first = add(first, 1) }
    )!while;
    (fn() bool = ge(i, first), fn() Unit = {
        total = add(total, mul(scale, hex_digit(get(s, i))));
        scale = mul(scale, 16);
        i = sub(i, 1);
    })!while;  // TODO: warning if you forget the !while :(
    total
}

fn multi_puts(s: Ptr(Str)) Unit = {
    const one = fn(s: Ptr(Str)) Unit = puts(s[]);
    foreach(s, one);
}
