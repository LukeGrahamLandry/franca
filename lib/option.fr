fn is_none() void = unit;
fn is_some() void = unit;
fn unwrap() void = unit;
fn if_opt() void = unit;
fn as_ref() void = unit;
fn none() void = unit;
fn some() void = unit;
fn ok();

fn Option(const T: Type) Type = {
    // TODO: it would be better if 0 was none but that's hard to change. -- Jun 26
    //       need to have better system of old compiler running comptime with old layout but compiling new compiler with new layout 
    Self: Type : @tagged(Some: T, None);
    
    fn none() Self = (None = ());
    fn some(t: T) Self = { 
        (Some = t) 
    };
    
    // TODO: this is probably neater so leave it. but the old match version broke when I started resolving const arg patterns as const?? like it sometimes couldn't see captures. -- Apr 22
    fn if(self: Self, const then: Fn(T, void)) void = (self.is_some(), => then(self.Some), =>())!if;
    fn if(self: *Self, const then: Fn(*T, void)) void = 
         (self.is_some(), => then(self.Some&), =>())!if;
    
    /*
    @match(self) {
        (fn Some(t: T) void = then(t));
        (fn None(t: void) void = ());
    };*/
    
    
    ::if_opt(T, bool);
    ::if_opt(T, T);
    
    fn or(self: Self, const else: Fn(void, T)) T =
        self.if(fn(t: T) T = t, => else()); // todo: should be able to just pass in else. might already work? 
    
    fn unwrap(self: Self) T =
        self.if(fn(t: T) T = t, => @as(T) panic("Unwrapped missing value."));
        
    fn is_some(self: Self) bool = self&!tag[].eq(tag_value(Self, @symbol Some));
    fn is_none(self: Self) bool = self&!tag[].eq(tag_value(Self, @symbol None));
    fn is_some(self: *Self) bool = self!tag[].eq(tag_value(Self, @symbol Some));
    fn is_none(self: *Self) bool = self!tag[].eq(tag_value(Self, @symbol None));
    
    // TODO: derive
    fn eq(self: Self, other: Self) bool = 
        self.if(fn(a) => {
            other.if(fn(b) => {
                a.eq(b)
            }, => false)
        }, => other.is_none());
    
    
    fn while(const next: Fn(void, Self), const body: Fn(T, void)) void = {
        // Note: this is formated a bit awkwardly because you don't want to expand next and body in multiple places. 
        // TODO: should add an optional warning if you care about binary size for expanding the same const closure multiple times. 
        dowhile {|
            v := next();
            v.if(body);
            v.is_some()
        };
    }
    
    Self
}

fn operator_question_prefix(const T: Type) Type = Option(T);

// TODO: it should close over T without the extra argument when put in the #generic fn Option
fn if_opt(const I: Type, const O: Type) void = {
    // TODO: the old one with @match should work. need to fix chained_captures better -- Apr 23. 
    fn if(self: ?I, const then: @Fn(some: I) O, const else: Fn(void, O)) O = 
        (self.is_some(), => then(self.Some), =>else())!if;
    /*
    @match(self) {
        (fn Some(t: I) O = then(t));
        (fn None(t: void) O = else()); // TODO: allow no arg name in match macro. 
    };
    */
}

:: as_ref(i64);
fn as_ref(const T: Type) void = {
    // TODO: this sucks cause you can't @match through a pointer 
    //       and like now do i have to write pointer versions of all of them so you dont have to manually call as_ref every time? 
    fn as_ref(self: *?T) ?*T = {
        cond := self!tag[].eq(::tag_value(?T, @symbol Some));
        ::if(?*T); // TODO: it tries to resolve the overload before it evals the closure's return type -- Apr 25
        if(cond, fn() ?*T => {
            some(self[].Some&)
        },  fn() ?*T = none())
    }
}

fn map();
fn opt_map(const In: Type, const Out: Type) void = {
    fn map(self: ?In, const f: @Fn(In, Out)) ?Out = {
        :: if_opt(In, ?Out);
        if(self, fn(t) => (Some = f(t)), => .None)
    }
}


fn is_err();
fn unwrap_err();

// TODO: you kinda want a magic context pointer so you can print stuff and have... context? 
fn Result(const T: Type, const E: Type) Type = {
    Self :: @tagged(Ok: T, Err: E);
    
    fn unwrap(self: *Self) *T = @match(self) {
        (fn Ok(t: *T) *T => t);
        (fn Err(e: *E) *T => unreachable_hack(*T)); // TODO: be a ble to derive print for anything. 
    };
    fn unwrap(self: Self) T = @match(self) {
        (fn Ok(t: T) T => t);
        (fn Err(e: E) T => unreachable_hack(T)); // TODO: be a ble to derive print for anything. 
    };
    fn is_err(self: *Self) bool = @match(self) {
        (fn Ok(_) => false);
        (fn Err(_) => true);
    };
    fn unwrap_err(self: Self) E = @match(self) {
        (fn Ok(t: T) E => unreachable_hack(E));  // TODO: be a ble to derive print for anything. 
        (fn Err(e: E) E => e); 
    };
    
    // TODO: make sure this parses without {}
    fn ok(self: Self) ?T = {
        @match(self) {
            (fn Ok(t: T) ?T => (Some = t); 
            (fn Err(e: E) ?T => (None = ())); 
        }
    }
    
    Self
}

// TODO: you need from_residual so you can have it work when different ok types but the same error type. 
// TOOD: this doesn't even have to be a macro cause i have non-local returns... if i had better polymorphism. 
fn try(maybe: FatExpr, ret: FatExpr) FatExpr #macro= '{
    m := @[maybe];
    if(m&.is_err(), => @[ret](Err = m.unwrap_err()));
    m.unwrap()
}';
