
fn is_none() Unit = unit;
fn is_some() Unit = unit;
fn unwrap() Unit = unit;
fn if_opt() Unit = unit;
fn as_ref() Unit = unit;
fn none() Unit = unit;
fn some() Unit = unit;


fn Option(const T: Type) Type = {
    const Self: Type = @tagged(Some: T, None);
    
    fn none() Self = (None = ());
    fn some(t: T) Self = (Some = t);
    
    // TODO: this is probably neater so leave it. but the old match version broke when I started resolving const arg patterns as const?? like it sometimes couldn't see captures. -- Apr 22
    fn if(var self: Self, const then: Fn(T, Unit)) Unit = (self.is_some(), => then(self.Some), =>())!if;
    /*
    @match(self) {
        (fn Some(t: T) Unit = then(t));
        (fn None(t: Unit) Unit = ());
    };*/
    
    
    ::if_opt(T, bool);
    ::if_opt(T, T);
    
    fn or(self: Self, const else: Fn(Unit, T)) T =
        self.if(fn(t: T) T = t, => else()); // todo: should be able to just pass in else. might already work? 
    
    fn unwrap(self: Self) T =
        self.if(fn(t: T) T = t, => @as(T) panic("Unwrapped missing value."));
        
    fn is_some(var self: Self) bool = self&!tag[].eq(tag_value(Self, @symbol Some));
    fn is_none(var self: Self) bool = self&!tag[].eq(tag_value(Self, @symbol None));

    // TODO: derive
    fn eq(self: Self, other: Self) bool = 
        self.if(fn(a) => {
            other.if(fn(b) => {
                a.eq(b)
            }, => false)
        }, => other.is_none());
    
    
    fn while(const next: Fn(Unit, Self), const body: Fn(T, Unit)) Unit = {
        // Note: this is formated a bit awkwardly because you don't want to expand next and body in multiple places. 
        // TODO: should add an optional warning if you care about binary size for expanding the same const closure multiple times. 
        dowhile {|
            var v = next();
            v.if(body);
            v.is_some()
        };
    }
    
    Self
}

fn operator_question_prefix(const T: Type) Type = Option(T);

// TODO: it should close over T without the extra argument when put in the #generic fn Option
fn if_opt(const I: Type, const O: Type) Unit = {
    // TODO: the old one with @match should work. need to fix chained_captures better -- Apr 23. 
    fn if(var self: ?I, const then: @Fn(some: I) O, const else: Fn(Unit, O)) O = 
        (self.is_some(), => then(self.Some), =>else())!if;
    /*
    @match(self) {
        (fn Some(t: I) O = then(t));
        (fn None(t: Unit) O = else()); // TODO: allow no arg name in match macro. 
    };
    */
}

:: as_ref(i64);
fn as_ref(const T: Type) Unit = {
    // TODO: this sucks cause you can't @match through a pointer 
    //       and like now do i have to write pointer versions of all of them so you dont have to manually call as_ref every time? 
    fn as_ref(self: *?T) ?*T = {
        let cond = self!tag[].eq(tag_value(?T, @symbol Some));
        ::if(?*T); // TODO: it tries to resolve the overload before it evals the closure's return type -- Apr 25
        if(cond, fn() ?*T => {
            some(self[].Some&)
        },  fn() ?*T = none())
    }

}


