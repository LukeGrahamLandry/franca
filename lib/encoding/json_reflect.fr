// TODO: parse_json for tuple, rawhashmap, slice
// TODO: return meaningful error message. 
// TODO: options for how permisive to be about unexpected fields. 
//       or duplicated fields. 

fn DeriveJson($T: Type) void = {
    fn parse_json(json: *JsonParser, self: *T) bool = {
        @inline_match(@run T.get_type_info_ref()) {
            (fn Struct($_) => {
                token := json.next().or(fn(_: Str) => return(false));
                ::tagged(@type token);
                if(!token&.is(.StartDict), => return(false));
                
                found := zeroed StaticBitSet(fields.len());
                
                fields :: T.get_fields();
                loop {
                    continue :: local_return;
                    token := json.next().or(fn(_: Str) => return(false));
                    
                    if token&.is(.End) {
                        i := 0;
                        inline_for fields { $f | 
                            inner := T.get_field_ptr(self, f);
                            @if(@run(f.default.id.id != 0)) 
                            if !found&.get(i) {
                                value := f.get_default_value();
                                inner[] = value.unwrap();
                                found&.set(i);
                            };
                            @if(@run IsOption(f.ty)) 
                            if !found&.get(i) {
                                inner[] = .None;
                                found&.set(i);
                            };
                            
                            if !found&.get(i) {
                                json.error = @tfmt("%\n- missing field '%' of '%'", 
                                    json.error, @run f.name.str(), @run T.typename().str());
                            };
                            
                            i += 1;
                        };
                        
                        return found&.count_ones() == fields.len();
                    };
                    
                    if(!token&.is(.Key), => return(false));
                    
                    i := 0;
                    inline_for fields { $f | 
                        name :: f[].name.str();
                        if name == token.Key {
                            inner := T.get_field_ptr(self, f);
                            success := json.parse_json(inner);
                            if(!success, => return(false));
                            found&.set(i);
                            continue();
                        };
                        i += 1;
                    };
                    
                    json.skip_next_value();
                    continue();
                };
            });
            fn Enum(it) => {
                token := json.next().or(fn(_: Str) => return(false));
                ::tagged(@type token);
                if(!token&.is(.StringValue), => return(false));
                ::?T;
                self[] = T.from_name(token.StringValue) || {
                    json.error = @tfmt("%\n- invalid enum varient '%' for '%'", json.error, token.StringValue, @run T.typename().str());
                    return(false)
                };
                true
            }
            @default => {
                panic("Unsupported type for DeriveJson");
            };
        };
        
        true
    }
    
    fn dump_json(self: *T, out: *List(u8)) void = {
        @inline_match(@run T.get_type_info_ref()) {
            (fn Struct($it) => {
                fields :: T.get_fields();
                prefix := "";
                out.push_all("{");
                inline_for fields { $f | 
                    name :: f[].name.str();
                    @fmt(out, "%\"%\": ", prefix, name);
                    prefix = ",";
                    inner := T.get_field_ptr(self, f);
                    inner.dump_json(out);
                };
                out.push_all("}");
            });
            @default => {
                panic("Unsupported type for DeriveJson");
            };
        };
    }
}

#where(fn(T) => PointerTo(IsCollection(Slice))(T) && (T != *Str))
fn dump_json(self: ~S, out: *List(u8)) void = {
    out.push_all("[");
    prefix := "";
    each self[] { inner | 
        out.push_all(prefix);
        prefix = ",";
        inner.dump_json(out);
    };
    out.push_all("]");
}

#where(fn(T) => PointerTo(IsCollection(Slice))(T) && (T != *Str))
fn parse_json(json: *JsonParser, self: ~S) bool = {
    a := json.out;
    token := json.next().or(fn(_: Str) => return(false));
    if(!token&.is(.StartList), => return(false));
    
    
    out := Deref(S).Element.list(a);
    loop {
        json.skip_whitespace();
        if json.peek_c() == "]".ascii() {
            _ := json.next();
            json.skip_whitespace();
            self[] = out.items();
            return true;
        };
        self := out&.push_uninit();
        ok := parse_json(json, self);
        @if(!ok) return(false);
    };
}

IsRawHashMap :: fn(T: Type) bool = {
    check :: fn($T: Type) Type = RawHashMap(T.Key, T.Value);
    has_const_field(T, @symbol Key) && has_const_field(T, @symbol Value) && invoke_specialized(Type, Type, check, T) == T
}

#where(PointerTo(IsRawHashMap))
fn dump_json(self: ~S, out: *List(u8)) void = {
    out.push_all("{");
    prefix := "";
    each self { key, value | 
        ::@ct_assert((@type key) == Str, zeroed Span, "TODO: trait for dump_json map key");
        out.push_all(prefix);
        prefix = ",";
        key&.dump_json(out);
        @fmt(out, ":");
        value.dump_json(out);
    };
    out.push_all("}");
}

IsTuple :: fn(T: Type) bool = {
    info := T.get_type_info_ref();
    info.is(.Struct) && info.Struct.is_tuple
}

#where(PointerTo(IsTuple))
fn dump_json(self: ~S, out: *List(u8)) void = {
    T :: Deref(S);
    fields :: T.get_fields();
    prefix := "";
    out.push_all("[");
    inline_for fields { $f | 
        @fmt(out, "%", prefix);
        prefix = ",";
        inner := T.get_field_ptr(self, f);
        inner.dump_json(out);
    };
    out.push_all("]");
}

fn parse_json(json: *JsonParser, i: *i64) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    if(!token&.is(.Float), => return(false));
    i[] = token.Float.int();
    true
}

fn parse_json(json: *JsonParser, i: *Str) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    if(!token&.is(.StringValue), => return(false));
    i[] = token.StringValue;
    true
}

fn dump_json(i: *i64, out: *List(u8)) void = {
    i.display(out);
}

// TODO: deduplicate with backend/meta/dump.fr/safe_print
fn dump_json(i: *Str, out: *List(u8)) void = {
    out.push_all("\"");
    for i[] { c |
        printable :: fn(c) => 
            c >= 32 && c <= 126 && c != "\"".ascii() && c != "\\".ascii();
        if printable(c) {
            out.push(c);
        } else {
            @fmt(out, "\\x");
            push_hex_byte(out, c, false);
        }
    };
    out.push_all("\"");
}

fn parse_json(json: *JsonParser, self: *bool) bool = {
    token := json.next().or(fn(_: Str) => return(false));
    @if_let(token) fn BoolValue(value) => {
        self[] = value;
        return true;
    };
    false
}

IsOption :: fn(T: Type) bool #fold = {
    it := T.get_type_info_ref();
    it.is(.Tagged) && {
        it := it.Tagged.cases&;
        it.len == 2 && it[0]._0 == (@symbol Some) && it[1]._0 == (@symbol None)
    }
}

#where(PointerTo(IsOption))
fn parse_json(json: *JsonParser, self: ~S) bool #where = {
    self.tag_ptr()[] = .Some;
    ok := parse_json(json, self.Some&);
    ok
}

#use("@/lib/encoding/json.fr");
#use("@/lib/collections/bit_set.fr");
