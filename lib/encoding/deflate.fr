// https://www.ietf.org/rfc/rfc1951.txt

Error :: @enum(Ok, BlockType3, CorruptNLen, BackTooFar, BadDynamicHeader);

// returns number of consumed bytes so you can read a footer if your format has one. 
decompress :: fn(in: []u8, correct_output: []u8) Ty(i64, Error) = {
    ::enum(Error);
    c: Cursor = (in = in, i = 0, j = 0, correct_output = correct_output); c := c&;
    final := 0;
    while => final != 1 {
        final = c.get_bits(1);
        btype_rev := c.get_bits(2);
        @if(INFGEN && final == 1) println("final");
        err := @switch(btype_rev) {
            @case(0) => c.noncompressed_block();
            @case(1) => c.fixed_block();
            @case(2) => c.dynamic_block();
            @case(3) => .BlockType3;
            @default => unreachable();
        };
        if err != .Ok {
            return(c.i, err);
        };
    };
    @assert_eq(c.j, c.correct_output.len, "didn't output enough bytes");
    (c.i.align_to(8)/8, .Ok)
}

noncompressed_block :: fn(c: *Cursor) Error = {  //  3.2.4. 
    c.skip_to_full_byte();
    len := c.get_bits(16);
    nlen := c.get_bits(16);
    @if(len != nlen.bit_not().bit_and(0xFFFF)) return(.CorruptNLen);
    range(0, len) { _ |
        c.yield_byte(c.in[c.i.udiv(8)]);
        c.i += 8;
    };
    .Ok
}

// TODO: i haven't actually tested this code path. does anything actually output files that use it? 
fixed_block :: fn(c: *Cursor) Error = {  // 3.2.6.
    c.read_block(ll_fixed, d_fixed)
}

dynamic_block :: fn(c: *Cursor) Error = {  // 3.2.7.
    @if(INFGEN) println("dynamic");
    
    hlit := c.get_bits(5) + 257;
    hdist := c.get_bits(5) + 1;
    hclen := c.get_bits(4) + 4;
    @if(!(hlit <= 286 && hdist <= 32 && hclen <= 19)) return(.BadDynamicHeader);
    
    // need to read the code-lengths that will be used to decode the data, 
    // but those code-lengths are also huffman-coded, 
    // so read another set of code-lengths used to decode the code-lengths. 

    alphabet :: code_length_alphabet;
    cl := stack_tree(alphabet.len(), 5);  // code lengths
    range(0, hclen) { i |
        cl.len[alphabet[i].zext()] = c.get_bits(3).trunc();
    };
    codes_from_lengths(cl, alphabet.len());
    
    // TODO: tighter bound than 750KB of stack? (but it's uninitialized so it doesn't actually matter)
    ll := stack_tree(286, MAX_BITS);  // length/literal
    c.read_code_lengths(ll.len, cl, hlit);
    debug_log_lengths(ll, hlit, "litlen");
    codes_from_lengths(ll, hlit);
    
    d := stack_tree(32, 5);  // distance
    c.read_code_lengths(d.len, cl, hdist);
    debug_log_lengths(d, hdist, "dist");
    codes_from_lengths(d, hdist);
    
    c.read_block(ll, d)
}

read_block :: fn(c: *Cursor, ll: *Tree, d: *Tree) Error = {  // 3.2.5.
    loop {
        ll_code := c.read_symbol(ll);
        if ll_code < 256 {
            c.yield_byte(ll_code.trunc());
        } else {
            @if(ll_code == 256) return(.Ok);

            ll_index: i64 = ll_code.zext() - 257;
            extra_bits_needed := ll_extra[ll_index];
            extra := c.get_bits(extra_bits_needed.zext());
            length := extra + ll_base[ll_index].zext();
            
            d_index: i64 = c.read_symbol(d).zext();
            extra_bits_needed := d_extra[d_index];
            extra := c.get_bits(extra_bits_needed.zext());
            distance := extra + d_base[d_index].zext();
            
            i := c.j - distance;
            @if(i < 0) return(.BackTooFar);
            range(0, length) { _ |
                c.yield_byte(c.correct_output[i]);
                i += 1;
            };
        };
    };
}

read_code_lengths :: fn(c: *Cursor, lengths: []u8, tree: *Tree, count: i64) void = {
    i := 0;
    lengths[0] = 0;  // TODO: are they allowed to do 16 as the first item? i guess you'd always just use 17/18
    while => i < count {
        s := c.read_symbol(tree);
        (n: i64, value: u8) := @switch(s) {
            @case(16) => (c.get_bits(2) + 3, lengths[i - 1]);
            @case(17) => (c.get_bits(3) + 3, 0);
            @case(18) => (c.get_bits(7) + 11, 0);
            @default => {
                @debug_assert(s < 16);
                (1, s.trunc())
            };
        };
        range(0, n) { _ |
            lengths[i] = value;
            i += 1;
        };
    };
}

read_symbol :: fn(c: *Cursor, tree: *Tree) u16 = {
    node := tree.node[0]&;
    while => node.value == BLANK {
        bit := c.get_bits(1);
        index: i64 = node.next&[bit].zext();
        @debug_assert_ne(index, BLANK, "invalid tree. every bit pattern should be used");
        node = tree.node[index]&;
    };
    node.value
}

codes_from_lengths :: fn(tree: *Tree, count: i64) void = {  // 3.2.2.
    // 1)
    bl_count := zeroed Array(u16, MAX_BITS+1);
    i := 0;
    for tree.len.slice(0, count) { l |
        bl_count&[l.zext()] += 1;
        i += 1;
    };
    
    // 2)
    code: u16 = 0;
    bl_count&[0] = 0;
    next_code := zeroed Array(u16, MAX_BITS+1);
    range(1, MAX_BITS+1) { bits |
        code += bl_count&[bits-1];
        code = code.shift_left(1);
        next_code&[bits] = code;
    }
    
    // 3)
    range(0, count) { n |
        len: i64 = tree.len[n].zext();
        if len != 0 {
            tree.code[n] = next_code&[len];
            @debug_assert_lt(tree.code[n], 1.shift_left(len));
            next_code&[len] += 1;
        }
    }
    tree.len.rest(count).set_zeroed();
    
    fill_tree(tree);
}

MAX_BITS :: 15;  // sizes the encoding in 3.2.7 can express: ll/d: 0-15, cl:0-7 

fill_tree :: fn(tree: *Tree) void = {
    count := 1;
    tree.node[0] = (value = BLANK, next = (BLANK, BLANK));
    range(0, tree.len.len) { i |
        length: i64 = tree.len[i].zext();
        if length != 0 {
            bit :: fn(bi) i64 => 
                tree.code[i].zext().shift_right_logical(length - bi - 1).bit_and(1);
            
            index := 0;
            range(0, length) { bi |
                link := tree.node[index].next&[bit(bi)]&;
                if link[] == BLANK {
                    // (count<tree.node.len) because i wildly over estimate based on max path length. 
                    link[] = count.trunc();
                    tree.node[count] = (value = BLANK, next = (BLANK, BLANK));
                    count += 1;
                };
                index = link[].zext();
                @debug_assert_eq(tree.node[index].value, BLANK, "double used index %", index);
            };
            tree.node[index].value = i.trunc();
        }
    };
    
    tree.n = count;
    
    // check you can't fall off the tree. 
    // TODO: error if they gave lengths that don't work?
    // TODO: is it allowed to have one leaf so there'd be a blank slot? 
    @debug_assert(count < 0xFFFF);
    each tree.node.slice(0, count) { it |
        l, r := (it.next&[0], it.next&[1]);
        if it.value != BLANK {
            @debug_assert(l == r && r == BLANK);
        } else {
            @debug_assert(l != BLANK && r != BLANK && l != r);
        }
    };
} 

BLANK :: 0xFFFF;

yield_byte :: fn(c: *Cursor, value: u8) void #inline = {
    @assert_eq(c.correct_output[c.j], value, "wrong output[%]", c.j);
    c.j += 1;
}

Tree :: @struct {
    code: []u16;
    len: []u8;
    node: []Node;
    n := 0;
    
    Node :: @struct {
        next: Array(u16, 2);
        value: u16;
    };
};

// TODO: i should have an allocator that hands out from a fixed 
//       chunk of stack and then i wouldn't need to write this twice
// TODO: choose the length of node array better
stack_tree :: fn($n: i64, $nbit: i64) *Tree #inline/*semantic*/ = @ref @as(Tree) (
    len = items(@ref(zeroed Array(u8, n))),
    code = items(@ref({ ::Array(u16, n); @uninitialized Array(u16, n) })),
    node = { 
        N :: 1.shift_left(nbit+1);
        ::Array(Tree.Node, N); 
        items(@ref(@uninitialized Array(Tree.Node, N))) 
    },
);

alloc_tree :: fn(n: i64, a: Alloc) Tree = (
    len = a.alloc_zeroed(u8, n),
    code = a.alloc_zeroed(u16, n),
    node = a.alloc_zeroed(Tree.Node, n*2),  // this size is good enough for the fixed tables
);

Cursor :: @struct {
    in: []u8;
    i: i64;
    correct_output: []u8;
    j: i64;
};

// TODO: error if run out of input
// least signifigant bit of the input byte is taken first 
get_bits :: fn(c: *Cursor, n: i64) i64 = {
    @debug_assert_ule(c.i + n, c.in.len * 8);
    byte_i, bit_i := c.i.udiv_mod(8);
    // safety: this reads out of bounds (at the end if in.len is not a multiple of 8) but masks off the extra. 
    //         so only a problem if we're at the end of a page and the next one is unmapped. 
    word := bit_cast_unchecked(*u8, *i64, c.in.ptr.offset(byte_i))[];  // :endian :alignment
    word := word.shift_right_logical(bit_i);  // throw out already consumed bits
    word := word.bit_and(1.shift_left(n) - 1); // mask out extra bits
    c.i += n;
    word
}

skip_to_full_byte :: fn(c: *Cursor) void = {
    c.i = c.i.ualign_to(8);
}

try :: fn(e: FatExpr, r: FatExpr) FatExpr #macro = 
    @{ e := @[e]; @if(e != .Ok) @[r](e); };

// for debugging, print log messages in the same format as https://github.com/madler/infgen
INFGEN :: false;

debug_log_lengths :: fn(tree: *Tree, count: i64, label: Str) void = @if(INFGEN) {
    range(0, count) { i |
        if tree.len[i] != 0 {
            @println("% % %", label, i, tree.len[i]);
        }
    };
};

// TODO: if people mostly don't use these, compute them at runtime 
//       the first time they're needed instead of including them in the binary

ll_fixed :: @static(Tree) {
    it := alloc_tree(288, ast_alloc());
    
    it.len.slice(0, 143+1).set_bytes(8);
    it.len.slice(144, 255+1).set_bytes(9);
    it.len.slice(256, 279+1).set_bytes(7);
    it.len.slice(280, 287+1).set_bytes(8);
    
    codes_from_lengths(it&, it.len.len);
    it.node.len = it.n;
    it
};

// this is dumb but makes it more consistant 
d_fixed :: @static(Tree) {
    it := alloc_tree(32, ast_alloc());
    it.len.set_bytes(5);
    enumerate it.code { i, it |
        it[] = i.trunc();
    };
    fill_tree(it&);
    it.node.len = it.n;
    it
}

// tables pasted from the spec. 
// TODO: little program that dumps them as ascii art so you can diff it with the rfc trivially. just for sanity. 
ll_extra :: @const_slice(@as(u8) 0,0,0,0,0,0,0,0, 1,1,1,1, 2,2,2,2, 3,3,3,3, 4,4,4,4, 5,5,5,5, 0);
ll_base :: @const_slice(@as(u16) 
    3,4,5,6,7,8,9,10,11,13, 
    15,17,19,23,27,31,35,43,51,59, 
    67,83,99,115,131,163,195,227,258,
);
d_extra :: @const_slice(@as(u8) 0,0,0,0, 1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7, 8,8, 9,9, 10,10, 11,11, 12,12, 13,13);
d_base :: @const_slice(@as(u16)
    1,2,3,4,5,7,9,13,17,25,
    33,49,65,97,129,193,257,385,513,769,
    1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,
);
code_length_alphabet :: @const_slice(@as(u8) 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);  
