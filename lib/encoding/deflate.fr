// https://www.ietf.org/rfc/rfc1951.txt

INFGEN :: false;

decompress :: fn(in: []u8, correct_output: []u8) void = {
    c: Cursor = (in = in, i = 0, j = 0, correct_output = correct_output); c := c&;
    final := 0;
    while => final != 1 {
        final = c.get_bits(1);
        fixed := c.get_bits(1);
        dynamic := c.get_bits(1);
        if fixed == 1 && dynamic == 1 {   
            @panic("error 0b11");
        };
        if fixed == 0 && dynamic == 0 {
            c.noncompressed_block();
        };
        if dynamic == 1 {
            c.dynamic_block();
        };
        if fixed == 1 {
            c.fixed_block();
        };
    };
    @assert_eq(c.j, c.correct_output.len, "didn't output enough bytes");
}

noncompressed_block :: fn(c: *Cursor) void = {  //  3.2.4. 
    c.skip_to_full_byte();
    len := c.get_bits(16);
    nlen := c.get_bits(16);
    @assert_eq(len, nlen.bit_not().bit_and(0xFFFF), "corrupt len/nlen");
    range(0, len) { _ |
        c.yield_byte(c.in[c.i/8]);
        c.i += 8;
    };
}

fixed_block :: fn(c: *Cursor) void = {  // 3.2.6.
    c.read_block(ll_fixed, d_fixed);
}

dynamic_block :: fn(c: *Cursor) void = {  // 3.2.7.
    @if(INFGEN) println("dynamic");
    
    hlit := c.get_bits(5);
    hdist := c.get_bits(5);
    hclen := c.get_bits(4);
    @debug_assert(hlit <= 286 - 257 && hdist <= 32 - 1 && hclen <= 19 - 4);  // TODO: error
    
    // need to read the code-lengths that will be used to decode the data, 
    // but those code-lengths are also huffman-coded, 
    // so read another set of code-lengths used to decode the code-lengths. 

    alphabet :: code_length_alphabet;
    cl := stack_tree(alphabet.len(), 5);
    range(0, hclen + 4) { i |
        cl.len[alphabet[i].zext()] = c.get_bits(3).trunc();
    };
    codes_from_lengths(cl);
    
    // for literal/length alphabet
    ll := stack_tree(286, 12/*wild over estimate*/);
    c.read_code_lengths(ll.len, cl, hlit + 257);
    
    @if(INFGEN) range(0, hlit + 257) { i |
        if ll.len[i] != 0 {
            @println("litlen % %", i, ll.len[i]);
        }
    };
    
    // for distance alphabet
    d := stack_tree(32, 5);
    c.read_code_lengths(d.len, cl, hdist + 1);
    
    @if(INFGEN) range(0, hdist + 1) { i |
        if d.len[i] != 0 {
            @println("dist % %", i, d.len[i]);
        }
    };
    
    ll_codes := zeroed Array(u16, 286);  
    codes_from_lengths(ll);
    
    codes_from_lengths(d);
    
    // now read the actual compressed data
    c.read_block(ll, d);
}

read_block :: fn(c: *Cursor, ll: *Tree, d: *Tree) void = {  // 3.2.5.
    loop {
        ll_code := c.read_symbol(ll);
        if ll_code < 256 {
            c.yield_byte(ll_code.trunc());
        } else {
            @if(ll_code == 256)return();

            ll_index: i64 = ll_code.zext() - 257;
            extra_bits_needed := ll_extra[ll_index];
            extra := c.get_bits(extra_bits_needed.zext());
            length := extra + ll_base[ll_index].zext();
            
            d_index: i64 = c.read_symbol(d).zext();
            extra_bits_needed := d_extra[d_index];
            extra := c.get_bits(extra_bits_needed.zext());
            distance := extra + d_base[d_index].zext();
            
            i := c.j - distance;
            @debug_assert_ge(i, 0);  // TODO: error
            range(0, length) { _ |
                @assert(i < c.j);
                c.yield_byte(c.correct_output[i]);
                i += 1;
            };
        };
    };
}

read_code_lengths :: fn(c: *Cursor, lengths: []u8, tree: *Tree, count: i64) void = {
    i := 0;
    lengths[0] = 0;  // TODO: are they allowed to do 16 as the first item? i guess you'd always just use 17/18
    while => i < count {
        s := c.read_symbol(tree);
        (n: i64, value: u8) := @switch(s) {
            @case(16) => (c.get_bits(2) + 3, lengths[i - 1]);
            @case(17) => (c.get_bits(3) + 3, 0);
            @case(18) => (c.get_bits(7) + 11, 0);
            @default => {
                @debug_assert(s < 16);
                (1, s.trunc())
            };
        };
        range(0, n) { _ |
            lengths[i] = value;
            i += 1;
        };
    };
}

read_symbol :: fn(c: *Cursor, tree: *Tree) u16 = {
    node := tree.node[0]&;
    while => node.value == UNUSED_CODE {
        bit := c.get_bits(1);
        index: i64 = node.next&[bit].zext();
        @debug_assert_ne(index, UNUSED_CODE);  // TODO: error
        node = tree.node[index]&;
    };
    node.value
}

// symbols are 0-287 so codes need 9 bits? but somehow no....
codes_from_lengths :: fn(tree: *Tree) void = {  // 3.2.2.
    // 1)
    bl_count := zeroed Array(u16, MAX_BITS+1);
    i := 0;
    for tree.len { l |
        bl_count&[l.zext()] += 1;
        i += 1;
    };
    
    // 2)
    code: u16 = 0;
    bl_count&[0] = 0;
    MAX_BITS :: 15;
    next_code := zeroed Array(u16, MAX_BITS+1);
    range(1, MAX_BITS+1) { bits |
        code = (code + bl_count&[bits-1]).shift_left(1);
        next_code&[bits] = code;
    }
    
    // 3)
    max_code := tree.len.len-1;
    range(0, max_code + 1) { n |
        len: i64 = tree.len[n].zext();
        if len != 0 {
            tree.code[n] = next_code&[len];
            next_code&[len] += 1;
        } else {
            tree.code[n] = UNUSED_CODE;
        }
    }
    
    range(0, max_code + 1) { n |
        if tree.code[n] != UNUSED_CODE {
            @debug_assert_lt(tree.code[n], 1.shift_left(tree.len[n].zext()));
        }
    }
    
    fill_tree(tree);
}

fill_tree :: fn(tree: *Tree) void = {
    count := 1;
    tree.node[0] = (value = UNUSED_CODE, next = (UNUSED_CODE, UNUSED_CODE));
    range(0, tree.code.len) { i |
        if tree.len[i] != 0 {
            bit :: fn(bi) i64 => 
                tree.code[i].zext().shift_right_logical(tree.len[i].zext() - bi - 1).bit_and(1);
            index := 0;
            range(0, tree.len[i].zext()) { bi |
                link := tree.node[index].next&[bit(bi)]&;
                if link[] == UNUSED_CODE {
                    link[] = count.trunc();
                    tree.node[count] = (value = UNUSED_CODE, next = (UNUSED_CODE, UNUSED_CODE));
                    count += 1;
                };
                index = link[].zext();
                @debug_assert_eq(tree.node[index].value, UNUSED_CODE, "double used index %", index);
            };
            tree.node[index].value = i.trunc();
        }
    };
    @debug_assert(count < 0xFFFF && count <= tree.node.len);
    tree.n = count;
} 

UNUSED_CODE :: 0xFFFF;

yield_byte :: fn(c: *Cursor, value: u8) void #inline = {
    @assert_eq(c.correct_output[c.j], value, "wrong output[%]", c.j);
    c.j += 1;
}

Tree :: @struct {
    code: []u16;
    len: []u8;
    node: []Node;
    n := 0;
    
    Node :: @struct {
        next: Array(u16, 2);
        value: u16;
    };
};

stack_tree :: fn($n: i64, $nbit: i64) *Tree #inline/*semantic*/ = @ref @as(Tree) (
    len = items(@ref(zeroed Array(u8, n))),
    code = items(@ref(zeroed Array(u16, n))),
    node = { ::Array(Tree.Node, n*2); items(@ref(zeroed Array(Tree.Node, 1.shift_left(nbit+1)))) },
);

alloc_tree :: fn(n: i64, a: Alloc) Tree = (
    len = a.alloc_zeroed(u8, n),
    code = a.alloc_zeroed(u16, n),
    node = a.alloc_zeroed(Tree.Node, n*2),
);

Cursor :: @struct {
    in: []u8;
    i: i64;
    correct_output: []u8;
    j: i64;
};

// least signifigant bit of the input byte is taken first 
// ?? and is the least signifigant bit of the result. 
fn get_bits(c: *Cursor, n: i64) i64 = {
    @debug_assert_ult(n, 64-8);
    byte_i, bit_i := c.i.div_mod(8);
    @debug_assert_ule(c.i + n, c.in.len * 8);
    // safety: this reads out of bounds (at the end if in.len is not a multiple of 8) but masks off the extra. 
    //         so only a problem if we're at the end of a page and the next one is unmapped. 
    word := bit_cast_unchecked(*u8, *i64, c.in.ptr.offset(byte_i))[];  // :endian :alignment
    word := word.shift_right_logical(bit_i);  // throw out already consumed bits
    word := word.bit_and(1.shift_left(n) - 1); // mask out extra bits
    c.i += n;
    word
}

fn skip_to_full_byte(c: *Cursor) void = {
    c.i = c.i.align_to(8);
}

ll_fixed :: @static(Tree) {
    it := alloc_tree(288, ast_alloc());
    
    it.len.slice(0, 143+1).set_bytes(8);
    it.len.slice(144, 255+1).set_bytes(9);
    it.len.slice(256, 279+1).set_bytes(7);
    it.len.slice(280, 287+1).set_bytes(8);
    
    codes_from_lengths(it&);
    it.node.len = it.n;
    it
};

// this is dumb but makes it more consistant 
d_fixed :: @static(Tree) {
    it := alloc_tree(32, ast_alloc());
    it.len.set_bytes(5);
    enumerate it.code { i, it |
        it[] = i.trunc();
    };
    fill_tree(it&);
    it.node.len = it.n;
    it
}

// tables pasted from the spec. 
// TODO: little program that dumps them as ascii art so you can diff it with the rfc trivially. just for sanity. 
ll_extra :: @const_slice(@as(u8) 0,0,0,0,0,0,0,0, 1,1,1,1, 2,2,2,2, 3,3,3,3, 4,4,4,4, 5,5,5,5, 0);
ll_base :: @const_slice(@as(u16) 
    3,4,5,6,7,8,9,10,11,13, 
    15,17,19,23,27,31,35,43,51,59, 
    67,83,99,115,131,163,195,227,258,
);
d_extra :: @const_slice(@as(u8) 0,0,0,0, 1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7, 8,8, 9,9, 10,10, 11,11, 12,12, 13,13);
d_base :: @const_slice(@as(u16)
    1,2,3,4,5,7,9,13,17,25,
    33,49,65,97,129,193,257,385,513,769,
    1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,
);
code_length_alphabet :: @const_slice(@as(u8) 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);  
