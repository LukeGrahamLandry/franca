// https://www.ietf.org/rfc/rfc1951.txt

// warning: some malicious input will bounds check fail instead of returning an error
Error :: @enum(Ok, BlockType3, CorruptNLen, BackTooFar, BadDynamicHeader);

// returns number of consumed bytes so you can read a footer if your format has one. 
decompress :: fn(in: []u8, out: *List(u8)) Ty(i64, Error) = {
    ::enum(Error);
    c: Cursor = (in = in, i = 0, out = out, start = out.len); c := c&;
    final := 0;
    while => final != 1 {
        final = c.get_bits(1);
        btype_rev := c.get_bits(2);
        @if(INFGEN && final == 1) println("final");
        err := @switch(btype_rev) {
            @case(0) => c.noncompressed_block();
            @case(1) => c.fixed_block();
            @case(2) => c.dynamic_block();
            @case(3) => .BlockType3;
            @default => unreachable();
        };
        if err != .Ok {
            return(c.i, err);
        };
    };
    (c.i.align_to(8)/8, .Ok)
}

noncompressed_block :: fn(c: *Cursor) Error = {  //  3.2.4. 
    c.i = c.i.ualign_to(8);
    len := c.get_bits(16);
    nlen := c.get_bits(16);
    @if(len != nlen.bit_xor(0xFFFF)) return(.CorruptNLen);
    bytes := c.in.subslice(c.i.udiv(8), len);
    c.out.push_all(bytes);
    c.i += len * 8;
    .Ok
}

// TODO: i haven't actually tested this code path. does anything actually output files that use it? 
fixed_block :: fn(c: *Cursor) Error = {  // 3.2.6.
    c.read_block(ll_fixed, d_fixed)
}

dynamic_block :: fn(c: *Cursor) Error = {  // 3.2.7.
    @if(INFGEN) println("dynamic");
    
    hlit := c.get_bits(5) + 257;
    hdist := c.get_bits(5) + 1;
    hclen := c.get_bits(4) + 4;
    @if(!(hlit <= 286 && hdist <= 32 && hclen <= 19)) return(.BadDynamicHeader);
    
    // need to read the code-lengths that will be used to decode the data, 
    // but those code-lengths are also huffman-coded, 
    // so read another set of code-lengths used to decode the code-lengths. 

    alphabet :: code_length_alphabet;
    cl := stack_tree(alphabet.len(), 5);  // code lengths
    cl.len.set_zeroed();  // the data is sparse
    range(0, hclen) { i |
        cl.len[alphabet[i].zext()] = c.get_bits(3).trunc();
    };
    build_tree(cl, alphabet.len());
    
    // TODO: tighter bound than 750KB of stack? (but it's uninitialized so it doesn't actually matter)
    ll := c.read_tree(286, MAX_BITS, cl, hlit, "litlen");  // length/literal
    d := c.read_tree(32, 5, cl, hdist, "dist");  // distance
    c.read_block(ll, d)
}

read_tree :: fn(c: *Cursor, $n: i64, $nbit: i64, cl: *Tree, count: i64, label: Str) *Tree #inline/*semantic*/ = {
    t := stack_tree(n, nbit);
    c.read_code_lengths(t.len, cl, count);
    debug_log_lengths(t, count, label);
    build_tree(t, count);
    t
}

read_block :: fn(c: *Cursor, ll: *Tree, d: *Tree) Error = {  // 3.2.5.
    loop {
        ll_code := c.read_symbol(ll);
        if ll_code < 256 {
            c.out.push(ll_code.trunc());
        } else {
            @if(ll_code == 256) return(.Ok);

            @debug_assert(ll_code <= 285);  // TODO: error
            length := c.read_extra_bits(ll_code - 257, ll_extra, ll_base);
            d_code := c.read_symbol(d);
            @debug_assert(d_code <= 29);  // TODO: error
            distance := c.read_extra_bits(d_code, d_extra, d_base);
            
            i := c.out.len - c.start - distance;
            @if(i < c.start) return(.BackTooFar);
            @if(INFGEN) @println("match % %", length, distance);
           
            // note: the copy is allowed to overlap the new bytes it writes.  
            c.out.reserve(length);
            dest := c.out.len;
            c.out.len += length;
            range(0, length) { j |
                c.out[dest+j] = c.out[i+j];
            };
        };
    };
}

read_extra_bits :: fn(c: *Cursor, code: u16, extra: []u8, base: []u16) i64 #inline = {
    i: i64 = code.zext();
    base[i].zext() + c.get_bits(extra[i].zext())
}

read_code_lengths :: fn(c: *Cursor, lengths: []u8, tree: *Tree, count: i64) void = {
    i := 0;
    lengths[0] = 0;  // TODO: are they allowed to do 16 as the first item? i guess you'd always just use 17/18
    while => i < count {
        s := c.read_symbol(tree);
        (n: i64, value: u8) := @switch(s) {
            @case(16) => (c.get_bits(2) + 3, lengths[i - 1]);
            @case(17) => (c.get_bits(3) + 3, 0);
            @case(18) => (c.get_bits(7) + 11, 0);
            @default => {
                @debug_assert(s < 16);
                (1, s.trunc())
            };
        };
        range(0, n) { _ |
            lengths[i] = value;
            i += 1;
        };
    };
}

read_symbol :: fn(c: *Cursor, tree: *Tree) u16 = {
    node := tree.node[0]&;
    while => node.value == BLANK {
        bit := c.get_bits(1);
        index: i64 = node.next&[bit].zext();
        @debug_assert_ne(index, BLANK, "invalid tree. every bit pattern should be used");
        node = tree.node[index]&;
    };
    node.value
}

build_tree :: fn(tree: *Tree, count: i64) void = {
    codes_from_lengths(tree, count);
    fill_tree(tree, count);
}

codes_from_lengths :: fn(tree: *Tree, count: i64) void = {  // 3.2.2.
    // 1)
    bl_count := zeroed Array(u16, MAX_BITS+1);
    i := 0;
    for tree.len.slice(0, count) { l |
        bl_count&[l.zext()] += 1;
        i += 1;
    };
    
    // 2)
    code: u16 = 0;
    bl_count&[0] = 0;
    next_code := zeroed Array(u16, MAX_BITS+1);
    range(1, MAX_BITS+1) { bits |
        code += bl_count&[bits-1];
        code = code.shift_left(1);
        next_code&[bits] = code;
    }
    
    // 3)
    range(0, count) { n |
        len: i64 = tree.len[n].zext();
        if len != 0 {
            tree.code[n] = next_code&[len];
            @debug_assert_lt(tree.code[n], 1.shift_left(len));
            next_code&[len] += 1;
        } else {
            tree.code[n] = 0;
        };
    }
}

MAX_BITS :: 15;  // sizes the encoding in 3.2.7 can express: ll/d: 0-15, cl:0-7 

// you could inline this together with codes_from_lengths and not coonstruct the array of codes in the middle, 
// but this isn't the slow part and doing it split this way makes it more clear that codes_from_lengths 
// is directly lifted from the rfc so its easy to verify that part. 
fill_tree :: fn(tree: *Tree, n: i64) void = {
    count := 1;
    tree.node[0] = (value = BLANK, next = (BLANK, BLANK));
    range(0, n) { i |
        length: i64 = tree.len[i].zext();
        if length != 0 {
            bit :: fn(bi) i64 => 
                tree.code[i].zext().shift_right_logical(length - bi - 1).bit_and(1);
            
            index := 0;
            range(0, length) { bi |
                link := tree.node[index].next&[bit(bi)]&;
                if link[] == BLANK {
                    // (count<tree.node.len) because i wildly over estimate based on max path length. 
                    link[] = count.trunc();
                    tree.node[count] = (value = BLANK, next = (BLANK, BLANK));
                    count += 1;
                };
                index = link[].zext();
                @debug_assert_eq(tree.node[index].value, BLANK, "double used index %", index);
            };
            tree.node[index].value = i.trunc();
        }
    };
    
    tree.node.len = count;
    // don't need these anymore
    tree.len.len = 0;
    tree.code.len = 0;
    
    // check you can't fall off the tree. 
    // TODO: error if they gave lengths that don't work?
    // TODO: is it allowed to have one leaf so there'd be a blank slot? 
    //       yes. TODO: find a test file that does that. 
    @debug_assert(count < 0xFFFF);
    each tree.node { it |
        l, r := (it.next&[0], it.next&[1]);
        if it.value != BLANK {
            @debug_assert(l == r && r == BLANK);
        } else {
            @debug_assert(l != BLANK && r != BLANK && l != r);
        }
    };
} 

BLANK :: 0xFFFF;

// <len> is used to build <code> which is used to build <node> which is used to decode
Tree :: @struct {
    len: []u8;
    code: []u16;
    node: []Node;
    
    Node :: @struct {
        next: Array(u16, 2);
        value: u16;
    };
};

// TODO: choose the length of node array better
stack_tree :: fn($n: i64, $nbit: i64) *Tree #inline/*semantic*/ = 
    @ref alloc_tree(n, nbit, Arena'stack_alloc(n*3 + size_of(Tree.Node)*(1.shift_left(nbit+1))));

alloc_tree :: fn(n: i64, nbit: i64, a: Alloc) Tree = (
    len = a.alloc_uninit(u8, n),
    code = a.alloc_uninit(u16, n),
    node = a.alloc_uninit(Tree.Node, 1.shift_left(nbit+1)),
);

Cursor :: @struct {
    in: []u8;
    i: i64;
    out: *List(u8);
    start: i64;
};

// TODO: error if run out of input
// least signifigant bit of the input byte is taken first 
get_bits :: fn(c: *Cursor, n: i64) i64 = {
    @debug_assert_ule(c.i + n, c.in.len * 8);
    byte_i, bit_i := c.i.udiv_mod(8);
    // safety: this reads out of bounds (at the end if in.len is not a multiple of 8) but masks off the extra. 
    //         so only a problem if we're at the end of a page and the next one is unmapped. 
    word := bit_cast_unchecked(*u8, *i64, c.in.ptr.offset(byte_i))[];  // :endian :alignment
    word := word.shift_right_logical(bit_i);  // throw out already consumed bits
    word := word.bit_and(1.shift_left(n) - 1); // mask out extra bits
    c.i += n;
    word
}

// for debugging, print log messages in the same format as https://github.com/madler/infgen
INFGEN :: false;

debug_log_lengths :: fn(tree: *Tree, count: i64, label: Str) void = @if(INFGEN) {
    range(0, count) { i |
        if tree.len[i] != 0 {
            @println("% % %", label, i, tree.len[i]);
        }
    };
};

// TODO: if people mostly don't use these, compute them at runtime 
//       the first time they're needed instead of including them in the binary

ll_fixed :: @static(Tree) {  // 3.2.6.
    it := alloc_tree(288, MAX_BITS, ast_alloc());
    
    it.len.slice(0, 143+1).set_bytes(8);
    it.len.slice(144, 255+1).set_bytes(9);
    it.len.slice(256, 279+1).set_bytes(7);
    it.len.slice(280, 287+1).set_bytes(8);
    
    build_tree(it&, 288);
    it
};

// this is dumb but makes it more consistant 
d_fixed :: @static(Tree) {
    it := alloc_tree(32, 5, ast_alloc());
    it.len.set_bytes(5);
    enumerate it.code { i, it |
        it[] = i.trunc();
    };
    fill_tree(it&, it.len.len);
    it
}

// TODO: little program that dumps them as ascii art so you can diff it with the rfc trivially. just for sanity. 
// 3.2.5. 
ll_extra :: @const_slice(@as(u8) 0,0,0,0,0,0,0,0, 1,1,1,1, 2,2,2,2, 3,3,3,3, 4,4,4,4, 5,5,5,5, 0);
ll_base :: @const_slice(@as(u16) 
    3,4,5,6,7,8,9,10,11,13, 
    15,17,19,23,27,31,35,43,51,59, 
    67,83,99,115,131,163,195,227,258,
);
d_extra :: @const_slice(@as(u8) 0,0,0,0, 1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7, 8,8, 9,9, 10,10, 11,11, 12,12, 13,13);
d_base :: @const_slice(@as(u16)
    1,2,3,4,5,7,9,13,17,25,
    33,49,65,97,129,193,257,385,513,769,
    1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,
);
code_length_alphabet :: @const_slice(@as(u8) 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);  
