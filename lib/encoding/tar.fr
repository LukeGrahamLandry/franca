// https://www.gnu.org/software/tar/manual/html_node/Standard.html

Header :: @struct {
    name: Array(u8, 100);
    mode: Array(u8, 8);
    uid: Array(u8, 8);
    gid: Array(u8, 8);
    size: Array(u8, 12);
    mtime: Array(u8, 12);
    chksum: Array(u8, 8);
    typeflag: u8;
    linkname: Array(u8, 100);
    magic: Array(u8, 6);
    version: Array(u8, 2);
    uname: Array(u8, 32);
    gname: Array(u8, 32);
    devmajor: Array(u8, 8);
    devminor: Array(u8, 8);
    prefix: Array(u8, 155);
    twelve: Array(u8, 12);
};

Error :: @enum(Truncated, BadOctalSize, FirstMagicNotUstar);

iter :: fn(in: []u8, $body: @Fn(h: *Header, contents: []u8) void) Result(i64, Error) = {
    S :: size_of(Header);
    @run @assert_eq(S, 512);
    
    @if(in.len < size_of(Header)) return(Err = .FirstMagicNotUstar);
    magic := in.peek_type(Header)[].magic&.items().slice(0, 5);
    @if(magic != "ustar") return(Err = .FirstMagicNotUstar);
    
    i := 0;
    while => i + S <= in.len {
        header := in.rest(i).peek_type(Header);
        i += S;
        size := as_octal(header.size&);
        size := size || {
            if i + S <= in.len {
                two_blocks := in.slice(i - S, i + S);
                if is_all_zeroes(two_blocks) {
                    return(Ok = i + S);  // end marker
                };
            };
            return(Err = .BadOctalSize)
        };
        if i + size > in.len {
            return(Err = .Truncated);
        };
        body(header, in.subslice(i, size));
        i += size.align_to(S);
    };
    (Ok = i.min(in.len))
}

// leading ascii zeros and null terminator
as_octal :: fn(bytes: ~T) ?i64 #where = {
    bytes: []u8 = bytes.items();
    value, rest := convert_number_dyn(bytes, 8);
    if rest.len != 1 || bytes[bytes.len - rest.len] != 0 {
        return(.None);
    };
    (Some = value)
}

TYPE :: @struct {
    REG :: "0".ascii();
    SYM :: "2".ascii(); 
    DIR :: "5".ascii(); 
    PAX :: 55;
    PAX2 :: 103;
};
