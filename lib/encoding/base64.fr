
// TODO: return error on invalid input
fn base64_decode(out: *List(u8), b64: Str) void = {
    @assert_eq(b64.len.mod(4), 0, "padding is required");
    out.reserve(b64.len / 4 * 3);
    i := 0;
    while => i + 4 <= b64.len {
        chunk(out, b64, i);
        i += 4;
    };
    out.len -= int(b64.ends_with("=="));
    out.len -= int(b64.ends_with("="));
    
    chunk :: fn(out: *List(u8), b64: []u8, i: i64) void #inline = {
        operator_index :: index_unchecked;
        v := b64[i+3].char()
            .bit_or(b64[i+2].char().shift_left(6))
            .bit_or(b64[i+1].char().shift_left(12))
            .bit_or(b64[i+0].char().shift_left(18));
        out.push_assume_capacity(v.shift_right_logical(16).trunc());
        out.push_assume_capacity(v.shift_right_logical(8).trunc());
        out.push_assume_capacity(v.trunc());
    }
    char :: fn(c: u8) i64 = {
        operator_index :: index_unchecked;
        table :: ast_alloc().alloc_init(u8, 255, fn(i) => char_calc(i.trunc()));
        table[c.zext()].zext()
    }
    char_calc :: fn(c: u8) u8 = {
        @if(c >= "A".ascii() && c <= "Z".ascii()) return((c - "A".ascii()) + 0);
        @if(c >= "a".ascii() && c <= "z".ascii()) return((c - "a".ascii()) + 26);
        @if(c >= "0".ascii() && c <= "9".ascii()) return((c - "0".ascii()) + 52);
        @if(c == "+".ascii()) return(62);
        @if(c == "/".ascii()) return(63);
        0
    };
}
