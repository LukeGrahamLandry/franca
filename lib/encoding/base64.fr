
// TODO: return error on invalid input
fn base64_decode(out: *List(u8), b64: Str) void = {
    @assert_eq(b64.len.mod(4), 0, "padding is required");
    out.reserve(b64.len / 4 * 3);
    i := 0;
    while => i + 4 <= b64.len {
        chunk(out, b64, i);
        i += 4;
    };
    out.len -= int(b64.ends_with("=="));
    out.len -= int(b64.ends_with("="));
    
    chunk :: fn(out: *List(u8), b64: []u8, i: i64) void #inline = {
        operator_index :: index_unchecked;
        v := b64[i+3].char()
            .bit_or(b64[i+2].char().shift_left(6))
            .bit_or(b64[i+1].char().shift_left(12))
            .bit_or(b64[i+0].char().shift_left(18));
        out.push_assume_capacity(v.shift_right_logical(16).trunc());
        out.push_assume_capacity(v.shift_right_logical(8).trunc());
        out.push_assume_capacity(v.trunc());
    }
    char :: fn(c: u8) i64 = {
        operator_index :: index_unchecked;
        table :: ast_alloc().alloc_init(u8, 255, fn(i) => char_calc(i.trunc()));
        table[c.zext()].zext()
    }
    char_calc :: fn(c: u8) u8 = {
        @if(c >= "A".ascii() && c <= "Z".ascii()) return((c - "A".ascii()) + 0);
        @if(c >= "a".ascii() && c <= "z".ascii()) return((c - "a".ascii()) + 26);
        @if(c >= "0".ascii() && c <= "9".ascii()) return((c - "0".ascii()) + 52);
        @if(c == "+".ascii()) return(62);
        @if(c == "/".ascii()) return(63);
        0
    };
}

encode :: fn(out: *List(u8), in: []u8) void = {
    out.reserve((in.len * 4).ualign_to(3) / 3);
    alphabet := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    while => in.len >= 3 {
        v: i64 = in[2].zext()
            .bit_or(in[1].zext().shift_left(8))
            .bit_or(in[0].zext().shift_left(16));
        in = in.rest(3);
        push(v, 4, 1);
    };
    push :: fn(v, $N, $O) => {
        inline_range(0, N) { i |
            i := v.shift_right_logical((N - i - O) * 6).bit_and(0b111111);
            out.push_assume_capacity(alphabet[i]);
        };
    };
    @switch(in.len) {
        @case(0) => return();
        @case(1) => {
            v: i64 = in[0].zext().shift_left(16);
            push(v, 2, -1);
            out.push_all("==");
        };
        @case(2) => {
            v: i64 = in[0].zext().shift_left(16)
                .bit_or(in[1].zext().shift_left(8));
            push(v, 3, 0);
            out.push_all("=");
        };
        @default => unreachable();
    };
}
