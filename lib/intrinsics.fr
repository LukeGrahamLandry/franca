//! These used to be just normal functions defined in the language that used inline assembly. 
//! Now they're implemented in the compiler, in the inst_intrinsic function of each backend. 
//! They behave like #inline functions: type checking, overloading, and function pointers work as normal. 
//! Some can be used by thier conventional infix operator syntax which the parser desugars to a function call to the intrinsic. 

fn add(a: i64, b: i64) i64 #intrinsic(.Add) #fold; // +
fn sub(a: i64, b: i64) i64 #intrinsic(.Sub) #fold; // -
fn mul(a: i64, b: i64) i64 #intrinsic(.Mul) #fold; // *
fn div(a: i64, b: i64) i64 #intrinsic(.Div) #fold; // /

fn eq(a: i64, b: i64) bool #intrinsic(.Eq) #fold; // ==
fn ne(a: i64, b: i64) bool #intrinsic(.Ne) #fold; // !=
fn le(a: i64, b: i64) bool #intrinsic(.Le) #fold; // <=
fn ge(a: i64, b: i64) bool #intrinsic(.Ge) #fold; // >=
fn lt(a: i64, b: i64) bool #intrinsic(.Lt) #fold; // <
fn gt(a: i64, b: i64) bool #intrinsic(.Gt) #fold; // >

fn shift_left(value: i64, shift_amount: i64) i64             #intrinsic(Intrinsic.ShiftLeft);
fn shift_right_logical(value: i64, shift_amount: i64) i64    #intrinsic(Intrinsic.ShiftRightLogical);
fn shift_right_arithmetic(value: i64, shift_amount: i64) i64 #intrinsic(Intrinsic.ShiftRightArithmetic);
fn bit_or(a: i64, b: i64) i64  #intrinsic(Intrinsic.BitOr);
fn bit_and(a: i64, b: i64) i64 #intrinsic(Intrinsic.BitAnd);
fn bit_xor(a: i64, b: i64) i64 #intrinsic(Intrinsic.BitXor);
fn bit_xor(a: u64, b: u64) u64 #intrinsic(Intrinsic.BitXor);

// These do nothing but llvm wants to know about it. 
fn int_from_rawptr(ptr: rawptr) i64 #intrinsic(Intrinsic.PtrToInt);
fn rawptr_from_int(ptr: i64) rawptr #intrinsic(Intrinsic.IntToPtr);

Intrinsic :: @enum(i64) (
    Add, Sub, Mul, Div,
    UDiv,
    FAdd, FSub, FMul, FDiv,
    ShiftLeft,
    ShiftRightLogical,
    ShiftRightArithmetic,
    BitAnd,
    BitOr,
    BitXor,
    Eq, Ne, Lt, Gt, Le, Ge,
    ULt, UGt, ULe, UGe,
    FEq, FNe, FLt, FGt, FLe, FGe,
    // First Single Argument
    BitNot,
    Trunc,
    ZeroExtend,
    SignExtend,
    FloatFromInt,
    IntFromFloat,
    ShrinkFloat,
    GrowFloat,
    IntToPtr, PtrToInt, // These do nothing but llvm gets super stressed out if you don't tell it what's going on. 
    FBitCast,
);

/*

fn bit_not(a: i64) i64         #intrinsic(Intrinsic.BitNot);

fn add(a: f64, b: f64) f64 #intrinsic(Intrinsic.FAdd);
fn sub(a: f64, b: f64) f64 #intrinsic(Intrinsic.FSub);
fn mul(a: f64, b: f64) f64 #intrinsic(Intrinsic.FMul);
fn div(a: f64, b: f64) f64 #intrinsic(Intrinsic.FDiv);
fn eq(a: f64, b: f64) bool #intrinsic(Intrinsic.FEq);
fn ne(a: f64, b: f64) bool #intrinsic(Intrinsic.FNe);
fn le(a: f64, b: f64) bool #intrinsic(Intrinsic.FLe);
fn ge(a: f64, b: f64) bool #intrinsic(Intrinsic.FGe);
fn lt(a: f64, b: f64) bool #intrinsic(Intrinsic.FLt);
fn gt(a: f64, b: f64) bool #intrinsic(Intrinsic.FGt);

fn trunc(v: u64) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: u32) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u64) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u64) u32 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u32) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u32 #intrinsic(Intrinsic.Trunc); 
fn trunc(v: u16) u8  #intrinsic(Intrinsic.Trunc);

fn zext(v: u32) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u8) u64  #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u32) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u8) u32  #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) u32 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u32) i64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) i64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: i32) i64 #intrinsic(Intrinsic.ZeroExtend);
fn intcast(v: i32) i64 #intrinsic(Intrinsic.SignExtend);
fn intcast(v: i64) i32 #intrinsic(Intrinsic.Trunc);

// preserves the value (not the bit pattern). rounds towards zero.
fn int(a: f64) i64 #intrinsic(Intrinsic.IntFromFloat);

// preserves the value (not the bit pattern). 
fn float(a: i64) f64 #intrinsic(Intrinsic.FloatFromInt);

// preserves the bit pattern (not the value)
fn bitcast(a: f64) i64 #intrinsic(Intrinsic.FBitCast);

// preserves the bit pattern (not the value)
fn bitcast(a: i64) f64 #intrinsic(Intrinsic.FBitCast);

fn cast(v: f64) f32 #intrinsic(Intrinsic.ShrinkFloat);
fn cast(v: f32) f64 #intrinsic(Intrinsic.GrowFloat);

fn offset(ptr: rawptr, bytes: i64) rawptr #intrinsic(Intrinsic.Add);
*/
