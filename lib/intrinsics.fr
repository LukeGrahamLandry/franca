fn add(a: i64, b: i64) i64 #intrinsic(Intrinsic.Add);
fn sub(a: i64, b: i64) i64 #intrinsic(Intrinsic.Sub);
fn mul(a: i64, b: i64) i64 #intrinsic(Intrinsic.Mul);
fn div(a: i64, b: i64) i64 #intrinsic(Intrinsic.Div);
fn eq(a: i64, b: i64) bool #intrinsic(Intrinsic.Eq);
fn ne(a: i64, b: i64) bool #intrinsic(Intrinsic.Ne);
fn le(a: i64, b: i64) bool #intrinsic(Intrinsic.Le);
fn ge(a: i64, b: i64) bool #intrinsic(Intrinsic.Ge);
fn lt(a: i64, b: i64) bool #intrinsic(Intrinsic.Lt);
fn gt(a: i64, b: i64) bool #intrinsic(Intrinsic.Gt);

fn shift_left(value: i64, shift_amount: i64) i64             #intrinsic(Intrinsic.ShiftLeft);
fn shift_right_logical(value: i64, shift_amount: i64) i64    #intrinsic(Intrinsic.ShiftRightLogical);
fn shift_right_arithmetic(value: i64, shift_amount: i64) i64 #intrinsic(Intrinsic.ShiftRightArithmetic);

fn bit_or(a: i64, b: i64) i64  #intrinsic(Intrinsic.BitOr);
fn bit_not(a: i64) i64         #intrinsic(Intrinsic.BitNot);
fn bit_and(a: i64, b: i64) i64 #intrinsic(Intrinsic.BitAnd);
fn bit_xor(a: i64, b: i64) i64 #intrinsic(Intrinsic.BitXor);
fn bit_xor(a: u64, b: u64) i64 #intrinsic(Intrinsic.BitXor);

fn add(a: f64, b: f64) f64 #intrinsic(Intrinsic.Add);
fn sub(a: f64, b: f64) f64 #intrinsic(Intrinsic.Sub);
fn mul(a: f64, b: f64) f64 #intrinsic(Intrinsic.Mul);
fn div(a: f64, b: f64) f64 #intrinsic(Intrinsic.Div);
fn eq(a: f64, b: f64) bool #intrinsic(Intrinsic.Eq);
fn ne(a: f64, b: f64) bool #intrinsic(Intrinsic.Ne);
fn le(a: f64, b: f64) bool #intrinsic(Intrinsic.Le);
fn ge(a: f64, b: f64) bool #intrinsic(Intrinsic.Ge);
fn lt(a: f64, b: f64) bool #intrinsic(Intrinsic.Lt);
fn gt(a: f64, b: f64) bool #intrinsic(Intrinsic.Gt);

fn trunc(v: u64) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: u32) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u8  #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u64) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u64) u32 #intrinsic(Intrinsic.Trunc);
fn trunc(v: u32) u16 #intrinsic(Intrinsic.Trunc);
fn trunc(v: i64) u32 #intrinsic(Intrinsic.Trunc); 
fn trunc(v: u16) u8  #intrinsic(Intrinsic.Trunc);

fn zext(v: u32) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u8) u64  #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u32) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u8) u32  #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) u32 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u32) i64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) i64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: u16) u64 #intrinsic(Intrinsic.ZeroExtend);
fn zext(v: i32) i64 #intrinsic(Intrinsic.ZeroExtend);
fn intcast(v: i32) i64 #intrinsic(Intrinsic.SignExtend);
fn intcast(v: i64) i32 #intrinsic(Intrinsic.Trunc);

// preserves the value (not the bit pattern). rounds towards zero.
fn int(a: f64) i64 #intrinsic(Intrinsic.IntFromFloat);

// preserves the value (not the bit pattern). 
fn float(a: i64) f64 #intrinsic(Intrinsic.FloatFromInt);

// preserves the bit pattern (not the value)
fn bitcast(a: f64) i64 #intrinsic(Intrinsic.BitCast);

// preserves the bit pattern (not the value)
fn bitcast(a: i64) f64 #intrinsic(Intrinsic.BitCast);

fn cast(v: f64) f32 #intrinsic(Intrinsic.ShrinkFloat);
fn cast(v: f32) f64 #intrinsic(Intrinsic.GrowFloat);

fn offset(ptr: rawptr, bytes: i64) rawptr #intrinsic(Intrinsic.Add);
fn int_from_rawptr(ptr: rawptr) i64       #intrinsic(Intrinsic.BitCast);
fn rawptr_from_int(ptr: i64) rawptr       #intrinsic(Intrinsic.BitCast);
