//! I have mixed feelings about this. It's a heavier runtime than I really want... 
//! but it makes debugging a hell of a lot less painful. 
//! 
//! For reference,
//! - libbacktrace 16k lines of c. 
//! - addr2line is 3k lines of rust... plus a 700 line lock file (including gimli for dwarf parsing, 42k lines).
//! Both rely on your executable having metadata in standard format (itanium c++ exception tables or dwarf debug info),
//! that is more complicated to generate than I'm willing to deal with (I could have llvm do it but that's still painful and I want to support many backends). 
//! I'm sure they solve a hard problem and solve it well/fast/whatever, but its clearly a more complicated problem than the one I have. 

RuntimeContext :: @struct(
    stack_trace: StackTraceNode,
    debug_info: GlobalDebugInfo,
    // This allows macros to invisibly call into the compiler. It will always be null at runtime.
    // comptime_compiler_ctx: rawptr,
    // temporary_allocator: Alloc,
    // reset_temporary_allocator: @FnPtr() void,
    // thread_id: i64,
    // panic_hook: @FnPtr(msg: Str) Never,
    // is_panicking: bool = false,
);

StackTraceNode :: (@struct(prev: ?*StackTraceNode, location: Location)!rec;
Location :: @struct(index: u32);

fn source_location() Location #macro;

_context :: @static(ImplicitContext);
fn get_context() *ImplicitContext #no_inline = _context;

fn caller_location() Location = {
    todo()
}

ColdSymbol :: @struct(id: u32);
LocationData :: @struct(
    line: u32, 
    col: u16, 
    file_index: u16, 
    enclosing_function: ColdSymbol, 
    code: ColdSymbol
);

GlobalDebugInfo :: @struct(
    locations: List(LocationData), // [Location]
    spans: List(Span),             // [Location]
    files: List(ColdSymbol),       // [file_index]
    cold_symbols: List(CStr),      // [ColdSymbol]
);
