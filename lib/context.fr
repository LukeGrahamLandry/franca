//! Your globals will be safe in the invisible hash table in the sky. 
//! This is mostly useful for letting me avoid implementing thread locals. 

// see threads/allocate_stack.
StaticTls :: @struct(
    comptime: rawptr,  // Will be null at runtime (unless you call into the compiler as a library). 
    reserved2 := 0,
    thread_index: i64,
    general_allocator: Alloc,  // this must be thread safe!
    current_os: u8,
    prefer_syscalls: bool,
    reserved: Array(i64, 2),
    environment_variables: *CStr,  // a null terminated array of null terminated strings
    cli_arguments: []CStr,
    // :UpdateBoot remove this field in favour of temporary_allocator_i
    temporary_allocator: *Arena.Allocator,  // each thread has its own
    panic_hook: @FnPtr(msg: Str) Never,
    extra := 0,
    global: *GlobalFrancaRuntime,
    temporary_allocator_i: Alloc,
    thread: rawptr,
    reserved3: Array(i64, 6),
);

franca_required_stack_bits :: 24;

// These are things that need to be inherited between compliation units. 
// ie. if comptime code starts a thread, its next_thread_id needs to continue 
//     from the compiler's, not reset at 1 or mutexes don't work. 
// note: this means you can't start threads from inside push_emergency_dynamic_environment()
// note: since this is in the environment, it doesn't get baked (unlike @static), 
//       instead franca_runtime_init sets up a new one if it thinks it can't inherit one from the host. 
GlobalFrancaRuntime :: @struct {
    next_thread_id: i64;
    green_threads: rawptr;  // lib/sys/sync/green.fr/Runtime (when SLOW_USERSPACE_THREADS=true)
    // TODO: crash_report RESOLVERS should be here too, 
    //       but the main place you want that is push_emergency_dynamic_environment. 
    //       maybe should have a static for saving the last globals pointer. 
    //       same idea as STASH_ENV but more official. 
};

// For AOT builds, the compiler generates a call to this as your program's main entry point. 
// note: whatever you had in the context at comptime is NOT baked into your program (unlike all other reachable memory).
// For jitted code, you inherit the compiler's context. (TODO: maybe that should only be for comptime/drivers)
// This also is not called for cached .frc programs run by the compiler (even though they're technically AOT too). 
franca_runtime_init :: fn(argc: i64, argv: *CStr, user: @FnPtr() void, envp: *CStr, kernel_sp: i64) void #no_trace = {
    // TODO: this will be wrong if you pass >4096 cli arguments
    is_sane_pointer :: fn(p: ~T) bool #where = {
        p := bit_cast_unchecked(@type p, i64, p);
        p > 4096 && p.shift_right_logical(48) == 0
    };
    ::ptr_utils(CStr);
    
    #use("@/lib/sys/process.fr");
    a := query_current_arch();
    // This is very fragile. relies on compiler/worker.fr/wrap_with_runtime_init and backend/<arch>/emit.fr
    if __driver_abi_version < 1349 {
        kernel_sp += @if(a == .aarch64, 0x40, @if(a == .rv64, 0x50, 0x48));
    } else {
        kernel_sp += @if(a == .aarch64, 0x30, @if(a == .rv64, 0x40, 0x38));
    };
    // note: kernel doesn't align sp to 16 but i have to allocate a new stack for tls anyway so it doesn't matter
    
    // TODO: this is probably a stupid idea. for now it feels clever that i can guess the os by apple passing the 
    //       normal c args to the entry point in registers and linux passing them on the stack. 
    //       super fragile to rely on nobody leaving junk in the registers for this. 
    is_linux := is_sane_pointer(argc) || !is_sane_pointer(envp) || !is_sane_pointer(argv);
    
    if is_linux && a != .wasm32 {
        entry_args_from_stack_linux(argc&, argv&, envp&, kernel_sp);
    } else {
        // if the args to main looked reasonable, assume we're in a hosted libc. 
        // which is always true on macos, and true on linux if we didn't make the exe ourself 
        // so the linker inserted an extra _start wrapper before calling our wrapper before calling this function. 
        // past the end of envp, linux has the auxiliary vector which is (key, value) pairs with the 
        // key seeming to be mostly low numbers. macos has more string pointers. 
        p := envp;
        while => !p.ptr.is_null() {
            p = p.offset(1);
        };
        p = p.offset(1);
        is_linux = !is_sane_pointer(p[]);
    };
    
    OS: Os = @if(is_linux, .linux, .macos);
    @if(query_current_arch() != .wasm32)
    @assert(!(is_sane_pointer(argc) || !is_sane_pointer(envp) || !is_sane_pointer(argv)), "failed to guess os");
    
    CAPTURE :: @static(@FnPtr() void);
    CAPTURE[] = user;
    
    // have_libc[] checks if relocations were successfully done, if not, clearly there's no dynamic loader and we can't use libc stuff. 
    have_libc :: @static(bool);
    
    impl2 :: fn() Never #no_trace = {
            thread := get_current_thread();
            c := thread.first_environment&;
            set_legacy_dynamic_environment(StaticTls.raw_from_ptr(c));
            temporary_allocator: Arena.Allocator = init(page_allocator, 1.shift_left(20));
            set_temporary_allocator(temporary_allocator&);
            c.panic_hook = print_and_exit1;
            c.global = @static(GlobalFrancaRuntime);
            c.global.next_thread_id = 1;  // :ThreadIdStartsAtOne
            c.prefer_syscalls = !have_libc[];
            c.thread = raw_from_ptr(@type thread[], thread);
            
            @if(SLOW_DEBUG_ALLOC, {
                general_allocator: import("@/lib/alloc/debug_alloc.fr").DebugAlloc = init();
                c.general_allocator = general_allocator&.borrow();
            }, {
                if have_libc[] && !NEVER_USE_LIBC_ALLOC {
                    c.general_allocator = libc_allocator;
                } else {
                    A :: import("@/lib/alloc/fixed_block.fr").BlockAlloc;
                    general_allocator: A = init(page_allocator);
                    c.general_allocator = general_allocator&.borrow();
                };
            });
            
            @if(use_threads) set_new_thread_id(c);
            
            @if(!TODOWASM || query_current_arch() != .wasm32)
            @if(!IS_BOOTSTRAPPING)  // :UpdateBoot
            if !have_libc[] && query_current_os() == .linux {
                do_relocations_static_linux();
            };
            
            @if(ALWAYS_BE_SIGNALLING) {
                C :: import("@/lib/crash_report.fr");
                C'request_backtrace_on_signal();
                C'request_backtrace_on_panic();
            };
            @if(SLOW_DEBUG_ALLOC) import("@/lib/crash_report.fr")'push_aot_debug_resolver();
            @if(SLOW_USERSPACE_THREADS, 
                import("@/lib/sys/sync/green.fr")'start_main_thread(CAPTURE[]),
                CAPTURE[]());
            temporary_allocator&.deinit(); // bleh, waste of time
            @if(SLOW_DEBUG_ALLOC) general_allocator().deinit();
            Syscall'exit(0);
    };
    
    @if(IS_BOOTSTRAPPING) {
        have_libc[] = true;
        stack := import("@/lib/sys/threads.fr")'allocate_stack(!have_libc[], OS);
        thread := bit_cast_unchecked(*u8, *import("@/lib/sys/threads.fr").Thread, stack.usable.ptr);
        thread.stack = stack;
        thread.first_environment.cli_arguments = (ptr = argv, len = argc);
        thread.first_environment.environment_variables = envp;
        thread.first_environment.current_os = (@as(i64) @as(Os) OS).trunc();
        call_in_stack(thread.stack.usable.end_pointer(), impl2);
    };

    // TODO: bring back the ability to ask for direct syscalls on macos, just as a fun trick as long as they don't change the abi.
    __libc_start_main :: fn(user: @FnPtr() Never, argc: i64, argv: *CStr, i: i64, f: i64, l: i64, s: i64) i64 #weak #libc;
    start := @as(rawptr) __libc_start_main;
    have_libc[] = !is_linux || !start.is_null();
    if query_current_arch() == .wasm32 {
        have_libc[] = false;  // ugh. null check doesn't work because weak imports aren't a thing, they're just stubs that crash. 
    };

    stack := import("@/lib/sys/threads.fr")'allocate_stack(!have_libc[], OS);
    thread := bit_cast_unchecked(*u8, *import("@/lib/sys/threads.fr").Thread, stack.usable.ptr);
    thread.stack = stack;
    thread.first_environment.cli_arguments = (ptr = argv, len = argc);
    thread.first_environment.environment_variables = envp;
    thread.first_environment.current_os = (@as(i64) @as(Os) OS).trunc();
    thread.stack_reserved_size = 1.shift_left(16);  // matters because examples/os uses after this as signal stack
    
    @if(!TODOWASM || query_current_arch() != .wasm32)
    if is_linux && have_libc[] {
        impl3 :: fn() Never #no_trace = {
            thread := get_current_thread();
            c := thread.first_environment.cli_arguments;
            __libc_start_main(impl2, c.len, c.ptr, 0, 0, 0, 0);
            unreachable()
        };
        // TODO: it's a concern that only the one that calls into libc needs extra padding to avoid junk addresses in the stack trace. 
        call_in_stack(thread.stack.usable.end_pointer().offset(-32), impl3);
    };
    
    call_in_stack(thread.stack.usable.end_pointer(), impl2);
    
    #use("@/backend/amd64/bits.fr");
    #use("@/backend/arm64/bits.fr");
    #use("@/backend/rv64/bits.fr");
    call_in_stack :: AsmFunction(fn(new_sp: *u8, callback: @FnPtr() Never) Never = (), @const_slice(
        add_im(.X64, sp, x0, @as(u12) 0, 0b0),
        movz(.X64, fp, 0, .Left0),
        movz(.X64, lr, 0, .Left0),  // noreturn
        br(x1, 0b0),
    ), fn(out: *List(u8)) => @asm_x64(  // rdi, rsi, rdx
        encode_bin(PrimaryOp.MovReg, X86Reg.rsp, X86Reg.rdi),
        encode_bin(PrimaryOp.XorReg, X86Reg.rbp, X86Reg.rbp),
        // note: not the no-push jmp because need to leave sp.mod(16)=8
        encode_call_reg(ModrmMode.Direct, X86Reg.rsi),
    ) out, fn(out: *List(u8)) => out.push_all(@slice(
        0x00, // 0 locals
        0x20, 0x00, // local.get(0)
        0xA7, // truncl
        0x24, 0x00, // global.set(0) stackbase
        0x20, 0x01, // local.get(1)
        0xA7, // truncl
        0x11, 0x00, 0x00, // call indirect :WasmTypeZeroIsVoidToVoid
        0x0B,  // end
    )), @const_slice(
        I(0, RvReg.A0.bits(), @as(u3) OpI.add, RvReg.SP.bits(), .op_imm),
        I(0, RvReg.Zero.bits(), @as(u3) OpI.add, RvReg.FP.bits(), .op_imm),
        I(0, RvReg.RA.bits(), @as(u3) OpI.add, RvReg.Zero.bits(), .op_imm),  // noreturn
        jalr(.A1, 0, .Zero),
    ));
};

// surely we don't need to call uname... right... right...?
fn query_current_os() Os = {
    @if(IS_BOOTSTRAPPING) return(Os.macos);
    @as(Os) @as(i64) tls(.current_os)[].zext()
}

//
// On macos (argc, argv) are passed to the entry point in registers so we're good to go. 
// But on linux, they're passed on the stack, so we have to grab them from our caller's frame. 
// see examples/elf_loader.fr/write_argc_argv_envp
//
// <low addresses>
// 
// (^^^ stack grows this way ^^^)
// [stack frame of user_main()]
// [stack frame of franca_runtime_init()]
// [stack frame of builtin_main()]
// argc  <- initial sp set by the kernel points here
// argv[0]
// ...
// argv[argc] = 0
// envp[0]
// ...
// envp[N] = 0
// aux key [0]
// aux val [0]
// ...
// aux key [M] = 0
// aux val [M] = 0
// 
// <high addresses>
//

fn entry_args_from_stack_linux(argc: *i64, argv: **CStr, envp: **CStr, sp: i64) void #inline = {
    caller_frame := ptr_from_int(Ty(i64, CStr), sp);
    argv[] = caller_frame._1&;
    argc[] = caller_frame._0;
    envp[] = argv[].offset(argc[] + 1);
}

// Don't try to do relocations when loaded from a .frc 
// TODO: better would be to give you the real base address and just have a fake elf header with no relocations. 
FRHOSTED_MAGIC :u64: 0x444554534F485246;

// On linux, if we're not linking to libc, we need to handle relocating pointers in static memory ourselves. 
// Since this runs before are done, you can't use anything with a pointer stored in @static memory in this function. 
// But calls and referencing symbols is fine because they use relative addressing. 
// Just no vtables. Alloc is fine because that's just a function pointer, not a pointer to a function pointer. 
do_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    // TODO: use (maybe backwards offset from) AT_PHDR instead of this symbol, 
    //       then it should work when going through a relocatable object as well
    base   := @import_symbol "__franca_base_address";
    if u64.ptr_from_raw(base)[] == FRHOSTED_MAGIC {
        return();
    }
    header := Elf.Header.ptr_from_raw(base);
    @debug_assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
        
    unpacked := Elf.DynUnpacked.zeroed();
    
    // TODO: it seems static elf doesn't require phdr (gcc doesn't put it but clang and i do) so think of a better way to do this. 
    @debug_assert(headers[0].type == .Phdr, "missing phdr");
    // skew != 0 requires PIC (which my compiler always outputs). 
    // on real linux skew==0 always if header.type==.Executable (you only get randomized if it says .Dynamic). 
    // my elf_loader always assumes PIC and puts you somewhere random. 
    requested_base := headers[0].vaddr - header.ehsize.zext();
    skew := base.int_from_rawptr() - requested_base;
    
    each headers { h |
        if h.type == .Dynamic {
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr + skew), len = h.mem_size / 16);
            unpacked = Elf'load_from_dynamic_header(dynamic);
        };
        // todo: this doesn't work for examples/os/user/init.fr
        // @debug_assert(h.type != .Interp, "asked for a dynamic loader (had Interp header) so why are we redoing relocations?");
    };
    
    ::ptr_utils(Elf.Symbol);
    unpacked.relocations.ptr = unpacked.relocations.ptr.offset_bytes(skew);
    each unpacked.relocations { it |
        @debug_assert(it.type == Elf.R_AMD64_64 || it.type == Elf.R_AARCH64_ABS64 || it.type == Elf.R_RISCV_64, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext()).offset_bytes(skew);
        dest := rawptr.ptr_from_raw(base.offset(it.offset - requested_base));
        if sym.value != 0 {
            dest[] = base.offset(sym.value).offset(it.addend - requested_base);
        } else {
            @debug_assert(sym.info.shift_right_logical(4) != Elf.STB_LOCAL);
        };
    };
};

__driver_abi_version :: @if(IS_BOOTSTRAPPING, 1119, __builtin_compiler_abi);

// :UpdateBoot
set_legacy_dynamic_environment :: fn(context: rawptr) void #inline/*semantic*/ = {
    @if(__driver_abi_version < 1512) {
        f :: fn(context: rawptr) i64 #intrinsic(INTRINSIC_SET_ENV);
        f(context);
    }
};

// :UpdateBoot
INTRINSIC_GET_ENV :: 64;
INTRINSIC_SET_ENV :: 65;

// TODO: the "tls" part should be at the end of the name so you can always search for "tls(.foo" to find all the places that access foo
fn push_tls_value($name: Fields(StaticTls), value: FieldType(StaticTls, name), $body: @Fn() void) void #generic = {
    it := tls(name);
    prev := it[];
    it[] = value;
    body();  // TODO: this should probably be @must_return
    it[] = prev;
}

push_as_tls :: push_tls_value;

fn tls($name: Fields(StaticTls)) *FieldType(StaticTls, name) #generic = {
    c := @if(__driver_abi_version < 1512, {
        f :: fn(_: i64) i64 #intrinsic(INTRINSIC_GET_ENV);
        f(0)
    }, {
        get_stack_base_for_tls()
    });

    c := StaticTls.ptr_from_int(c);
    StaticTls.get_field(c, name)
}

fn get_stack_base_for_tls() i64 = {
    // TODO: this generates dumb code because a gets a new slot each time its inlined and the backend doesn't know base is the same every time
    a := @uninitialized i64;
    i64.int_from_ptr(a&).bit_and(bit_not(1.shift_left(franca_required_stack_bits) - 1))
}

::if(rawptr);
fn scary_log(s: Str) void = {

    // force a jit-shim because write() has a weird dependency on @syscall
    //_ := Syscall'write(@as(Fd) (fd = 1), s.ptr, s.len);
    impl :: fn(s: Str) void = {
        _ := Syscall'write(@as(Fd) (fd = 1), s.ptr, s.len);
    };
    f: (@FnPtr(s: Str) void) = impl;
    f(s)
}

fn temp() Alloc = {
    @if(__driver_abi_version < 1263) return(tls(.temporary_allocator)[].borrow());
    tls(.temporary_allocator_i)[]
}

fn set_temporary_allocator(a: *Arena.Allocator) void #noinline /*:UpdateBoot*/ = {
    if __driver_abi_version < 1263 {
        tls(.temporary_allocator)[] = a;
    };
    tls(.temporary_allocator_i)[] = a.borrow();
}
    
fn general_allocator() Alloc = 
    tls(.general_allocator)[];

fn mark_temporary_storage() Alloc.Mark = 
    temp().mark();

fn reset_temporary_storage(mark: Alloc.Mark) void = 
    temp().reset(mark);
    
#inline #use("@/lib/sys/sync/atomics.fr") 
fn set_new_thread_id(ctx: *StaticTls) void = {
    ctx.thread_index = i64.atomic_inc(ctx.global.next_thread_id&);
}

// - We saved (argc, argv) from the entry point (but someone might have changed it in the context).  
// - The memory returned here is shared with other threads. So it's probably a bad plan to mutate it. 
fn cli_args() []CStr = {
    tls(.cli_arguments)[]
}

// - We saved (envp) from the entry point (but someone might have changed it in the context).  
// - Have to iterate every time you look something up, so if you want multiple you're better off writing the loop yourself. 
// - The memory returned here is shared with other threads. So it's probably a bad plan to mutate it. 
// - fn getenv(name: CStr) CStr #libc;
fn get_environment_variable(name: Str) ?CStr = {
    @if(IS_BOOTSTRAPPING) return(.None);
    envp := tls(.environment_variables)[];
    while => !envp[].ptr.is_null() {
        if starts_with(envp[], name) && envp[][name.len] == "=".ascii() {
            return(Some = (ptr = envp[].ptr.offset(name.len + 1)));
        };
        envp = envp.offset(1);
    };
    .None
}    
