//! Your globals will be safe in the invisible hash table in the sky. 
//! This is mostly useful for letting me avoid implementing thread locals. 

// A pointer to this struct is passed as a hidden parameter to (almost) every function. 
// (Soon you will be able to add your own things, to use this as tls).
DefaultContext :: @struct(
    comptime: rawptr,  // Will be null at runtime (unless you call into the compiler as a library). 
    reserved2 := 0,
    thread_index: i64,
    general_allocator: Alloc,  // this must be thread safe!
    current_os: u8,
    prefer_syscalls: bool,
    reserved: Array(i64, 2),
    environment_variables: *CStr,  // a null terminated array of null terminated strings
    cli_arguments: []CStr,
    temporary_allocator: *ArenaAlloc,  // each thread has its own
    panic_hook: @FnPtr(msg: Str) Never,
    extra := 0,
    reserved3: Array(i64, 10),
);

// this is set in franca_runtime_init and read in push_zeroed_dynamic_context
OS :: @static(ClearOnAotBake(Os)) (it = ComptimeEnvironment.ptr_from_raw(get_build_options()[].env)[].comptime_os);

// For AOT builds, the compiler generates a call to this as your program's main entry point. 
// note: whatever you had in the context at comptime is NOT baked into your program (unlike all other reachable memory).
// For jitted code, you inherit the compiler's context. (TODO: maybe that should only be for comptime/drivers)
// This also is not called for cached .frc programs run by the compiler (even though they're technically AOT too). 
franca_runtime_init :: fn(argc: i64, argv: *CStr, user: @FnPtr() void, envp: *CStr, four: *CStr) void = {
    // TODO: this will be wrong if you pass >4096 cli arguments
    is_sane_pointer :: fn(p: ~T) bool #where = {
        p := bit_cast_unchecked(@type p, i64, p);
        p > 4096 && p.shift_right_logical(48) == 0
    };
    ::ptr_utils(CStr);
    
    fp := align_stack();
    
    // If you pass a .frc file to the compiler directly, it assumes it's a driver so the first argument 
    // will be a *ImportVTable, and we can skip the runtime setup stuff and just inherit its panic handler, etc. 
    if is_sane_pointer(argc) {
        driver_vtable_magic_offset :: offset_of(ImportVTable, Fields(ImportVTable).magic);
        p := i64.ptr_from_int(argc + driver_vtable_magic_offset)[];
        if p == DRIVER_VTABLE_MAGIC {
            c := context(DefaultContext);
            OS[].it = @as(Os) @as(i64) c.current_os.zext();
            user();
            return();
        };
    };
    
    // TODO: this is probably a stupid idea. for now it feels clever that i can guess the os by apple passing the 
    //       normal c args to the entry point in registers and linux passing them on the stack. 
    //       super fragile to rely on nobody leaving junk in the registers for this. 
    is_linux := is_sane_pointer(argc) || !is_sane_pointer(envp) || !is_sane_pointer(argv);
    
    OS[].it = @if(is_linux, .linux, .macos);
    
    if is_linux {
        entry_args_from_stack_linux(argc&, argv&, envp&, fp);
        @assert(!(is_sane_pointer(argc) || !is_sane_pointer(envp) || !is_sane_pointer(argv)), "failed to guess os");
    };
    
    CAPTURE :: @static(@FnPtr() void);
    CAPTURE[] = user;
    
    impl2 :: fn(argc: i64, argv: *CStr, envp: *CStr) void = {
        push_zeroed_dynamic_context {   // for now this sets c.current_os=OS[]
            c := context(DefaultContext);
            temporary_allocator: ArenaAlloc = init(page_allocator, 1.shift_left(20));
            c.temporary_allocator = temporary_allocator&;
            c.panic_hook = print_and_exit1;
            @if(is_linking_libc(), {
                c.general_allocator = libc_allocator;
            }, {
                A :: import("@/lib/alloc/fixed_block.fr").BlockAlloc;
                general_allocator: A = init(page_allocator);
                c.general_allocator = general_allocator&.borrow();
            });
            c.cli_arguments = (ptr = argv, len = argc);
            c.environment_variables = envp;
            @if(use_threads) set_new_thread_id(c);
            
            @if(!IS_BOOTSTRAPPING)  // :UpdateBoot
            if !is_linking_libc() && query_current_os() == .linux {
                do_relocations_static_linux();
            };
            
            @if(ALWAYS_BE_SIGNALLING) {
                C :: import("@/lib/crash_report.fr");
                C'request_backtrace_on_signal();
                C'request_backtrace_on_panic();
            };
            CAPTURE[]();
            temporary_allocator&.deinit(); // bleh, waste of time
            Syscall'exit(0);
        };
    };

    @if(!IS_BOOTSTRAPPING)
    if is_linux && is_linking_libc() {
        // TODO: the NOSYS is a HACK to make -syscalls make a real static binary
        //       alternative is to keep is_linking_libc() foldable but the point of my current project is to make everything more dynamic so you don't have to recompile. 
        __libc_start_main :: fn(user: @FnPtr(argc: i64, argv: *CStr, envp: *CStr) void, argc: i64, argv: *CStr, i: i64, f: i64, l: i64) i64 #weak #libc #syscall(NOSYS, NOSYS, NOSYS);
        __libc_start_main(impl2, argc, argv, 0, 0, 0);
        unreachable();
    };
    
    impl2(argc, argv, envp);
};

// surely we don't need to call uname... right... right...?
fn query_current_os() Os = {
    @if(IS_BOOTSTRAPPING) return(Os.macos);
    @as(Os) @as(i64) context(DefaultContext)[].current_os.zext()
}

// On macos (argc, argv) are passed to the entry point in registers so we're good to go. 
// But on linux, they're passed on the stack, so we have to grab them from our caller's frame. 
// Also on linux glib expects the stack to be 16 byte aligned but the kernel doesn't do that for you. 
//
// The forced #inline is important! We need this call to not fuck with the stack. 
fn align_stack() i64 #inline = {
    // TODO: start_trace
    #use("@/backend/amd64/bits.fr");
    #use("@/backend/arm64/bits.fr");
    
    get_fp :: AsmFunction(fn() i64 = (), {
        @const_slice(mov(Bits.X64, x0, fp), ret())
    }) { (out: *List(u8)) |
        @asm_x64(encode_bin(PrimaryOp.MovReg, X86Reg.rax, X86Reg.rbp), PrimaryOp.Ret) out;
    };
    
    fix_stack :: AsmFunction(fn() void = (), {
        @const_slice(ret(),ret())  // hopefully unreachable. i think the stack alignment hting is much more strict on arm. 
    }) { (out: *List(u8)) | @asm_x64(
        // We just want to sub 8 from sp but we have to return by popping something off the stack. 
        encode_op_reg(PrimaryOp.PopBase, X86Reg.rax),
        encode_op_reg(PrimaryOp.PushBase, X86Reg.rax),
        encode_op_reg(PrimaryOp.PushBase, X86Reg.rax), 
        PrimaryOp.Ret,
    ) out;};
    
    s := get_fp();
    @debug_assert_eq(s.mod(8), 0);
    if s.mod(16) != 0 {
        fix_stack();
    };
    s
}

fn entry_args_from_stack_linux(argc: *i64, argv: **CStr, envp: **CStr, fp: i64) void #inline = {
    caller_frame := ptr_from_int(*Ty(i64, i64, CStr), fp)[];
    argv[] = caller_frame._2&;
    argc[] = caller_frame._1;
    envp[] = argv[].offset(argc[] + 1);
}

// Don't try to do relocations when loaded from a .frc 
// TODO: better would be to give you the real base address and just have a fake elf header with no relocations. 
FRHOSTED_MAGIC :u64: 0x444554534F485246;

// On linux, if we're not linking to libc, we need to handle relocating pointers in static memory ourselves. 
// Since this runs before are done, you can't use anything with a pointer stored in @static memory in this function. 
// But calls and referencing symbols is fine because they use relative addressing. 
// Just no vtables. Alloc is fine because that's just a function pointer, not a pointer to a function pointer. 
do_relocations_static_linux :: fn() void = {
    Elf :: import("@/backend/elf/bits.fr");
    base   := @import_symbol "__franca_base_address";
    if u64.ptr_from_raw(base)[] == FRHOSTED_MAGIC {
        return();
    }
    header := Elf.Header.ptr_from_raw(base);
    @debug_assert_eq(header.magic, Elf.MAGIC, "we're not in an elf file?");
    headers: []Elf.ProgramHeader = (
        ptr = Elf.ProgramHeader.ptr_from_raw(base.offset(header.program_header_off)), 
        len = header.program_header_num.zext(),
    );
    ::enum(Elf.SegmentType);
    ::enum(Elf.DynTag);
    
    ElfDynUnpacked :: @struct {
        strings: []u8;
        symbols: *Elf.Symbol;
        relocations: []Elf.RelA;
    };
    
    unpacked := ElfDynUnpacked.zeroed();
    each headers { h |
        if h.type == .Dynamic {
            // TODO: i don't super understand why i don't need to add `base` here. i guess it fixed it for me? 
            dynamic: []Elf.Dyn = (ptr = Elf.Dyn.ptr_from_int(h.vaddr), len = h.mem_size / 16);
            for dynamic { it |
                @match(it.tag) {
                    fn StrTab() => {
                        unpacked.strings.ptr = u8.ptr_from_int(it.val);
                    }
                    fn StrSz() => {
                        unpacked.strings.len = it.val;
                    }
                    fn SymTab() => {
                        unpacked.symbols = Elf.Symbol.ptr_from_int(it.val);
                    }
                    fn RelA() => {
                        unpacked.relocations.ptr = Elf.RelA.ptr_from_int(it.val);
                    }
                    fn RelASz() => {
                        unpacked.relocations.len = it.val / size_of(Elf.RelA);
                    }
                    @default => ();
                };
            };
        };
    };
    
    ::ptr_utils(Elf.Symbol);
    each unpacked.relocations { it |
        @debug_assert_eq(it.type, Elf.R_AMD64_GLOB_DAT, "TODO: unknown relocation type %", it.type);
        sym := unpacked.symbols.offset(it.sym.zext());
        dest := rawptr.ptr_from_raw(base.offset(it.offset - Elf.MYSTERY_SPICE));
        dest[] = base.offset(sym.value).offset(it.addend - Elf.MYSTERY_SPICE);
    };
};

// HACK. if context is passed in a global it will leak out from the callee. 
fn query_context_is_implicit() bool = {
    callee :: fn() void #noinline = {
        if get_dynamic_context() != rawptr_from_int(123) {
            scary_log("lost the context");
            Syscall'exit(1);
        };
        set_dynamic_context(rawptr_from_int(456));  // leaks context!
    };
    old_context := get_dynamic_context();
    outer := rawptr_from_int(123);
    set_dynamic_context(outer);
    callee();
    implicit := get_dynamic_context() == outer;
    set_dynamic_context(old_context);
    implicit
}

size_of_dynamic_context :: DefaultContext.size_of(); // @builtin size_of_dynamic_context;

fn get_dynamic_context() rawptr = 
    builtin_get_dynamic_context(0);

builtin_get_dynamic_context :: fn(_: i64) rawptr #intrinsic(INTRINSIC_GET_ENV);  // :UpdateBoot
set_dynamic_context :: fn(context: rawptr) i64 #intrinsic(INTRINSIC_SET_ENV);  // :UpdateBoot

INTRINSIC_GET_ENV :: 64;
INTRINSIC_SET_ENV :: 65;

fn push_zeroed_dynamic_context($body: @Fn() void) void = {
    new_context := @uninitialized Array(u8, size_of_dynamic_context);
    new_context&.items().set_bytes(0);
    new_context := raw_from_ptr(@type new_context, new_context&);
    old_context := get_dynamic_context();
    set_dynamic_context(new_context);
    c := context(DefaultContext);
    c.current_os = (@as(i64) @as(Os) OS[].it).trunc();  // unfortunate we're not doing what the name of the function would imply
    c.prefer_syscalls = !is_linking_libc();
    body();
    set_dynamic_context(old_context);
}

fn push_dynamic_context($body: @Fn() void) void = {
    old_context := get_dynamic_context();
    new_context := @uninitialized Array(u8, size_of_dynamic_context);
    new_context := raw_from_ptr(@type new_context, new_context&);
    if !old_context.is_null() {
        copy_no_alias(new_context, old_context, size_of_dynamic_context); 
    } else {
        scary_log("Tried to inherit null context.");
    };
    set_dynamic_context(new_context);
    body();
    // there are places where i early return from body so you can't do anything interesting here. 
    // but the environment is stored in a local variable this set() only matters if the caller does something after the push() block. 
    set_dynamic_context(old_context);
}

// TODO: let the driver program add new fields. 
fn get_offset_to_dynamic_context_field(T: Type) i64 = {
    if T == DefaultContext {
        0
    } else {
        scary_exit()
    }
}

fn context($T: Type) *T #generic = {
    off :: {
        env := get_comptime_environment();
        get_offset_to_dynamic_context_field(T)  
    };
    c := get_dynamic_context().offset(off);
    T.ptr_from_raw(c)
}

::if(rawptr);
fn scary_log(s: Str) void = {

    // force a jit-shim because write() has a weird dependency on @syscall
    //_ := Syscall'write(@as(Fd) (fd = 1), s.ptr, s.len);
    impl :: fn(s: Str) void = {
        _ := Syscall'write(@as(Fd) (fd = 1), s.ptr, s.len);
    };
    f: (@FnPtr(s: Str) void) = impl;
    f(s)
}

fn temp() Alloc #inline = 
    context(DefaultContext)[].temporary_allocator.borrow();

fn general_allocator() Alloc #inline = 
    context(DefaultContext)[].general_allocator;

fn mark_temporary_storage() ArenaMarker = 
    context(DefaultContext)[].temporary_allocator.mark();

fn reset_temporary_storage(mark: ArenaMarker) void = 
    context(DefaultContext)[].temporary_allocator.reset_retaining_capacity(mark);
    
#inline #use("@/lib/sys/sync/atomics.fr") 
fn set_new_thread_id(ctx: *DefaultContext) void= {
    NEXT_THREAD_ID :: @static(i64) 1;  // :ThreadIdStartsAtOne
    ctx.thread_index = i64.atomic_inc(NEXT_THREAD_ID);
}

// - We saved (argc, argv) from the entry point (but someone might have changed it in the context).  
// - The memory returned here is shared with other threads. So it's probably a bad plan to mutate it. 
fn cli_args() []CStr = {
    context(DefaultContext)[].cli_arguments
}

// - We saved (envp) from the entry point (but someone might have changed it in the context).  
// - Have to iterate every time you look something up, so if you want multiple you're better off writing the loop yourself. 
// - The memory returned here is shared with other threads. So it's probably a bad plan to mutate it. 
// - fn getenv(name: CStr) CStr #libc;
fn get_environment_variable(name: Str) ?CStr = {
    envp := context(DefaultContext)[].environment_variables;
    while => !envp[].ptr.is_null() {
        if starts_with(envp[], name) && envp[][name.len] == "=".ascii() {
            return(Some = (ptr = envp[].ptr.offset(name.len + 1)));
        };
        envp = envp.offset(1);
    };
    .None
}    
