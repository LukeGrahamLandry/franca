Compiler :: *CompilerValue;
CompilerValue :: @struct(pointer_to_pointer_to_selfhosted: rawptr);
CompCtx :: @struct(data: Compiler, vtable: *ImportVTable);
fn CRes($T: Type) Type = Result(T, rawptr);
 
Backend :: @enum(i64) (Aarch64, Cranelift); ::enum(Backend);
Arch :: @enum(i64) (Aarch64, X86_64, Wasm32);
ExecStyle :: @enum(i64) (Jit, Aot);
Os :: @enum(i64) (Macos, Linux, Windows);

TargetEnv :: @struct(
    arch: Arch,
    os: Os,
);

ExportVTable :: @struct(
    resolve_comptime_import: ?@FnPtr(userdata: rawptr, c: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = .None,
    log_event: ?@FnPtr(userdata: rawptr, c: Compiler, msg: *CompilerLogEvent) void = .None,
);

ImportVTable :: @rec @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    init_compiler: @FnPtr(comptime_arch: Backend, options: *BuildOptions) Compiler,
    find_unique_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_fns_with_tag: @FnPtr(c: Compiler, tag: Symbol) Slice(FuncId),
    destroy_compiler: @FnPtr(c: Compiler) void, 
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle) CRes(void),
    // SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(rawptr),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) Span, 
    parse_stmts: @FnPtr(c: Compiler, f: *Span) Result(Slice(FatStmt), *CompileError),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(void),
    _0: usize,
    get_build_options: @FnPtr(c: Compiler) *BuildOptions,
    comptime_arch: @FnPtr() Ty(Arch, Os),
    get_default_driver_exports: @FnPtr() *ExportVTable, 
    emit_llvm: @FnPtr(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry, target: Arch) BucketArray(u8),
);
// TODO: better error for @FnPtr if you forget return type. 

// because you don't want people to depend on llvm.fr
// TODO: don't be a header file!
// All the functions we emit are name-mangled based on thier funcid, so you can't call them from the outside.
// We also mark them as 'private' to give llvm permisson to remove them if all uses are inlined.
// If you want to just pass the resultant ir to clang, tell us how entry points should be exposed. 
ProgramEntry :: @enum(i64) (
    // do nothing, let the caller deal with it
    GiveMeTheCodeAndGiveItToMeRaw,  
    // create a main function that calls all the <fns>
    TestRunnerMain,  
    // create named wrappers for all the <fns>. if one of them is called "main", that will be the program entry point.
    // it is an error to have a name collission. 
    ExportWithNames, 
);

CompileError :: @tagged(
    Msg: @struct(span: Span, msg: Str),
    Parse: @struct(span: Span, msg: Str),
    ExpectedCompileError: Span,
    TypeMismatch: @struct(span: Span, wanted: Type, found: Type),
    CoerceConst: @struct(span: Span, wanted: Type, found: Type, expr: *FatExpr),
    InvalidField: @struct(span: Span, container: Type, name: Symbol),
);

// TODO: depending on layout is jail. Vec isn't repr(C)
// TODO: make totally sure which cap/len order.

ComptimeEnvironment :: @struct(
    pad4 := 0,
    pad5 := 0,
    make_slice_t: ?FuncId,
    bake_os: ?OverloadSet,
    fat_expr_type: ?Type,
    intrinsic_type: ?Type,
    build_options: rawptr,
    unquote_placeholders: ?FuncId,
    pad1 := 0,  
    pad2 := 0,
    pad3 := 0,
    link_rename_arg: ?Type,
    push_x86_func: ?Type,
    compile_error_pointer: ?Type,
);

// Note: changing these default values requires rebuilding the compiler! (an extra time if the program you're interested in is the compiler).
BuildOptions :: @struct(
    // false for smaller binary, true for better debugging. 
    // Without this, we put the `private` modifer on functions so they can be removed if all uses are inlined. 
    // With this, we also include the source string name of the function (instead of just the id), but the names are still unstable!
    // For exports you want to refer to by name, use the ProgramEntry option.
    // Note: turning this off might make it look like more ir if the word 'private' on every function adds more than the names, but the produced exe will be smaller.  
    retain_function_names: bool = false,
    // TODO: compilation order bug with disabling debug assertions -- Jul 24
    safety_checks: EnumMap(SafetyCheck, bool) = (data = init(@slice(SAFE_MODE, SAFE_MODE, SAFE_MODE, SAFE_MODE, true))),
    _pad: i64 = 0,
    // Generics may cause redundant code for distinct types that have the same representation. 
    // Should the front end remedy the situation? 
    deduplicate_bytecode: bool = true,
    debug_info: bool = false,
    wasm32: bool = false,  // :build_options_wasm
    comptime_jit: Backend = .Aarch64,
    driver_vtable_ptr: *ExportVTable,
    driver_vtable_user_data: rawptr = 0.rawptr_from_int(),
    // This effects what emit_bc does for the @uninitilized ast node. 
    // TODO: do it in the allocators as well?
    // TODO: do it in stack slots (between field padding)
    zero_init_memory: bool = false,
);

SAFE_MODE :: true; // TODO: default driver program with this as a cli argument 

SafetyCheck :: @enum(i64) (
    Bounds,
    DebugAssertions, // TODO: i cant disable DebugAssertions because i have some compilation order bug. hopefully can fix with sema rewrite. -- Jul 24
    // - `index` should not change the length of a collection. 
    NonCompliantOverload, // TODO: decide if i want to do this... currently UNUSED
    InvalidTag, // @match on @tagged or @enum
    // You probably never want to turn this off. 
    // But i like the idea for minimizing the compiler binary i have to commit. (tho perhaps thats a terrible idea because it could make a stressful situation more confusing).
    // TODO: this only affects the @panic macro, not direct calls to the panic function. 
    KeepPanicMessages,
);

// TODO: expose id
// :sema_regression this used to work as an #unsafe_noop_cast overload set
symbol_from_id :: fn (id: u32) Symbol = {
    ptr_cast_unchecked(From = u32, To = Symbol, ptr = id&)[]
};
fn id(self: Symbol) u32 #unsafe_noop_cast;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
Symbol  :: @builtin Symbol;  // TODO: why does making this a struct here and then giving it to the compiler cause tag_value to get called with two types. -- Jun 13
ScopeId :: @builtin ScopeId;
LabelId :: @builtin LabelId;
FuncId  :: @builtin FuncId;
//LabelId :: @struct(id: u32);
//ScopeId :: @struct(id: u32);
//FuncId :: @struct(id: u32);
//Symbol :: @struct(id: u32);

FatExpr :: @rec @struct(
    expr: Expr,
    loc: Span,
    ty: Type,
    done: bool,
);
PlaceholderValue :: @enum(i64) (AllZeros, Unknown, Label, Argument, OverloadSet, OnceUsed, PlaceholderUsed, InProgressMacro);
Expr :: @tagged(
    Poison: PlaceholderValue,
    Value: @struct(bytes: Values, coerced: bool),
    Switch: @struct(value: *FatExpr, default: *FatExpr, cases: RsVec(Ty(i64, FatExpr))),
    Call: @struct(f: *FatExpr, arg: *FatExpr),
    Block: @struct(body: RsVec(FatStmt), result: *FatExpr, ret_label: ?LabelId, hoisted_constants: bool),
    Tuple: RsVec(FatExpr),
    Closure: *Func,
    _AddToOverloadSet,
    _SuffixMacro,
    FieldAccess: @struct(container: *FatExpr, name: Symbol),
    StructLiteralP: Pattern,
    PrefixMacro: @struct(handler: *FatExpr, arg: *FatExpr, target: *FatExpr),
    GetVar: Var,
    GetNamed: Symbol,
    String: Symbol,
    PtrOffset: @struct(ptr: *FatExpr, bytes: i64, name: Symbol),
    GetParsed: WaitingParse,
    Cast: *FatExpr,

    If: @struct(cond: *FatExpr, if_true: *FatExpr, if_false: *FatExpr),
    Loop: *FatExpr,
    Addr: *FatExpr,
    Quote: *FatExpr,
    Slice: *FatExpr,
    Deref: *FatExpr,
    ConstEval: *FatExpr,
    FnPtr: *FatExpr,
    FromBitLiteral: @struct(value: i64, bit_count: i64), 
    Uninitialized,
    Unquote: *FatExpr,
    Placeholder: i64,
    Builtin: Symbol,
    ContextualField: Symbol,
    As: @struct(type: *FatExpr, value: *FatExpr),
);

WaitingParse :: @struct(id: i64);
Values :: @tagged(
    Big: RsVec(u8),
    Small: Ty(i64, u8),
);
FatStmt :: @rec @struct(
    stmt: Stmt,
    _pad1: i64 = 0,
    _pad2: i64 = 0,
    loc: Span,
    done: bool = false,
);
Stmt :: @tagged(
    Noop: void,
    Eval: FatExpr,
    DeclFunc: *Func,
    DeclVar: @struct(value: FatExpr, ty: LazyType, name: Var),
    DeclVarPattern: @struct(binding: Pattern, value: FatExpr),
    DeclNamed: @struct(kind: VarType, value: FatExpr, ty: LazyType, name: Symbol),
    Set: @struct(place: FatExpr, value: FatExpr),
    ExpandParsedStmts: usize,
    Annotations: RsVec(Annotation),
);
Func :: @struct(
    annotations: RsVec(Annotation),
    nullable_link_rename_func: i64 = 0, 
    finished_bytecode_pointer: ?i64 = .None, // this is just used for introspection in examples/compiler_gui
    callees: RsVec(FuncId),
    mutual_callees: RsVec(FuncId),
    var_name: ?Var,
    finished_arg: ?Type,
    finished_ret: ?Type,
    cc: ?CallConv,
    return_var: ?Var,
    scope: ?ScopeId,
    body: FuncImpl,
    arg: Pattern,
    ret: LazyType,
    name: Symbol,
    loc: Span,
    flags: u32 = 0,
);

FnFlag :: @enum(i64) (
    NotEvilUninit,
    ResolvedBody,
    ResolvedSign,
    AllowRtCapture,
    EnsuredCompiled,
    AsmDone,
    TryConstantFold,
    Generic,
    UnsafeNoopCast,
    NoStackTrace,
    MayHaveAquiredCaptures,
    TookPointerValue,
    Once,
    OnceConsumed,
    NoInline,
    AnyConstArgs,
    MadeVarsForRuntimeArgs,
    Macro,
    BodyIsSpecial,
    Cold,
    SyntheticImmEval,
    ComptimeOnly,
    LogBc,
    LogAsm,
    LogAsmBc,
    LogIr,
    LogAst,
    NoTail,
);

Annotation :: @struct(
    name: Symbol,
    args: ?FatExpr,
);
Var :: @struct(
    kind: VarType,
    name: Symbol,
    id: u32,
    scope: ScopeId,
    block: u16,
);
VarType :: @enum(i64) (
    _Unused, 
    Var,
    Const,
);
CallConv :: @enum(i64) (
    CCallReg,
    CCallRegCt,
    _Unused,
    Inline,
);
FuncImpl :: @rec @tagged(
    Normal: FatExpr,
    DynamicImport: Symbol,
    ComptimeAddr: i64,
    JittedAarch64: RsVec(u32),
    LlvmIr: Symbol,
    CSource: Symbol,
    _Unused: usize,
    PendingRedirect: @struct(arg: Type, ret: Type, os: OverloadSet),
    Redirect: FuncId,
    Merged: RsVec(FuncImpl),
    Empty: void,
    QbeIr: Symbol,
    Intrinsic: Intrinsic,
    X86AsmText: Symbol,
    X86AsmBytes: RsVec(u8),
);

Pattern :: @struct(
    bindings: RsVec(Binding),
    loc: Span,
);
Binding :: @struct(
    name: Name,
    ty: LazyType,
    default: ?FatExpr,
    kind: VarType,
);
Name :: @tagged(
    Ident: Symbol,
    Var: Var,
    None,
);
LazyType :: @rec @tagged(
    EvilUninit: void,
    Infer,
    PendingEval: FatExpr, 
    Finished: Type, 
    Returning: Type,
);
Span :: @struct(low: u32, high: u32);

TypeInfo :: @tagged(
    Int: IntTypeInfo,
    Never,
    F64,
    F32,
    Bool,
    Fn: FnType,
    FnPtr: @struct(
        ty: FnType,
        cc: CallConv,
    ),
    Ptr: Type, // One element
    Array: @struct(
        inner: Type,
        len: u32, // note: not usize!! that confusing the padding cause i pass by reference now without going through InterpSend -- May 27
    ),
    Struct: @struct(
        // You probably always have few enough that this is faster than a hash map. // TODO: check that
        fields: RsVec(Field),
        layout_done: bool,
        is_tuple: bool,
        const_field_count: u16,
    ),
    // What rust calls an enum
    Tagged: @struct(
        cases: RsVec(Ty(Symbol, Type)),
        tag: Type,
    ),
    // TODO: on assignment, check that it's a valid value. (at the very least do it for constants)
    Enum: @struct(
        raw: Type,
        fields: RsVec(Ty(Symbol, Values)),
        sequential: bool
    ),
    Placeholder,
    Named: Ty(Type, Symbol),
    void, // TODO: same as empty tuple but easier to type
    VoidPtr,
    Label: Type,
);

IntTypeInfo :: @struct(
    bit_count: i64,
    signed: bool,
);

FnType :: @struct(
    // Functions with multiple arguments are treated as a tuple.
    arg: Type,
    ret: Type,
    arity: u16,
);

Field :: @struct(
    name: Symbol,
    ty: Type,
    default: ?Var,
    byte_offset: usize, // TODO: make this optional so you can't forget to check if layout ready / field is constant? -- Jul 6
    kind: VarType,
);

// TODO: this should be #ct and get it from SelfHosted.ast_arena
fn ast_alloc() Alloc = todo_allocator;

// TODO: make the other enum varient builtin so you can use it and still override eq. because my order independence doesn't really work. 
// TODO: unhandled switch case if i try to make this u8
Prim :: @enum(i64) (I8, I16, I32, I64, F64, F32, P64);

BakedVarId :: @struct(id: u32);

// A piece of static data that can be baked into an output file (c code, object, etc).
// TODO: deduplicate
// TODO: track type so structs can be more than just a blob of bytes.
// TODO: distinguish between constant and static. For now, everything is a mutable static because the language doesn't have the concept of const pointers.
BakedVar :: @tagged(
    Zeros: i64, // length
    Bytes: RsVec(u8),
    VoidPtrArray: RsVec(BakedEntry),
);

BakedEntry :: @tagged(
    Num: @struct(value: i64, ty: Prim),
    FnPtr: FuncId,
    AddrOf: BakedVarId,
);

TypeMeta :: @struct(
    _pad: u32 = 0,
    inferred_name: Symbol = Symbol.zeroed(),
    float_mask: u32,
    size_slots: u16,
    stride_bytes: u16,
    align_bytes: u16,
    contains_pointers: bool,
    pass_by_ref: bool,
    is_sized: bool,
);

#redirect(Ty(u32, u32), bool) fn eq(a: ScopeId, b: ScopeId) bool;
#redirect(*Symbol, i64) fn hash(i: *Type) i64;
#redirect(Ty(u32, u32), bool) fn ne(a: Type, b: Type) bool;

CompilerLogEvent :: @tagged(
    Msg: Str,
);

// :link_rename
LinkRenameArg :: @struct(
    target: TargetEnv,
    out: *List(u8),
    old_name: Str,
);
