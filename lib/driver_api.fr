Compiler :: *CompilerValue;
CompilerValue :: @struct(pointer_to_pointer_to_selfhosted: rawptr, vtable: *ImportVTable);
CompCtx :: @struct(data: Compiler, vtable: *ImportVTable);
fn CRes($T: Type) Type = Result(T, rawptr);
 
Backend :: @enum(i64) (Aarch64 = 1);
Arch :: @enum(i64) (Aarch64 = 1, X86_64 = 2);
ExecStyle :: @enum(i64) (Jit = 0, Aot = 1);
Os :: @enum(i64) (Macos = 0, Linux = 1, Windows = 2);

TargetEnv :: @struct(
    arch: Arch,
    backend: Backend,
    style: ExecStyle, 
    os: Os,
);

ExportVTable :: @struct(
    resolve_comptime_import: ?@FnPtr(userdata: rawptr, c: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = .None,
);

ImportVTable :: @rec @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    _a: usize, // TODO: remove
    init_compiler: @FnPtr(comptime_arch: Backend) Compiler,
    find_unique_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_fns_with_tag: @FnPtr(c: Compiler, tag: Symbol) Slice(FuncId),
    _b: usize,
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle) CRes(void),
    // SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(rawptr),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func,
    _d: usize,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) Span, 
    parse_stmts: @FnPtr(c: Compiler, f: *Span) Result(Slice(FatStmt), ParseErr),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(void),
    make_jitted_exec: @FnPtr(c: Compiler) void,
    give_vtable: @FnPtr(c: Compiler, vtable: *ExportVTable, userdata: rawptr) void,
    get_function_name: @FnPtr(c: Compiler, f: FuncId) Symbol, // TODO: remove now that you can just access the field. 
    comptime_arch: @FnPtr() Ty(Arch, Os),
    _c: usize, 
    _emit_bc: usize,
    get_type_meta: @FnPtr(c: Compiler, ty: Type) TypeMeta,
    __a: usize,
    _f: usize, 
    __b: @FnPtr(c: Compiler, fn_body: rawptr) void,
    _e: usize,
    get_compiler_builtins_source: @FnPtr() Str,
    _i: usize,
    emit_llvm: @FnPtr(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry) BucketArray(u8),
    _j: usize,
    _g: usize,
    _h: usize,
    clone_expr: @FnPtr(e: *FatExpr) FatExpr,
    clone_type: @FnPtr(e: *LazyType) LazyType,
    intern_type: @FnPtr(c: Compiler, e: TypeInfo) Type,
    get_type: @FnPtr(c: Compiler, e: Type) *TypeInfo,
    log_type: @FnPtr(c: Compiler, e: Type) Str,
    check_for_new_aot_bake_overloads: @FnPtr(comp: Compiler) CRes(void),
);
// TODO: better error for @FnPtr if you forget return type. 

// because you don't want people to depend on llvm.fr
// TODO: don't be a header file!
// All the functions we emit are name-mangled based on thier funcid, so you can't call them from the outside.
// We also mark them as 'private' to give llvm permisson to remove them if all uses are inlined.
// If you want to just pass the resultant ir to clang, tell us how entry points should be exposed. 
ProgramEntry :: @enum(i64) (
    // do nothing, let the caller deal with it
    GiveMeTheCodeAndGiveItToMeRaw,  
    // create a main function that calls all the <fns>
    TestRunnerMain,  
    // create named wrappers for all the <fns>. if one of them is called "main", that will be the program entry point.
    // it is an error to have a name collission. 
    ExportWithNames, 
);

ParseErr :: @struct(span: Span, msg: Str);

// TODO: depending on layout is jail. Vec isn't repr(C)
// TODO: make totally sure which cap/len order.

ComptimeEnvironment :: @struct(
    inject_function_header: ?Ty(FuncId, FuncId),
    make_slice_t: ?FuncId,
    bake_os: ?OverloadSet,
    fat_expr_type: ?Type,
);

// TODO: expose id
fn symbol_from_id(id: u32) Symbol #unsafe_noop_cast;
fn id(self: Symbol) u32 #unsafe_noop_cast;


// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
Symbol  :: @builtin Symbol;  // TODO: why does making this a struct here and then giving it to the compiler cause tag_value to get called with two types. -- Jun 13
ScopeId :: @builtin ScopeId;
LabelId :: @builtin LabelId;
FuncId  :: @builtin FuncId;
//LabelId :: @struct(id: u32);
//ScopeId :: @struct(id: u32);
//FuncId :: @struct(id: u32);
//Symbol :: @struct(id: u32);

FatExpr :: @rec @struct(
    expr: Expr,
    loc: Span,
    ty: Type,
    done: bool,
);
Expr :: @tagged(
    Poison: void,
    Value: @struct(bytes: Values, coerced: bool),
    WipFunc: FuncId,
    Call: @struct(f: *FatExpr, arg: *FatExpr),
    Block: @struct(body: RsVec(FatStmt), result: *FatExpr, ret_label: ?LabelId, hoisted_constants: bool),
    Tuple: RsVec(FatExpr),
    Closure: *Func,
    AddToOverloadSet: RsVec(Func),
    SuffixMacro: @struct(name: Symbol, arg: *FatExpr),
    FieldAccess: @struct(container: *FatExpr, name: Symbol),
    StructLiteralP: Pattern,
    PrefixMacro: @struct(handler: *FatExpr, arg: *FatExpr, target: *FatExpr),
    GetVar: Var,
    GetNamed: Symbol,
    String: Symbol,
    PtrOffset: @struct(ptr: *FatExpr, bytes: i64, name: Symbol),
    GetParsed: WaitingParse,
    Cast: *FatExpr,
);
WaitingParse :: @struct(id: i64);
Values :: @tagged(
    Big: RsVec(u8),
    Small: Ty(i64, u8),
);
FatStmt :: @rec @struct(
    stmt: Stmt,
    annotations: RsVec(Annotation),
    loc: Span,
);
Stmt :: @tagged(
    Noop: void,
    Eval: FatExpr,
    DeclFunc: *Func,
    DeclVar: @struct(value: FatExpr, ty: LazyType, name: Var),
    DeclVarPattern: @struct(binding: Pattern, value: FatExpr),
    DeclNamed: @struct(kind: VarType, value: FatExpr, ty: LazyType, name: Symbol),
    Set: @struct(place: FatExpr, value: FatExpr),
    ExpandParsedStmts: usize,
);
Func :: @struct(
    annotations: RsVec(Annotation),
    capture_vars: Ty(usize, usize, usize), // TODO: remove
    callees: RsVec(FuncId),
    mutual_callees: RsVec(FuncId),
    var_name: ?Var,
    finished_arg: ?Type,
    finished_ret: ?Type,
    cc: ?CallConv,
    return_var: ?Var,
    scope: ?ScopeId,
    body: FuncImpl,
    arg: Pattern,
    ret: LazyType,
    name: Symbol,
    loc: Span,
    flags: u32 = 0,
);

FnFlag :: @enum(i64) (
    NotEvilUninit,
    ResolvedBody,
    ResolvedSign,
    AllowRtCapture,
    EnsuredCompiled,
    AsmDone,
    TryConstantFold,
    CalleesAsmDone,
    Generic,
    UnsafeNoopCast,
    NoStackTrace,
    MayHaveAquiredCaptures,
    TookPointerValue,
    DidSema,
);

Annotation :: @struct(
    name: Symbol,
    args: ?FatExpr,
);
Var :: @struct(
    kind: VarType,
    name: Symbol,
    id: u32,
    scope: ScopeId,
    block: u16,
);
VarType :: @enum(i64) (
    Let, 
    Var,
    Const,
);
CallConv :: @enum(i64) (
    CCallReg,
    CCallRegCt,
    OneRetPic,
    Inline,
);
FuncImpl :: @rec @tagged(
    Normal: FatExpr,
    DynamicImport: Symbol,
    ComptimeAddr: usize,
    JittedAarch64: RsVec(u32),
    LlvmIr: Symbol,
    CSource: Symbol,
    _EmitCranelift: usize,
    PendingRedirect: @struct(arg: Type, ret: Type, os: OverloadSet),
    Redirect: FuncId,
    Merged: RsVec(FuncImpl),
    Empty: void,
    CompilerBuiltin: Symbol,
);
Pattern :: @struct(
    bindings: RsVec(Binding),
    loc: Span,
);
Binding :: @struct(
    name: Name,
    ty: LazyType,
    default: ?FatExpr,
    kind: VarType,
);
Name :: @tagged(
    Ident: Symbol,
    Var: Var,
    None,
);
LazyType :: @rec @tagged(
    EvilUninit: void,
    Infer,
    PendingEval: FatExpr, 
    Finished: Type, 
    Returning: Type,
);
Span :: @struct(low: u32, high: u32);

TypeInfo :: @tagged(
    Int: IntTypeInfo,
    Never,
    F64,
    F32,
    Bool,
    Fn: FnType,
    FnPtr: @struct(
        ty: FnType,
        cc: CallConv,
    ),
    Ptr: Type, // One element
    Array: @struct(
        inner: Type,
        len: u32, // note: not usize!! that confusing the padding cause i pass by reference now without going through InterpSend -- May 27
    ),
    Struct: @struct(
        // You probably always have few enough that this is faster than a hash map. // TODO: check that
        fields: RsVec(Field),
        layout_done: bool,
        is_tuple: bool,
        const_field_count: u16,
    ),
    // What rust calls an enum
    Tagged: @struct(
        cases: RsVec(Ty(Symbol, Type)),
        tag: Type,
    ),
    // TODO: on assignment, check that it's a valid value. (at the very least do it for constants)
    Enum: @struct(
        raw: Type,
        fields: RsVec(Ty(Symbol, Values)),
        sequential: bool
    ),
    Placeholder,
    Named: Ty(Type, Symbol),
    void, // TODO: same as empty tuple but easier to type
    VoidPtr,
    Label: Type,
);

IntTypeInfo :: @struct(
    bit_count: i64,
    signed: bool,
);

FnType :: @struct(
    // Functions with multiple arguments are treated as a tuple.
    arg: Type,
    ret: Type,
    arity: u16,
);

Field :: @struct(
    name: Symbol,
    ty: Type,
    default: ?Var,
    byte_offset: usize, // TODO: make this optional so you can't forget to check if layout ready / field is constant? -- Jul 6
    kind: VarType,
);

// TODO: this should be #ct and get it from SelfHosted.ast_arena
fn ast_alloc() Alloc = todo_allocator;

// TODO: make the other enum varient builtin so you can use it and still override eq. because my order independence doesn't really work. 
Prim :: @enum(i64) (I8, I16, I32, I64, F64, F32, P64);

BakedVarId :: @struct(id: u32);

// A piece of static data that can be baked into an output file (c code, object, etc).
// TODO: deduplicate
// TODO: track type so structs can be more than just a blob of bytes.
// TODO: distinguish between constant and static. For now, everything is a mutable static because the language doesn't have the concept of const pointers.
BakedVar :: @tagged(
    Zeros: i64, // length
    Bytes: RsVec(u8),
    VoidPtrArray: RsVec(BakedEntry),
);

BakedEntry :: @tagged(
    Num: @struct(value: i64, ty: Prim),
    FnPtr: FuncId,
    AddrOf: BakedVarId,
);

TypeMeta :: @struct(
    _pad: i64,
    float_mask: u32,
    size_slots: u16,
    stride_bytes: u16,
    align_bytes: u16,
    contains_pointers: bool,
    pass_by_ref: bool,
);

Flag :: @enum(
    _reserved_null_,
    aarch64,
    llvm,
    cranelift,
    _reserved_end_arch_, // It's important which are above and below this point.
    generic,
    as,
    inline,
    noinline,
    asm,
    c_call,
    macro,
    placeholder,
    comptime_addr,
    init,
    slice,
    unquote_macro_apply_placeholders,
    from_bit_literal,
    rec,
    quote,
    unquote,
    deref,
    patch,
    ct,
    any_reg,
    Impl,
    main,
    builtin_if,
    builtin_while,
    if,
    loop,
    addr,
    tag,
    reflect_print,
    fn_ptr,
    toplevel,
    include_std,
    unreachable,
    rt,
    test,
    operator_star_prefix,
    operator_question_prefix,
    operator_up_arrow_prefix,
    operator_ampersand_prefix,
    operator_plus_equal,
    operator_minus_equal,
    operator_star_equal,
    operator_slash_equal,
    operator_index,
    builtin,
    no_memo,
    uninitialized,
    const_eval,
    contextual_field,
    outputs,
    when,
    one_ret_pic,
    Anon,
    log_bc,
    log_asm,
    log_ir,
    log_ast,
    skip_cranelift,
    log_asm_bc,
    return,
    cranelift_emit,
    Force_Cranelift,
    Force_Aarch64,
    tail,
    redirect,
    libc,
    __shift_or_slice,
    no_tail, // TOOD: HACK. stack ptr/slice arg is UB so have to manually use this! not acceptable!
    __return,
    __get_assertions_passed,
    __string_escapes,
    test_broken,
    Load,
    Store,
    fold,
    ptr,
    len,
    export,
    __tag_check,
    c,
    unsafe_noop_cast,
    import,
    type,
    struct,
    tagged,
    enum,
    bake_relocatable_value,
    local_return,
    no_trace,
    compiler_builtin_transform_callsite,
    late,
    _reserved_count_,
    // TODO: add these to the rust version and move _Reserved_Count_ down!
    add,
    sub,
    mul,
    div,
    lt,
    gt,
    ge,
    le,
    eq,
    ne,
    neg,
    not,
    and,
    operator_squares_prefix,
);

#redirect(Ty(u32, u32), bool) fn eq(a: ScopeId, b: ScopeId) bool;
#redirect(*Symbol, i64) fn hash(i: *Type) i64;
#redirect(Ty(u32, u32), bool) fn ne(a: Type, b: Type) bool;
