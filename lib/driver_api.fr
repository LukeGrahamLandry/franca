Compiler :: *CompilerValue;
CompilerValue :: @struct(pointer_to_pointer_to_selfhosted: rawptr);
CompCtx :: @rec @struct(data: Compiler, vtable: *ImportVTable);
fn CRes($T: Type) Type = Result(T, *CompileError);

// TODO: some of the old build stuff uses these names in file paths
Arch :: @enum(i64) (aarch64, x86_64, wasm32);  ::enum(Arch);
ExecStyle :: @enum(i64) (Jit, Aot);
// TODO: some of the old build stuff uses these names in file paths
Os :: @enum(i64) (macos, linux, wasip1); ::enum(Os); // TODO: windows, free_standing

TargetEnv :: @struct(
    arch: Arch,
    os: Os,
);

ExportVTable :: @struct(
    resolve_comptime_import: ?@FnPtr(userdata: rawptr, c: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = .None,
    log_event: ?@FnPtr(userdata: rawptr, c: Compiler, msg: *CompilerLogEvent) void = .None,
);

// TODO: exchange version numbers with the driver somehow so abi breaks are more sane.
ImportVTable :: @rec @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    init_compiler: @FnPtr(options: *BuildOptions) Compiler,
    find_unique_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_fns_with_tag: @FnPtr(c: Compiler, tag: Symbol) Slice(FuncId),
    destroy_compiler: @FnPtr(c: Compiler) void, 
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle) CRes(void),
    // SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(rawptr),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) AbiHackSpan, 
    parse_stmts: @FnPtr(c: Compiler, f: *Span) Result(Slice(FatStmt), *CompileError),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(void),
    get_baked: @FnPtr(c: Compiler, id: BakedVarId) rawptr, // *BakedValue
    get_build_options: @FnPtr(c: Compiler) *BuildOptions,
    comptime_arch: @FnPtr() Ty(Arch, Os),  // TODO: remove
    get_default_driver_exports: @FnPtr() *ExportVTable, 
    check_for_new_aot_bake_overloads: @FnPtr(c: Compiler) void,
    driver_abi_version: i64,
    _emit_bc: @FnPtr(void) Never,
    fmt_error: @FnPtr(c: Compiler, err: *CompileError, out: *List(u8)) void,
    add_comptime_library: @FnPtr(c: Compiler, lib_name: Symbol, handle: rawptr) void,
    get_type_meta: @FnPtr(c: Compiler, type: Type) *TypeMeta,
    get_type_info: @FnPtr(c: Compiler, type: Type) *TypeInfo,
    get_whole_line: @FnPtr(c: Compiler, span: Span) FrancaCodeLine, // :SLOW
    report_aot_progress: @FnPtr(c: Compiler, fid: FuncId, is_start: bool, zone: i64) void, // for profiling
    emit_relocatable_constant: @FnPtr(c: Compiler, ty: Type, value: []u8, loc: Span) CRes(BakedVarId),
    log_expr: @FnPtr(c: Compiler, e: *FatExpr) Str,
    log_stmt: @FnPtr(c: Compiler, e: *FatStmt) Str,
    log_type: @FnPtr(c: Compiler, e: Type) Str,
    log_func: @FnPtr(c: Compiler, e: *Func) Str,
    emit_relocatable_constant_body: @FnPtr(c: Compiler, bytes: []u8, ty: Type, force_default_handling: bool) CRes(Slice(BakedEntry)),
    emit_qbe_included: @FnPtr(module: rawptr, comp: *CompCtx, fns: [] FuncId, entry: ProgramEntry) BucketArray(u8),
    init_default_qbe_module: @FnPtr(module_out: rawptr, qbe_env_goal_in: rawptr) void,
    took_address: @FnPtr(c: Compiler, n: *Var) bool, // (this is get, not set)
    run_qbe_passes: @FnPtr(ir_fn: rawptr) void,
    finish_qbe_module: @FnPtr(module: rawptr) [][]u8,
    get_alloc: @FnPtr(c: Compiler) Alloc,
    drop_qbe_module: @FnPtr(module: rawptr) void,
    codegen_thread_main: @FnPtr(codegenshared: rawptr) void,
    default_handle_message: @FnPtr(in: []DriverMessage, out: []DriverResult) void,
    compile_ast: @FnPtr(c: Compiler, expr: *FatExpr, hint: Type) void,
    intern_type: @FnPtr(c: Compiler, info: *TypeInfo) Type,  // The compiler makes a copy of the argument
    intern_func: @FnPtr(c: Compiler, f: *Func) FuncId,  // The compiler makes a copy of the argument
    add_to_scope: @FnPtr(c: Compiler, s: ScopeId, name: Symbol, type: Type, value: rawptr) void,
    reserve_baked: @FnPtr(c: Compiler, jit_ptr: ?i64) BakedVarId,
    materialize_in_jit_address_space: @FnPtr(c: Compiler, module: rawptr, id: BakedVarId) rawptr,
    // TODO: give people a more powerful primitive that can be used to build this. like insert redirect. 
    replace_body_source: @FnPtr(c: Compiler, fid: FuncId, new_source: Str) CRes(void),
);

AbiHackSpan :: @struct(low: i64, high: i64);
fn shrink(s: AbiHackSpan) Span = (low = s.low.trunc(), high = s.high.trunc());

FrancaCodeLine :: @struct(filename: Str, line: i64, col: i64, line_text: Span);

// TODO: better error for @FnPtr if you forget return type. 

// because you don't want people to depend on llvm.fr
// TODO: don't be a header file!
// All the functions we emit are name-mangled based on thier funcid, so you can't call them from the outside.
// We also mark them as 'private' to give llvm permisson to remove them if all uses are inlined.
// If you want to just pass the resultant ir to clang, tell us how entry points should be exposed. 
ProgramEntry :: @enum(i64) (
    // do nothing, let the caller deal with it
    GiveMeTheCodeAndGiveItToMeRaw,  
    // create a main function that calls all the <fns>
    TestRunnerMain,  
    WrapMain, 
    // create named wrappers for all the <fns>. if one of them is called "main", that will be the program entry point.
    // it is an error to have a name collission. 
    ExportWithNames, 
); ::enum(ProgramEntry);

CompileError :: @tagged(
    Msg: @struct(span: Span, msg: Str),
    Parse: @struct(span: Span, msg: Str),
    ExpectedCompileError: Span,
    TypeMismatch: @struct(span: Span, wanted: Type, found: Type),
    CoerceConst: @struct(span: Span, wanted: Type, found: Type, expr: *FatExpr),
    InvalidField: @struct(span: Span, container: Type, name: Symbol),
);

ComptimeEnvironment :: @struct(
    _: ?FuncId,
    make_slice_t: ?FuncId,
    bake_os: ?OverloadSet,
    fat_expr_type: ?Type,
    intrinsic_type: ?Type,
    build_options: rawptr,
    unquote_placeholders: ?FuncId,
    comptime_os: Os,
    os_type: ?Type,
    link_rename_arg: ?Type,
    push_x86_func: ?Type,
    compile_error_pointer: ?Type,
    // Generally you don't want to read this because you might be cross compiling!
    // The compiler needs it tho to choose what the comptime jit should do... tho thats questionable since it won't change. 
    // You can use query_current_arch instead (and compile both branches). 
    // TODO: I should be able to tell you the target arch... because i need to know it when choosing which inline asm for llvm. 
    comptime_arch: Arch,
    __: Ty(i64, i64) = (0, 0),
    c_str_type := UnknownType,
    ir_op_cls_types := UnknownType,
    dynamic_context_type := UnknownType,
    runtime_init: ?FuncId,
    static_context_var: ?BakedVarId,
);

// Note: changing these default values requires rebuilding the compiler! (if your driver program is using ImportVTable.default_build_options). 
//       (an extra time if the program you're interested in is the compiler).
BuildOptions :: @struct(
    // false for smaller binary, true for better debugging. 
    // Without this, we put the `private` modifer on functions so they can be removed if all uses are inlined. 
    // With this, we also include the source string name of the function (instead of just the id), but the names are still unstable!
    // For exports you want to refer to by name, use the ProgramEntry option.
    // Note: turning this off might make it look like more ir if the word 'private' on every function adds more than the names, but the produced exe will be smaller.  
    retain_function_names: bool = true, 
    safety_checks: import("@/lib/collections/enum_map.fr")'EnumMap(SafetyCheck, bool) = (data = init(@slice(true, true, true, true, true))),
    _pad: i64 = 0,
    // Generics may cause redundant code for distinct types that have the same representation. 
    // Should the front end remedy the situation? 
    deduplicate_bytecode: bool = true,  // TODO: fix this. it is ignored for now. (always false)
    debug_info: bool = false,
    wasm32: bool = false,  // :build_options_wasm
    _pad4 := 0,
    // TODO: remove this in favour of handle_message
    driver_vtable_ptr: *ExportVTable,
    driver_vtable_user_data: rawptr = 0.rawptr_from_int(),
    // This effects what emit_bc does for the @uninitilized ast node. 
    // TODO: do it in the allocators as well?
    // TODO: do it in stack slots (between field padding)
    zero_init_memory: bool = false,
    _pad5 := false, 
    _pad3 := false,
    // At comptime, context passing convention must match whatever the compiler was compiled with. 
    implicit_context_comptime := true, // This value is ignored! Set later by the compiler. 
    implicit_context_runtime := true, // This you can choose in the driver program (false is not thread safe)
    target_os_bitset: u32 = 0,
    target_arch_bitset: u32 = 0,
    handle_message: @FnPtr(in: []DriverMessage, out: []DriverResult) void,
    env := rawptr_from_int(0),
    use_raw_syscalls := false,
    always_track_ir_names := false,
);

SafetyCheck :: @enum(i64) (
    Bounds,
    DebugAssertions,
    // - `index` should not change the length of a collection. 
    NonCompliantOverload, // TODO: decide if i want to do this... currently UNUSED
    InvalidTag, // @match on @tagged or @enum
    // You probably never want to turn this off. 
    // But i like the idea for minimizing the compiler binary i have to commit. (tho perhaps thats a terrible idea because it could make a stressful situation more confusing).
    // TODO: this only affects the @panic macro, not direct calls to the panic function. 
    KeepPanicMessages,
);

// TODO: expose id
// :sema_regression this used to work as an #unsafe_noop_cast overload set
symbol_from_id :: fn (id: u32) Symbol = {
    ptr_cast_unchecked(From = u32, To = Symbol, ptr = id&)[]
};
fn id(self: Symbol) u32 #unsafe_noop_cast;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
Symbol  :: @builtin Symbol;  // TODO: why does making this a struct here and then giving it to the compiler cause tag_value to get called with two types. -- Jun 13
ScopeId :: @builtin ScopeId;
LabelId :: @builtin LabelId;
FuncId  :: @builtin FuncId;
//LabelId :: @struct(id: u32);
//ScopeId :: @struct(id: u32);
//FuncId :: @struct(id: u32);
//Symbol :: @struct(id: u32);

// TODO: Make it sane to change the layout of these. 
//       Put them in a namespace and seperate the compiler's comptime repr from its exported repr. 
//       Allow having a step where they get translated if they don't match (like the first time you compile after changing them). 
//       Currently you're pretty much fucked if you want to change the size of FatExpr/FatStmt because macros use arrays of them. 
//       -- Sep 19

FatExpr :: @rec @struct(
    expr: Expr,
    loc: Span,
    ty: Type,
    done: bool,
);
PlaceholderValue :: @enum(i64) (AllZeros, Unknown, Label_DidYouReturnOutsideABlockLikeInAnExprFunction, Argument, OverloadSet, OnceUsed, PlaceholderUsed, InProgressMacro, EmptyBindingValue, Generic);
Expr :: @tagged(
    Poison: PlaceholderValue,
    Value: @struct(bytes: Values, coerced: bool),
    Switch: @struct(value: *FatExpr, default: *FatExpr, cases: RawList(Ty(i64, FatExpr))),
    Call: @struct(f: *FatExpr, arg: *FatExpr),
    Block: @struct(
        body: RawList(FatStmt), 
        result: *FatExpr, 
        ret_label: ?LabelId, 
        hoisted_constants: bool, 
        block_resolved: bool, 
        scope: ScopeId
    ),
    Tuple: RawList(FatExpr),
    Closure: *Func,
    Spread: *FatExpr,
    _SuffixMacro,
    FieldAccess: @struct(container: *FatExpr, name: Symbol, no_dot_call: bool),  // :FirstFieldIsTheChild
    StructLiteralP: Pattern,
    PrefixMacro: @struct(handler: *FatExpr, arg: *FatExpr, target: *FatExpr),
    GetVar: Var,
    GetNamed: Symbol,
    String: Symbol,
    PtrOffset: @struct(ptr: *FatExpr, bytes: i64, name: Symbol),  // :FirstFieldIsTheChild
    GetParsed: WaitingParse,
    Cast: *FatExpr,
    If: @struct(cond: *FatExpr, if_true: *FatExpr, if_false: *FatExpr),
    Loop: *FatExpr,
    Addr: *FatExpr,
    Quote: *FatExpr,
    Slice: *FatExpr,
    Deref: *FatExpr,
    ConstEval: *FatExpr,
    FnPtr: *FatExpr,
    FromBitLiteral: @struct(value: i64, bit_count: i64), 
    Uninitialized,
    Unquote: *FatExpr,
    Placeholder: i64,
    Builtin: Symbol,
    ContextualField: Symbol,
    As: @struct(type: *FatExpr, value: *FatExpr),
    Unreachable,
    // On apple-arm, wasm, and riscv, #c_variadic arguments have a different calling convention than named arguments so the backend needs to know where they start. 
    CVariadicMarker,
    UndeclaredVar: @struct(name: Symbol, scope: ScopeId),
    DataSymbol: Symbol,
);

WaitingParse :: @struct(id: i64);
Values :: @tagged(
    Big: RawList(u8),
    Small: Ty(i64, u8),
);
FatStmt :: @rec @struct(
    stmt: Stmt,
    _pad1: i64 = 0,
    _pad2: i64 = 0,
    loc: Span,
    done: bool = false,
);
Stmt :: @tagged(
    Noop: void,
    Eval: FatExpr,
    DeclFunc: *Func,
    _DeclVar: @struct(_0: FatExpr, _1: LazyType, _2: Var),
    DeclVarPattern: @struct(binding: Pattern, value: FatExpr),
    _DeclNamed,
    Set: @struct(place: FatExpr, value: FatExpr),
    ExpandParsedStmts: usize,
    Annotations: RawList(Annotation),
    Decl: *Binding,  
);
Func :: @struct(
    annotations: RawList(Annotation),
    nullable_link_rename_func: i64 = 0, 
    comptime_jit_symbol_id: u32 = 0,
    has_comptime_jit_symbol_id := false,
    generation: u32 = 0,
    use_scope: ScopeId = NOSCOPE,
    callees: RawList(FuncId),
    mutual_callees: RawList(FuncId),
    var_name: ?Var,
    finished_arg: ?Type,
    finished_ret: ?Type,
    cc: ?CallConv,
    return_var: ?Var,
    scope: ?ScopeId,
    body: FuncImpl,
    arg: Pattern,
    ret: LazyType,
    name: Symbol,
    loc: Span,
    flags: i64 = 0,
);

FnFlag :: @enum(i64) (
    NoMangle, // TODO: not used yet.
    ResolvedBody,
    ResolvedSign,
    AllowRtCapture,
    EnsuredCompiled,
    AsmDone,
    TryConstantFold,
    Generic,
    UnsafeNoopCast,
    MayHaveAquiredCaptures,
    TookPointerValue,
    Once,
    OnceConsumed,
    NoInline,
    AnyConstArgs,
    MadeVarsForRuntimeArgs,
    Macro,
    BodyIsSpecial,
    SyntheticImmEval,
    ComptimeOnly,
    LogAsm,
    LogIr,
    LogAst,
    Intrinsic,
    TargetSplit,
    AlreadyHasShim,
    RealAsmDone,
    NoContext,
    YesContext,
    CVariadic,
    UnboundGenerics,
    DisallowInOverloadSet,
    WasLambdaLiteral, // in a call expression
    AllowDuplicated,
);

Annotation :: @struct(
    name: Symbol,
    _pad := 0,
    args: FatExpr,
);
Var :: @struct(
    kind: VarType,
    name: Symbol,
    id: u32,
    scope: ScopeId,
    block: u16 = 0,
);
VarType :: @enum(i64) (
    _Unused, 
    Var,
    Const,
);
CallConv :: @enum(i64) (
    CCallReg,
    Inline,
);
FuncImpl :: @rec @tagged(
    Normal: FatExpr,
    DynamicImport: DynamicImport,
    _5,
    JittedAarch64: RawList(u32),
    _0,
    _1,
    TargetOsSplit: @struct(os: Os, fid: FuncId),
    PendingRedirect: @struct(arg: Type, ret: Type, os: OverloadSet),
    Redirect: FuncId,
    Merged: RawList(FuncImpl),
    Empty,
    _2,
    Intrinsic: i64,
    _3,
    X86AsmBytes: RawList(u8),
    _4, 
    NewIntrinsic: NewIntrinsicPayload,
    Syscall: []i32,  // #syscall(linux-arm64, linux-amd64, macos)     -1 if not supported 
    Ir: PrecompiledIr,
);

// comptime=0 when you're cross compiling and it's something platform specific 
// so you can't dlopen it at comptime. that's fine, you just can't call it. 
DynamicImport :: @struct(name: Symbol, lib: Symbol, comptime: i64);

PrecompiledIr :: @struct(fn_internal: i64, data: []BakedVarId, funcs: []FuncId);  // for import_c/ffi
NewIntrinsicPayload :: @struct(ir_op: i32, ir_cls: i32);

Pattern :: @struct(
    bindings: RawList(Binding),
    loc: Span,
);

Annotations :: RawList(Annotation);

Binding :: @struct(
    name: Name,
    ty: LazyType,
    nullable_tag: *Annotations,
    // Will be Poison.EmptyBindingValue if none was there (not the same as void value for explicit `name = ()`).    fn get_default
    default: FatExpr,
    kind: VarType,
);
Name :: @tagged(
    Ident: Symbol,
    Var: Var,
    None,
);
LazyType :: @rec @tagged(
    EvilUninit: void,
    Infer,
    PendingEval: FatExpr, 
    Finished: Type, 
    Returning: Type,
    UnboundGeneric: Symbol,
    Generic: Var,
);
Span :: @struct(low: u32, high: u32);
fn is_null(s: Span) bool = s.high == 0 && s.low == 0;

TypeInfo :: @tagged(
    Int: IntTypeInfo,
    Never,
    F64,
    F32,
    Bool,
    Fn: FnType,
    FnPtr: @struct(
        ty: FnType,
        cc: CallConv,
    ),
    Ptr: Type,
    Array: @struct(
        inner: Type,
        len: u32, 
    ),
    Struct: @struct(
        // You probably always have few enough that this is faster than a hash map. // TODO: check that
        fields: RawList(Field),
        layout_done: bool,
        is_tuple: bool,
        is_union: bool,
        scope: ScopeId,
    ),
    // What rust calls an enum
    Tagged: @struct(
        cases: RawList(Ty(Symbol, Type)),
        tag: Type,
    ),
    // TODO: on assignment, check that it's a valid value. (at the very least do it for constants)
    Enum: @struct(
        raw: Type,
        fields: RawList(Ty(Symbol, Values)),
        sequential: bool
    ),
    Placeholder,
    Named: Ty(Type, Symbol),
    void, // TODO: same as empty tuple but easier to type
    VoidPtr,
    Label: Type,
);

IntTypeInfo :: @struct(
    bit_count: i64,
    signed: bool,
);

FnType :: @struct(
    // Functions with multiple arguments are treated as a tuple.
    arg: Type,
    ret: Type,
    arity: u16,
);

Field :: @struct(
    name: Symbol,
    ty: Type,
    nullable_tag: *Annotations,
    // id will be zero if absent.     fn get_default
    default: Var,
    byte_offset: i64, // TODO: make this optional so you can't forget to check if layout ready / field is constant? -- Jul 6
    _pad := 0,
);

BakedVarId :: @struct(id: u32);

// A piece of static data that can be baked into an output file (c code, object, etc).
// TODO: deduplicate
// TODO: track type so structs can be more than just a blob of bytes.
// TODO: distinguish between constant and static. For now, everything is a mutable static because the language doesn't have the concept of const pointers.
BakedVar :: @tagged(
    Zeros: i64, // length
    Bytes: RawList(u8),
    VoidPtrArray: RawList(BakedEntry),
);

BakedEntry :: @tagged(
    Num: @struct(value: i64, _ := 0),
    FnPtr: FuncId,
    AddrOf: BakedVarId,
);

TypeMeta :: @struct(
    stride_bytes: u32,
    inferred_name: Symbol = Symbol.zeroed(),
    _: u32 = 0, // TODO: remove
    size_slots: u16,  // only used in emit_ir:is_local_scalar then can removed (but will need to track seperatly in old emit_bc)
    __: u16 = 0, 
    align_bytes: u16,
    contains_pointers: bool,
    pass_by_ref: bool = false,  // TODO: can remove this now but i kinda want to keep the old emit_bc example working. should change it to track it's own bitset
    is_sized: bool,
);

#redirect(Ty(u32, u32), bool) fn eq(a: ScopeId, b: ScopeId) bool;

CompilerLogEvent :: @tagged(
    Msg: Str,
);

// :link_rename
LinkRenameArg :: @struct(
    target: TargetEnv,
    out: *List(u8),
    old_name: Str,
);

NOSCOPE :: @as(ScopeId) scope_from_index(trunc(-1)); 

// TODO: expose id like normal struct
fn scope_from_index(i: u32) ScopeId = {
    s := ptr_cast_unchecked(u32, ScopeId, i&)[]; 
    s
}

// TODO: make it possible for examples/soft_draw to work AOT (needs to link a macos framework)
DriverMessage :: @tagged(
    ReadSourceCode: @struct(path: Symbol),
    Log: @struct(message: Str),  // TODO: use this instead of print for debug_log_*?
    // TODO: implement the rest of these
    //ParseScopeEnd: @struct(path: Symbol, stmts: *RawList(FatStmt)),
    //FindImport: @struct(lib_name: Symbol, fid: FuncId, func_name: Symbol),
    CompileBodyStart: @struct(fid: FuncId),
    EmitIrStart: @struct(when: ExecStyle, fid: FuncId, internal: rawptr /*good luck*/),
    EmitIrEnd: @struct(internal: rawptr /*good luck*/, ir_type: Symbol, fid: FuncId, when: ExecStyle),
    //Disassemble: @struct(bytes: []u8),
    EmitDataEnd: @struct(internal: rawptr /*good luck*/, count: i64, internal_module: rawptr /* good luck */),
);

DriverResult :: @tagged(
    Continue: void,
    String: ?Str,  // ReadSourceCode, Disassemble 
    FoundImport: @tagged(Found: rawptr, RuntimeOnly, NotFound),
    ReplacedIr, // EmitIrStart
);
