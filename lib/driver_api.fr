Compiler :: *CompilerValue;
CompilerValue :: @struct(pointer_to_pointer_to_selfhosted: rawptr);
CompCtx :: @struct(data: Compiler, vtable: *ImportVTable);
fn CRes($T: Type) Type = Result(T, rawptr);
 
Backend :: @enum(i64) (Aarch64 = 1);
Arch :: @enum(i64) (Aarch64 = 1, X86_64 = 2);
ExecStyle :: @enum(i64) (Jit = 0, Aot = 1);
Os :: @enum(i64) (Macos = 0, Linux = 1, Windows = 2);

TargetEnv :: @struct(
    arch: Arch,
    backend: Backend,
    style: ExecStyle, 
    os: Os,
);

ExportVTable :: @struct(
    resolve_comptime_import: ?@FnPtr(userdata: rawptr, c: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = .None,
);

ImportVTable :: @rec @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    _a: usize, // TODO: remove
    init_compiler: @FnPtr(comptime_arch: Backend, options: *BuildOptions) Compiler,
    find_unique_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_fns_with_tag: @FnPtr(c: Compiler, tag: Symbol) Slice(FuncId),
    _b: usize,
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle) CRes(void),
    // SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(rawptr),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func,
    _d: usize,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) Span, 
    parse_stmts: @FnPtr(c: Compiler, f: *Span) Result(Slice(FatStmt), ParseErr),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(void),
    make_jitted_exec: @FnPtr(c: Compiler) void,
    give_vtable: @FnPtr(c: Compiler, vtable: *ExportVTable, userdata: rawptr) void,
    _k: usize,
    comptime_arch: @FnPtr() Ty(Arch, Os),
    _c: usize, 
    _l: usize,
    _m: usize,
    __a: usize,
    _f: usize, 
    __b: @FnPtr(c: Compiler, fn_body: rawptr) void,
    _e: usize,
    get_compiler_builtins_source: @FnPtr() Str,
    _i: usize,
    emit_llvm: @FnPtr(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry) BucketArray(u8),
    // TODO: HACK: last bucket is inline assembly 
    emit_qbe: @FnPtr(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry) BucketArray(u8),
    _g: usize,
    _h: usize,
    _clone_expr: usize,
    _clone_type: usize,
    _intern_type: usize,
    _get_type: usize,
    _log_type: usize,
    check_for_new_aot_bake_overloads: @FnPtr(comp: Compiler) CRes(void),
);
// TODO: better error for @FnPtr if you forget return type. 

// because you don't want people to depend on llvm.fr
// TODO: don't be a header file!
// All the functions we emit are name-mangled based on thier funcid, so you can't call them from the outside.
// We also mark them as 'private' to give llvm permisson to remove them if all uses are inlined.
// If you want to just pass the resultant ir to clang, tell us how entry points should be exposed. 
ProgramEntry :: @enum(i64) (
    // do nothing, let the caller deal with it
    GiveMeTheCodeAndGiveItToMeRaw,  
    // create a main function that calls all the <fns>
    TestRunnerMain,  
    // create named wrappers for all the <fns>. if one of them is called "main", that will be the program entry point.
    // it is an error to have a name collission. 
    ExportWithNames, 
);

ParseErr :: @struct(span: Span, msg: Str);

// TODO: depending on layout is jail. Vec isn't repr(C)
// TODO: make totally sure which cap/len order.

ComptimeEnvironment :: @struct(
    inject_function_header: ?Ty(FuncId, FuncId),
    make_slice_t: ?FuncId,
    bake_os: ?OverloadSet,
    fat_expr_type: ?Type,
    intrinsic_type: ?Type,
    build_options: rawptr,
    unquote_placeholders: ?FuncId,
    driver_vtable_ptr: rawptr,
    driver_vtable_user_data: rawptr,
);

// Note: changing these default values requires rebuilding the compiler! (an extra time if the program you're interested in is the compiler).
BuildOptions :: @struct(
    // false for smaller binary, true for better debugging. 
    // Without this, we put the `private` modifer on functions so they can be removed if all uses are inlined. 
    // With this, we also include the source string name of the function (instead of just the id), but the names are still unstable!
    // For exports you want to refer to by name, use the ProgramEntry option.
    // Note: turning this off might make it look like more ir if the word 'private' on every function adds more than the names, but the produced exe will be smaller.  
    retain_function_names: bool = false,
    // TODO: compilation order bug with disabling debug assertions -- Jul 24
    safety_checks: EnumMap(SafetyCheck, bool) = (data = init(@slice(SAFE_MODE, true, SAFE_MODE, SAFE_MODE))),
    _hack: i64,
    // Generics may cause redundant code for distinct types that have the same representation. 
    // Should the front end remedy the situation? 
    deduplicate_bytecode: bool = true,
);

SAFE_MODE :: true; // TODO: default driver program with this as a cli argument 

SafetyCheck :: @enum(i64) (
    Bounds,
    DebugAssertions, // TODO: i cant disable DebugAssertions because i have some compilation order bug. hopefully can fix with sema rewrite. -- Jul 24
    // - `index` should not change the length of a collection. 
    NonCompliantOverload, // TODO: decide if i want to do this... currently UNUSED
    InvalidTag, // @match on @tagged or @enum
);

// TODO: expose id
fn symbol_from_id(id: u32) Symbol #unsafe_noop_cast;
fn id(self: Symbol) u32 #unsafe_noop_cast;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
Symbol  :: @builtin Symbol;  // TODO: why does making this a struct here and then giving it to the compiler cause tag_value to get called with two types. -- Jun 13
ScopeId :: @builtin ScopeId;
LabelId :: @builtin LabelId;
FuncId  :: @builtin FuncId;
//LabelId :: @struct(id: u32);
//ScopeId :: @struct(id: u32);
//FuncId :: @struct(id: u32);
//Symbol :: @struct(id: u32);

FatExpr :: @rec @struct(
    expr: Expr,
    loc: Span,
    ty: Type,
    done: bool,
);
Expr :: @tagged(
    Poison: void,
    Value: @struct(bytes: Values, coerced: bool),
    Switch: @struct(value: *FatExpr, default: *FatExpr, cases: RsVec(Ty(i64, FatExpr))),
    Call: @struct(f: *FatExpr, arg: *FatExpr),
    Block: @struct(body: RsVec(FatStmt), result: *FatExpr, ret_label: ?LabelId, hoisted_constants: bool),
    Tuple: RsVec(FatExpr),
    Closure: *Func,
    _AddToOverloadSet,
    _SuffixMacro,
    FieldAccess: @struct(container: *FatExpr, name: Symbol),
    StructLiteralP: Pattern,
    PrefixMacro: @struct(handler: *FatExpr, arg: *FatExpr, target: *FatExpr),
    GetVar: Var,
    GetNamed: Symbol,
    String: Symbol,
    PtrOffset: @struct(ptr: *FatExpr, bytes: i64, name: Symbol),
    GetParsed: WaitingParse,
    Cast: *FatExpr,

    If: @struct(cond: *FatExpr, if_true: *FatExpr, if_false: *FatExpr),
    Loop: *FatExpr,
    Addr: *FatExpr,
    Quote: *FatExpr,
    Slice: *FatExpr,
    Deref: *FatExpr,
    ConstEval: *FatExpr,
    FnPtr: *FatExpr,
    FromBitLiteral: @struct(value: i64, bit_count: i64), 
    Uninitialized,
    Unquote: *FatExpr,
    Placeholder: i64,
    Builtin: Symbol,
    ContextualField: Symbol,
    As: @struct(type: *FatExpr, value: *FatExpr),
);

WaitingParse :: @struct(id: i64);
Values :: @tagged(
    Big: RsVec(u8),
    Small: Ty(i64, u8),
);
FatStmt :: @rec @struct(
    stmt: Stmt,
    annotations: RsVec(Annotation),
    loc: Span,
);
Stmt :: @tagged(
    Noop: void,
    Eval: FatExpr,
    DeclFunc: *Func,
    DeclVar: @struct(value: FatExpr, ty: LazyType, name: Var),
    DeclVarPattern: @struct(binding: Pattern, value: FatExpr),
    DeclNamed: @struct(kind: VarType, value: FatExpr, ty: LazyType, name: Symbol),
    Set: @struct(place: FatExpr, value: FatExpr),
    ExpandParsedStmts: usize,
);
Func :: @struct(
    annotations: RsVec(Annotation),
    capture_vars: Ty(usize, usize, usize), // TODO: remove
    callees: RsVec(FuncId),
    mutual_callees: RsVec(FuncId),
    var_name: ?Var,
    finished_arg: ?Type,
    finished_ret: ?Type,
    cc: ?CallConv,
    return_var: ?Var,
    scope: ?ScopeId,
    body: FuncImpl,
    arg: Pattern,
    ret: LazyType,
    name: Symbol,
    loc: Span,
    flags: u32 = 0,
);

FnFlag :: @enum(i64) (
    NotEvilUninit,
    ResolvedBody,
    ResolvedSign,
    AllowRtCapture,
    EnsuredCompiled,
    AsmDone,
    TryConstantFold,
    CalleesAsmDone,
    Generic,
    UnsafeNoopCast,
    NoStackTrace,
    MayHaveAquiredCaptures,
    TookPointerValue,
    Once,
    OnceConsumed,
);

Annotation :: @struct(
    name: Symbol,
    args: ?FatExpr,
);
Var :: @struct(
    kind: VarType,
    name: Symbol,
    id: u32,
    scope: ScopeId,
    block: u16,
);
VarType :: @enum(i64) (
    Let, 
    Var,
    Const,
);
CallConv :: @enum(i64) (
    CCallReg,
    CCallRegCt,
    _OneRetPic,
    Inline,
);
FuncImpl :: @rec @tagged(
    Normal: FatExpr,
    DynamicImport: Symbol,
    ComptimeAddr: usize,
    JittedAarch64: RsVec(u32),
    LlvmIr: Symbol,
    CSource: Symbol,
    _EmitCranelift: usize,
    PendingRedirect: @struct(arg: Type, ret: Type, os: OverloadSet),
    Redirect: FuncId,
    Merged: RsVec(FuncImpl),
    Empty: void,
    QbeIr: Symbol,
    Intrinsic: Intrinsic,
);

Pattern :: @struct(
    bindings: RsVec(Binding),
    loc: Span,
);
Binding :: @struct(
    name: Name,
    ty: LazyType,
    default: ?FatExpr,
    kind: VarType,
);
Name :: @tagged(
    Ident: Symbol,
    Var: Var,
    None,
);
LazyType :: @rec @tagged(
    EvilUninit: void,
    Infer,
    PendingEval: FatExpr, 
    Finished: Type, 
    Returning: Type,
);
Span :: @struct(low: u32, high: u32);

TypeInfo :: @tagged(
    Int: IntTypeInfo,
    Never,
    F64,
    F32,
    Bool,
    Fn: FnType,
    FnPtr: @struct(
        ty: FnType,
        cc: CallConv,
    ),
    Ptr: Type, // One element
    Array: @struct(
        inner: Type,
        len: u32, // note: not usize!! that confusing the padding cause i pass by reference now without going through InterpSend -- May 27
    ),
    Struct: @struct(
        // You probably always have few enough that this is faster than a hash map. // TODO: check that
        fields: RsVec(Field),
        layout_done: bool,
        is_tuple: bool,
        const_field_count: u16,
    ),
    // What rust calls an enum
    Tagged: @struct(
        cases: RsVec(Ty(Symbol, Type)),
        tag: Type,
    ),
    // TODO: on assignment, check that it's a valid value. (at the very least do it for constants)
    Enum: @struct(
        raw: Type,
        fields: RsVec(Ty(Symbol, Values)),
        sequential: bool
    ),
    Placeholder,
    Named: Ty(Type, Symbol),
    void, // TODO: same as empty tuple but easier to type
    VoidPtr,
    Label: Type,
);

IntTypeInfo :: @struct(
    bit_count: i64,
    signed: bool,
);

FnType :: @struct(
    // Functions with multiple arguments are treated as a tuple.
    arg: Type,
    ret: Type,
    arity: u16,
);

Field :: @struct(
    name: Symbol,
    ty: Type,
    default: ?Var,
    byte_offset: usize, // TODO: make this optional so you can't forget to check if layout ready / field is constant? -- Jul 6
    kind: VarType,
);

// TODO: this should be #ct and get it from SelfHosted.ast_arena
fn ast_alloc() Alloc = todo_allocator;

// TODO: make the other enum varient builtin so you can use it and still override eq. because my order independence doesn't really work. 
// TODO: unhandled switch case if i try to make this u8
Prim :: @enum(i64) (I8, I16, I32, I64, F64, F32, P64);

BakedVarId :: @struct(id: u32);

// A piece of static data that can be baked into an output file (c code, object, etc).
// TODO: deduplicate
// TODO: track type so structs can be more than just a blob of bytes.
// TODO: distinguish between constant and static. For now, everything is a mutable static because the language doesn't have the concept of const pointers.
BakedVar :: @tagged(
    Zeros: i64, // length
    Bytes: RsVec(u8),
    VoidPtrArray: RsVec(BakedEntry),
);

BakedEntry :: @tagged(
    Num: @struct(value: i64, ty: Prim),
    FnPtr: FuncId,
    AddrOf: BakedVarId,
);

TypeMeta :: @struct(
    _pad: i64,
    float_mask: u32,
    size_slots: u16,
    stride_bytes: u16,
    align_bytes: u16,
    contains_pointers: bool,
    pass_by_ref: bool,
);

Flag :: @enum(
    _reserved_null_,
    aarch64,
    llvm,
    cranelift,
    _reserved_end_arch_, // It's important which are above and below this point.
    generic,
    as,
    inline,
    noinline,
    asm,
    c_call,
    macro,
    placeholder,
    comptime_addr,
    init,
    slice,
    unquote_macro_apply_placeholders,
    from_bit_literal,
    rec,
    quote,
    unquote,
    deref,
    patch,
    ct,
    any_reg,
    Impl,
    main,
    builtin_if,
    builtin_while,
    if,
    loop,
    addr,
    tag,
    reflect_print,
    fn_ptr,
    toplevel,
    include_std,
    unreachable,
    rt,
    test,
    operator_star_prefix,
    operator_question_prefix,
    operator_up_arrow_prefix,
    operator_ampersand_prefix,
    operator_plus_equal,
    operator_minus_equal,
    operator_star_equal,
    operator_slash_equal,
    operator_index,
    builtin,
    no_memo,
    uninitialized,
    const_eval,
    contextual_field,
    outputs,
    when,
    one_ret_pic,
    Anon,
    log_bc,
    log_asm,
    log_ir,
    log_ast,
    skip_cranelift,
    log_asm_bc,
    return,
    cranelift_emit,
    force_cranelift,
    force_aarch64,
    tail,
    redirect,
    libc,
    __shift_or_slice,
    no_tail, // TOOD: HACK. stack ptr/slice arg is UB so have to manually use this! not acceptable!
    __return,
    __get_assertions_passed,
    __string_escapes,
    test_broken,
    load,
    store,
    fold,
    ptr,
    len,
    export,
    __tag_check,
    c,
    unsafe_noop_cast,
    import,
    type,
    struct,
    tagged,
    enum,
    bake_relocatable_value,
    local_return,
    no_trace,
    compiler_builtin_transform_callsite,
    late,
    once,
    qbe,
    intrinsic,
    _reserved_count_,  // TODO: remove. this langauge has non-garbage reflection. 
    compiler_debug_assert_eq_i64,
    
    // These are operators that have syntax desugaring. 
    add, sub, mul, div, lt, gt, ge, le, eq, ne, neg, not, and,
    operator_squares_prefix,
    
    // These can be used with @builtin.
    OverloadSet, Scope, FuncId, LabelId, Symbol, i64, bool, true, false,
    
    // These must be in order because tuple field names use them and compute by offsetting Flag._0.raw().
     _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9, 
    _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,
);

#redirect(Ty(u32, u32), bool) fn eq(a: ScopeId, b: ScopeId) bool;
#redirect(*Symbol, i64) fn hash(i: *Type) i64;
#redirect(Ty(u32, u32), bool) fn ne(a: Type, b: Type) bool;
