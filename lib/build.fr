
LinkTime :: @enum(i64) (Static, Dynamic);

// TODO: hack
// TODO: switch between clang and clang++ based on lib
CLANG_PATH :: "/opt/homebrew/opt/llvm/bin/clang++";

fn with(vtable: *ImportVTable, comp: Compiler) CompCtx = 
    (data = comp, vtable = vtable);

fn get_tagged(comp: CompCtx, tag: Str) Slice(FuncId) = {
    tag := {comp.vtable.intern_string}(comp.data, tag);
    {comp.vtable.get_fns_with_tag}(comp.data, tag)
}

// TODO: overloading
fn get_unique_named(c: CompCtx, name: Str) ?FuncId = {
    f := {c.vtable.intern_string}(c.data, name);
    {c.vtable.find_unique_func}(c.data, f)
}
// SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
// TODO: no unwrap! return error. but then llvm backend has to be able to deal with tagged unions correctly. 
fn get_jitted(c: CompCtx, f: FuncId) rawptr = {
    res := {c.vtable.compile_func}(c.data, f, .Jit).unwrap();
    ptr := {c.vtable.get_jitted_ptr}(c.data, f).unwrap();
    {c.vtable.make_jitted_exec}(c.data);
    ptr
}

fn new_with_src(vtable: *ImportVTable, src: Str, arch: Backend) Compiler = {
    comp := {vtable.init_compiler}(arch);
    file := {vtable.add_file}(comp, "main", src);
    stmts := {vtable.parse_stmts}(comp, file&).unwrap();
    {vtable.make_and_resolve_and_compile_top_level}(comp, stmts).unwrap();
    comp
}

TmpFile :: @struct(name: Array(u8, 16), fd: Fd);
fn remove(self: TmpFile) voidResult = remove(self&.c_name());
fn c_name(self: *TmpFile) CStr = (ptr = self.name&.as_ptr());
fn s_name(self: *TmpFile) Str = self.c_name().str();

fn open_temp_file() TmpFile = {
    template := "/tmp/fXXXXXX\0";
    name: Array(u8, 16) = init(@as(u8) 0.trunc());
    name&.items().subslice(0, template.len).copy_from(template);
    filename: CStr = (ptr = name&.as_ptr());
    fd := mkstemp(filename).unwrap();
    (name = name, fd = fd)
}

fn exec_cmd(path: Str, args: Slice(Str)) Never = {
    path := path.maybe_borrow_cstr(temp()); // LEAK, but who cares, we just forked. 
    cargs: List(CStr) = list(args.len.add(2), temp());
    cargs&.push(path);
    for(args) {s|
        cargs&.push(s.maybe_borrow_cstr(temp()));
    };
    // TODO: this is what llvm doen't like, it cant do ptr_from_int.
    cargs&.push((ptr = u8.ptr_from_int(0))); // libc wants a null terminated array.
    execv(path, cargs.maybe_uninit.ptr);
    
    // ERROR
    @println("Failed to exec path=%", path);
    cargs.len -= 1; // don't try to print the null terminator
    for(cargs) {s|
        @println("- %", s);
    };
    panic("failed to exec!")
}

// TODO: better error handling. 
// TODO: use posix_spawnp instead? that makes it easier to return an error to the caller. using fork is a pain. 
// TODO: it doesn't look up the command like a shell does.
fn run_cmd_blocking(path: Str, args: Slice(Str)) bool = {
    pid := fork();
    if(pid.eq(0.intcast())) {|
       exec_cmd(path, args);
       unreachable();
    };
    
    status: i32 = 0.intcast();
    res := waitpid(pid, status&, 0.intcast()); 
    :: assert_eq(i32);
    assert_eq(res, pid); // TODO: error handling, check errno
    status.eq(0.intcast())
}

// TODO: return error if this becomes a lib thing which it probably should. 
fn read_to_string(alloc: Alloc, path: Str) List(u8) = {
    bytes: List(u8) = list(alloc);
    bytes&.read_and_push(path);
    bytes
}

// TODO: return error
fn read_and_push(out: *List(u8), path: Str) void = {
    path := path.maybe_borrow_cstr(out.gpa); // TODO: LEAK
    flag := (@as(i64) OpenFlag.Read);
    f := open(path, flag).unwrap();
    len := f.lseek(0, .End).unwrap();
    f.lseek(0, .Set);
    out.reserve(len);
    ptr := out.maybe_uninit.ptr.offset(out.len);
    read_len := read(f, ptr, out.maybe_uninit.len).unwrap();
    assert_eq(read_len, len); // sanity
    out.len += len;
    close(f); // TODO: defer
}

fn fork_and_catch(alloc: Alloc, $f: @Fn() void) Ty(bool, List(u8), List(u8)) = {
    out := Array(Fd, 2).zeroed();
    err := Array(Fd, 2).zeroed();
    pipe(out&);
    pipe(err&);
    
    pid := fork();
    if(pid.eq(0.intcast())){|
        // Child
        dup2(out&[1], STD_OUT);
        dup2(err&[1], STD_ERR);
        
        // need to make sure there's something on both pipes or it blocks?
        println(" ");
        err := STD_ERR;
        err&.write(" ");
        
        f();
        exit(0);
    };
    
    read_all :: fn(fd: Fd) List(u8) => {
        buf: List(u8) = list(99999, alloc);
        len := read(fd, buf.maybe_uninit.ptr, buf.maybe_uninit.len).unwrap();
        buf.len = len;
        buf
    };

    status := 0.intcast();
    waitpid(pid, status&, 0.intcast());

    // TODO: how big is the pipe's buffer?
    outs := read_all(out&[0]);
    errs := read_all(err&[0]);
    close(out&[0]);
    close(err&[0]);

    (status.eq(0.intcast()), outs, errs)
}

fn render_callgraph(comp: CompCtx, entry_points: Slice(FuncId), out_a: Alloc) List(u8) = {
    out: List(u8) = list(out_a);
    pending: List(FuncId) = entry_points.clone(temp());
    done: BitSet = empty();
    while(=> pending.len.ne(0)){|
        continue :: local_return;
        fid := pending&.pop().unwrap();
        if(done&.get(fid.to_index().zext()), => continue()); // might have been added multiple times
        done&.set(fid.to_index().zext(), temp());
        
        // Note: compile before checking callees!
        {comp.vtable.compile_func}(comp.data, fid, .Aot).unwrap();
        func := {comp.vtable.get_function}(comp.data, fid);
        @fmt(out&, "\n[%]\n   - ", {comp.vtable.get_string}(comp.data, func.name));
        
        callee :: fn(c: FuncId) void => {
            func := {comp.vtable.get_function}(comp.data, c);
            @fmt(out&, "%, ", {comp.vtable.get_string}(comp.data, func.name));
            if(not(done&.get(c.to_index().zext()))){|
                pending&.push(c);
            };
        
        };
        
        for(func.callees.items(), callee);
        out&.push_all("\n   - ");
        for(func.mutual_callees.items(), callee);
    };
    out
}

// TODO auto fucking matic
fn display(self: Arch, out: *List(u8)) void = {
    s: Str = @switch(self) {
        @case(.Aarch64) => "aarch64";
        @case(.X86_64) => "x86_64";
    };
    out.push_all(s);
}

fn display(self: Os, out: *List(u8)) void = {
    s: Str = @switch(self) {
        @case(.Macos) => "macos";
        @case(.Linux) => "linux";
        @case(.Windows) => "windows";
    };
    out.push_all(s);
}

fn save_path_for_lib(env: Ty(Arch, Os), linking: LinkTime, lib_name: Str) Str = {
    ext := @switch(linking) {
        @case(.Static) => "o";
        @case(.Dynamic) => "dylib";
    };
    (@format("target/franca/%-%/%.%", env._0, env._1, lib_name, ext) temp()).items()
}

#redirect(Ty(i64, i64), bool) fn eq(a: Os, b: Os) bool;
#redirect(Ty(i64, i64), bool) fn eq(a: LinkTime, b: LinkTime) bool;

// TODO: not this!
#redirect(Ty(i64, i64), bool) fn eq(a: Arch, b: Arch) bool;
#redirect(Ty(i64, i64), bool) fn ne(a: Arch, b: Arch) bool;

fn ident(name: Flag) Symbol = {
    symbol_from_id((@as(i64) name).trunc())
}


// Essentially describing something to pass to clang (after adding some combination of -o -O -c -dynamiclib -static -ast-dump) 
ForeignLibrary :: @struct(
    name: Str, // for caching the output file and #import functions knowing which dylib to check. 
    input_files: Slice(Str) = empty(),
    macro_defines: Slice(Str) = empty(),     // -D, ie. SOME_LIB_IMPL
    include_paths: Slice(Str) = empty(),     // -I,
    macos_frameworks: Slice(Str) = empty(),  // -framework, ie. MetalKit
    objective_c: bool = false,
    raw_c_source: ?Str = .None,
);

// TODO: move these to x/<name>
// TODO: impl build system with these. make it a one-liner to add a dependency to driver. 

wuffs_lib: ForeignLibrary : (
    name = "wuffs",
    input_files = "bindings/wuffs/release/c/wuffs-v0.4.c".single(ast_alloc()),
    macro_defines = "WUFFS_IMPLEMENTATION".single(ast_alloc()),
);

sokol_macos_lib: ForeignLibrary : (
    name = "sokol",
    macro_defines = @slice("SOKOL_METAL", "SOKOL_IMPL", "SOKOL_NO_ENTRY") ast_alloc(),
    include_paths = "bindings/sokol".single(ast_alloc()),
    macos_frameworks = @slice("Metal", "MetalKit", "Cocoa", "QuartzCore") ast_alloc(),
    objective_c = true,
    raw_c_source = (Some = """
        #include "sokol_app.h"
        #include "sokol_gfx.h"
        #include "sokol_glue.h"
        #include "sokol_log.h"
        #include "util/sokol_debugtext.h"
        #include "util/sokol_gl.h"
        #include "util/sokol_shape.h"
    """),
);

// TODO: be consistant about figuring out the cwd
tracy_lib: ForeignLibrary : (
    name = "tracy",
    input_files = "../bindings/tracy/public/TracyClient.cpp".single(ast_alloc()),
    macro_defines = "TRACY_ENABLE=1".single(ast_alloc()),
    include_paths = "../bindings/tracy".single(ast_alloc()),
);

fn build_foreign_cached(lib: ForeignLibrary, env: Ty(Arch, Os), linking: LinkTime) Result(Str, void) = {
    path := save_path_for_lib(env, linking, lib.name);
    if(path.file_exists(), => return((Ok = path)));
    
    args: List(Str) = list(10, temp());
    
    for lib.include_paths { s | 
        s := @format("-I%", s) temp();
        args&.push(s.items());
    };
    
    for lib.macro_defines { s | 
        s := @format("-D%", s) temp();
        args&.push(s.items());
    };
    
    if lib.objective_c {|
        args&.push_all(@slice ("-x", "objective-c"));
    };
    
    // TODO: put this on the lib struct? tracy spams
    args&.push("-Wno-deprecated-declarations");
    
    assert(lib.raw_c_source.is_none(), "TODO: write file and compile it");
    for lib.input_files { s | 
        args&.push(s);
    };
    
    assert(lib.macos_frameworks.is_empty(), "TODO: do you need to tell it frameworks now?");
    
    @switch(linking) {
        @case(.Static) => {
            args&.push("-c");
            args&.push("-static");// TODO: only tracy?
        };
        @case(.Dynamic) => args&.push("-dynamiclib");
    };
    args&.push_all(@slice ("-o", path));
    
    // Since we save it, might as well take the extra hundred years to make it go fast. 
    args&.push("-Os");
    
    
    @println("[build %] %;", lib.name, args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    if(not(success), => return(.Err));
    
    (Ok = path)
}

::display_slice(Str);
