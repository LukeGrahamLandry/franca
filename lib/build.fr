
LinkTime :: @enum(i64) (Static, Dynamic);

// TODO: hack
// TODO: switch between clang and clang++ based on lib
CLANG_PATH :: "/opt/homebrew/opt/llvm/bin/clang++";

fn with(vtable: *ImportVTable, comp: Compiler) CompCtx = 
    (data = comp, vtable = vtable);

fn get_tagged(comp: CompCtx, tag: Str) Slice(FuncId) = {
    tag := {comp.vtable.intern_string}(comp.data, tag);
    {comp.vtable.get_fns_with_tag}(comp.data, tag)
}

// TODO: overloading
fn get_unique_named(c: CompCtx, name: Str) ?FuncId = {
    f := {c.vtable.intern_string}(c.data, name);
    {c.vtable.find_unique_func}(c.data, f)
}

// SAFETY: you must call created_jit_fn_ptr_value if you create a Values and then compile for AOT
// TODO: no unwrap! return error. but then llvm backend has to be able to deal with tagged unions correctly. 
fn get_jitted(c: CompCtx, f: FuncId) rawptr = {
    res := {c.vtable.compile_func}(c.data, f, .Jit).unwrap();
    ptr := {c.vtable.get_jitted_ptr}(c.data, f).unwrap();
    ptr
}

fn default_build_options(vtable: *ImportVTable) *BuildOptions = {
    mem := libc_allocator.alloc(BuildOptions, 1);
    mem.ptr[] = (driver_vtable_ptr = {vtable.get_default_driver_exports}());
    mem.ptr
}

fn new_with_src(vtable: *ImportVTable, src: Str, options: *BuildOptions) Compiler = {
    comp := {vtable.init_compiler}(options);
    file := {vtable.add_file}(comp, "main", src);
    stmts := {vtable.parse_stmts}(comp, file&).unwrap();
    {vtable.make_and_resolve_and_compile_top_level}(comp, stmts).unwrap();
    comp
}

fn intern_string(comp: CompCtx, s: Str) Symbol = {
    {comp.vtable.intern_string}(comp.data, s)
}

fn get_string(comp: CompCtx, s: Symbol) Str = {
    {comp.vtable.get_string}(comp.data, s)
}

fn get_function(comp: CompCtx, f: FuncId) *Func = {
    {comp.vtable.get_function}(comp.data, f)
}

fn get_function_name(comp: CompCtx, f: FuncId) Symbol = {
    comp.get_function(f)[].name
}

TmpFile :: @struct(name: Array(u8, 16), fd: Fd);
fn remove(self: TmpFile) voidResult = remove(self&.c_name());
fn c_name(self: *TmpFile) CStr = (ptr = self.name&.as_ptr());
fn s_name(self: *TmpFile) Str = self.c_name().str();

fn open_temp_file() TmpFile = {
    template := "/tmp/fXXXXXX\0";
    name: Array(u8, 16) = init(@as(u8) 0.trunc());
    name&.items().subslice(0, template.len).copy_from(template);
    filename: CStr = (ptr = name&.as_ptr());
    fd := mkstemp(filename).unwrap();
    (name = name, fd = fd)
}

fn exec_cmd(path: Str, args: Slice(Str)) Never = {
    path := path.maybe_borrow_cstr(temp()); // LEAK, but who cares, we just forked. 
    cargs: List(CStr) = list(args.len.add(2), temp());
    cargs&.push(path);
    for(args) {s|
        cargs&.push(s.maybe_borrow_cstr(temp()));
    };
    // TODO: this is what llvm doen't like, it cant do ptr_from_int.
    cargs&.push((ptr = u8.ptr_from_int(0))); // libc wants a null terminated array.
    execvp(path, cargs.maybe_uninit.ptr);
    
    // ERROR
    @println("Failed to exec path=%", path);
    cargs.len -= 1; // don't try to print the null terminator
    for(cargs) {s|
        @println("- %", s);
    };
    panic("failed to exec!")
}

// TODO: better error handling. 
// TODO: use posix_spawnp instead? that makes it easier to return an error to the caller. using fork is a pain. 
// TODO: it doesn't look up the command like a shell does.
fn run_cmd_blocking(path: Str, args: Slice(Str)) bool = {
    pid := fork();
    if(pid.eq(0.intcast())) {
       exec_cmd(path, args);
    };
    
    status: i32 = 0.intcast();
    res := waitpid(pid, status&, 0); 
    :: assert_eq(i32);
    assert_eq(res, pid); // TODO: error handling, check errno
    status.eq(0.intcast())
}

// TODO: a version that returns error instead of panicking
fn read_to_string(alloc: Alloc, path: Str) List(u8) = {
    bytes: List(u8) = list(alloc);
    bytes&.read_and_push(path);
    bytes
}

// TODO: a version that returns error instead of panicking
fn read_and_push(out: *List(u8), path: Str) void = {
    log_err :: fn() => @panic("Failed to read file '%'", path);
    path := path.maybe_borrow_cstr(out.gpa); // TODO: LEAK
    f := open_read(path).or(=> log_err());
    len := f.lseek(0, .End).or(=> log_err());
    f.lseek(0, .Set);
    out.reserve(len);
    ptr := out.maybe_uninit.ptr.offset(out.len);
    read_len := read(f, ptr, out.maybe_uninit.len).or(=> log_err());
    assert_eq(read_len, len); // sanity
    out.len += len;
    close(f); // TODO: defer
}

// :TooManyArgsX64
fn emit_llvm(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId), entry: ProgramEntry, arch: Arch, os: Os) BucketArray(u8) #inline = {
    _ := alloc;  // TODO
    target: TargetEnv = (arch = arch, os = os);
    {comp.vtable.emit_llvm}(comp.data, fns, entry, target&)
}

// :TooManyArgsX64
fn exec_and_catch(path: Str, args: Slice(Str), alloc: Alloc) Ty(bool, List(u8), List(u8)) #inline = {
    fork_and_catch(alloc) {
        exec_cmd(path, args);
    }
}

// TODO: move this to sys/process.fr
fn fork_and_catch(alloc: Alloc, $f: @Fn() void) Ty(bool, List(u8), List(u8)) = {
    out := Array(Fd, 2).zeroed();
    err := Array(Fd, 2).zeroed();
    pipe(out&);
    pipe(err&);
    
    pid := fork();
    if(pid.eq(0.intcast())){
        // Child
        dup2(out&[1], STD_OUT);
        dup2(err&[1], STD_ERR);
        
        f();
        exit(0);
    };
    
    // TODO: manual outlining like people do in rust is kinda annoying.
    //       but also mine is extra dumb because i still copy and recompile this for every const argument of the outer function,
    //       and rely on deduplicating to fix it.
    fn collect_output(alloc: Alloc, out: Fd, err: Fd, pid: i32) Ty(bool, List(u8), List(u8)) = {
        base_buffer_size := 65536;
        // TODO: make base buffer size a default argument
        outs: List(u8) = list(base_buffer_size, alloc);
        errs: List(u8) = list(base_buffer_size, alloc);
        
        flag: u16 = (@as(i64) PollEvents.In).trunc();
        o: PollFds = (fd = out, events = flag, revents = 0);
        e: PollFds = (fd = err, events = flag, revents = 0);
        poll_data: Array(PollFds, 2) = init(@slice(o, e));
        poll_data := poll_data&.items();
        
        // If the output of the forked thing were small it would be good enough to just allocate a big buffer and read it all into it after waiting with hang.
        // but i think if it fills the pipe it hangs forever cause you cant read to clear the pipe because you're blocking until the process ends,
        // and its blocking until theres room to write more in the pipe. 
        status := 0.intcast();
        dowhile() {()bool|
            fn read_some(buf: *List(u8), f: PollFds) void = {
                c := (@as(i64) f.revents.zext()).bit_and(@as(i64) PollEvents.In) != 0;
                if c {
                    len := read(f.fd, buf.maybe_uninit.ptr.offset(buf.len), buf.maybe_uninit.len - buf.len).unwrap();
                    buf.len += len;
                    if buf.len == buf.maybe_uninit.len {
                        buf.reserve(buf.len);
                        read_some(buf, f);
                    };
                };
            };
    
            usleep(1000);
            was_done := waitpid(pid, status&, @as(i64) WaitPidOptions.NoHang);
            can_read := poll(poll_data, 0).unwrap();
            read_some(outs&, poll_data[0]);
            read_some(errs&, poll_data[1]);
            was_done == 0
        };
        close(out);
        close(err);
        (status.eq(0.intcast()), outs, errs)
    }
    collect_output(alloc, out&[0], err&[0], pid)
}

fn render_callgraph(comp: CompCtx, entry_points: Slice(FuncId), out_a: Alloc) List(u8) = {
    out: List(u8) = list(out_a);
    pending: List(FuncId) = entry_points.clone(temp());
    done: BitSet = empty();
    while(=> pending.len.ne(0)){
        continue :: local_return;
        fid := pending&.pop().unwrap();
        if(done&.get(fid.to_index().zext()), => continue()); // might have been added multiple times
        done&.set(fid.to_index().zext(), temp());
        
        // Note: compile before checking callees!
        {comp.vtable.compile_func}(comp.data, fid, .Aot).unwrap();
        func := {comp.vtable.get_function}(comp.data, fid);
        @fmt(out&, "\n[%]\n   - ", {comp.vtable.get_string}(comp.data, func.name));
        
        callee :: fn(c: FuncId) void => {
            func := {comp.vtable.get_function}(comp.data, c);
            @fmt(out&, "%, ", {comp.vtable.get_string}(comp.data, func.name));
            if(not(done&.get(c.to_index().zext()))){
                pending&.push(c);
            };
        
        };
        
        for(func.callees.items(), callee);
        out&.push_all("\n   - ");
        for(func.mutual_callees.items(), callee);
    };
    out
}

fn save_path_for_lib(env: Ty(Arch, Os), linking: LinkTime, lib_name: Str) Str = {
    ::enum(LinkTime);
    ext := @match(linking) {
        fn Static() => "o";
        fn Dynamic() => "dylib";
    };
    (@format("target/franca/%-%/%.%", env._0, env._1, lib_name, ext) temp()).items()
}

#redirect(Ty(i64, i64), bool) fn eq(a: LinkTime, b: LinkTime) bool;

// Essentially describing something to pass to clang (after adding some combination of -o -O -c -dynamiclib -static -ast-dump) 
ForeignLibrary :: @struct(
    name: Str, // for caching the output file and #import functions knowing which dylib to check. 
    input_files: Slice(Str) = empty(),
    macro_defines: Slice(Str) = empty(),     // -D, ie. SOME_LIB_IMPL
    include_paths: Slice(Str) = empty(),     // -I,
    macos_frameworks: Slice(Str) = empty(),  // -framework, ie. MetalKit
    objective_c: bool = false,
    raw_c_source: ?Str = .None,
    allow_at_comptime: bool = true,
    cpp: bool = false,
);

ForeignLanguage :: @enum(C, CPlusPlus, ObjectiveC);

// TODO: move these to x/<name>
// TODO: impl build system with these. make it a one-liner to add a dependency to driver. 

wuffs_lib: ForeignLibrary : (
    name = "wuffs",
    input_files = "bindings/wuffs/release/c/wuffs-v0.4.c".single(ast_alloc()),
    macro_defines = "WUFFS_IMPLEMENTATION".single(ast_alloc()),
);

sokol_macos_lib: ForeignLibrary : (
    name = "sokol",
    macro_defines = @slice("SOKOL_METAL", "SOKOL_IMPL", "SOKOL_NO_ENTRY") ast_alloc(),
    include_paths = "bindings/sokol".single(ast_alloc()),
    macos_frameworks = @slice("Metal", "MetalKit", "Cocoa", "QuartzCore") ast_alloc(),
    objective_c = true,
    raw_c_source = (Some = SOKOL_ALL_SOURCE),
);

SOKOL_ALL_SOURCE :: """
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_glue.h"
#include "sokol_log.h"
#include "sokol_time.h"
// #include "sokol_audio.h"
#include "util/sokol_debugtext.h"
#include "util/sokol_gl.h"
#include "util/sokol_shape.h"
"""


sokol_and_imgui_macos_lib: ForeignLibrary : (
    name = "sokol_imgui",
    macro_defines = @slice("SOKOL_METAL", "SOKOL_IMPL", "SOKOL_NO_ENTRY", "CIMGUI_DEFINE_ENUMS_AND_STRUCTS") ast_alloc(),
    include_paths = @slice("bindings/sokol", "bindings/cimgui") ast_alloc(),
    macos_frameworks = @slice("Metal", "MetalKit", "Cocoa", "QuartzCore") ast_alloc(),
    objective_c = true,
    raw_c_source = (Some = SOKOL_AND_IMGUI_ALL_SOURCE),
    allow_at_comptime = false,
);

SOKOL_AND_IMGUI_ALL_SOURCE :: """
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_glue.h"
#include "sokol_log.h"
#include "sokol_time.h"
// #include "sokol_audio.h"
#include "util/sokol_debugtext.h"
#include "util/sokol_gl.h"
#include "util/sokol_shape.h"
#include "cimgui.h"
#include "util/sokol_imgui.h"
"""

// TODO: be consistant about figuring out the cwd
tracy_lib: ForeignLibrary : (
    name = "tracy",
    input_files = "bindings/tracy/public/TracyClient.cpp".single(ast_alloc()),
    macro_defines = "TRACY_ENABLE=1".single(ast_alloc()),
    include_paths = "bindings/tracy".single(ast_alloc()),
);

// dont forget recursive clone git submodules
dearimgui_lib: ForeignLibrary : (
    name = "dearimgui",
    include_paths = ("bindings/cimgui").single(ast_alloc()),
    raw_c_source = (Some = """
#include "imgui/imgui.cpp"
#include "imgui/imgui_draw.cpp"
#include "imgui/imgui_tables.cpp"
#include "imgui/imgui_widgets.cpp"
#include "imgui/imgui_demo.cpp"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "cimgui.cpp"
    """),
    cpp = true,
);

::display_slice(Str);
fn build_foreign_cached(lib: ForeignLibrary, env: Ty(Arch, Os), linking: LinkTime) Result(Str, void) = {
    path := save_path_for_lib(env, linking, lib.name);
    if(path.file_exists(), => return((Ok = path)));
    
    args: List(Str) = list(10, temp());
    
    for lib.include_paths { s | 
        s := @format("-I%", s) temp();
        args&.push(s.items());
    };
    
    for lib.macro_defines { s | 
        s := @format("-D%", s) temp();
        args&.push(s.items());
    };
    
    if lib.objective_c {
        args&.push_all(@slice ("-x", "objective-c"));
    };
    
    if lib.cpp {
        args&.push_all(@slice ("-x", "c++"));
    };
    
    // TODO: put this on the lib struct? tracy spams
    args&.push("-Wno-deprecated-declarations");
    
    src_file: ?TmpFile = .None;
    if lib.raw_c_source { src | 
        src_file = (Some = open_temp_file());
        f := src_file.Some&;
        f.fd&.write(src);
        args&.push(f.s_name()); // Note: this points into the thing so it can't move. // TODO: footgun :(
    };
    
    for lib.input_files { s | 
        args&.push(s);
    };
    
    ::enum(LinkTime);
    @match(linking) {
        fn Static() => {
            args&.push("-c");
            args&.push("-static");// TODO: only tracy?
        };
        fn Dynamic() => {
            args&.push("-dynamiclib");
            
            // TODO: if os == macos
            for lib.macos_frameworks { name |
                args&.push("-framework");
                args&.push(name);
            };
        };
    };
    args&.push_all(@slice ("-o", path));
    
    // Since we save it, might as well take the extra hundred years to make it go fast. 
    args&.push("-Os");
    
    args&.push("-target");
    args&.push(target_triple(env._0, env._1));

    @println("[build %] %;", lib.name, args.items());
    success := run_cmd_blocking("clang++", args.items());  // TODO: use the right clang (might not want ++ for something that can be compiled as either)
    if(not(success), => return(.Err));
    
    if src_file { f |
        f.remove();
    };
    
    (Ok = path)
}

fn target_triple(arch: Arch, os: Os) Str = {
    @match(os) {
        fn macos() => {
            @match(arch) {
                fn aarch64() => return("aarch64-apple-darwin");
                fn x86_64()  => return("x86_64-apple-darwin");
                @default => ();
            };
        }
        fn linux() => {
            // TODO: dont always say musl!!
            @match(arch) {
                fn aarch64() => return("aarch64-linux-musl");
                fn x86_64()  => return("x86_64-linux-musl");
                @default => ();
            };
        }
        // TODO: you want this but then you have to deal with #target_arch not supporting all options
        //fn free_standing() => {
        //    @match(arch) {
        //        fn wasm32() => return("wasm32");
        //        @default => ();
        //    };
        //}
        //@default => ();
    };
    @panic("we don't support the triple for % % because we are dumb and bad and new", arch, os)
}
    
ComptimeLibs :: @struct(
    ctx: CompCtx, 
    handles: HashMap(Symbol, BuiltLib),
);

// TODO: all these should get the allocator from the compiler 
//       so they don't have to use ast_alloc#ct so drivers could be prebuilt as a normal program
fn empty_libs(ctx: CompCtx) ComptimeLibs = {
    (ctx = ctx, handles = init(ast_alloc()))
}

BuiltLib :: @struct(
    jit: ?DlHandle,
    aot_object_file: ?Str,
);

fn add_lib(self: *ComptimeLibs, lib: ForeignLibrary) void = {
    env := {self.ctx.vtable.comptime_arch}();  // TODO: pass in for cross compiling
    
    ::Result(Str, void);
    aot_path := lib.build_foreign_cached(env, .Static).unwrap();
    
    ::if(?DlHandle);
    jit: ?DlHandle = if lib.allow_at_comptime {
        jit_path := lib.build_foreign_cached(env, .Dynamic).unwrap(); 
        jit := dlopen(jit_path.maybe_borrow_cstr(temp()), DlFlag.Lazy);
        @assert(!jit.lib.is_null(), "failed to open '%' at '%' for comptime", lib.name, jit_path);
        (Some = jit)
    } else {
        .None
    };
    
    built: BuiltLib = (jit = jit, aot_object_file = (Some = aot_path));
    name := self.ctx.intern_string(lib.name);
    prev := self.handles&.insert(name, built);
    @assert(prev.is_none(), "added lib % twice", lib.name);
}

// TODO: forward to another if we aren't the first to set the pointer? maybe all the handlers should be lists? idk. 
fn intercept_imports(self: *ComptimeLibs) void = {
    opts := {self.ctx.vtable.get_build_options}(self.ctx.data);
    opts.driver_vtable_ptr.resolve_comptime_import = (Some = comptimelibs_resolve_import);
    opts.driver_vtable_user_data = ComptimeLibs.raw_from_ptr(self);
}

fn get_aot_objects(self: *ComptimeLibs) List(Str) = {
    out: List(Str) = list(self.handles.raw.len_including_tombstones, temp());
    
    each self.handles& { _, v | 
        if v.aot_object_file { path | 
            out&.push(path);
        };
    };
    
    out
}

// TODO: be able to use overloading and manually resolve when you need a function pointer with the first arg type erased. 
comptimelibs_resolve_import :: fn(userdata: rawptr, comp: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = {
    self := ComptimeLibs.ptr_from_raw(userdata);
    lib := self.handles&.get_ptr(lib_name).or() {
        return(.None)
    };
    fn_name := self.ctx.get_string(fn_name); // TODO: expose get_c_str function
    // TODO: dont unwrap here and let this function return if available for jit and aot seperatly
    f := dlsym(lib.jit.unwrap(), fn_name.maybe_borrow_cstr(temp()));
    @assert(!f.is_null(), "Missing function '%' in '%'", fn_name, self.ctx.get_string(lib_name));
    (Some = f)
};

// TODO: stop calling this! its in the env already
get_comptime_arch :: fn() Arch = {
    @run { 
        a := query_current_arch();
        a.unwrap()
    }
}
