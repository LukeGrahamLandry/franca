fn has_pointers(T: Type) bool #fold = {
    i := T.get_meta();
    i.contains_pointers
}

fn get_fields(S: Type) Slice(Field) #fold = {
    info := get_type_info_ref(S); 
    assert(info.is(.Struct), "Expected struct type");
    info.Struct.fields.items() 
}

fn get_variants(S: Type) Slice(Ty(Symbol, Type)) #fold = {
    info := get_type_info_ref(S); 
    assert(info.is(.Tagged), "Expected @tagged type");
    fuck := info.Tagged.cases;
    ::List(Ty(Symbol, Type));
    fuck.items() 
}

// SAFETY: S must be a struct with field f. 
get_field_ptr :: fn($S: Type, self: *S, $f: *Field) *f[].ty #generic #inline = {
    @run {
        assert(!(f[].kind == VarType.Const), "cannot get pointer to constant field");
    };
    inner := S.int_from_ptr(self);
    inner := inner + (:: f[].byte_offset);
    inner := f[].ty.ptr_from_int(inner);
    inner
}

// TODO: if you pass a pointer as $t it still tpyechecks !!! :FUCKED -- Jul 16
get_variant_ptr :: fn($E: Type, self: *E, $t: E.Tag()) *E.get_variant_type(t) #generic #inline = {
    inner := E.int_from_ptr(self);
    inner := inner + 8;
    inner := E.get_variant_type(t).ptr_from_int(inner);
    inner
}

// TODO: if you get garbage memory / safety cvheck failed here its becasue it doesnt typecheck maybe. -- Jul 16 :FUCKED
get_variant_type :: fn($E: Type, t: E.Tag()) Type #generic = {
    cases := E.get_variants();
    ::tagged(E); // :sema_regression. but might just be order?
    data := cases.index(t.ordinal());
    data._1
}

get_variant_ptr_for :: fn($E: Type, self: *E, $case: *Ty(Symbol, Type)) *case[]._1 #generic #inline = {
    inner := E.int_from_ptr(self);
    inner := inner + 8;
    inner := case[]._1.ptr_from_int(inner);
    inner
}
