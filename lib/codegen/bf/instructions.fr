//! https://esolangs.org/wiki/Brainfuck
//! Interesting some similarities to web assembly, 
//! - It's a harvard architecture (code and data don't share an address space)
//! - Only structured control flow (bf doesn't even have functions, just while loops)

const Bf = @enum(i64) (
    Right  = 0x3E,  // >
    Left   = 0x3C,  // <
    Inc    = 0x2B,  // +
    Dec    = 0x2D,  // -
    Output = 0x2E,  // .   output the byte in the cell
    Input  = 0x2C,  // ,   read a byte of input to the cell
    Open   = 0x5B,  // [   jump past matching ] if ptr[].eq(0)
    Close  = 0x5D,  // ]   jump back to matching [ if ptr[].ne(0)
);

const set_zero = "[-]";

//////////
// Each basic block has a header that handles calling the correct block based on an offset in the data array. 
// When target_offset is 0, it means enter the next block, and you decrement it for each one you pass. 
// The end of a block must put where to go next in memory. This implements unconditional jumps. 
// Wrap the whole list of blocks in +[- ___ +] so you wrap around and use high offsets to go backwards. 
//////////
//          ; initial layout: ptr=a=0; stored=1; cond=0; next=target_offset
// >>>      ; ptr=next
// [ - <  ] ; if (next) decrement next; ptr=cond for exit; 
// <<       ; next to stored OR cond to a
// [<       ; if (ptr)  ptr=a 
// BODY     ; BODY must set next and not break layout
// ]        ; and ptr=a=0 to exit the block 
//////////
const program_start = ">+< +[-";  // then the first block is the entry point. 
const program_end = "+]";
const block_start = ">>>[-<]<<[<";
const block_end = "]";
