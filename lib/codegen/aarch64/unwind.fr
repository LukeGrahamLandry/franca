// TODO: fix all this shit
fn hackheap(ops: Ty(*u32, i64)) = {
    var out: List(u32) = list(ops&[1][]);
    push_all(out!addr, @as(Slice(u32)) ops);
    var out: Slice(u32) = items(out!addr);
    out
}

const AsmInst = u32; // TODO: Should be Unique(u32) but then need to fix resolve_backtrace_symbol
const InstPtr = *AsmInst;  // TODO: **AsmInst as return type doesnt work?? 

// The first 16 bytes of a stack frame is always one of these. 
const Frame = (
    // TODO: be able to say this type is *Frame. this is harder than fixing the forward declarations thing i feel. 
    fp: VoidPtr,  // Pointer to the previous Frame (start of its stack). 
    lr: InstPtr  // Saved instruction pointer value. 
)!struct;

@no_interp @aarch64 
fn get_fp() *Frame = hackheap((
    mov(Bits.X64[], x0, fp),
    ret(),
)!slice)!asm;

/// An array of compiled asm function pointers. Indices are FuncId and missing entries are 0. 
@no_interp @aarch64
fn get_indirect_fn_array() Slice(InstPtr) = {
    @no_interp @aarch64 
    fn get_indirect_fn_array_ptr() *InstPtr = hackheap((
        mov(Bits.X64[], x0, x21),
        ret(),
    )!slice)!asm;

    (ptr: get_indirect_fn_array_ptr(), len: number_of_functions())
}

@no_interp @aarch64 
fn ptr_to_int(ptr: VoidPtr) i64 = hackheap((
    ret(),
    ret(),
)!slice)!asm;

@no_interp @aarch64 
fn int_to_ptr(ptr: i64) VoidPtr = hackheap((
    ret(),
    ret(),
)!slice)!asm;

/// Guess which function contains the instruction pointer 'ip'.
/// 'f' will be the one that starts closest to 'ip' but before it. 
/// 'rel_ip' is how many bytes into the function 'ip' is (1 asm instruction is 4 bytes). 
/// If 'ip' is in an ffi (or compiler builtin) function, 'rel_ip' will be very large. 
@no_interp @aarch64
fn get_func_id(ip: InstPtr) (f: FuncId, rel_ip: i64)!struct = {
    var functions = get_indirect_fn_array();
    var best_index: i64 = number_of_functions();
    var best_distance = 99999999;
    
    // Check every function id. 
    functions.enumerate(fn(i: i64, func: *InstPtr) Unit = {
        let func: VoidPtr = func[];
        let func = func.ptr_to_int();
        // Skip missing functions (null start ptr).  
        if(func.ne(0)) {|
            let ip: VoidPtr = ip;
            let dist = ip.ptr_to_int().sub(func);
            // If distance is negative, 'ip' is before 'func' so can't be inside it (don't care if its closer). 
            if(dist.lt(best_distance).and(dist.ge(0))) {|
                best_distance = dist;
                best_index = i;
            };
        };
    });
    
    // TODO: return optional. 
    (f: best_index, rel_ip: best_distance)
}

/// Note: This relies on the stack frame layout used by bc_to_asm and rustc matching. 
@no_interp @aarch64 @pub
fn collect_backtrace() Unit = {
    var addr: *Frame = get_fp();
    var i = 0;
    var info: RsResolvedSymbol;
    // TODO: nullable pointer should be spelled ?*T
    (fn= addr.fp[].ptr_to_int().ne(0), fn= {
        (resolve_backtrace_symbol(addr.lr[], info&), fn= {
            let len = info&.name_len[];
            (len.ne(0), fn= {
                // TODO: HACK. be able to address bytes so puts doesnt .mul(8). rn this gets truncated to a multiple of 8 chars. 
                let s: Str = (info&.owned_name[], len.div(8));
                puts(s);
            }, fn= {
                puts("Rust found but len=0.".str());
            })!if;
        }, fn= {
            // TODO: check that its not some other ffi thing that rust couldn't find a name for. 
            var func = addr.lr[].get_func_id();
            let fid = func&.f[];
            (number_of_functions().gt(@as(i64) fid), fn= {
                let name = fid.name();
                // TODO: after overload rework (which should have make it stricter but clearly not)...  
                //       invalid memory reference before I renamed this to sym_to_str. when it was str() i guess it picked the wrong overload which is really scary. 
                //       broken unique types so it tried to do the str(int) maybe but of so, that should have worked and just printed the number. 
                //          -- Apr 6, 2024
                let name: Str = name.sym_to_str();
                puts(name);
            }, fn= {
                puts("Rust not found but I also not found.".str());
            })!if;
        })!if;
        putchar(10);
        
        let fp: *Frame = addr.fp[];
        addr = fp;
        i = i.add(1);
    })!while;
}
