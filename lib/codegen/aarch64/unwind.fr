const AsmInst = i64; // TODO: Should be Unique(u32) but then need to fix resolve_backtrace_symbol
const InstPtr = *AsmInst;  // TODO: **AsmInst as return type doesnt work?? 

// The first 16 bytes of a stack frame is always one of these. 
const Frame = @struct(
    // TODO: be able to say this type is *Frame. this is harder than fixing the forward declarations thing i feel. 
    fp: rawptr,  // Pointer to the previous Frame (start of its stack). 
    lr: InstPtr  // Saved instruction pointer value. 
);

#aarch64 #c_call
fn get_fp() *Frame = (
    mov(Bits.X64, x0, fp),
    ret(),
)!asm;

/// An array of compiled asm function pointers. Indices are FuncId and missing entries are 0. 
// __get_comptime_dispatch_ptr is now in the compiler because my previous strat with x21 felt sketchy
// so i'll need to revisit this when i want to emit executables that do stack traces on panic. 
fn get_indirect_fn_array() Slice(InstPtr) = {
    (ptr = __get_comptime_dispatch_ptr(), len = number_of_functions())
}

/// Guess which function contains the instruction pointer 'ip'.
/// 'f' will be the one that starts closest to 'ip' but before it. 
/// 'rel_ip' is how many bytes into the function 'ip' is (1 asm instruction is 4 bytes). 
/// If 'ip' is in an ffi (or compiler builtin) function, 'rel_ip' will be very large. 
fn get_func_index(ip: InstPtr) (@struct(f: i64, rel_ip: i64)) = {
    var functions = get_indirect_fn_array();
    var best_index: i64 = number_of_functions();
    var best_distance = 99999999;
    
    // Check every function id. 
    functions.enumerate(fn(i: i64, func: *InstPtr) Unit => {
        let func: rawptr = func[];
        let func = func.ptr_to_int();
        // Skip missing functions
        if(func.ne(@as(i64) 0x1337)) {|
            let ip: rawptr = ip;
            let dist = ip.ptr_to_int().sub(func);
            // If distance is negative, 'ip' is before 'func' so can't be inside it (don't care if its closer). 
            if(dist.lt(best_distance).and(dist.ge(0))) {|
                best_distance = dist;
                best_index = i;
            };
        };
    });
    
    // TODO: return optional. 
    (f = best_index, rel_ip = best_distance)
}

const RsResolvedSymbol = RsResolvedSymbol!builtin;
const FrResolvedSymbol = @struct(name: Symbol, fid: FuncId);
const ResolvedFn = @tagged(Rust: RsResolvedSymbol, Franca: FrResolvedSymbol, Unknown: InstPtr);

// TODO: take const callback instead of allocating list? since list wants to panic which wasnts to call this,
// TODO: check for panic while panicking. 
/// TODO: you want to do this on panics should shouldn't be allocating but this is nice for test. 
/// Note: This relies on the stack frame layout used by bc_to_asm and rustc matching. 
#aarch64 fun collect_backtrace() List$ResolvedFn = {
    var found: List$ResolvedFn = list(10);
    var addr = get_fp();
    var i = 0;
    var info: RsResolvedSymbol = ()!uninitialized;
    // TODO: nullable pointer should be spelled ?*T
    while(=> addr[].fp.ptr_to_int().ne(0)) {|
        if(resolve_backtrace_symbol(addr[].lr, info&), => {
            let r: ResolvedFn = (Rust = info); // TODO: should be able to do this inline
            found&.push(r);
        }, => {
            // TODO: check that its not some other ffi thing that rust couldn't find a name for. 
            var func = addr[].lr.get_func_index();
            let fid = func.f;
            if(number_of_functions().gt(fid), => {
                let fid = fid.index_to_func_id();
                let name = fid.name();
                let r: ResolvedFn = (Franca = (name = name, fid = fid));
                found&.push(r);
            }, => {
                let r: ResolvedFn = (Unknown = addr[].lr);
                found&.push(r);
            });
        });
        
        let fp: *Frame = addr[].fp;
        addr = fp;
        i = i.add(1);
    };
    found
}
