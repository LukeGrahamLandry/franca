//! https://llvm.org/docs/LangRef.html
// TODO: callable functions that return ir so i can template int vs float. rn its a sad copy-paste. 

//////
/// Integers

@llvm @pub 
fn add(a: i64, b: i64) i64 = (
    "%out = add i64 %a, %b",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn sub(a: i64, b: i64) i64 = (
    "%out = sub i64 %a, %b",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn mul(a: i64, b: i64) i64 = (
    "%out = mul i64 %a, %b",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn div(a: i64, b: i64) i64 = (
    "%out = sdiv i64 %a, %b",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn eq(a: i64, b: i64) bool = (
    "%out = icmp eq i64 %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn ne(a: i64, b: i64) bool = (
    "%out = icmp ne i64 %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn le(a: i64, b: i64) bool = (
    "%out = icmp sle i64 %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn ge(a: i64, b: i64) bool = (
    "%out = icmp sge i64 %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn lt(a: i64, b: i64) bool = (
    "%out = icmp slt i64 %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn gt(a: i64, b: i64) bool = (
    "%out = icmp sgt i64 %a, %b",
    "ret i1 %out",
)!asm;

//////
/// Bitwise

@llvm @pub 
fn shift_left(value: i64, shift_amount: i64) i64 = (
    "%out = shl i64 %value, %shift_amount",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn bit_or(a: i64, b: i64) i64 = (
    "%out = or i64 %a, %b",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn bit_not(a: i64) i64 = (
    "%out = not i64 %a",
    "ret i64 %out",
)!asm;

@llvm @pub 
fn bit_and(a: i64, b: i64) i64 = (
    "%out = and i64 %a, %b",
    "ret i64 %out",
)!asm;

//////
/// Floats

@llvm @pub 
fn add(a: f64, b: f64) f64 = (
    "%out = fadd double %a, %b",
    "ret double %out",
)!asm;

@llvm @pub 
fn sub(a: f64, b: f64) f64 = (
    "%out = fsub double %a, %b",
    "ret double %out",
)!asm;

@llvm @pub 
fn mul(a: f64, b: f64) f64 = (
    "%out = fmul double %a, %b",
    "ret double %out",
)!asm;

@llvm @pub 
fn div(a: f64, b: f64) f64 = (
    "%out = fdiv double %a, %b",
    "ret double %out",
)!asm;

// For float cmp, 
// - o=ordered: false if either is nan
// - u=unordered: true if either is nan
// Which is interesting because it means the NaN != NaN thing isn't real, they just all choose that for some reason. 

@llvm @pub 
fn eq(a: f64, b: f64) bool = (
    "%out = fcmp oeq double %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn ne(a: f64, b: f64) bool = (
    "%out = fcmp one double %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn le(a: f64, b: f64) bool = (
    "%out = fcmp ole double %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn ge(a: f64, b: f64) bool = (
    "%out = fcmp oge double %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn lt(a: f64, b: f64) bool = (
    "%out = fcmp olt double %a, %b",
    "ret i1 %out",
)!asm;

@llvm @pub 
fn gt(a: f64, b: f64) bool = (
    "%out = fcmp ogt double %a, %b",
    "ret i1 %out",
)!asm;
