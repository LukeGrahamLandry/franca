//! https://llvm.org/docs/LangRef.html
// TODO: callable functions that return ir so i can template int vs float. rn its a sad copy-paste. 

//////
/// Integers

#llvm #c_call
fn add(a: i64, b: i64) i64 = """
    %out = add i64 %a, %b
    ret i64 %out
"""!asm;

#llvm #c_call
fn sub(a: i64, b: i64) i64 = """
    %out = sub i64 %a, %b
    ret i64 %out
"""!asm;

#llvm #c_call
fn mul(a: i64, b: i64) i64 = """
    %out = mul i64 %a, %b
    ret i64 %out
"""!asm;

#llvm #c_call
fn div(a: i64, b: i64) i64 = """
    %out = sdiv i64 %a, %b
    ret i64 %out
"""!asm;

#llvm #c_call
fn eq(a: i64, b: i64) bool = """
    %out = icmp eq i64 %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn ne(a: i64, b: i64) bool = """
    %out = icmp ne i64 %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn le(a: i64, b: i64) bool = """
    %out = icmp sle i64 %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn ge(a: i64, b: i64) bool = """
    %out = icmp sge i64 %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn lt(a: i64, b: i64) bool = """
    %out = icmp slt i64 %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn gt(a: i64, b: i64) bool = """
    %out = icmp sgt i64 %a, %b
    ret i1 %out
"""!asm;

//////
/// Bitwise

#llvm #c_call
fn shift_left(value: i64, shift_amount: i64) i64 = """
    %out = shl i64 %value, %shift_amount
    ret i64 %out
"""!asm;

#llvm #c_call
fn bit_or(a: i64, b: i64) i64 = """
    %out = or i64 %a, %b
    ret i64 %out
"""!asm;

#llvm #c_call
fn bit_not(a: i64) i64 = """
    %out = not i64 %a
    ret i64 %out
"""!asm;

#llvm #c_call
fn bit_and(a: i64, b: i64) i64 = """
    %out = and i64 %a, %b
    ret i64 %out
"""!asm;

//////
/// Floats

#llvm #c_call
fn add(a: f64, b: f64) f64 = """
    %out = fadd double %a, %b
    ret double %out
"""!asm;

#llvm #c_call
fn sub(a: f64, b: f64) f64 = """
    %out = fsub double %a, %b
    ret double %out
"""!asm;

#llvm #c_call
fn mul(a: f64, b: f64) f64 = """
    %out = fmul double %a, %b
    ret double %out
"""!asm;

#llvm #c_call
fn div(a: f64, b: f64) f64 = """
    %out = fdiv double %a, %b
    ret double %out
"""!asm;

// For float cmp, 
// - o=ordered: false if either is nan
// - u=unordered: true if either is nan
// Which is interesting because it means the NaN != NaN thing isn't real, they just all choose that for some reason. 

#llvm #c_call
fn eq(a: f64, b: f64) bool = """
    %out = fcmp oeq double %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn ne(a: f64, b: f64) bool = """
    %out = fcmp one double %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn le(a: f64, b: f64) bool = """
    %out = fcmp ole double %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn ge(a: f64, b: f64) bool = """
    %out = fcmp oge double %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn lt(a: f64, b: f64) bool = """
    %out = fcmp olt double %a, %b
    ret i1 %out
"""!asm;

#llvm #c_call
fn gt(a: f64, b: f64) bool = """
    %out = fcmp ogt double %a, %b
    ret i1 %out
"""!asm;

//////
/// Other

#llvm #c_call
fn offset(p: rawptr, bytes: i64) rawptr = """
    %pp = ptrtoint ptr %p to i64
    %a = add i64 %pp, %bytes
    %ppp = inttoptr i64 %a to ptr
    ret ptr %ppp
"""!asm;