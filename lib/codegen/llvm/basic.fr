//! https://llvm.org/docs/LangRef.html
// TODO: callable functions that return ir so i can template int vs float. rn its a sad copy-paste. 

//////
/// Integers

#llvm
fn add(a: i64, b: i64) i64 = (
    "%out = add i64 %a, %b",
    "ret i64 %out",
)!asm;

#llvm
fn sub(a: i64, b: i64) i64 = (
    "%out = sub i64 %a, %b",
    "ret i64 %out",
)!asm;

#llvm
fn mul(a: i64, b: i64) i64 = (
    "%out = mul i64 %a, %b",
    "ret i64 %out",
)!asm;

#llvm
fn div(a: i64, b: i64) i64 = (
    "%out = sdiv i64 %a, %b",
    "ret i64 %out",
)!asm;

#llvm
fun eq(a: i64, b: i64) bool = (
    "%out = icmp eq i64 %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn ne(a: i64, b: i64) bool = (
    "%out = icmp ne i64 %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn le(a: i64, b: i64) bool = (
    "%out = icmp sle i64 %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn ge(a: i64, b: i64) bool = (
    "%out = icmp sge i64 %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn lt(a: i64, b: i64) bool = (
    "%out = icmp slt i64 %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn gt(a: i64, b: i64) bool = (
    "%out = icmp sgt i64 %a, %b",
    "ret i1 %out",
)!asm;

//////
/// Bitwise

#llvm
fn shift_left(value: i64, shift_amount: i64) i64 = (
    "%out = shl i64 %value, %shift_amount",
    "ret i64 %out",
)!asm;

#llvm
fn bit_or(a: i64, b: i64) i64 = (
    "%out = or i64 %a, %b",
    "ret i64 %out",
)!asm;

#llvm
fn bit_not(a: i64) i64 = (
    "%out = not i64 %a",
    "ret i64 %out",
)!asm;

#llvm
fn bit_and(a: i64, b: i64) i64 = (
    "%out = and i64 %a, %b",
    "ret i64 %out",
)!asm;

//////
/// Floats

#llvm
fn add(a: f64, b: f64) f64 = (
    "%out = fadd double %a, %b",
    "ret double %out",
)!asm;

#llvm
fn sub(a: f64, b: f64) f64 = (
    "%out = fsub double %a, %b",
    "ret double %out",
)!asm;

#llvm
fn mul(a: f64, b: f64) f64 = (
    "%out = fmul double %a, %b",
    "ret double %out",
)!asm;

#llvm
fn div(a: f64, b: f64) f64 = (
    "%out = fdiv double %a, %b",
    "ret double %out",
)!asm;

// For float cmp, 
// - o=ordered: false if either is nan
// - u=unordered: true if either is nan
// Which is interesting because it means the NaN != NaN thing isn't real, they just all choose that for some reason. 

#llvm
fun eq(a: f64, b: f64) bool = (
    "%out = fcmp oeq double %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn ne(a: f64, b: f64) bool = (
    "%out = fcmp one double %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn le(a: f64, b: f64) bool = (
    "%out = fcmp ole double %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn ge(a: f64, b: f64) bool = (
    "%out = fcmp oge double %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn lt(a: f64, b: f64) bool = (
    "%out = fcmp olt double %a, %b",
    "ret i1 %out",
)!asm;

#llvm
fn gt(a: f64, b: f64) bool = (
    "%out = fcmp ogt double %a, %b",
    "ret i1 %out",
)!asm;

//////
/// Other

#llvm
fun raw_slice(p: VoidPtr, first: i64, one_past_last: i64) VoidPtr = (
    "%pp = ptrtoint ptr %p to i64",
    "%a = add i64 %pp, %first",
    "%ppp = inttoptr i64 %a to ptr",
    "ret ptr %ppp"
)!asm;