// TODO: 
//     - fix @print
//     - be able to declare fn display for anything with a write method. really I want my old @impl syntax. 
//     - derive fn display for structs based on fields. 
//     - \n etc. 

fn todo() Never = panic("Not Yet Implemented");

fun write(fd: *Fd, bytes: Slice(u8)) Unit = {
    let len = bytes.len().mul(8); // TODO: packed strings
    let written: isize = write(fd[], bytes&.ptr[], len);
    assert(written.eq(len), "Failed Write");
}

fun write(self: *List$u8, bytes: Str) Unit = self.push_all(bytes);
fun display(self: Str, writer: *List$u8) Unit = writer.write(self);

/// @fmt(Writer, fmt_spec_str, ...Args)
/// Currently display is only implemented with 'Writer' being *List$u8 (TODO: need better generics). 
/// 'Args' can be any types that have fn display(Self, Writer) Unit;
/// 'fmt_spec_str' must be a const string value. '%' characters will be replaced (like printf, you just don't need the type hint).
// TODO: double '%%' to actually put a literal '%' 
#macro 
fun fmt(arg: AstExpr) AstExpr = {
    var arg = compile_ast(arg);
    arg.ty = UnknownType;  // need to compile so @println can use a macro that expands to a tuple but dont want to remember the type since it will change when our macro gets expanded. -- Apr 25
    let args: Slice(AstExpr) = arg.expr.Tuple;
    // TODO: assert no side effects or use variable so it doesn't run many times. 
    var writer = compile_ast(args[0]);
    
    let params = args.rest(2);  // TODO: fix bounds check when this is one long?
    
    let fmt_string = const_eval_string(args[1]);
    var parts: List(Str) = fmt_string.split("%");  // TODO: dont leak
    var parts: Slice(Str) = parts&.items();
    parts.len().eq(params.len().add(1)).assert("Fmt specifier count mismatch");
    
    let count = parts.len().add(params.len());
    var actions: List(AstExpr) = list(count);  // TODO: with_capacity_exact or shrink_to_fit at the end or have AstExpr.Tuple expose that its a Vec not a Slice 
    
    // TODO: reserve space for known length args. 
    const emit = fn(msg: AstExpr) Unit => {
        var action: FatExpr = 'display(<msg>, <writer>)';
        actions&.push(action);
    };
    
    emit(@literal(Str) parts[0]);
    
    // TODO: zip iterators 
    params.enumerate(fn(i: i64, param: *AstExpr) Unit => {
        emit(param[]);
        let s = parts[i.add(1)]&;
        emit(compile_ast(@literal(Str) s[]));
    });
    var actions: Slice(AstExpr) = actions&.items();
    arg.expr.Tuple = @as(Ty(*AstExpr, i64)) actions;
    arg
}

#macro 
fun concat(var arg: AstExpr) AstExpr = {
    let args: Slice(AstExpr) = arg.expr.Tuple;
    var actions: List(AstExpr) = list(args.len());
    
    '{
        var join_list: List$u8 = list();
        <{
            args.enumerate(fn(i: i64, param: *AstExpr) Unit => {  // TODO: zip iterators 
                // TODO: having () in the cast instead of lit(Unit) stopped working when I changed some things to use the infallible imm_eval_known which is weird -- Apr 21 
                let action: FatExpr = '@as(Unit) push_all(join_list&, @as(Str) <param[]>)';
                actions&.push(action);
            });
            
            var actions: Slice(AstExpr) = actions&.items();
            arg.expr.Tuple = @as(Ty(*AstExpr, i64)) actions;
            arg
        }>;
        join_list&.items()  // TODO: this leaks the list. 
    }'
}

#macro 
fn prepend_tuple(arg: AstExpr, target: AstExpr) AstExpr = {
    var target = compile_ast(target);
    // TODO: now that i dont double track types, this will break everything if you do it to an int literal. -- May 1
    target.ty = UnknownType;
    var original: Slice$AstExpr = target.expr.Tuple;
    var tuple: List$AstExpr = list(original.len.add(1));
    tuple&.push(arg);
    tuple&.push_all(original);
    target.expr.Tuple = (tuple.maybe_uninit.ptr, tuple.len); // TODO
    target
}

#macro 
fun println(arg: AstExpr) AstExpr = '{
    var out: List$u8 = list(0);
    @fmt(@prepend_tuple(out&) <arg>);
    println(out&.items());
    out&.drop();
}';


// TODO: use fn display to implement fn str instead of fn str allocating. rn this leaks. 
fun display(self: i64, writer: *List$u8) Unit = display(self.str(), writer);

fun display(self: bool, writer: *List$u8) Unit = display(self.str(), writer);

fun display(self: Type, writer: *List$u8) Unit = {
    display("TODO: display type", writer);
}

fun display(self: Symbol, writer: *List$u8) Unit = {
    // TODO: !!!! don't use c str! but need to have less sketchy tuple abi. 
    display(self.c_str(), writer);
}

// You probably don't want to be calling this often, it has to iterate the string to get the length. 
fun display(self: CStr, writer: *List$u8) Unit = {
    self.for {(c: u8) Unit|
        writer.push(c);
    };
}

fun display(self: Unit, writer: *List$u8) Unit = display("()", writer);

fun display(self: f64, writer: *List$u8) Unit = {
    @fmt(writer, "%", self.int()); // TODO: higher precision rendering
}

::if(Str);
fun str(self: bool) Str = if(self, fn()Str = "true", fn()Str = "false");

// TODO: this whole model of resolving the overload up front doesn't work because you need to call different functions 
//       at compiletime or runtime depending on the target arch. So need to delay as long as possible by passing in the overload set. 
//       Alternatively, I could go through with the Expr::Either but that feels like special casing just for the ct/rt. 


//////
/// CStr

/// Not bounds checked
fun index(self: CStr, i: i64) *u8 = offset_bytes(@as(*u8) self, i);
fun get(self: CStr, i: i64) u8 = self.index(i).load();
fun set(self: CStr, i: i64, v: u8) Unit = self.index(i).store(v);

fun for(var self: CStr, const f: Fn(u8, Unit)) Unit = {
    ::ptr_utils(u8);
    
    dowhile {() bool |
        c := self[0]; // this doesn't need .load() anymore because of :SmallTypes
        if(c.eq(@as(u8) 0), => false){|
            f(c);  
            self = @as(*u8) (@as(*u8) self).offset_bytes(1);
            true
        }
    }
}

/// you probably don't want to call this very often. 
fun to_list(self: CStr) List$u8 = {
    out : List$u8 = list();
    self.for {(c: u8) Unit|
        out&.push(c);
    };
    out
}

/// Like rust, not c. hex escapes eat exactly two chars. no octal escapes except \0. 
// Note: you can't use the string escapes in the body of this function, or any it calls, because there's no bootstrapping step. 
fn __string_escapes(raw: Str) Str #fold = {
    backslash       : u8 : 92;
    doublequote     : u8 : 34;
    horizontal_tab  : u8 :  9;
    carriage_return : u8 : 13;

    out : List$u8 = list(raw.len);
    i := 0;
    while(=> i.lt(raw.len)){|
        c := raw[i]; i += 1;
        if(c.eq(backslash)){|
            c = raw[i]; i += 1;
            c = @switch(c) {
                @case("n".ascii()) => @as(u8) 10;
                @case(doublequote) => doublequote;
                @case(backslash)   => backslash;
                @case("r".ascii()) => carriage_return;
                @case("t".ascii()) => horizontal_tab;
                @case("'".ascii()) => "'".ascii();  // rust has this one because of single quoted char literals. 
                @case("0".ascii()) => 0;
                @case("x".ascii()) => {
                    s := raw.subslice(i, 2); i += 2;
                    @as(u8) @as(i64) hex(s)
                };
                @default fn(_: u8) => panic("Unknown escape character"); // TODO: compile_error. better message. show line. 
            };
        };
        out&.push(c);
    };
    
    // TODO: should put in the string pool. 
    //       maybe this should be a macro that works on idents so compiler knows they're still just a string literal.
    //       but that kinda feels less elegant. 
    out.items() // LEAK
}
