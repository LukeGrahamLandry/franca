// TODO: 
//     - fix @print
//     - be able to declare fn display for anything with a write method. really I want my old @impl syntax. 
//     - derive fn display for structs based on fields. 
//     - \n etc. 

fn todo() Never = panic("Not Yet Implemented");

fun write(fd: *Fd, bytes: Slice(u8)) Unit = {
    let len = bytes.len().mul(8); // TODO: packed strings
    let written: isize = write(fd[], bytes&.ptr[], len);
    assert(written.eq(len), "Failed Write");
}

fun write(self: *List$i64, bytes: Str) Unit = self.push_all(bytes);
fun display(self: Str, writer: *List$i64) Unit = writer.write(self);

/// (@fmt(Writer, fmt_spec_str, ...Args))
/// Currently display is only implemented with 'Writer' being *List$i64 (TODO: need better generics). 
/// 'Args' can be any types that have fn display(Self, Writer) Unit;
/// 'fmt_spec_str' must be a const string value. '%' characters will be replaced (like printf, you just don't need the type hint).
// TODO: double '%%' to actually put a literal '%' 
@annotation 
fun fmt(arg: AstExpr) AstExpr = {
    var arg = compile_ast(arg);
    arg&.ty[] = UnknownType;  // need to compile so @println can use a macro that expands to a tuple but dont want to remember the type since it will change when our macro gets expanded. -- Apr 25
    let args: Slice(AstExpr) = arg&.expr.Tuple[];
    let writer: *AstExpr = args.index(0);  // TODO: assert no side effects or use variable so it doesn't run many times. 
    var writer = compile_ast(writer[]);
    
    let fmt_string: *AstExpr = args.index(1);
    let params = args.rest(2);  // TODO: fix bounds check when this is one long?
    
    let fmt_string = const_eval_string(fmt_string[]);
    var parts: List(Str) = fmt_string.split("%".str());  // TODO: dont leak
    var parts: Slice(Str) = parts&.items();
    parts.len().eq(params.len().add(1)).assert("Fmt specifier count mismatch");
    
    let count = parts.len().add(params.len());
    var actions: List(AstExpr) = list(count);  // TODO: with_capacity_exact or shrink_to_fit at the end or have AstExpr.Tuple expose that its a Vec not a Slice 
    
    var display_fn = @literal(OverloadSet) display;
    
    // TODO: reserve space for known length args. 
    const emit = fn(msg: AstExpr) Unit = {
        var action: FatExpr = '<display_fn>(<msg>, <writer>)';
        actions&.push(action);
    };
    
    let s: *Str = parts.index(0);
    emit(@literal(Str) s[]);
    
    // TODO: zip iterators 
    params.enumerate(fn(i: i64, param: *AstExpr) Unit = {
        emit(param[]);
        let s: *Str = parts.index(i.add(1));
        emit(compile_ast(@literal(Str) s[]));
    });
    
    var actions: Slice(AstExpr) = actions&.items();
    arg&.expr.Tuple[] = actions;
    arg
}

@annotation 
fun concat(arg: AstExpr) AstExpr = {
    let args: Slice(AstExpr) = arg&.expr.Tuple[];
    var actions: List(AstExpr) = list(args.len());
    
    // TODO: this is really trash. need a better way to express this. the problem is that you don't re-run closure captures after expanding the macro. 
    let list_fn = @literal(OverloadSet) List;
    let init_fn = @literal(OverloadSet) list;
    let push_fn = @literal(OverloadSet) push_all;
    let str_t = @literal(Type) Str;
    let items_fn = @literal(OverloadSet) items;
    let i64_t = @literal(Type) i64;
    let fn_as = @literal(as);
    
    '{
        var join_list: <list_fn>(<i64_t>) = <init_fn>();
        <{
            args.enumerate(fn(i: i64, param: *AstExpr) Unit = {  // TODO: zip iterators 
                // TODO: having () in the cast instead of lit(Unit) stopped working when I changed some things to use the infallible imm_eval_known which is weird -- Apr 21 
                let action: FatExpr = '@(<fn_as>)(<@literal(Unit)>) <push_fn>(join_list&, @(<fn_as>)(<str_t>) <param[]>)';
                actions&.push(action);
            });
            
            var actions: Slice(AstExpr) = actions&.items();
            arg&.expr.Tuple[] = actions;
            arg
        }>;
        <items_fn>(join_list&)  // TODO: this leaks the list. 
    }'
}

@annotation 
fn prepend_tuple(arg: AstExpr, target: AstExpr) AstExpr = {
    var target = compile_ast(target);
    target&.ty[] = UnknownType;
    var original: Slice$AstExpr = target&.expr.Tuple[];
    var tuple: List$AstExpr = list(original&.len[].add(1));
    tuple&.push(arg);
    tuple&.push_all(original);
    target&.expr.Tuple[] = (tuple&.maybe_uninit.ptr[], tuple&.len[]); // TODO
    target
}

@annotation 
fun println(arg: AstExpr) AstExpr = '{
    var out: List$i64 = list(0);
    (@fmt(@prepend_tuple(out&) <arg>));
    println(out&.items());
    out&.drop();
}';

// TODO: HACK. Compiler doesn't know about Slice(_) so string literals are the wrong type. 
fun display(self: ""!type, writer: *List$i64) Unit = {
    let s: Str = @as(Str) self;  // TODO: why do i need the type hint on the variable, not just in the @as (missing @as works tho)? 
    display(s, writer);
}

fun display(self: i64, writer: *List$i64) Unit = {
    // TODO: use fn display to implement fn str instead of fn str allocating. rn this leaks. 
    let s = self.str();
    display(s, writer);
}

// TODO: this whole model of resolving the overload up front doesn't work because you need to call different functions 
//       at compiletime or runtime depending on the target arch. So need to delay as long as possible by passing in the overload set. 
//       Alternatively, I could go through with the Expr::Either but that feels like special casing just for the ct/rt. 

// What's the easiest way to spell generic impls? 
// const Write: Type = @trait(fn(T: Type) bool = function_exists(write!symbol, Ty(T, Str), Unit));
// @impl fn(const W: Write) Unit = {
//     fun display(self: i64, writer: W) Unit = {
//         let s = self.str();
//         writer.write(s)
//      }
// }
// 
// fun write(self: *List_i64, bytes: Str) Unit = self.push_all(bytes);
// List_i64.Ptr().implements(Write).assert();
// var output: List_i64;
// 123.display(output&);
// 
