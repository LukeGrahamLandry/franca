// TODO: 
//     - be able to declare fn display for anything with a write method. really I want my old @impl syntax. 
//     - derive fn display for structs based on fields. 

fn println(msg: Str) void = {
    print(msg);
    
    // TODO: extra syscall is sad
    new_line: u8 = 10.trunc();
    print(@as(Str) (ptr = new_line&, len=1));
}

fn print(msg: Str) void = {
    STD_OUT: Fd : (fd = 1.intcast());
    written := write(STD_OUT, msg.ptr, @as(usize) msg.len);
    // TODO: confusing dependency
    //assert_eq(msg.len, written.unwrap());
    // TODO: check errno. loop if not all written. 
}

// REMEMBER, you can't just open with flags .Write and then call this, it wont truncate the file!
fn write(fd: *Fd, bytes: Slice(u8)) void = {
    written := write(fd[], bytes.ptr, bytes.len).unwrap();
    // TOOD: loop if not all written
}

fn write(self: *List(u8), bytes: Str) void = self.push_all(bytes);
fn display(self: Str, writer: *List(u8)) void = writer.write(self);

/// @fmt(Writer, fmt_spec_str, ...Args)
/// Currently display is only implemented with 'Writer' being *List$u8 (TODO: need better generics). 
/// 'Args' can be any types that have fn display(Self, Writer) void;
/// 'fmt_spec_str' must be a const string value. '%' characters will be replaced (like printf, you just don't need the type hint).
// TODO: double '%%' to actually put a literal '%' 
#macro 
fn fmt(arg: AstExpr) AstExpr = {
    arg := compile_ast(arg);
    args := arg.expr.Tuple.items();
    // TODO: assert no side effects or use variable so it doesn't run many times. 
  
    writer := compile_ast(args[0]);
    format_into(writer, args.rest(1), arg.loc)
}

fn format_into(writer: FatExpr, args: Slice(FatExpr), loc: Span) FatExpr = {
    assert(args.len != 0, "don't use @fmt with no '%' placeholders, just use a string"); // TOOD: i think it segfaults before you get here -- Jun 12 oh tag check
    params := args.rest(1);  // TODO: fix bounds check when this is one long?
    
    fmt_string := const_eval_string(args[0]);
    parts := fmt_string.split("%", temp());
    parts := parts&.items();
    parts.len().eq(params.len().add(1)).assert("Fmt specifier count mismatch");
    count := parts.len().add(params.len());
    actions: List(AstExpr) = list(count, ast_alloc());  // TODO: with_capacity_exact or shrink_to_fit at the end or have AstExpr.Tuple expose that its a Vec not a Slice 
    
    // TODO: reserve space for known length args. 
    emit :: fn(msg: AstExpr) void => {
        action: FatExpr = @{ display(@[msg], @[writer]) };
        actions&.push(action);
    };
    emit(@literal parts[0]);
    
    // TODO: zip iterators
    enumerate params { i, param |
        emit(param[]);
        s := parts[i.add(1)]&;
        emit(compile_ast(@literal s[]));
    };
    // need to compile so @println can use a macro that expands to a tuple but dont want to remember the type since it will change when our macro gets expanded. -- Apr 25
    (expr = (Tuple = actions.rs()), loc = loc, ty = UnknownType, done = false)
}

#macro 
fn concat(arg: AstExpr, rt_alloc: AstExpr) AstExpr = {
    args := arg.expr.Tuple.items();
    actions: List(AstExpr) = list(args.len(), ast_alloc());
    
    @{
        // TODO: caller needs to pass allocator since this is at runtime. 
        join_list: List(u8) = list(@[rt_alloc]);
        @[{
            args.enumerate(fn(i, param) => {  // TODO: zip iterators 
                // TODO: having () in the cast instead of lit(void) stopped working when I changed some things to use the infallible imm_eval_known which is weird -- Apr 21 
                action := @{ @as(void) push_all(join_list&, @as(Str) @[param[]]) };
                actions&.push(action);
            });
            
            arg.expr.Tuple = actions.rs();
            arg
        }];
        join_list&.items()  // TODO: this leaks the list. 
    }
}

#macro 
fn prepend_tuple(arg: AstExpr, target: AstExpr) AstExpr = {
    target := compile_ast(target);
    // TODO: now that i dont double track types, this will break everything if you do it to an int literal. -- May 1
    target.ty = UnknownType;
    original := target.expr.Tuple.items();
    tuple: List(AstExpr) = list(original.len.add(1), ast_alloc()); 
    tuple&.push(arg);
    tuple&.push_all(original);
    target.expr.Tuple = (tuple.len, tuple.maybe_uninit.ptr, tuple.len); // TODO
    target
}

#macro 
fn println(arg: AstExpr) AstExpr = @{
    out: List(u8) = list(0, temp());
    @fmt(@prepend_tuple(out&) @[arg]);
    println(out&.items());
    out&.drop();
};

#macro 
fn print(arg: AstExpr) AstExpr = @{
    out: List(u8) = list(0, temp());
    @fmt(@prepend_tuple(out&) @[arg]);
    print(out&.items());
    out&.drop();
};

#macro 
fn format(arg: AstExpr, alloc: AstExpr) AstExpr = @{
    out: List(u8) = list(0, @[alloc]);
    @fmt(@prepend_tuple(out&) @[arg]);
    out
};

#macro 
fn panic(arg: AstExpr) AstExpr = @{
    out: List(u8) = list(0, temp()); 
    @fmt(@prepend_tuple(out&) @[arg]);
    panic(out&.items());
};

// TODO: use fn display to implement fn str instead of fn str allocating. rn this leaks. 
fn display(i: i64, s: *List(u8)) void = {
    if(i.lt(0)) {|
        push(s, "-".ascii());
        i.neg().display(s);
    } {|
        is_digit := i.ge(0).and(i.lt(10));
        if(is_digit, 
            => s.push(add(48, i)),
            => {
                i.div(10).display(s);
                s.push(i.mod(10).add(48));
            }
        );
    };
}

fn display(self: bool, writer: *List(u8)) void = display(self.str(), writer);

fn display(self: Type, writer: *List(u8)) void = {
    display("TODO: display type", writer);
}

fn display(self: Symbol, writer: *List(u8)) void = {
    // TODO: !!!! don't use c str! but need to have less sketchy tuple abi. 
    display(self.c_str(), writer);
}

// You probably don't want to be calling this often, it has to iterate the string to get the length. 
fn display(self: CStr, writer: *List(u8)) void = {
    for self {c|
        writer.push(c);
    };
}

fn display(self: void, writer: *List(u8)) void = display("()", writer);

fn display(self: f64, writer: *List(u8)) void = {
    // TODO: if you try to inline this into the macro call, it crashes trying to compile in fn fmt. 
    //       bus error. works on cranelift tho which is fun. 
    //       works if you call self.int here and then also inline it so its a problem with adding it as a callee?
    //       -- May 26
    value := self.int();
    @fmt(writer, "%", value); // TODO: higher precision rendering
}

fn println(self: CStr) void = @println("%", self);

::if(Str);
fn str(self: bool) Str = if(self, fn()Str = "true", fn()Str = "false");

// TODO: this whole model of resolving the overload up front doesn't work because you need to call different functions 
//       at compiletime or runtime depending on the target arch. So need to delay as long as possible by passing in the overload set. 
//       Alternatively, I could go through with the Expr::Either but that feels like special casing just for the ct/rt. 


//////
/// CStr

/// Not bounds checked
fn index(self: CStr, i: i64) *u8 = offset_bytes(self.ptr, i);
fn get(self: CStr, i: i64) u8 = self.index(i)[];
fn set(self: CStr, i: i64, v: u8) void = self.index(i).store(v);

fn for(self: CStr, $f: @Fn(c: u8) void) void = {
    ::ptr_utils(u8);
    
    dowhile {|
        c := self[0]; // this doesn't need .load() anymore because of :SmallTypes
        if(c.eq(@as(u8) 0.trunc()), => false){|
            f(c);  
            self = (ptr = self.ptr.offset_bytes(1));
            true
        }
    }
}

/// Slowly iterates the string to find the null terminator. 
/// The returned string is backed by the same memory as the original.
fn str(self: CStr) Str = {
    len := 0;
    for self {_| 
        len += 1;
    };
    (ptr = self.ptr, len = len)
}

// Wildly unsafe, assumes whatever memory happens to be past the end of the string will stay the same as long as you need the returned cstr. 
// TODO: this is a garbage api because you can't tell if it made a copy so you can't free it. 
//       i guess you can compare the pointers but... yuck. 
// TODO: debug_assert no internal zeros.
fn maybe_borrow_cstr(self: Str, alloc: Alloc) CStr #leak = {
    ::if(CStr);
    past_last := self.ptr.offset(self.len); // awkward because normal index functions are bounds checked. 
    if(past_last[].eq(0.trunc()), => (ptr = self.ptr)) {|
        s := self.clone(alloc);
        s&.push(@as(u8) 0.trunc());
        (ptr = s.maybe_uninit.ptr) // LEAK
    }
}

/// Like rust, not c. hex escapes eat exactly two chars. no octal escapes except \0. 
// Note: you can't use the string escapes in the body of this function, or any it calls, because there's no bootstrapping step. 
// :blessed: the compiler generates comptime calls to this function when you use backslashes in a string literal. 
fn __string_escapes(raw: Str) Str #fold = {
    backslash       : u8 : 92.trunc();
    doublequote     : u8 : 34.trunc();
    horizontal_tab  : u8 :  9.trunc();
    carriage_return : u8 : 13.trunc();
    new_line        : u8 : 0x0A;

    out : List(u8) = list(raw.len, ast_alloc());
    i := 0;
    while(=> i.lt(raw.len)){|
        c := raw[i]; i += 1;
        if(c.eq(backslash)){|
            c = raw[i]; i += 1;
            c = @switch(c) {
                @case("n".ascii()) => new_line;
                @case(doublequote) => doublequote;
                @case(backslash)   => backslash;
                @case("r".ascii()) => carriage_return;
                @case("t".ascii()) => horizontal_tab;
                @case("'".ascii()) => "'".ascii();  // rust has this one because of single quoted char literals. 
                @case("0".ascii()) => @as(u8) 0.trunc();
                @case("x".ascii()) => {
                    s := raw.subslice(i, 2); i += 2;
                    @as(u8) hex(s).trunc()
                };
                @default fn(_: u8) => panic("Unknown escape character"); // TODO: compile_error. better message. show line. 
            };
        };
        out&.push(c);
    };
    
    // TODO: should put in the string pool. 
    //       maybe this should be a macro that works on idents so compiler knows they're still just a string literal.
    //       but that kinda feels less elegant. 
    out.items() // LEAK
}

fn println(msg: bool) void = {
    msg := if(msg, =>"true", =>"false");
    println(msg);
}

fn println(i: i64) void = {
    // TODO: static alloc since we know the bound on number of digits
    mem: List(u8) = list(i.div(10).abs().add(2), temp());
    i.display(mem&);
    mem&.push_all("\n");
    print(mem&.items());
}
fn println(msg: u8) void = println(@as(i64) msg);

fn print(i: i64) void = {
    // TODO: static alloc since we know the bound on number of digits
    mem: List(u8) = list(i.div(10).abs().add(1), temp());
    i.display(mem&);
    print(mem&.items());
}

// TODO: this should return an option. 
// TODO: use @switch once I have ranges. 
fn hex_digit(cc: u8) i64 = {
    c: i64 = cc.zext();
    if(ge(c, 97), 
        => { 
            assert(lt(c, 107), "hex OOB"); 
            add(sub(c, 97), 10) 
        }, 
        => if(ge(c, 65), 
            => { 
                assert(lt(c, 75), "hex OOB"); 
                add(sub(c, 65), 10) 
            }, 
            => { 
                assert(lt(c, 58), "hex OOB"); 
                sub(c, 48)
            }
        )
    )
}

// TODO: this should return an error. 
fn hex(s: Str) i64 = {
    total := 0;
    scale := 1;
    i := s.len().sub(1);
    first := 0;
    
    // This prevents overflow for tracking scale for lots of leading zeros. 
    // TODO: add a test that requires this. lol its an insane number tho so could just not bother 
    while(=> first.lt(s.len()).and(=> eq(get(s, first), @as(u8) 48.trunc()))) {|
        first = add(first, 1) 
    };
    
    while(=> ge(i, first)) {|
        total = add(total, mul(scale, hex_digit(get(s, i))));
        scale = mul(scale, 16);
        i = sub(i, 1);
    };
    total
}


// TODO: this should return an option instead of asserting. 
fn dec_digit(cc: u8) i64 = {
    c: i64 = cc.zext();
    //assert(c.ge("0".char()).and(c.le("9".char())), "dec OOB");
    c.sub("0".char())
}
    
// TODO: this should return an error. 
fn float(s: Str) f64 = {
    value := 0.0;
    scale := 0.1;
    seen_decimal := false;
    for(s){c|
        if(seen_decimal) {|
            value += dec_digit(c).float().mul(scale);
            scale = scale.div(10.0);  // TODO: /= doesn't work??
        } {|
            if(c.eq(".".ascii()), => { seen_decimal = true; }) {|
                value *= 10.0;
                value += dec_digit(c).float();
            }
        };
    };
    
    value
}

fn is_ascii_digit(c: u8) bool = c.ge("0".ascii()).and(c.le("9".ascii()));
fn is_ascii_alpha(c: u8) bool = 
    c.ge("a".ascii()).and(c.le("z".ascii()))
        .or(=> c.ge("A".ascii()).and(c.le("Z".ascii())))
        .or(=> c.eq("_".ascii()));


#redirect(i64, void) fn println(a: u64) void; // TODO: WRONG. sign
fn println(a: u32) void = println(@as(i64) a.zext()); 
#redirect(Ty(i64, *List(u8)), void) fn display(a: u64, out: *List(u8)) void; // TODO: WRONG. sign
fn display(a: u32, out: *List(u8)) void = display(@as(i64) a.zext(), out); 
fn display(a: i32, out: *List(u8)) void = display(@as(i64) a.zext(), out);  // TODO: WRONG. sign.

fn fmt_hex(value: i64) Str = {
    out := "0x".clone(temp());
    range(0, 16) {i|
        shift := 15.sub(i).mul(4);
        mask := 15.shift_left(shift);
        digit := value.bit_and(mask).div(1.shift_left(shift)); // TODO: right shift intrinsic
        ::if(u8);
        d := if(digit.lt(10), => "0".ascii().add(digit.trunc()), => "A".ascii().add(digit.sub(10).trunc())); 
        out&.push(d);
    };
    out.items()
}

fn display(self: rawptr, out: *List(u8)) void = 
    self.int_from_rawptr().display(out);

/// SAFETY: must not be cyclic!
fn DeriveFmt($T: Type) void = {
    info := T.get_type_info();
    assert(info&.is(.Struct), "TODO: non-struct");
    
    fn display(self: *T, out: *List(u8)) void = {
        out.push_all("(");
        prefix := "";
        inline_for T.get_fields() { $f|
            inner := T.int_from_ptr(self);
            inner := inner + f[].byte_offset;
            inner := (f[].ty).ptr_from_int(inner);
            
            // TODO: better error message if not defined. 
            @fmt(out, "%% = %", prefix, :: f[].name.str(), inner[]);
            prefix = ", ";
        };
        out.push_all(")");
    }
}

// TODO: move to meta.fr
fn get_fields(A: Type) Slice(Field) #fold = {
    a := get_type_info(A); 
    a.Struct.fields.items() 
}

fn display(i: *i64, out: *List(u8)) void = i[].display(out);
