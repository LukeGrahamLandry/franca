Type  :: @builtin Type;  // but what kind...?
unit  :: ();  // The officially blessed empty tuple.
void  :: @type(unit);  // The set of all empty tuples.
bool  :: @builtin bool;
true  :: @builtin true;
false :: @builtin false;
i64   :: @builtin i64;
f64   :: @builtin f64;
Never :: @builtin Never;  // It is illegal to create a value of this type. 
usize :: i64; // todo
isize :: i64; // todo
rawptr :: @builtin rawptr;
OverloadSet :: @builtin OverloadSet;
f32 :: @builtin f32;

:: bootstrap_compiler_environment();

// :blessed:
// Code behind the @late macro is only enabled after this function runs. 
// Non-builtin_prefix_macro macros cannot be expanded before this function runs, 
// because the compiler doesn't have the type 'FatExpr', so it can't resolve the overload.
fn bootstrap_compiler_environment() void = {
    env := get_comptime_environment();
    s: Fn(Type, Type) : Slice;
    env.make_slice_t = (Some = s);
    env.bake_os = (Some = bake_relocatable_value);  // This is only needed for aot so it's not super important that it be here... but it does have to be somewhere. 
    env.fat_expr_type = (Some = FatExpr);
    
    // you have to do tagged TypeInfo before you enable @late code. 
    // but now since these are all compiled in one block, it instantiates the const arg functions first regardless of lexical order, so its fine. 
    tagged(TypeInfo); 
    tagged(Expr);
    tagged(Stmt);
    tagged(LazyType);
    tagged(Name);
}

// TODO: these are still somewhat order dependent because of `:: expr;`.
//       should go through and make sure everything weird is pulled up into bootstrap_compiler_environment. 
#include_std("compiler");
#include_std("lib/driver_api.fr");
#include_std("lib/math.fr");
#include_std("lib/collections/slice.fr");
#include_std("lib/arena.fr");
#include_std("lib/sys/libc.fr");
#include_std("lib/codegen/llvm/intrinsics.fr");
#include_std("lib/pointers.fr");
#include_std("lib/casts.fr");
#include_std("lib/alloc.fr");
#include_std("lib/collections/list.fr");
#include_std("lib/collections/map.fr");
#include_std("lib/option.fr");
#include_std("lib/sys/process.fr");
#include_std("lib/ast.fr");
#include_std("lib/macros.fr");
#include_std("lib/fmt.fr");
#include_std("lib/sys/panic.fr");
#include_std("lib/collections/bucket_array.fr");
#include_std("lib/collections/bit_set.fr");
#include_std("lib/codegen/aarch64/instructions.fr");
#include_std("lib/codegen/aarch64/intrinsics.fr");
#include_std("lib/codegen/wasm/instructions.fr");
#include_std("lib/codegen/bf/instructions.fr");
#include_std("codegen_cranelift_intrinsics");
#include_std("lib/codegen/aarch64/unwind.fr");
#include_std("lib/codegen/aarch64/jump.fr");
#include_std("lib/codegen/c/intrinsics.fr");
#include_std("lib/loop.fr");
#include_std("lib/build.fr");
#include_std("lib/sys/fs.fr");
#include_std("lib/sys/terminal.fr");
#include_std("lib/trace.fr");
#include_std("lib/meta.fr");
#include_std("lib/hash.fr");
