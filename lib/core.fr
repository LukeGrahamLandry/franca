@pub const Type = @builtin("Type");  // but what kind...?
@pub const Unit: Type = ();  // The set of all empty tuples.
@pub const unit: Unit = ();  // The officially blessed empty tuple.
@pub const bool: Type = @builtin("bool");
@pub const true: bool = @builtin("true");
@pub const false: bool = @builtin("false");
@pub const i64: Type = @builtin("i64");
@pub const f64: Type = @builtin("f64");
@pub const Never: Type = @builtin("Never");
@pub const usize = i64; // todo
@pub const isize = i64; // todo
@pub const VoidPtr: Type = @builtin("VoidPtr");
@pub const OverloadSet: Type = @builtin("OverloadSet");

// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
@pub const Symbol: Type = @builtin("Symbol");

// TODO: this is the forward declaration for struct initilizers to bind to. hate it. 
@pub fn init(_: Unit) Unit = ();

#include_std("int_type");

@pub const f32 = f64; // TODO

@pub fn UInt(bits: i64) Type = IntType(bits, false);
@pub fn SInt(bits: i64) Type = IntType(bits, true);

@pub fn Tag(E: Type) Type = i64;  // Currently enum tags are untyped but that will likely change.

// TODO: this sucks. dynamically make these for uxx & ixx.
@pub const u1 = UInt(1);
@pub const u2 = UInt(2);
@pub const u4 = UInt(4);
@pub const u5 = UInt(5);
@pub const u6 = UInt(6);
@pub const u8 = UInt(8);
@pub const u12 = UInt(12);
@pub const u16 = UInt(16);
@pub const u19 = UInt(19);
@pub const u32 = UInt(32);
@pub const u64 = UInt(64);
@pub const i7 = SInt(7);
@pub const i8 = SInt(8);
@pub const i16 = SInt(16);
@pub const i19 = SInt(19);
@pub const i26 = SInt(26);
@pub const i32 = SInt(32);
@pub const i33 = SInt(33);

#include_std("codegen/aarch64/basic.gen.fr");
#include_std("codegen/llvm/basic.fr");
#include_std("compiler");

@pub @comptime @impl 
fn if(const T: Type) Unit = {
    @pub fn if(cond: bool, const then: Fn(Unit, T), const else: Fn(Unit, T)) T =
        (cond, then, else)!if;
}

// TODO: auto impl generics
if(i64); if(Unit); if(bool);

@pub fn if(cond: bool, const then: Fn(Unit, Unit)) Unit =
    (cond, then, fn=())!if;

@pub fn while(const cond: Fn(Unit, bool), const body: Fn(Unit, Unit)) Unit =
    (cond, body)!while;

@pub fn dowhile(const f: Fn(Unit, bool)) Unit = (f, fn=())!while;

@pub fn mod(big: i64, divisor: i64) i64 = sub(big, mul(div(big, divisor), divisor));
@pub fn max(a: i64, b: i64) i64 = (lt(a, b), fn=b, fn=a)!if;
@pub fn min(a: i64, b: i64) i64 = (gt(a, b), fn=b, fn=a)!if;
@pub fn not(b: bool) bool = (b, fn = false, fn = true)!if;
@pub fn neg(a: i64) i64 = sub(0, a);
@pub fn abs(val: i64) i64 = (val.ge(0), fn = val, fn = val.neg())!if;
@pub fn int(val: bool) i64 = (val, fn = 1, fn = 0)!if;
@pub fn eq(a: bool, b: bool) bool = a.int().eq(b.int());


// TODO: this gets a bit silly if I have to define this stuff all again but with different types. 
//       it would be cool if it could be done with traits. like anything with an ordering could have a fn max (bad example for floats i guess)
// TODO: !!! "Expected Ident but found Number(0)" my hacky dot parsing for floats is broken?
//       oh its probably because i handle zero differently for 0x and 0b
// @pub fn neg(a: f64) f64 = sub(0.0, a); // TODO: there's an instruction for this. which would be better because there's no zero register for floats. 

/// Yes, really...
@pub fn is_nan(a: f64) bool = a.eq(a).not();  // TODO: this could be fewer instructions but this is more fun. 

// There must be a not insane way to do this but i gave up and read the two's complement wikipedia page.
/// Convert an i64 to an i<bit_count> with the (64-<bit_count>) leading bits 0.
@pub fn signed_truncate(x: i64, bit_count: i64) i64 = {
    let mask = 1.shift_left(bit_count).sub(1);
    // TODO: fix if() on emit_rust because var name isn't None
    (le(x, 0), fn() i64 = {
        bit_and(add(bit_not(mul(x, neg(1))), 1), mask)
    }, fn() i64 = x)!if
}

@forward @pub fn assert_eq() = ();  // TODO

// TODO: this cant just be a no-op because the vm counts that my tests trigger all their assertions.
/// Stupid question, but I guess it's wierd if I don't let you ask.
@pub fn assert_eq(_: Unit, __: Unit) Unit = assert_eq(0, 0);

// Note: these are not short circuiting because arguments are always evaluated. 
@pub fn and(a: bool, b: bool) bool = a.if(fn = b, fn = false);
@pub fn or(a: bool, b: bool) bool = a.if(fn = true, fn = b);

// Note: these are short circuiting. The closure will only be called if necessary. 
@pub fn and(a: bool, const b: Fn(Unit, bool)) bool = a.if(b, fn = false);
@pub fn or(a: bool, const b: Fn(Unit, bool)) bool = a.if(fn = true, b);

// TODO: be more efficient about this type of function. It needs to be evaluated at comptime,
//       but you don't have to make a new function object to specialize it, just inline the value.
//       @inline instead of @comptime should work for that since !macros are intercepted in the compiler,
//       but it doesn't bind the args correctly for some reason.
// Measured in interpreter stack slots.
@pub fn size_of(const T: Type) i64 = T!size_of;
// These don't care about the size of the type, they just measure in interp stack slots. 


@pub fn operator_star_prefix(T: Type) Type = Ptr(T);

@pub const Fd = Unique(i32);
#include_std("libc");

@forward @env @pub fn println(msg: ""!type) Unit;
// Halts the program and reports an error. The return value can typecheck as anything because it never returns. 
@forward @pub fn panic(msg: ""!type) Never;
@pub fn assert(cond: bool, msg: ""!type) Unit = (cond, fn() Unit=(), fn() Unit={
    panic(msg); // TODO: fix overload resolution so this doesn't need the semi colon to turn Never to Unit
})!if;

#include_std("slice.fr");
#include_std("mem.fr");
#include_std("list.fr");
#include_std("system.fr");
#include_std("compiler_flat");
#include_std("ast.fr");
#include_std("compiler_late");
#include_std("macros.fr");

#include_std("codegen/aarch64/instructions.fr");
#include_std("codegen/aarch64/basic.fr");
#include_std("codegen/wasm/instructions.fr");


@pub
fn println(msg: Str) Unit = {
    let msg: ""!type = msg; // TODO: HACK
    println(msg);
};

@pub
fn println(msg: bool) Unit = {
    let msg = (msg, fn="true", fn="false")!if;
    println(msg);
}

#include_std("codegen/aarch64/unwind.fr");
#include_std("fmt.fr");
#include_std("codegen/bf/instructions.fr");


/* TODO
@comptime @generic
fn zeroed(const T: Type) Fn(Unit, T) = {
    (fn() T = {
        var t: T;
        var bytes: VoidPtr = t&;
        var bytes: *i64 = bytes;
        var bytes: Slice(i64) = assume(bytes, size_of(T));
        for(bytes, fn(ptr: *i64) = {
            ptr[] = 0;
        });
        t
    })
}
*/
