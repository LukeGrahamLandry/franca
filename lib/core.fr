Type  :: @builtin Type;
void  :: @builtin void;  // The set of all empty tuples.
bool  :: @builtin bool;
true  :: @builtin true;
false :: @builtin false;
i64   :: @builtin i64;
f64   :: intern_type(.F64);
Never :: @builtin Never;  // It is illegal to create a value of this type. 
rawptr :: @builtin rawptr;
OverloadSet :: @builtin OverloadSet;
f32 :: intern_type(.F32);

:: bootstrap_compiler_environment_pre();
:: bootstrap_compiler_environment_post();

// :blessed:
// Non-builtin_prefix_macro macros cannot be expanded before this function runs, 
// because the compiler doesn't have the type 'FatExpr', so it can't resolve the overload.
fn bootstrap_compiler_environment_pre() void = {
    env := get_comptime_environment();
    s: Fn(Type, Type) : Slice;
    env.make_slice_t = (Some = s);
    env.bake_os = (Some = bake_relocatable_value);  // This is only needed for aot so it's not super important that it be here... but it does have to be somewhere. 
    env.fat_expr_type = (Some = FatExpr);
    env.intrinsic_type = (Some = i64);  // :UpdateBoot
    q: Fn(Slice(FatExpr), FatExpr) : unquote_macro_apply_placeholders;
    env.unquote_placeholders = (Some = q);
    env.c_str_type = CStr;
    
    // once the normal @enum/@tagged are compiled this is done automatically. 
    // need to do it manually for the types that are needed early using builtin_macro. 

    T :: tagged_derive;
    T(TypeInfo); 
    T(Expr);
    T(Stmt);
    T(LazyType);
    T(Name);
    T(?Var);
    T(?Type);
    T(?LabelId);
    T(?FuncId);
    T(?OverloadSet);
    T(?Symbol);
    T(?i64);
    T(FuncImpl);
    T(Values);
    E :: enum_derive;
    E(Os);
    E(Arch);
    E(PlaceholderValue);
    E(VarType);
};

fn bootstrap_compiler_environment_post() void = {
    env := get_comptime_environment(); // TODO: this can just be a thing on the comptime context but it starts to get a bit circular...
    env.compile_error_pointer = (Some = *CompileError);
    env.os_type = (Some = Os);
    env.runtime_init = (Some = franca_runtime_init);
}

// TODO: this is a pain but doing it for every program makes mandlebrot like 10-30% slower -- Sep 21

fn enable_franca_ir_types(t: Type) void = {
    env := get_comptime_environment();
    env.ir_op_cls_types = t;
}

fn get_build_options() *BuildOptions = {
    env := get_comptime_environment();
    BuildOptions.ptr_from_raw(env.build_options)
}

fn is_linking_libc() bool = {
    !tls(.prefer_syscalls)[]
}

// TODO: a use_threads=false compiler cannot build a use_threads=true compiler. -- Mar 14, 2025
//       "panic! unlocked a mutex that was already unlocked"
use_threads :: true;

// TODO: (SLOW_MEMORY_DEBUGGING,SLOW_DEBUG_ALLOC,SLOW_PROTECT_ARENA) are broken
SLOW_MEMORY_DEBUGGING :: false;
SLOW_MEMORY_JUNK :: 0xAB;
NEVER_USE_LIBC_ALLOC :: false;
ALWAYS_BE_SIGNALLING :: false;
SLOW_DEBUG_ALLOC :: false;
SLOW_PROTECT_ARENA :: false;
SLOW_USERSPACE_THREADS :: false && !IS_BOOTSTRAPPING;
SLOW_ARENA_CANARY :: false && !IS_BOOTSTRAPPING;
SLOW_LEAK_ARENAS :: false; 
TODOWASM :: true && !IS_BOOTSTRAPPING;

// TODO: clean this up. 
//       it point is to wrap the @tagged and @enum provided by the compiler 
//       with the something that derives eq, is, tag, etc.

fn enum(a: FatExpr, b: FatExpr) FatExpr #macro #outputs(Type) = @{
    X :: @[import("@/lib/scope_hack.fr")'enum(a, b)];
    ::enum_derive(X);
    X
};

fn tagged(a: FatExpr) FatExpr #macro #outputs(Type) = @{
    X :: @[import("@/lib/scope_hack.fr")'tagged(a)];
    ::tagged_derive(X);
    X
};

// TODO: these are still somewhat order dependent because of `:: expr;`.
//       should go through and make sure everything weird is pulled up into bootstrap_compiler_environment. 
#use("@/lib/scope_hack.fr");
#include_std("lib/driver_api.fr");
#include_std("lib/sugar.fr");
#include_std("lib/math.fr");
#include_std("lib/collections/slice.fr");
#include_std("lib/context.fr");
#include_std("lib/sys/libc.fr");
#include_std("lib/memory.fr");
#include_std("lib/alloc/alloc.fr");
#include_std("lib/collections/list.fr");
#include_std("lib/option.fr");
#include_std("lib/macros.fr");
#include_std("lib/fmt.fr");
#include_std("lib/sys/panic.fr");
#include_std("lib/meta.fr");
#include_std("lib/hash.fr");

// :UpdateBoot this seems fixed now? 
:: @if(IS_BOOTSTRAPPING) {  // coconut.jpg ðŸ¤¡
    //x: Expr.Tag() = .Block;
    //y := x.ordinal();
    // the above works on arm but not macos-x64 (it hangs forever)
    assert_eq(1, 1);
};

Sha256 :: import("@/lib/mix/sha256.fr");
Random :: import("@/lib/mix/random.fr");
Arena :: import("@/lib/alloc/arena.fr");
Foreign :: import("@/tests/deps.fr");
