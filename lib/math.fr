
fn div_mod(big: i64, divisor: i64) Ty(i64, i64) = {
    d := big / divisor;
    (d, big - d * divisor)
}

fn mod(big: i64, divisor: i64) i64 = sub(big, mul(div(big, divisor), divisor));
fn max(a: i64, b: i64) i64 = if(lt(a, b), =>b, =>a);
fn min(a: i64, b: i64) i64 = if(gt(a, b), =>b, =>a);
fn neg(a: i64) i64 = sub(0, a);
fn abs(val: i64) i64 = if(val.ge(0), => val, => val.neg());
fn int(val: bool) i64 = if(val, => 1, => 0);
fn eq(lhs: Symbol, rhs: Symbol) bool = lhs.int().eq(rhs.int());
fn to_bool(b: i64) bool = if(eq(b, 0), => false, => true);

// TODO: this gets a bit silly if I have to define this stuff all again but with different types. 
//       it would be cool if it could be done with traits. like anything with an ordering could have a fn max (bad example for floats i guess)
fn neg(a: f64) f64 = sub(0.0, a); // TODO: there's an instruction for this. which would be better because there's no zero register for floats. 

/// Yes, really...
fn is_nan(a: f64) bool = a.eq(a).not();  // TODO: this could be fewer instructions but this is more fun. 

// There must be a not insane way to do this but i gave up and read the two's complement wikipedia page.
/// Convert an i64 to an i<bit_count> with the (64-<bit_count>) leading bits 0.
fn signed_truncate(x: i64, bit_count: i64) u32 = {
    mask := 1.shift_left(bit_count).sub(1);
    ::if(u32);
    if(x < 0, => mask.bit_and(bit_not(x * -1) + 1).trunc(), => x.trunc())
}

MAX_u32 :: 0xFFFFFFFF;

// TODO: this is probably slow now that we have to call it a bunch of times for compiler/backend/aarch64 and not just once for the inline asm functions. 
fn fold_shift_or(ints: []i64) u32 = {
    //::display_slice(i64);
    //@println("%", ints);
    @assert(ints.len < 32, "% is too many args for fold_shift_or", ints.len);
    acc := 0;
    range(0, ints.len / 3) { i |
        //@print("% ", acc); // :debug
        x := ints[i * 3];
        sh := ints[i * 3 + 1];
        size_info := ints[i * 3 + 2]; // HACK. masking fixed maual_mmap. u16 has garabge memory where read as u64.
        bit_count := size_info.abs();
        is_signed := size_info < 0;
        if is_signed {|
            x = signed_truncate(x, bit_count).zext();
        };
        @assert(sh < 32, "% too much shift", sh);
        //@assert(x.shift_left(sh) <= 1.shift_left(32), "% << %", x, sh);
        mask := 1.shift_left(bit_count) - 1;
        acc = acc.bit_or(x.bit_and(mask).shift_left(sh));
    };
    //@println("%", acc); // :debug
    @assert(acc > 0 && acc <= MAX_u32.zext(), "% is not a valid u32", acc);
    acc.trunc()
};

////////////////
/// Booleans ///
////////////////
// u1 is a number so this is kinda like math... idk.

// Note: its a fun game to make this call the other fn if instead of the macro and measure how much slower it compiles itself. 
fn if(cond: bool, $then: @Fn() void) void =
    @if(cond, then, =>());

fn if($T: Type) void = {
    fn if(cond: bool, $then: @Fn() T, $else: @Fn() T) T = @if(cond, then, else);
}

// TODO: auto impl generics
::if(i64); ::if(void); ::if(bool); ::if(u8); 

fn eq(a: bool, b: bool) bool = a.int().eq(b.int());
fn not(b: bool) bool = if(b, => false, => true);

// Note: these are not short circuiting because arguments are always evaluated. 
fn and(a: bool, b: bool) bool = a.if(=> b, => false);
fn or(a: bool, b: bool) bool = a.if(=> true, => b);

// Note: these are short circuiting. The closure will only be called if necessary. 
fn and(a: bool, $b: @Fn() bool) bool = a.if(b, => false);
fn or(a: bool, $b: @Fn() bool) bool = a.if(=> true, b);

/////////////////
/// Fake Ints ///
/////////////////
// TODO: this sucks. dynamically make these for uxx & ixx.
// TODO: store these in the next sane size up, not always i64. 

fn UInt(bits: i64) Type #fold = IntType(bits, false);
fn SInt(bits: i64) Type #fold = IntType(bits, true);

u1  :: UInt(1);
u2  :: UInt(2);
u4  :: UInt(4);
u5  :: UInt(5);
u6  :: UInt(6);
u8  :: UInt(8);
u12 :: UInt(12);
u16 :: UInt(16);
u19 :: UInt(19);
u32 :: UInt(32);
u64 :: UInt(64);
i7  :: SInt(7);
i8  :: SInt(8);
i16 :: SInt(16);
i19 :: SInt(19);
i26 :: SInt(26);
i32 :: SInt(32);
i33 :: SInt(33);


/////////////////
/// Redirects ///
/////////////////

fn Ord($T: Type) void = {
    fn eq(lhs: T, rhs: T) bool = lhs.int().eq(rhs.int());
    fn ne(lhs: T, rhs: T) bool = lhs.int().ne(rhs.int());
    fn lt(lhs: T, rhs: T) bool = lhs.int().lt(rhs.int());
    fn le(lhs: T, rhs: T) bool = lhs.int().le(rhs.int());
    fn gt(lhs: T, rhs: T) bool = lhs.int().gt(rhs.int());
    fn ge(lhs: T, rhs: T) bool = lhs.int().ge(rhs.int());
}

fn int(i: i64) i64 #unsafe_noop_cast;
fn int(i: u8)  i64 #inline = i.zext();    ::Ord(u8);
fn int(i: u32) i64 #inline = i.zext();    ::Ord(u32);
fn int(i: u64) i64 #inline = i.bitcast(); ::Ord(u64); // TODO: wrong!!! signed
fn int(i: i32) i64 #inline = i.intcast(); ::Ord(i32);
fn int(i: u16) i64 #inline = i.zext();    ::Ord(u16);

::{
    UNum :: fn($T: Type) void = {
        fn add(lhs: T, rhs: T) T = lhs.int().add(rhs.int()).trunc();
        fn sub(lhs: T, rhs: T) T = lhs.int().sub(rhs.int()).trunc();
        fn mul(lhs: T, rhs: T) T = lhs.int().mul(rhs.int()).trunc();
        fn div(lhs: T, rhs: T) T = lhs.int().div(rhs.int()).trunc();
        fn min(lhs: T, rhs: T) T = lhs.int().min(rhs.int()).trunc();
        fn max(lhs: T, rhs: T) T = lhs.int().max(rhs.int()).trunc();
        fn mod(lhs: T, rhs: T) T = lhs.int().mod(rhs.int()).trunc();
    };
    UNum(u8); 
    UNum(u16);
    UNum(u32);
};

#redirect(Ty(i64, i64), i64)  fn shift_left(value: u64, shift_amount: i64) u64;
#redirect(Ty(i64, i64), i64)  fn bit_or(lhs: u64, rhs: u64) u64;
#redirect(Ty(i64, i64), i64)  fn bit_and(lhs: u64, rhs: u64) u64;
#redirect(i64, i64)           fn bit_not(value: u64) u64;
#redirect(Ty(i64, i64), i64)  fn mul(lhs: u64, rhs: u64) u64;
#redirect(Ty(i64, i64), i64)  fn add(lhs: u64, rhs: u64) u64;

// TODO: dumb
fn bit_or(lhs: u32, rhs: u32) u32 = bit_or(@as(i64) lhs.zext(), @as(i64) rhs.zext()).trunc();
fn bit_and(lhs: u32, rhs: u32) u32 = bit_and(@as(i64) lhs.zext(), @as(i64) rhs.zext()).trunc();
fn shift_left(value: u32, shift_amount: i64) u32 = shift_left(@as(i64) value.zext(), shift_amount).trunc();
// TODO: bit_not can't just redirect because that would flip the leading zeros too. 

fn shift_right_logical(value: u32, shift_amount: i64) u32 = 
    shift_right_logical(@as(i64) value.zext(), shift_amount).trunc();
fn shift_right_logical(value: u64, shift_amount: i64) u64 = 
    shift_right_logical(@as(i64) value.bitcast(), shift_amount).bitcast();
