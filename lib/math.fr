#include_std("codegen/aarch64/basic.gen.fr");
#include_std("codegen/llvm/basic.fr");

fn mod(big: i64, divisor: i64) i64 = sub(big, mul(div(big, divisor), divisor));
fn max(a: i64, b: i64) i64 = (lt(a, b), fn()=b, fn()=a)!if;
fn min(a: i64, b: i64) i64 = (gt(a, b), fn()=b, fn()=a)!if;
fn not(b: bool) bool = (b, fn() bool = false, fn() bool = true)!if;
fn neg(a: i64) i64 = sub(0, a);

// There must be a not insane way to do this but i gave up and read the two's complement wikipedia page.
/// Convert an i64 to an i<bit_count> with the (64-<bit_count>) leading bits 0.
fn signed_truncate(x: i64, bit_count: i64) i64 = {
    let mask = sub(shift_left(1, bit_count), 1);
    (le(x, 0), fn() i64 = {
        bit_and(add(bit_not(mul(x, neg(1))), 1), mask)
    }, fn() i64 = x)!if
}
