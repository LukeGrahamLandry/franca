const Type;  // but what kind...?
const Any: Type;  // Any value that fits in a single stack slot.
const Unit: Type = ();  // The set of all empty tuples.
const unit: Unit = ();  // The officially blessed empty tuple.
const bool: Type;
const true: bool;
const false: bool;
const i64: Type;
const f64: Type;
const Never: Type;

// @cap(raw_ptr)
const VoidPtr: Type;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files.
// There's nothing special about it unless you're interacting with the asts in macros.
const Symbol: Type;

fn IntType(bits: i64, signed: bool) Type;

// TODO: dynamically make these for uxx & ixx.
const f32 = f64; // TODO

fn UInt(bits: i64) Type = IntType(bits, false);
fn SInt(bits: i64) Type = IntType(bits, true);

fn Tag(E: Type) Type = i64;  // Currently enum tags are untyped but that will likely change.
fn tag_symbol(E: Type, value: i64) Symbol;

// Simple types
fn Ptr(Inner: Type) Type;  // A reference to one `Inner`
/// Create a new type with the same representation in memory as `T` but distinct for type checking / overload resolution.
fn Unique(T: Type) Type;
fn type_id(T: Type) i64;

/// The type of 'fn(Arg) Ret'. This is a comptime only value.
/// All calls are inlined, as are calls that pass one of these as an argument.
/// Captures of runtime variables are allowed since you just inline everything anyway.
/// Const captures behave as you'd expect from first class closures.
fn Fn(Arg: Type, Ret: Type) Type;

// TODO: include calling convention.
/// Like Fn(Arg, Ret) but as a runtime value. Same as a function pointer in c but with less insane syntax :).
/// Use '!addr' on a normal Fn value to get create a value of this type.
/// - The function cannot have any runtime variable captures,
///   but they could be implemented on top of this by taking an environment data pointer as an argument.
/// - The function cannot have any const arguments, they must be baked before creating the pointer.
fn FnPtr(Arg: Type, Ret: Type) Type;

// TODO: this sucks. dynamically make these for uxx & ixx.
const u1 = UInt(1);
const u2 = UInt(2);
const u4 = UInt(4);
const u5 = UInt(5);
const u6 = UInt(6);
const u8 = UInt(8);
const u12 = UInt(12);
const u16 = UInt(16);
const u19 = UInt(19);
const u32 = UInt(32);
const u64 = UInt(64);
const i7 = SInt(7);
const i8 = SInt(8);
const i16 = SInt(16);
const i19 = SInt(19);
const i26 = SInt(26);
const i32 = SInt(32);
