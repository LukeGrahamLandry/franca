// TODO: These are just cringe forward declarations to create the overload sets. 
fun for();
fun enumerate();
fun get();
fun set();
fun fill();
fun subslice();
fun index();
fun slice();
fun len();
fun memcpy();
fun rest();
fun find();

fun range(start: i64, end: i64, const yield: Fn(i64, Unit)) Unit = {
    var i = start;
    while(=> i.lt(end)) {|
        yield(i);
        i = i.add(1);
    };
}

// TODO: PROBLEM: now that im not just taking the first overload, this not using comptiem cache because its not #generic so multiple versions of inner functions can get made 
//       I still want to replace @comptiem with just having const args but need to make @impl use the cache. 

#comptime
fun Slice(const T: Type) Type = {
    Self :: @struct(ptr: *T, len: i64);
    
    ::ptr_utils(T);
    
    fun slice(ptr: *T) Self = (ptr = ptr, len = 1);
    // TODO: fun empty() Self = (ptr = zeroed(), len = 0);
    fun slice(ptr: *T, count: i64) Self = (ptr = ptr, len = count);
    #inline
    fun len(var self: Self) i64 = self.len;
    
    #inline
    fun get(var self: Self, i: i64) T = {
        let v: *T = self.index(i);  // TODO: fix so dont need useless binding 
        v[]
    }
    
    #inline
    fun index(var self: Self, i: i64) *T = {
        // TODO: this should work but its kinda a dumb way to do it from before I gave ptr_utils -- May 2
        //var s = self.subslice(i, 1);
        //s&.ptr[]
        
        assert(i.lt(self.len), "OOB");  
        self.ptr.offset(i)
    }
    
    // TODO: this should work without inlining. 
    #inline
    fun set(var self: Self, i: i64, v: T) Unit = {
        // TODO: allowing this is a bit creepy if I don't specify order of evaluation. 
        //       and having it be placement is scary if you aliased the lhs ptr on the rhs. 
        self.index(i)[] = v; 
    }
    
    fun slice(var self: Self, first: i64, past_last: i64) Self = {
        // TODO: first should be lt
        // TODO: its sad that im doing double bounds check in common case where its just index()
        assert(first.le(self.len()).and(past_last.le(self.len())), "OOB"); 
        const bytes = size_of(T);
        let raw_first = first.mul(bytes);
        let ptr: rawptr = self.ptr;
        let new_ptr: rawptr = ptr.offset(raw_first);
        // TODO: shouldn't need the extra binding. broke with scan ahead consts / renumber comptime. 
        //       only for tests/fmt.fr, that can't be the only place that calls items(), some scary ordering thing? -- Apr 22
        let res: Self = (ptr = new_ptr, len = past_last.sub(first)); 
        res
    }
    
    fun subslice(var self: Self, first: i64, count: i64) Self = {
        self.slice(first, first.add(count))
    }
    
    fun rest(var self: Self, first: i64) Self = {
        self.slice(first, self.len())
    }
    
    // TODO: the other fn type syntax so you can name the arguments in the closure as documentation. 
    // TODO: be more consistant about how tuples are expanded into args to fix Fn((a, b), c) === Fn(a, b, c) when you want Fn(Ty(a, b), c)
    //       seems like a massive mistake that I create ambiguity and then just guess something stupid and hope for the best. 
    fun enumerate(var arr: Self, const f: Fn(Ty(i64, *T), Unit)) Unit = {
        var i = 0;
        while(=> lt(i, arr.len())) {|
            let e: *T = arr.index(i);
            f(i, e);
            i = i.add(1);
        };
    }
    
    // TODO: I don't love that I have to write the deref version seperatly
    //       but I dont have let destructuring (only function args) so its a pain to take tuples by pointer. 
    //       I should be able to destructure Ptr(A, B) to (Ptr(A), Ptr(B))
    fun for(var arr: Self, const f: Fn(T, Unit)) Unit = 
        for(arr, fn(v: *T) Unit => f(v[]));
    
    fun for(var arr: Self, const f: Fn(*T, Unit)) Unit = {
        var i = 0;
        let l = arr.len();
        while(fn() bool => lt(i, l)) {|
            f(arr.index(i));
            i = i.add(1);
        };
    }
    
    fun memcpy(dest: Self, src: Self) Unit = {
        assert(eq(len(dest), len(src)), "OOB");  // Note: not using `asser t_eq` because the vm tracks those for my tests
        // TODO: sad that this does the bounds check every iteration but a real optimiser would fix it for me anyway so meh. 
        // TODO: this used to work as binding. new syntax is better but old should still work. broke when scan ahead resolve. -- Apr 22
        // const f = fn(i: i64, e: *T) Unit = dest.set(i, e[]);
        src.enumerate {(i: i64, e: *T) Unit|
             dest.set(i, e[]);
        };
    }
    
    // TODO: add addr_eq/identical if that's really what you want but like... it never is I feel. 
    fun eq(lhs: Self, rhs: Self) bool = {
        eq(lhs.len(), rhs.len()).and { () bool |
            var i = 0;
            while(=>i.lt(len(lhs)).and(=> lhs.get(i).eq(rhs.get(i)))) {| 
                i = i.add(1); 
            };
            eq(i, lhs.len())
        }
    }
    
    /// Set all elements of the slice to 't'. 
    fun fill(self: *Self, t: T) Unit = {
        for(self) { (ptr: *T) |
            ptr[] = t;
        };
    }
    
    Self
}

// The parser generates casts to this type for string literals which is dumb but make them not suck ass to work with.
__string_literal_type_hack :: Str;

Str :: Slice(i64);

fun endswith(haystack: Str, needle: Str) bool = {
    // TODO: prefix if syntax forces you to give a return type annotation
    (lt(len(haystack), len(needle)),
        => false,
        => {
            let start = subslice(haystack, sub(len(haystack), len(needle)), len(needle)); 
            eq(start, needle)
        }
    )!if
}

// TODO: these should just be on Slice(T)
fun startswith(haystack: Str, needle: Str) bool = {
    if(lt(len(haystack), len(needle)), => false,
        fn() bool => {
            let start = subslice(haystack, 0, len(needle)); 
            eq(start, needle)
        }
    )
}

// TODO: this should return an option. 
// TODO: use @switch once I have ranges. 
fun hex_digit(c: i64) i64 = {
    if(ge(c, 97), 
        fn() i64 =>  { assert(lt(c, 107), "hex OOB"); add(sub(c, 97), 10) }, 
        fn() i64 => if(ge(c, 65), 
            fn() i64 => { assert(lt(c, 75), "hex OOB"); add(sub(c, 65), 10) }, 
            fn() i64 => { assert(lt(c, 58), "hex OOB"); sub(c, 48)}
        )
    )
}

// TODO: this should return an error. 
fun hex(s: Str) i64 = {
    var total = 0;
    var scale = 1;
    var i = s.len().sub(1);
    var first = 0;
    
    // This prevents overflow for tracking scale for lots of leading zeros. 
    // TODO: add a test that requires this. lol its an insane number tho so could just not bother 
    while(=> first.lt(s.len()).and(=> eq(get(s, first), 48))) {|
        first = add(first, 1) 
    };
    
    while(=> ge(i, first)) {|
        total = add(total, mul(scale, hex_digit(get(s, i))));
        scale = mul(scale, 16);
        i = sub(i, 1);
    };
    total
}

fun multi_println(s: Slice$Str) Unit = {
    for(s) {(s: *Str)| println(s[]); };
}
