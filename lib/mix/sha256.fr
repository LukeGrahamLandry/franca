// https://en.wikipedia.org/wiki/SHA-2

hex :: fn(message: []u8) []u8 = {
    digest := hash(message);
    s := u8.list(temp());
    @fmt(s&, "%", digest&);
    s.items()
};

// TODO: if we're doing this then it should be a unique type
fn display(digest: *Digest, out: *List(u8)) void = {
    out.reserve(64);
    digest := digest.items().interpret_as_bytes();
    for digest { b | 
        push_hex_byte(out, b, false);
    };
}

Digest :: Array(u32, 8);

// TODO: there's special instructions for the round loop in both amd64 and arm64
hash :: fn(message: []u8) Digest = {
    h: Array(u32, 8) = :: u32.map_in_place(eratosthenes(20), 
        fn(x) => x.float().sqrt().fraction32())
        .init();
    
    length_in_bits := message.len * 8;
    chunk_count := message.len / 64;
    range(0, chunk_count) { _ | 
        chunk := ptr_cast_unchecked(u8, Array(u8, 64), message.ptr);
        update(h&, chunk);
        message.ptr = message.ptr.offset(64);
    };
    message.len -= chunk_count * 64;
    finalize(message, h, length_in_bits)
};

finalize :: fn(incomplete_chunk: []u8, h: Digest, length_in_bits: i64) Digest = {
    message := incomplete_chunk;
    chunk := @uninitialized Array(u8, 64); 
    extra := chunk&.items();
    extra.slice(0, message.len).copy_from(message);  // the unaligned end of the input
    extra[message.len] = 128;  // set first bit after the message to 1. 
    message.len += 1;
    if message.len + 8 <= 64 {
        // We have space for just one chunk of padding. 
    } else {
        extra.rest(message.len).set_zeroed();
        update(h&, chunk&);
        message.len = 0;
    };
    extra.rest(message.len).set_zeroed();
    // TODO: is alignment real?
    ptr_cast_unchecked(u8, i64, extra.ptr.offset(64-8))[] = byte_swap(length_in_bits);
    update(h&, chunk&);
    
    u32.map_in_place(h&.items(), fn(x) => byte_swap(x));
    h
};

update :: fn(h: *Array(u32, 8), chunk: *Array(u8, 64)) void = {
    round_constants :: u32.map_in_place(eratosthenes(312), 
        fn(x) => x.float().cbrt().fraction32());
    rotr :: rotate_right; xor :: bit_xor; shr :: shift_right_logical; and :: bit_and;
    
    // TODO: is alignment real? 
    chunk := ptr_cast_unchecked(@type chunk[], Array(u32, 16), chunk);
    
    w := @uninitialized Array(u32, 64); w := w&;
    v0 := h[0]; v1 := h[1]; v2 := h[2]; v3 := h[3];
    v4 := h[4]; v5 := h[5]; v6 := h[6]; v7 := h[7];
    inline_range(0, 64) { i |
        w[i] = @if(i >= 16, {
            wi15, wi2 := (w[i - 15], w[i - 2]);
            s0  := wi15.rotr(7).xor(wi15.rotr(18)).xor(wi15.shr(3));
            s1  := wi2.rotr(17).xor(wi2.rotr(19)).xor(wi2.shr(10));
            w[i - 16] + s0 + w[i - 7] + s1
        }, {
            byte_swap(chunk[i]) // because we work at the confusion factory
        });
    
        S1    := v4.rotr(6).xor(v4.rotr(11)).xor(v4.rotr(25));
        ch    := v4.and(v5).xor(v4.bit_not().and(v6));
        temp1 := v7 + S1 + ch + round_constants[i] + w[i];
        S0    := v0.rotr(2).xor(v0.rotr(13)).xor(v0.rotr(22));
        maj   := v0.and(v1).xor(v0.and(v2)).xor(v1.and(v2));
        temp2 := S0 + maj;

        v7 = v6;
        v6 = v5;
        v5 = v4;
        v4 = v3 + temp1;
        v3 = v2;
        v2 = v1;
        v1 = v0;
        v0 = temp1 + temp2;
    };
    h[0] += v0; h[1] += v1; h[2] += v2; h[3] += v3;
    h[4] += v4; h[5] += v5; h[6] += v6; h[7] += v7;
};

// TODO: something broken with ::assert_eq(a, b) outside a block at top level :fucked

// Stuff for computing the constants because I hate just pasting tables. 

map_in_place :: fn($T: Type, arr: []T, $f: @Fn(x: T) T) []T #generic = {
    each(arr, fn(x) => { x[] = f(x[]); });
    arr
};

// First 32 bits of the fractional component of x. 
// Used for generating magic numbers for some hashing algorithms. 
fraction32 :: fn(x: f64) u32 = {
    x := x - floor(x);
    x := int(x * float(1.shift_left(32)));
    x.trunc()
};

// calculate the prime numbers below n
eratosthenes :: fn($n: i64) []u32 #fold = {
    Bits :: import("@/lib/collections/bit_set.fr").StaticBitSet;
    unprime: Bits(n) = empty();
    out := u32.list(ast_alloc());
    high := n.float().sqrt().int() + 1;
    range(2, high) { i |
        if !unprime&.get(i) {
            out&.push(i.trunc());
            j := i * i;
            while => j < n {
                unprime&.set(j);
                j += i;
            };
        };
    };
    range(high, n) { i |
        if !unprime&.get(i) {
            out&.push(i.trunc());
        };
    };
    
    out.items()
};
