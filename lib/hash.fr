

// TODO: return the function instead so you can wrap with your own logic. 
// TODO: pass things as byte slices when possible? (no pointers + no padding)
fn AutoHash($T: Type, $Hasher: Type) void = {
    fn hash(hasher: *Hasher, self: *T) void = {
        @inline_match(@run T.get_type_info_ref()) {
            (fn Struct($_) => {
                inline_for T.get_fields() { $f | 
                    inner := T.get_field_ptr(self, f);
                    // TODO: better error message if not defined. 
                    hasher.hash(inner);
                };
            });
            (fn Tagged($_) => {
                i := 0; // TODO : inline_enumerate
                tag_value := self.tag().ordinal();
                hasher.hash(tag_value&); // TODO: do i want to hash it as Tag so you get the type and can do cool things if you try hard enough? -- Jul 6
                // TODO: @inline_switch.
                inline_for T.get_variants() { $f | 
                    // TODO: you could just implement it for void...
                    //       but the way youd do it here would be to impl for *void,
                    //       which is what c uses as a rawptr so feels unexpected. 
                    non_void :: !(f[]._1 == void);
                    if i == tag_value {|
                        @if(non_void) {
                            inner := T.get_variant_ptr_for(self, f);
                            hasher.hash(inner);
                        };
                        return();
                    };
                    i += 1;
                };
                // TODO: @safety unreachable_unchecked so you don't bloat the code. i don't trust that llvm can notice my tag preconditions. 
                panic("Tried to hash @tagged with invalid tag value. Uninitilized memory?")
            });
            @default => :: panic("Unsupported type for AutoHash");
        }
    }
}

fn AutoEq($T: Type) void = {
    fn ne(lhs: *T, rhs: *T) bool #inline = 
        !lhs.eq(rhs);
    
    fn eq(lhs: *T, rhs: *T) bool = {
        @inline_match(@run T.get_type_info_ref()) {
            (fn Struct($_) => {
                inline_for T.get_fields() { $f | 
                    l_inner := T.get_field_ptr(lhs, f);
                    r_inner := T.get_field_ptr(rhs, f);
                    // TODO: better error message if not defined. 
                    if(!l_inner.eq(r_inner), => return(false));
                };
                true
            });
            (fn Tagged($_) => {
                i := 0; // TODO : inline_enumerate
                tag_value := lhs.tag().ordinal();
                
                if tag_value != rhs.tag().ordinal() {|
                    return(false);
                };
                
                // TODO: @inline_switch.
                inline_for T.get_variants() { $f | 
                    non_void :: !(f[]._1 == void);
                    if i == tag_value {|
                        @if(non_void, => {
                            l_inner := T.get_variant_ptr_for(lhs, f);
                            r_inner := T.get_variant_ptr_for(rhs, f);
                            return(l_inner.eq(r_inner));
                        }, => { return(true); });
                    };
                    i += 1;
                };
                // TODO: @safety unreachable_unchecked so you don't bloat the code. i don't trust that llvm can notice my tag preconditions. 
                @panic("Tried to eq @tagged with invalid tag value %. Uninitilized memory?", tag_value);
                // TODO: compiler bug! if you let Never fall through you get garbage from the early return???????? -- jul 20
                false
            });
            @default => :: panic("Unsupported type for AutoEq");
        }
    }
}

////////////////////////////////////

TrivialHasher :: @struct(h: u64);
fn init() TrivialHasher #inline = {
    (h = 2166136261)
}
fn hash(hasher: *TrivialHasher, i: *u64) void = {
    hasher.h = hasher.h.bit_xor(i[]);
    hasher.h *= @as(u64) 16777619;
}
fn end(self: *TrivialHasher) u64 = {
    self.h
}

// this is dumb! 
fn HashAsInt($T: Type, $Hasher: Type) void = {
    fn hash(hasher: *Hasher, self: *T) void = {
        i: u64 = self[].int().bitcast();
        hasher.hash(i&);
    }
}

// TODO: really need to have less painful polymorphism stuff so you don't have to put everything in one place. 
//       i think this will go away eventually with the sema rewrite. 
// TODO: even before that move this into the compiler so you don't have to do these clones for every program? 
fn StupidAddHashable($H: Type) void = {
    fn DerefHash($T: Type) void = {
        fn hash(hasher: *H, a: *T) void #inline = hasher.hash(a[]);
    }
    
    WalkInts() { $T | HashAsInt(T, H); };
    HashAsInt(u8, H);
    #redirect(Ty(*H, *u32), void) fn hash(h: *H, s: *Type) void;
    #redirect(Ty(*H, *u32), void) fn hash(h: *H, s: *Symbol) void;
    #redirect(Ty(*H, *u32), void) fn hash(h: *H, s: *LabelId) void;
    HashEach([]u8, H);
    AutoHash(TypeInfo, H); AutoEq(TypeInfo);
    AutoHash(IntTypeInfo, H); AutoEq(IntTypeInfo);
    AutoHash(FnType, H); AutoEq(FnType);
    AutoHash(?Var, H); AutoEq(?Var);
    DerefHash(*TypeInfo); DerefEq(*TypeInfo);
    AutoHash(get_variant_type(TypeInfo, TypeInfo.Tag().FnPtr), H); AutoEq(get_variant_type(TypeInfo, TypeInfo.Tag().FnPtr));
    AutoHash(get_variant_type(TypeInfo, TypeInfo.Tag().Array), H); AutoEq(get_variant_type(TypeInfo, TypeInfo.Tag().Array));
    AutoHash(get_variant_type(TypeInfo, TypeInfo.Tag().Tagged), H); AutoEq(get_variant_type(TypeInfo, TypeInfo.Tag().Tagged));
    AutoHash(get_variant_type(TypeInfo, TypeInfo.Tag().Enum), H); AutoEq(get_variant_type(TypeInfo, TypeInfo.Tag().Enum));
    enum(CallConv); DerefEq(CallConv);
    enum(VarType); DerefEq(VarType);
    AutoHash(Ty(Symbol, Type), H); AutoEq(Ty(Symbol, Type));
    AutoHash(Ty(Type, Symbol), H); AutoEq(Ty(Type, Symbol));
    AutoHash(Ty(Symbol, Values), H); AutoEq(Ty(Symbol, Values));
    HashEach(RsVec(Field), H);
    HashEach(RsVec(Ty(Symbol, Type)), H);
    HashEach(RsVec(Ty(Symbol, Values)), H);
    
    
    //// :struct_layout_in_type_info important that some things aren't included by hash and eq!
    fn hash(hasher: *H, self: *Field) void = {
        hasher.hash(self.name&);
        hasher.hash(self.ty&);
        hasher.hash(self.default&);
        hasher.hash(self.kind&);
    }
    TypeInfoStruct :: get_variant_type(TypeInfo, TypeInfo.Tag().Struct);
    fn hash(hasher: *H, self: *TypeInfoStruct) void = {
        hasher.hash(self.fields&);
        hasher.hash(self.is_tuple&);
    }
    
    fn hash(h: *H, s: *CallConv) void #redirect(Ty(*H, *i64), void);
    fn hash(h: *H, s: *VarType) void #redirect(Ty(*H, *i64), void);
    
    fn hash(h: *H, s: *Var) void = {
        h.hash(s.id&);
    }
    
    fn hash(h: *H, s: *Values) void = {
        b := s.bytes();
        h.hash(b&);
    }
}


fn eq(a: *Values, b: *Values) bool = {
    a.bytes() == b.bytes()
}

:: {
    StupidAddHashable(TrivialHasher);
};

fn DerefEq($T: Type) void = {
    fn eq(a: *T, b: *T) bool #inline = a[] == b[];
}

:: WalkInts(fn($T) => DerefEq(T));
:: DerefEq(Type);
:: DerefEq(Symbol);
:: DerefEq(LabelId);
:: DerefEq(i64);
fn eq(a: LabelId, b: LabelId) bool #redirect(Ty(u32, u32), bool);

fn eq(a: *u8, b: *u8) bool = {
    a[] == b[]
}

fn WalkInts($do: @Fn(t: Type) void) void = {
    do(u32);
    do(u16);
    //do(u8); // TODO: this gets less stupid once i have more robust out of order compilation i hope! sad day for now
    do(i64);
    do(i32);
    do(i16);
    do(i8);
    do(bool);
}

::enum(VarType);