//! https://en.wikipedia.org/wiki/LEB128

LEB_MORE :: 128;
MAX_u8 :: 255;
fn leb128_unsigned(out: *List(u8), i: i64) void = {
    dowhile {
        byte := i.bit_and(MAX_u8);
        i = i.shift_right_logical(7);
        more := i != 0;
        if more {
            byte = byte.bit_or(LEB_MORE);
        }; 
        out.push(@as(u8) byte.trunc());
        more
    };
}

fn leb128_signed(out: *List(u8), i: i64) void = {
    done := false;
    while => !done {
        byte: u8 = i.trunc();
        i = i.shift_right_arithmetic(6);
        done = i.eq(0).or(i == -1);
        if done {
            byte = (@as(i64) byte.zext().bit_and(LEB_MORE.bit_not())).trunc();
        } else {
            i = i.shift_right_arithmetic(1);
            byte = (@as(i64) byte.zext().bit_or(LEB_MORE)).trunc();
        };
        out.push(byte);
    };
}

fn read_leb128_unsigned(bytes: []u8) Ty(u64, []u8, bool) = {
    result: u64 = 0;
    shift := 0;
    loop {
        if bytes.len == 0 {
            return(0, empty(), false);
        };
        
        b := bytes[0];
        low_bits: u64 = b.zext().bit_and(127);
        result = result.bit_or(low_bits.shift_left(shift));
        shift += 7;
        bytes = bytes.slice_pop_first();

        if b.zext().bit_and(LEB_MORE) == 0 {
            return(result, bytes, true);
        };
    }
}

// How many bytes will it take to encode x?
fn uleb_size(x: i64) i64 = {
    buf := @uninitialized Array(u8, 16);
    buf: List(u8) = (maybe_uninit = buf&.items(), len = 0, gpa = panicking_allocator);
    leb128_unsigned(buf&, x);
    buf.len
}
