// TODO: make a version of this that checks alignment
/// This function does nothing, it just lies to the typechecker. 
/// It's a bit clunky to type but maybe that's good for morale since its wildly unsafe!
/// SAFETY: the pointer must be aligned correctly for the new type and valid for use as the new size. 
ptr_cast_unchecked :: fn(const From: Type, const To: Type, ptr: *From) *To #generic #unsafe_noop_cast = unreachable("This is a no-op at runtime!");

raw_from_ptr :: fn(const From: Type, ptr: *From) rawptr #generic #unsafe_noop_cast = unreachable("This is a no-op at runtime!");
ptr_from_raw :: fn(const To: Type, ptr: rawptr) *To #generic #unsafe_noop_cast = unreachable("This is a no-op at runtime!");

int_from_ptr :: fn(const From: Type, ptr: *From) i64 #generic = From.raw_from_ptr(ptr).int_from_rawptr();
ptr_from_int :: fn(const To: Type, ptr: i64) *To #generic = To.ptr_from_raw(ptr.rawptr_from_int());

// TODO: most of the time what you want to do with these is replace the first argument with a rawptr or reverse that. 
//       should provide convience functions for that. 
erase_types_fn :: fn(const Arg: Type, const Ret: Type, ptr: FnPtr(Arg, Ret)) rawptr #generic #unsafe_noop_cast = unreachable("This is a no-op at runtime!");
assume_types_fn :: fn(const Arg: Type, const Ret: Type, ptr: rawptr) FnPtr(Arg, Ret) #generic #unsafe_noop_cast = unreachable("This is a no-op at runtime!");

// TODO: HACK: this only exists because you have to do this so often because generated ffi types don't know how to create a real slice type. 
//       previously you could use @as to do this but it seemed super fragile to have that just ignore field names,
//       when this is the probably the only common situation you'd do that on purpose.  
//       having @as essentually be a transmute is dumb.  -- Jun 1
// TODO: these are dumb names because it sounds like it would be `self: *(T, T)` <-> `(ptr = self, len = 2)`
//       but its temporary anyway. 
slice_from_tuple :: fn(const E: Type, tuple: Ty(i64, *E, i64)) Slice(E) #generic #inline = 
    (ptr = tuple._1, len = tuple._2);

tuple_from_slice :: fn(const E: Type, slice: Slice(E)) Ty(i64, *E, i64) #generic #inline = 
    (slice.len, slice.ptr, slice.len);

fn zeroed(const T: Type) T #generic = {
    t: T = ()!uninitialized;
    ptr := ptr_cast_unchecked(From = T, To = u8, ptr = t&);
    // TODO: have a fancier memset.
    each(slice(ptr, T.size_of())) { b |
        b[] = 0.trunc(); 
    };
    t
}


fn zext(v: u8)  i64 = (@as(u64) v.zext()).bitcast();


fn bitcast(v: u64) i64 #unsafe_noop_cast = unreachable("This is a no-op at runtime!");
fn bitcast(v: i64) u64 #unsafe_noop_cast = unreachable("This is a no-op at runtime!");

// TODO: intrinsic
fn bitcast(a: u32) f32 = ptr_cast_unchecked(u32, f32, a&)[];

cast_to_bytes :: fn(const T: Type, self: *T) Slice(u8) #generic = {
    ptr := ptr_cast_unchecked(T, u8, self);
    slice(ptr, :: T.size_of())
};
