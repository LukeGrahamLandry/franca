// TODO: fix scope resolution for generics 
// TODO: These are just cringe forward declarations to create the overload sets. 
fun list() Unit;
fun push() Unit;
fun items() Unit;
fun drop() Unit;
fun push_all() Unit;
fun clone() Unit;
fun pop_last() Unit;
fun reserve() Unit;
fun repeated() Unit;
fun clear() Unit;
fun as_ptr() Unit;

#comptime
fun List(const T: Type) Type = {
    const Self = @struct(maybe_uninit: Slice$T, len: i64);
    fun list(cap: i64) Self = { 
        let ptr: rawptr = alloc(T, cap);
        (maybe_uninit = (ptr = ptr, len = cap), len = 0)  // todo: no alloc if len 0 since i dont free
    }
    fun list() Self = list(0);
    
    fun repeated(t: T, count: i64) Self = {
        var self = list(count);
        range(0, count, fn(_: i64) Unit => self&.push(t));
        self
    }
    
    // Can't reuse the allocation because drop() will free it. TODO: COW
    fun clone(from: Slice$T) Self = {  // TODO: better error message if you put the = on the wrong side of the type
        var self = list(from.len());
        self&.push_all(from);
        self
    }
    
    fun items(self: *Self) Slice$T = {
        self.maybe_uninit.slice(0, self.len)
    }
    fun items(var self: Self) Slice$T = self&.items();
    
    // A pointer to the first element of the list. 
    // SAFETY: dont use the pointer if the list is empty. invalidated by resize. 
    fun as_ptr(self: *Self) *T = self.maybe_uninit.ptr;
    
    #inline
    fun index(self: *Self, i: i64) *T = {
        assert(i.lt(self.len), "OOB");
        self.maybe_uninit.index(i)
    }
    
    // TODO: hack because auto deref doesn't work through function calls
    // TODO: self shouldn't have to be var just to read fields
    fun index(var self: Self, i: i64) *T = {
        assert(i.lt(self.len), "OOB");
        self.maybe_uninit.index(i)
    }
    
    fun len(self: Self) i64 #inline = self.len;
    fun len(self: *Self) i64 #inline = self.len;

    ::DeriveIndexable(Self, T);
    ::DeriveIndexable(*Self, T);

    fun reserve(self: *Self, extra: i64) Unit = {
        let total = self.len.add(extra);
        let old_cap = self.maybe_uninit.len;
        if(lt(old_cap, total)) {|
            let cap = 4.max(old_cap.add(extra).max(old_cap.mul(2)));
            var new: Self = list(cap);
            if(self.len.gt(0)) {|  // TODO: it doesnt let you create a zero length slice in items()
                let dest: Slice$T = new.maybe_uninit.subslice(0, self.len);
                memcpy(dest, items(self));
                new.len = self.len;
            };
            drop(self);
            self[] = new;
        };
    }
    
    fun push(self: *Self, v: T) Unit = {
        reserve(self, 1);
        let last = self.maybe_uninit.index(self.len); 
        last[] = v;
        self.len = add(self.len, 1);
    }
    
    fun pop_last(self: *Self) T = {
        assert(gt(self.len, 0), "OOB");
        let i = sub(self.len, 1);
        self.len = i;
        self.maybe_uninit.get(i)
    }
    
    fun push_all(self: *Self, new: Slice$T) Unit = {
        reserve(self, len(new));
        let dest = subslice(self.maybe_uninit, self.len, len(new));
        memcpy(dest, new);
        self.len = add(self.len, len(new));
    }
    
    fun push_all(self: *Self, owned: *Self) Unit = {
        self.push_all(owned.items());
        owned.drop();
    }
    
    // TODO: this doesn't drop the entries. 
    fun drop(self: *Self) Unit = {
        if(self.maybe_uninit.len.ne(0)) {|
            let ptr: rawptr = self.maybe_uninit.ptr;
            // TODO: calling this makes fmt.fr fail when runtime target is aarch64,
            //       but it fails in the comptime interp still which is scary. 
            //       its a poison on taking args of a SplitFunc. 
            //       but its fine when collections.fr calls drop and that targets both too tho maybe doesnt cause a split because simpler comptime. 
            //       
            dealloc(T, ptr, self.maybe_uninit.len);
            self.maybe_uninit.len = 0;
            self.len = 0;
        };
    }
    
    /// Retains capacity
    fun clear(self: *Self) Unit = {
        self.len = 0;
    }
    
    Self
}

// TODO: can't do this because of circular dependency. 
//       in List it needs to call the other assert which means it needs the types of the whole overload set so it needs to compile List$i64
fun assert(cond: bool, const msg: Fn(Unit, List$u8)) Unit = {
    if(cond.not()){|
        var msg = msg();
        let msg: Str = msg&.items();
        panic(msg);
    }
}


// TODO: this is really inefficient if you already own 'a'
fun concat(a: Str, b: Str) List$u8 = {
    var c: List$u8 = list$ a.len().add(b.len());
    c&.push_all(a);
    c&.push_all(b);
    c
}

/// The returned strings are subslices of the original. 
fun split(haystack: Str, needle: Str) List(Str) = {
    assert(needle.len().gt(0), "OOB");
    var lines: List$Str = list$1;
    var i = 0;
    let last = sub(len(haystack), len(needle));
    var start = 0;
    // TODO: !! should be lt maybe?
    while(=> le(i, last)) {|
        if(eq(get(haystack, i), get(needle, 0)), fn() Unit => {
            let check = subslice(haystack, i, len(needle));
            if(eq(check, needle), fn() Unit => {
                let found = subslice(haystack, start, i.sub(start));
                push(lines&, found);
                i = add(i, len(needle));
                start = i;
            }) {| i = add(i, 1); };
        }) {| i = add(i, 1); };
    };
    let found = subslice(haystack, start, max(0, sub(len(haystack), start)));
    lines&.push(found);
    lines
}

// TODO: better error message if you call this on Ptr(Str)
fun splitlines(s: Str) List(Str) = {
    var lf: Str = (@as(u8) 10)!slice;  // TODO: string escapes
    split(s, lf)
}

fun str() Unit = { unit };  // TODO: scope.rs support recursion. 

// It's such a pain to google an ascii table every time.  
// This takes a constant argument to ensure the length check happens during compilation.
// So this function can take the place of a char literal in other languages without new syntax. 
// TODO: utf8
fun char(const s: Str) i64 = {
    :: {
        // TODO: can't get field of const cause cant take pointer. 
        // TODO: @assert that takes a format string so its less painful to print the arg as well. 
        assert(s.len().eq(1), "char str expected length 1"); 
        @as(i64) @as(u8) s.get(0)
    }
}


fun ascii(const s: Str) u8 = {
    :: {
        c := s.char();
        // TODO: auto bounds checks on @as?
        assert(c.lt(128), "expected ascii"); // TODO: make an @assert fmt version. 
        @as(u8) c
    }
}

// TODO: this needs to return List$u8 since it allocates. 
//       really you want to have a nice Writer abstraction so you can seperate the formating and the allocation. 
//        I need List$u8.deref() -> Str because currently its really annoying to use functions that return owned strings, 
//       since many string functions just need to borrow thier arguments so you can't chain things nicely. 
fun str(i: i64) Str = {
    var s: List(u8) = list(1);
    if(i.lt(0)) {|
        push(s&, "-".ascii());
        push_all(s&, i.neg().str());
    } {|
    
        if(and(ge(i, 0), lt(i, 10)), 
            => push(s&, add(48, i)),
            => {
                push_all(s&, str(div(i, 10))); // TODO: push to list
                push(s&, add(48, mod(i, 10)));
            }
        );
    };
    
    items(s&)
}

// TODO
fun push(self: *List(u8), v: i64) Unit = self.push(@as(u8) v);

// See `println(Str)` or `e!reflect_print` for something more useful. TODO: make this generic.
fn print(i: i64) Unit = {
    var s = str(i);
    print(s);
}
