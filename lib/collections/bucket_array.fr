//! A growable collection similar to a List, however, 
//! it stores entries in seperate chunks, instead of doing a copying resize when it runs out of memory. 
//! So you lose the ability to elements as one contiguous slice but in return get stable addresses, 
//! so you can safely hold internal pointers (until you call drop or clear). 

/// This implementation does not guarentee that all buckets are full, so you can't index the collection. 
/// But when you push_all a whole slice at once, it is guarenteeed to be stored contiguously 
/// (allocating a new bucket if out of space, which may be bigger than bucket_size), so you get back a slice to it.
/// TODO: will probably want a version that makes the opposite trade off eventually. 
fn BucketArray(const T: Type) Type = {
    // TODO: buckets should probably be stored in a linked list but I can't do self referential types yet :( -- May 28
    Self :: @struct(buckets: List(List(T)), len: i64, b: i64, bucket_size: i64, gpa: Alloc, i: i64);
    // TODO: should have an unmanaged version of a list so that you store the allocator once in the BucketArray and pass it in to each call. 
    // TODO: have push_within_capacity for when you want to assert that it doesn't reallocate. 
    
    fn init(bucket_size: i64, gpa: Alloc) Self = { 
        self: Self = (buckets = list(4, gpa), len = 0, b = 0, bucket_size = bucket_size, gpa = gpa, i = 0);
        self.buckets&.push(@as(List(T)) list(bucket_size, self.gpa));
        self
    }
    
    ::?*List(T);
    
    /// Ensures there is enough space for <extra> contiguous elements. 
    fn reserve(self: *Self, extra: i64) void = {
        bucket: *List(T) = self.current();
        
        total := bucket.len.add(extra);
        old_cap := bucket.maybe_uninit.len;
        if(lt(old_cap, total)) {|
            self.i += 1;
            if(self.i.eq(self.buckets.len)) {|
                cap := extra.max(self.bucket_size);
                self.buckets&.push(@as(List(T)) list(cap, self.gpa));
            };
        };
    }
    
    /// The returned pointer is stable (it can be held until drop is called on the collection).
    fn push(self: *Self, v: T) *T = {
        ::?*T;
        reserve(self, 1);
        self.len += 1;
        bucket := self.current();
        bucket.push(v);
        bucket.last().unwrap()
    }
    
    /// The returned slice is stable (it can be held until drop is called on the collection).
    fn push_all(self: *Self, new: Slice(T)) Slice(T) = {
        reserve(self, new.len);
        self.len += new.len;
        bucket := self.current();
        bucket.push_all(new);
        ::?Slice(T);
        bucket.items().slice_last(new.len).unwrap()
    }
    
    // This can be used to write directly into it after calling fn reserve(). 
    fn current(self: *Self) *List(T) = 
        self.buckets.index(self.i);
    
    // TODO: have a version that recursively drops? 
    // TODO: rename clear_retaining_capacity? or is that too annoying to type. 
    fn clear(self: *Self) void = {
        each(self.buckets, fn(b) => b.clear());
        self.i = 0;
    }
   // TODO: fn drop 

    
    fn for(self: *Self, const f: @Fn(s: Slice(T)) void) void = {
        range(0, self.i.add(1)) {i|
            bucket := self.buckets[i]&;
            f(bucket.items());
        };
    }
    
    Self
}

fn current();