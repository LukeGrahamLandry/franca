// TODO: make these come from some fancy ffi meta program thing -- Apr 25
const AstExpr = FatExpr;
const UnknownType = UnknownType!builtin;
const FatExpr = FatExpr!builtin; 
const FuncId = FuncId!builtin;
const FatStmt = FatStmt!builtin;
const TypeInfo = TypeInfo!builtin;
const Field = Field!builtin;
const IntTypeInfo = IntTypeInfo!builtin;
const Stmt = Stmt!builtin;
const Expr = Expr!builtin;
Binding :: Binding!builtin;
LazyType :: LazyType!builtin;


// TODO: Calling the same macro multiple times was totally fucked because you alias the constants!
//       I need copy vs clone. but this is my temporary fix. you need to call this every time you use !quote. 
//       clone_ast


// TODO: 'fn intern_wide_str(s: Str) Symbol' would be nice since on asm strings will be painful to communicate with compiler 

// This checks if types are identical. 
// You might want to use can_assign_types instead since that has more knowledge about assignable but not identical types.
fun eq(a: Type, b: Type) bool = {
    // Types are represented as a number (not nessisarily directly an index)... you almost never want to see them that way so didn't bother making this public. 
    #aarch64 #c_call fn typeid_to_int(type: Type) i64 = (ret(), ret())!asm; // ret, ret // TODO: single instruction asm tuple. 
    #llvm #c_call fn typeid_to_int(ty: Type) i64 = "ret i64 %ty"!asm; // TODO: at least give the correct error if you try to do it on a single string. rn it just blindly chooses the other overload even though that shouldn't be allowed on this arch. scary!  -- Apr 20

    a.typeid_to_int().eq(b.typeid_to_int())
}

// TODO: really you want the compiler ffi things to be defined here so they're easy to see and hang comments off. 
//       but for now its convient to have thier signetures in the same place as i assign thier comptime_addr.  -- Apr 20

// TODO: Make a 'fn const_eval(const T, value: FatExpr) T;' once i have partial const in @generic -- Apr 27

#generic #comptime
fun const_eval(const T: Type) Fn(FatExpr, T) = (fn(value: FatExpr) T = {
    var out: T = ()!uninitialized;
    const_eval(value, T, @as(rawptr) out&); // crashes on type error
    out
});

// TODO: make sure its an error to shadow a const with a function. -- Apr 27
const const_eval_string = const_eval(Str);
const const_eval_type = const_eval(Type);
