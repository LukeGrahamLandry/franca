fn rs(); 
fn assume_owned();
fn to_index();

UnknownType :: @builtin UnknownType;
// TODO: HACK: -- May 27
//      The compiler can't expose this directly because the argument is an enum which is hard to cope with for my current c_call,
//      but the return type isn't a multiple of 8 bytes (now that TypeId is small) so it doesn't know how to load it into a register 
//      so it can't be a flat_call either. this can go away when i follow proper c abi. 
//      there are some contexts it wont let you call this from. see body of fn Array(Type, i64) for an example. 
fn intern_type(ty: TypeInfo) Type = intern_type_ref(ty&);

// TODO: really you want the compiler ffi things to be defined here so they're easy to see and hang comments off. 
//       but for now its convient to have thier signetures in the same place as i assign thier comptime_addr.  -- Apr 20

// TODO: Make a 'fn const_eval($T, value: FatExpr) T;' once i have partial const in @generic -- Apr 27

fn const_eval($T: Type) (@Fn(value: FatExpr) T) #generic = (fn(value: FatExpr) T = {
    out := T.uninitialized();
    const_eval(value, T, T.raw_from_ptr(out&)); // crashes on type error
    out
});

// TODO: make sure its an error to shadow a const with a function. -- Apr 27
const_eval_string :: const_eval(Str);
const_eval_type :: const_eval(Type);

fn ne(a: Type, b: Type) bool #redirect(Ty(u32, u32), bool);

// This checks if types are identical. 
// You might want to use can_assign_types instead since that has more knowledge about assignable but not identical types.
fn eq(a: Type, b: Type) bool #redirect(Ty(u32, u32), bool);

#fold fn int(s: Symbol) i64 = {
    i := ptr_cast_unchecked(From = Symbol, To = u32, ptr = s&)[];
    i.zext()
}

fn get_flag(self: *Func, flag: FnFlag) bool = {
    mask := 1.shift_left(@as(i64) flag);
    (@as(i64) self.flags.zext()).bit_and(mask) != 0
}

fn set_flag(self: *Func, flag: FnFlag) void = {
    mask := 1.shift_left(@as(i64) flag);
    new := (@as(i64) self.flags.zext()).bit_or(mask);
    self.flags = new.trunc();
}

fn unset_flag(self: *Func, flag: FnFlag) void = {
    mask := 1.shift_left(@as(i64) flag);
    new := (@as(i64) self.flags.zext()).bit_and(mask.bit_not());
    self.flags = new.trunc();
}

fn has_tag(self: *Func, flag: Flag) bool = {
    each self.annotations { a |
        if(a.name == flag.ident(), => return(true));
    };
    false
}

fn ident(self: *Binding) ?Symbol = {
    @match(self.name) {
        fn Var(v) => (Some = v.name);
        fn Ident(v) => (Some = v);
        @default => .None;
    }
}

fn ne(a: FuncId, b: FuncId) bool #redirect(Ty(u32, u32), bool);

fn from_index();
fn as_index();

fn TypedIndex($T: Type) void = {
    fn as_index(f: T) i64 = f.to_index().zext();
    
    fn to_index(f: T) u32 #unsafe_noop_cast;
    
    fn from_index(idx: i64) T = {
        val: u32 = idx.trunc();
        ptr_cast_unchecked(From = u32, To = T, ptr = val&)[]
    }
}

:: TypedIndex(FuncId);
:: TypedIndex(OverloadSet);
:: TypedIndex(LabelId);
:: TypedIndex(Type);

fn decode_sig(self: *FnBody, i: u32) *PrimSig = { // Note: not stable if you push again!!
    self.sig_payloads&.index(i.zext())
} 

// This includes the indirect ret pointer!!
fn arg_slots(self: *PrimSig) i64 = {
    if(self.first_arg_is_indirect_return, => self.args.len + 1, => self.args.len)
}

fn decode_switch(cases: *RsVec(SwitchPayload)) Ty([]SwitchPayload, ?BbId) = {
    has_default := cases.last().unwrap()[].value == -1;
    ::if(Ty([]SwitchPayload, ?BbId));
    if(has_default) {
        (cases.items().slice(0, cases.len - 1), (Some = cases.last().unwrap()[].block))
    } else {
        (cases.items(), .None)
    }
}

fn get_info(c: CompCtx, type: Type) *TypeMeta = {
    {c.vtable.get_type_meta}(c.data, type)
}

fn get_type(c: CompCtx, type: Type) *TypeInfo = {
    {c.vtable.get_type_info}(c.data, type)
}

fn get_baked(c: CompCtx, id: BakedVarId) *Ty(rawptr, BakedVar) = {
    {c.vtable.get_baked}(c.data, id)
}

fn get_build_options(c: CompCtx) *BuildOptions = {
    {c.vtable.get_build_options}(c.data)
}

fn follow_redirects(program: CompCtx, f_id: FuncId) FuncId = {
    dowhile() {
        @match(program.get_function(f_id)[].body&) {
            fn Redirect(target) => {
                f_id = target[];
                true
            }
            @default => false;
        }
    };
    f_id
}

FrancaCodeLine :: @struct(filename: Str, line: i64, col: i64, line_text: Span);

// TODO: prepending all this shit to every program is getting a bit dumb. 

fn display(self: *FuncId, out: *List(u8)) void = {
    @fmt(out, "F%", self[].as_index());
}
fn display(self: FuncId, out: *List(u8)) void = {
    @fmt(out, "F%", self.as_index());
}


fn finished_ty(self: *Func) ?FnType = {
    if self.finished_arg { arg |
        if self.finished_ret { ret |
            return(Some = (arg = arg, ret = ret, arity = @as(u16) self.arg.bindings.len().max(1).trunc()));
        };
    };
    .None
}
