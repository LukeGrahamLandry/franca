fn rs(); 
fn assume_owned();
fn to_index();
fn funcid_from_index();

// TODO: make these come from some fancy ffi meta program thing -- Apr 25
AstExpr :: FatExpr;
UnknownType :: @builtin UnknownType;
// TODO: HACK: -- May 27
//      The compiler can't expose this directly because the argument is an enum which is hard to cope with for my current c_call,
//      but the return type isn't a multiple of 8 bytes (now that TypeId is small) so it doesn't know how to load it into a register 
//      so it can't be a flat_call either. this can go away when i follow proper c abi. 
//      there are some contexts it wont let you call this from. see body of fn Array(Type, i64) for an example. 
fn intern_type(ty: TypeInfo) Type = intern_type_ref(ty&);

// TODO: Calling the same macro multiple times was totally fucked because you alias the constants!
//       I need copy vs clone. but this is my temporary fix. you need to call this every time you use !quote. 
//       clone_ast

// This checks if types are identical. 
// You might want to use can_assign_types instead since that has more knowledge about assignable but not identical types.
fn eq(a: Type, b: Type) bool = {
    // Types are represented as a number (not nessisarily directly an index)... you almost never want to see them that way so didn't bother making this public. 
    #aarch64 #c_call fn typeid_to_int(type: Type) i64 = (ret(), ret())!asm; // ret, ret // TODO: single instruction asm tuple. 
    #llvm #c_call fn typeid_to_int(ty: Type) i64 = "%out = zext i32 %ty to i64\nret i64 %out"!asm; 
    #c fn typeid_to_int(ty: Type) i64 = "return ty;"!asm; 
    
    a.typeid_to_int().eq(b.typeid_to_int())
}

// TODO: really you want the compiler ffi things to be defined here so they're easy to see and hang comments off. 
//       but for now its convient to have thier signetures in the same place as i assign thier comptime_addr.  -- Apr 20

// TODO: Make a 'fn const_eval(const T, value: FatExpr) T;' once i have partial const in @generic -- Apr 27

fn const_eval(const T: Type) (@Fn(value: FatExpr) T) #generic = (fn(value: FatExpr) T = {
    out: T = ()!uninitialized;
    const_eval(value, T, T.raw_from_ptr(out&)); // crashes on type error
    out
});

// TODO: make sure its an error to shadow a const with a function. -- Apr 27
const_eval_string :: const_eval(Str);
const_eval_type :: const_eval(Type);

// TODO: footgun: they might not be in order by oridinal or the values might not even be ints. 
// TODO: make it clear that the slice should be in a constant somehow. 
fn get_enum_names(E: Type) Slice(Str) = {
    info := get_type_info(E);
    assert(eq(info&!tag[], tag_value(TypeInfo, @symbol Enum)), "expected enum type");
    names: List(Str) = list(ast_alloc());
    
    for (info.Enum.fields.items()) { i|
        names&.push(i._0.str());
    };
    names.items()
}

fn to_index(f: FuncId) u32 = {
    i := ptr_cast_unchecked(From = FuncId, To = u32, ptr = f&)[];
    magic_offset :: 30;  // must match ast.rs
    mask: u32 : 1.shift_left(magic_offset).bit_not().trunc();
    i.bit_and(mask)
}

fn funcid_from_index(f: u32) FuncId = {
    magic_offset :: 30;  // must match ast.rs
    mask: u32 : 1.shift_left(magic_offset).trunc();
    f := f.bit_or(mask)
    ptr_cast_unchecked(From = u32, To = FuncId, ptr = f&)[]
}

    
#fold fn int(s: Symbol) i64 = {
    i := ptr_cast_unchecked(From = Symbol, To = u32, ptr = s&)[];
    i.zext()
}


#redirect(Ty(i64, i64), bool) fn eq(a: Prim, b: Prim) bool;
