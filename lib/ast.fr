const FatExpr: Type = @builtin("FatExpr"); 
@pub const AstExpr = FatExpr;

@interp @pub fn infer_raw_deref_type(expr: FatExpr) TypeInfo;
@interp @pub fn promote_closure(expr: FatExpr) FuncId;

// TODO: Calling the same macro multiple times was totally fucked because you alias the constants!
//       I need copy vs clone. but this is my temporary fix. you need to call this every time you use !quote. 
//       clone_ast

/// Convert a pointer to a value into an ast that will produce that value when evaluated. 
/// It is illegal to pass a <ty> that does not match the value behind <ptr>. 
@interp fn literal_ast(ty: Type, ptr: VoidPtr) FatExpr;

@interp @pub fn get_type_int(e: AstExpr) IntTypeInfo;

// TODO: const ast = @module { @pub fn new_call(); ... }; for namespacing? 
// Note: These are less important now that !unquote exists but maybe its nicer for simple things to just be function calls. 
@pub fn new_call_ast(f: AstExpr, arg: AstExpr) AstExpr = f!unquote(arg!unquote)!quote;
@pub fn new_pair_ast(a: AstExpr, b: AstExpr) AstExpr = (a!unquote, b!unquote)!quote;

// You probably don't want to call this directly.  
@interp @pub fn unquote_macro_apply_placeholders(exprs: Slice(FatExpr)) FatExpr;  

/// Calls Compiler::compile_expr 
/// Infers the type and avoids some redundant work if you duplicate the ast node in a bunch of places after calling this. 
@interp @pub fn compile_ast(expr: AstExpr) AstExpr;

// TODO: generics
@interp @pub fn const_eval_string(value: AstExpr) Str;
@interp @pub fn const_eval_type(value: AstExpr) Type;

