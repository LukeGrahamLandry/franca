const FatExpr: Type = @builtin("FatExpr"); 
@pub const AstExpr = FatExpr;

// TODO: Calling the same macro multiple times was totally fucked because you alias the constants!
//       I need copy vs clone. but this is my temporary fix. you need to call this every time you use !quote. 
//       clone_ast

// TODO: const ast = @module { @pub fn new_call(); ... }; for namespacing? 
// Note: These are less important now that !unquote exists but maybe its nicer for simple things to just be function calls. 
@pub fn new_call_ast(f: AstExpr, arg: AstExpr) AstExpr = f!unquote(arg!unquote)!quote;
@pub fn new_pair_ast(a: AstExpr, b: AstExpr) AstExpr = (a!unquote, b!unquote)!quote;

// TODO: 'fn intern_wide_str(s: Str) Symbol' would be nice since on asm strings will be painful to communicate with compiler 

// This checks if types are identical. 
// You might want to use can_assign_types instead since that has more knowledge about assignable but not identical types.
@pub fn eq(a: Type, b: Type) bool = {
    // Types are represented as a number (not nessisarily directly an index)... you almost never want to see them that way so didn't bother making this public. 
    @aarch64 @c_call fn typeid_to_int(type: Type) i64 = (0xd65f03c0, 0xd65f03c0)!asm; // ret, ret // TODO: single instruction asm tuple. 
    @llvm fn typeid_to_int(ty: Type) i64 = ("", "ret i64 %ty")!asm; // TODO: at least give the correct error if you try to do it on a single string. rn it just blindly chooses the other overload even though that shouldn't be allowed on this arch. scary!  -- Apr 20

    a.typeid_to_int().eq(b.typeid_to_int())
}

// TODO: really you want the compiler ffi things to be defined here so they're easy to see and hang comments off. 
//       but for now its convient to have thier signetures in the same place as i assign thier comptime_addr.  -- Apr 20
