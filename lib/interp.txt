const Type;  // but what kind...?
const Any: Type;  // Any value that fits in a single stack slot. 
const Unit: Type = ();  // The set of all empty tuples.
const unit: Unit = ();  // The officially blessed empty tuple.
const bool: Type;
const true: bool;
const false: bool;
const i64: Type;
const f64: Type;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files. 
// There's nothing special about it unless you're interacting with the asts in macros.
const Symbol: Type;

@comptime fn IntType(bits: i64, signed: bool) Type = i64; // TODO

const u8 = IntType(8, false);
const u16 = IntType(16, false);
const u32 = IntType(32, false);
const u64 = IntType(64, false);
const i8 = IntType(8, true);
const i16 = IntType(16, true);
const i32 = IntType(32, true);
const f32 = f64; // TODO

// Debugging
fn print(_: Any) Unit;
fn assert_eq(_: Any, __: Any) bool;  // TODO: shadowing args breaks my debug check for not losing things

// Math
fn add(_: i64, __: i64) i64;
fn sub(_: i64, __: i64) i64;
fn mul(_: i64, __: i64) i64;
fn div(_: i64, __: i64) i64;
fn eq(_: i64, __: i64) bool;
fn ne(_: i64, __: i64) bool;
fn lt(_: i64, __: i64) bool;
fn gt(_: i64, __: i64) bool;
fn le(_: i64, __: i64) bool;
fn ge(_: i64, __: i64) bool;

// Simple types
@comptime fn Ptr(Inner: Type) Type;  // A reference to one `Inner`
@comptime fn Slice(Inner: Type) Type;    // A reference to an unknown number of `Inner`s
/// Create a new type with the same representation in memory as `T` but distinct for type checking / overload resolution. 
@comptime fn Unique(T: Type) Type;

/// The type of 'fn(Arg) Ret'. This is a comptime only value. 
/// All calls are inlined, as are calls that pass one of these as an argument. 
/// Captures of runtime variables are allowed since you just inline everything anyway. 
/// Const captures behave as you'd expect from first class closures. 
@comptime fn Fn(Arg: Type, Ret: Type) Type;

// TODO: include calling convention. 
// TODO
/// Like Fn(Arg, Ret) but as a runtime value. Same as a function pointer in c but with less insane syntax :). 
/// Use '!addr' on a normal Fn value to get create a value of this type. 
/// - The function cannot have any runtime variable captures,
///   but they could be implemented on top of this by taking an environment data pointer as an argument. 
/// - The function cannot have any const arguments, they must be baked before creating the pointer. 
// @comptime fn FnPtr(Arg: Type, Ret: Type) Type;

// TODO
// A value-type like a tuple but all elements are the same type. 
// @comptime fn StaticArray(inner: Type, count: i64) Type;
// TODO: need to support using comptime args in other args. 
// @comptime fn static_array(Inner: Type, count: i64, element: Inner) StaticArray(Inner);
// @comptime fn static_array_uninit(Inner: Type, count: i64) StaticArray(Inner);
// @comptime fn Comptime(T: Type) Type;
// @comptime fn Runtime(T: Type) Type;
// const NullTerminated = Ptr(u8);
const Str = Ptr(u8);
fn puts(s: Str) Unit;

// TODO: need to track container types better. 
// fn Tag(E: Type) Type = i64;  // Currently enum tags are untyped but that will likely change. 

/// Get the discriment used at runtime. 
@comptime fn tag_value(E: Type, case_name: Symbol) i64;

// Control flow
// fn if(cond: bool, false_branch: Fn(Any, Any), true_branch: Fn(Any, Any)) Any = {
//     (cond, false_branch, true_branch)!if  // TODO: make closure arguments work. 
// }

fn not(b: bool) bool = (b, fn() bool = false, fn() bool = true)!if;

// Note: these are not short circuiting because arguments are always evaluated. TODO: varients that accept closures/ 
fn and(a: bool, b: bool) bool = (a, fn() bool = b, fn() bool = false)!if;
fn or(a: bool, b: bool) bool = (a, fn() bool = true, fn() bool = b)!if;

// TODO: stop using Any once I trust generics. 
// Working with pointers
fn get(ptr: Ptr(Any)) Any;
fn set(ptr: Ptr(Any), value: Any) Unit;
fn len(ptr: Ptr(Any)) i64;
fn slice(ptr: Ptr(Any), first: i64, one_past_last: i64) Ptr(Any);
/// The result may have more room than you asked for (which is useful for growable collections in allocators that use fixed size blocks). 
fn alloc(Element: Type, count: i64) Ptr(Any); 
/// `ptr` must be exactly a slice returned by `alloc` (not a subslice of it).
fn dealloc(Element: Type, ptr: Ptr(Any)) Unit;

// Inspecting the interpreter
fn is_comptime() bool;
fn is_uninit(_: Ptr(Any)) bool;
fn is_oob_stack(_: Ptr(Any)) bool;
@inline fn print_callstack() Unit;
fn comptime_cache_get(f: Fn(Any, Any), arg: Any) (bool, Any);
fn comptime_cache_insert(f: Fn(Any, Any), arg: Any, ret: Any) Unit;

// Halts the program and reports an error. 
// The return value can typecheck as anything because it never returns. 
fn panic(msg: Str) Any;

fn get_i(tuple: Ptr(Any), i: Any) Any = {
    get(slice(tuple, i, add(i, 1)))
}

fn mod(big: i64, divisor: i64) i64 = {
    sub(big, mul(div(big, divisor), divisor))
}

fn max(a: i64, b: i64) i64 = {
    (lt(a, b), fn()=b, fn()=a)!if
}

fn min(a: i64, b: i64) i64 = {
    (gt(a, b), fn()=b, fn()=a)!if
}

fn assert(cond: bool, msg: Str) Unit = (cond, fn()=(), fn()=panic(msg))!if;
