// TODO: rename this file. split into Slice and List? 

// TODO: fix scope resolution for generics 
@pub fn list() Unit = {unit};
@pub fn push() Unit = {unit};
@pub fn items() Unit = {unit};
@pub fn drop() Unit = {unit};
@pub fn subslice() Unit = {unit};
@pub fn push_all() Unit = {unit};
@pub fn list_clone() Unit = {unit};
@pub fn for() Unit = {unit};
@pub fn enumerate() Unit = {unit};
@pub fn index() Unit = {unit};
@pub fn slice() Unit = {unit};
@pub fn len() Unit = {unit};
@pub fn find() Unit = {unit};
@pub fn pop_last() Unit = {unit};
@pub fn memcpy() Unit = {unit};
@pub fn get() Unit = {unit};
@pub fn set() Unit = {unit};
@pub fn reserve() Unit = {unit};
@pub fn rest() Unit = {unit};
@pub fn repeated() Unit = {unit};
@pub fn clear() Unit = {unit};
@pub fn fill() Unit = {unit};
@pub fn assume() Unit = {unit};


@pub
fn range(start: i64, end: i64, const yield: Fn(i64, Unit)) Unit = {
    var i = start;
    while(fn = i.lt(end)) {|
        yield(i);
        i = i.add(1);
    };
}

// TODO: return slice so the result may have more room than you asked for (which is useful for growable collections in allocators that use fixed size blocks). 
@interp fn alloc_inner(Element: Type, count: i64) VoidPtr; 
/// `ptr` must be exactly a slice returned by `alloc` (not a subslice of it).
@interp fn dealloc_inner(Element: Type, ptr: VoidPtr, len: i64) Unit;

@interp @pub fn alloc(const Element: Type, count: i64) VoidPtr = alloc_inner(Element, count); 
@interp @pub fn dealloc(const Element: Type, ptr: VoidPtr, len: i64) Unit = dealloc_inner(Element, ptr, len); 

// TODO: PROBLEM: now that im not just taking the first overload, this not using comptiem cache because its not @comptime so multiple versions of inner functions can get made 
//       I still want to replace @comptiem with just having const args but need to make @impl use the cache. 
//       also if you say its @comptime, then you cant have const arg or you get random "overwrite arg" assertions

@impl @pub @comptime
fn Slice(T: Type) Type = {
    const Self: Type = (ptr: *T, len: i64)!struct;
    const T = T;  // TODO
    
    @pub fn slice(ptr: *T) Self = (ptr: ptr, len: 1);
    // TODO: @pub fn empty() Self = (ptr: zeroed(), len: 0);
    @pub fn slice(ptr: *T, count: i64) Self = (ptr: ptr, len: count);
    @pub fn len(self: Self) i64 = self&.len[];
    @pub fn assume(ptr: *T, len: i64) Self = (ptr: ptr, len: len);
    
    @pub fn get(self: Self, i: i64) T = {
        let v: *T = self.index(i);  // TODO: fix so dont need useless binding 
        v[]
    }
    
    @pub fn index(self: Self, i: i64) *T = {
        var s = self.subslice(i, 1);
        s&.ptr[]
    }
    
    @pub fn set(self: Self, i: i64, v: T) Unit = {
        // TODO: allowing this is a bit creepy if I don't specify order of evaluation. 
        //       and having it be placement is scary if you aliased the lhs ptr on the rhs. 
        self.index(i)[] = v;
    }
    
    @pub fn slice(self: Self, first: i64, past_last: i64) Self = {
        // TODO: first should be lt
        // TODO: its sad that im doing double bounds check in common case where its just index()
        assert(first.le(self.len()).and(past_last.le(self.len())), "OOB"); 
        const slots = size_of(T);
        let raw_first = first.mul(slots);
        let raw_past_last = past_last.mul(slots);
        let ptr: VoidPtr = self&.ptr[];
        let new_ptr: VoidPtr = ptr.raw_slice(raw_first, raw_past_last);
        (ptr: new_ptr, len: past_last.sub(first))
    }
    
    @pub fn subslice(self: Self, first: i64, count: i64) Self = {
        self.slice(first, first.add(count))
    }
    
    @pub fn rest(self: Self, first: i64) Self = {
        self.slice(first, self.len())
    }
    
    // TODO: the other fn type syntax so you can name the arguments in the closure as documentation. 
    // TODO: be more consistant about how tuples are expanded into args to fix Fn((a, b), c) === Fn(a, b, c) when you want Fn(Ty(a, b), c)
    //       seems like a massive mistake that I create ambiguity and then just guess something stupid and hope for the best. 
    @pub fn enumerate(arr: Self, const f: Fn(Ty(i64, *T), Unit)) Unit = {
        var i = 0;
        while(fn = lt(i, arr.len())) {|
            let e: *T = arr.index(i);
            f(i, e);
            i = i.add(1);
        };
    }
    
    // TODO: I don't love that I have to write the deref version seperatly
    //       but I dont have let destructuring (only function args) so its a pain to take tuples by pointer. 
    //       I should be able to destructure Ptr(A, B) to (Ptr(A), Ptr(B))
    @pub fn for(arr: Self, const f: Fn(T, Unit)) Unit = {
        for(arr, fn(v: *T) Unit = f(v[]))
    }
    
    @pub fn for(arr: Self, const f: Fn(*T, Unit)) Unit = {
        var i = 0;
        let l = arr.len();
        while(fn() bool = lt(i, l)) {|
            f(arr.index(i));
            i = i.add(1);
        };
    }
    
    @pub fn memcpy(dest: Self, src: Self) Unit = {
        assert(eq(len(dest), len(src)), "OOB");  // Note: not using `asser t_eq` because the vm tracks those for my tests
        // TODO: sad that this does the bounds check every iteration but a real optimiser would fix it for me anyway so meh. 
        const f = fn(i: i64, e: *T) Unit = dest.set(i, e[]);
        src.enumerate(f);
    }
    
    // TODO: add addr_eq/identical if that's really what you want but like... it never is I feel. 
    @pub fn eq(lhs: Self, rhs: Self) bool = {
        (eq(lhs.len(), rhs.len()), fn() bool = {
            var i = 0;
            while(fn=i.lt(len(lhs)).and(fn = lhs.get(i).eq(rhs.get(i)))) {| 
                i = i.add(1); 
            };
            eq(i, lhs.len())
        }, fn() bool = false)!if
    }
    
    /// Set all elements of the slice to 't'. 
    @pub fn fill(self: *Self, t: T) Unit = {
        for(self) { (ptr: *T) |
            ptr[] = t;
        };
    }
    
    Self
}

/*
@pub @comptime @generic
fn slice_cast(Dest: Type, Src: Type) Fn(Slice$Src, Slice$Dest) = {
    
    (fn(self: Slice$Src) Slice$Dest = {
        // TODO: adjust len & assert mod==0
    })
}
*/

@impl @pub @comptime
fn List(T: Type) Type = {
    const T = T;
    const Self: Type = (maybe_uninit: Slice$T, len: i64)!struct;
    @pub fn list(cap: i64) Self = { 
        let ptr: VoidPtr = alloc(T, cap);
        (maybe_uninit: (ptr: ptr, len: cap), len: 0)  // todo: no alloc if len 0 since i dont free
    }
    @pub fn list() Self = list(0);
    
    @pub fn repeated(t: T, count: i64) Self = {
        var self: Self = list(count);
        range(0, count, fn(_: i64) Unit = self&.push(t));
        self
    }
    
    // Can't reuse the allocation because drop() will free it. TODO: COW
    @pub fn list_clone(from: Slice$T) Self = {  // TODO: better error message if you put the = on the wrong side of the type
        var self: Self = list(from.len());
        self&.push_all(from);
        self
    }
    
    @pub fn items(self: *Self) Slice$T = {
        self.maybe_uninit[].slice(0, self.len[])
    }
    
    @pub fn index(self: *Self, i: i64) *T = {
        assert(i.lt(self.len[]), "OOB");
        self.maybe_uninit[].index(i)
    }
    
    @pub fn get(self: *Self, i: i64) T = {
        let v: *T = self.index(i);
        v[]
    }
    
    @pub fn get(self: Self, i: i64) T = {
        let ptr: *T = self&.index(i);
        ptr[]
    }
    
    @pub fn reserve(self: *Self, extra: i64) Unit = {
        let total = self.len[].add(extra);
        let old_cap = self.maybe_uninit.len[];
        if(lt(old_cap, total)) {|
            let cap = 4.max(old_cap.add(extra).max(old_cap.mul(2)));
            var new: Self = list(cap);
            if(self.len[].gt(0)) {|  // TODO: it doesnt let you create a zero length slice in items()
                let dest: Slice$T = new&.maybe_uninit[].subslice(0, self.len[]);
                memcpy(dest, items(self));
                new&.len[] = self.len[];
            };
            drop(self);
            self[] = new;
        };
    }
    
    @pub fn push(self: *Self, v: T) Unit = {
        reserve(self, 1);
        let last = self.maybe_uninit[].index(self.len[]); 
        last[] = v;
        self.len[] = add(self.len[], 1);
    }
    
    @pub fn pop_last(self: *Self) T = {
        assert(gt(self.len[], 0), "OOB");
        let i = sub(self.len[], 1);
        self.len[] = i;
        self.maybe_uninit[].get(i)
    }
    
    @pub fn push_all(self: *Self, new: Slice$T) Unit = {
        reserve(self, len(new));
        let dest = subslice(self.maybe_uninit[], self.len[], len(new));
        memcpy(dest, new);
        self.len[] = add(self.len[], len(new));
    }
    
    @pub fn push_all(self: *Self, owned: *Self) Unit = {
        self.push_all(owned.items());
        owned.drop();
    }
    
    @pub fn drop(self: *Self) Unit = {
        if(self.maybe_uninit.len[].ne(0)) {|
            let ptr: VoidPtr = self.maybe_uninit.ptr[];
            // TODO: calling this makes fmt.fr fail when runtime target is aarch64,
            //       but it fails in the comptime interp still which is scary. 
            //       its a poison on taking args of a SplitFunc. 
            //       but its fine when collections.fr calls drop and that targets both too tho maybe doesnt cause a split because simpler comptime. 
            //       
            dealloc(T, ptr, self.maybe_uninit.len[]);
            self.maybe_uninit.len[] = 0;
            self.len[] = 0;
        };
    }
    
    /// Retains capacity
    @pub fn clear(self: *Self) Unit = {
        self.len[] = 0;
    }
    
    Self
}

@pub const Str = Slice(i64);
@pub fn dump_ffi_types() Str;

/* 
// TODO: can't do this because of circular dependency. 
//       in List it needs to call the other assert which means it needs the types of the whole overload set so it needs to compile List$i64
@pub fn assert(cond: bool, const msg: Fn(Unit, List$i64)) Unit = {
    if(cond.not()){|
        var msg = msg();
        let msg: Str = msg&.items();
        panic(msg.str());
    }
}
*/

// TODO: this is really inefficient if you already own 'a'
@pub fn concat(a: Str, b: Str) List$i64 = {
    var c: List$i64 = list$ a.len().add(b.len());
    c&.push_all(a);
    c&.push_all(b);
    c
}

/// The returned strings are subslices of the original. 
@pub fn split(haystack: Str, needle: Str) List(Str) = {
    assert(needle.len().gt(0), "OOB");
    var lines: List$Str = list$1;
    var i = 0;
    let last = sub(len(haystack), len(needle));
    var start = 0;
    // TODO: !! should be lt maybe?
    while(fn = le(i, last)) {|
        if(eq(get(haystack, i), get(needle, 0)), fn() Unit = {
            let check = subslice(haystack, i, len(needle));
            if(eq(check, needle), fn() Unit = {
                let found = subslice(haystack, start, i.sub(start));
                push(lines&, found);
                i = add(i, len(needle));
                start = i;
            }) {| i = add(i, 1); };
        }) {| i = add(i, 1); };
    };
    let found = subslice(haystack, start, max(0, sub(len(haystack), start)));
    lines&.push(found);
    lines
}

// TODO: better error message if you call this on Ptr(Str)
@pub fn splitlines(s: Str) List(Str) = {
    var lf: Str = (10)!slice;  // TODO: string escapes
    split(s, lf)
}

@pub fn endswith(haystack: Str, needle: Str) bool = {
    // TODO: prefix if syntax forces you to give a return type annotation
    (lt(len(haystack), len(needle)),
        fn= false,
        fn= {
            let start: Str = subslice(haystack, sub(len(haystack), len(needle)), len(needle));  // TODO: infer type
            eq(start, needle)
        }
    )!if
}

// TODO: these should just be on Slice(T)
@pub fn startswith(haystack: Str, needle: Str) bool = {
    if(lt(len(haystack), len(needle)), fn = false,
        fn() bool = {
            let start: Str = subslice(haystack, 0, len(needle));  // TODO: infer type
            eq(start, needle)
        }
    )
}

@pub fn str() Unit = { unit };  // TODO: scope.rs support recursion. 

// TODO: this needs to return List$i64 since it allocates. 
//       really you want to have a nice Writer abstraction so you can seperate the formating and the allocation. 
//        I need List$i64.deref() -> Str because currently its really annoying to use functions that return owned strings, 
//       since many string functions just need to borrow thier arguments so you can't chain things nicely. 
@pub fn str(i: i64) Str = {
    var s: List(i64) = list(1);
    if(and(ge(i, 0), lt(i, 10)), 
        fn() Unit = push(s&, add(48, i)),
        fn() Unit = {
            push_all(s&, str(div(i, 10))); // TODO: push to list
            push(s&, add(48, mod(i, 10)));
        }
    );
    
    items(s&)
}

// TODO: this should return an option. 
// TODO: use @switch once I have ranges. 
@pub fn hex_digit(c: i64) i64 = {
    if(ge(c, 97), 
        fn() i64 =  { assert(lt(c, 107), "hex OOB"); add(sub(c, 97), 10) }, 
        fn() i64 = if(ge(c, 65), 
            fn() i64 = { assert(lt(c, 75), "hex OOB"); add(sub(c, 65), 10) }, 
            fn() i64 = { assert(lt(c, 58), "hex OOB"); sub(c, 48)}
        )
    )
}

// TODO: this should return an error. 
@pub fn hex(s: Str) i64 = {
    var total = 0;
    var scale = 1;
    var i = s.len().sub(1);
    var first = 0;
    
    // This prevents overflow for tracking scale for lots of leading zeros. 
    // TODO: add a test that requires this. lol its an insane number tho so could just not bother 
    while(fn = first.lt(s.len()).and(fn = eq(get(s, first), 48))) {|
        first = add(first, 1) 
    };
    
    while(fn = ge(i, first)) {|
        total = add(total, mul(scale, hex_digit(get(s, i))));
        scale = mul(scale, 16);
        i = sub(i, 1);
    };
    total
}

@pub fn multi_println(s: Slice$Str) Unit = {
    for(s) {(s: *Str)| println(s[]); };
}

// TODO: this is stupid. i have a whole house of cards going on with unique types. ""!type needs to die. 
@pub fn str_eq(lhs: Str, rhs: Str) bool = eq(lhs, rhs);
@pub fn str_eq(lhs: ""!type, rhs: ""!type) bool = eq(str(lhs), str(rhs));
@pub fn startswith(lhs: ""!type, rhs: ""!type) bool = startswith(str(lhs), str(rhs));
@pub fn endswith(lhs: ""!type, rhs: ""!type) bool = endswith(str(lhs), str(rhs));

// See `println(Str)` or `e!reflect_print` for something more useful. TODO: make this generic.
@pub @env fn print(i: i64) Unit = {
    var s = str(i);
    println(s);
}

// TODO: letting you use this at runtime gets pretty yucky. you need to garbage collect symbols somehow? 
@pub @interp fn str(s: Symbol) Str;

@pub fn str(s: ""!type) Str = {  // TODO: god damn bro
    let ptr: **i64 = s&[0];
    let len = s&[1];
    slice(ptr[], len[])
};

@pub fn str(s: Str) ""!type = {  // TODO: god damn bro
    let ptr: **i64 = s&[0];
    let len = s&[1];
    (ptr[], len[])
};

@pub fn push_all(self: *List(i64), s: ""!type) Unit = {  // TODO: god damn bro
    self.push_all(s.str());
};
