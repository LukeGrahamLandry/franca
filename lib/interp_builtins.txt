const Type;
const Any: Type;  // Any value that fits in a single stack slot. 
const Unit: Type = ();  // The set of all empty tuples.
const unit: Unit = ();  // The officially blessed empty tuple.
const bool: Type;
const true: bool;
const false: bool;
const i64: Type;


// An interned string blessed by the compiler.
// This is the type of identifiers in source files. 
// There's nothing special about it unless you're interacting with the asts in macros.
const Symbol: Type = i64;

// Debugging
fn print(_: Any) Unit;
fn assert_eq(_: Any, _: Any) bool;

// Math
fn add(_: i64, _: i64) i64;
fn sub(_: i64, _: i64) i64;
fn mul(_: i64, _: i64) i64;
fn div(_: i64, _: i64) i64;
fn eq(_: i64, _: i64) bool;
fn ne(_: i64, _: i64) bool;
fn lt(_: i64, _: i64) bool;
fn gt(_: i64, _: i64) bool;
fn le(_: i64, _: i64) bool;
fn ge(_: i64, _: i64) bool;

// Simple types
@comptime fn Ptr(Inner: Type) Type;  // A reference to one `Inner`
@comptime fn Slice(Inner: Type) Type;    // A reference to an unknown number of `Inner`s
// `Fn(A, B)` === `fn(A) B` but this makes it a normal function. (might want to remove the other syntax? but i like it for generic constraints). 
@comptime fn Fn(Arg: Type, Ret: Type) Type;
// A value-type like a tuple but all elements are the same type. 
@comptime fn StaticArray(inner: Type, count: i64) Type;
@comptime fn Map(Key: Type, Value: Type) Type;
// TODO: need to support using comptime args in return type
@comptime fn static_array(Inner: Type, count: i64, element: Inner) StaticArray(Inner);
@comptime fn static_array_uninit(Inner: Type, count: i64) StaticArray(Inner);
@comptime fn Comptime(T: Type) Type;
@comptime fn Runtime(T: Type) Type;
@comptime fn Struct(fields: Map(Symbol, Type)) Type;

// TODO: need to track container types better. 
// fn Tag(E: Type) Type = i64;  // Currently enum tags are untyped but that will likely change. 
@comptime fn tag_value(E: Type, case_name: Symbol) i64;  // Enum reflection. 

// Control flow
// fn if(cond: bool, false_branch: Fn(Any, Any), true_branch: Fn(Any, Any)) Any;

// Working with pointers
fn get(ptr: Ptr(Any)) Any;
fn set(ptr: Ptr(Any), value: Any) Unit;
fn len(ptr: Ptr(Any)) i64;
fn slice(ptr: Ptr(Any), first: i64, one_past_last: i64) Ptr(Any);
/// The result may have more room than you asked for (which is useful for growable collections in allocators that use fixed size blocks). 
fn alloc(Element: Type, count: i64) Ptr(Any); 
/// `ptr` must be exactly a slice returned by `alloc` (not a subslice of it).
fn dealloc(Element: Type, ptr: Ptr(Any)) Unit;

// Inspecting the interpreter
fn is_comptime() bool;
fn is_uninit(_: Ptr(Any)) bool;
fn is_oob_stack(_: Ptr(Any)) bool;
@inline fn print_callstack() Unit;
fn comptime_cache_get(f: Fn(Any, Any), arg: Any) (bool, Any);
fn comptime_cache_insert(f: Fn(Any, Any), arg: Any, ret: Any) Unit;

fn get_i(tuple: Ptr(Any), i: Any) Any = {
    get(slice(tuple, i, add(i, 1)))
}
