const Type;
const Any: Type;  // Any value that fits in a single stack slot. 
const Unit: Type = ();  // The set of all empty tuples.
const unit: Unit = ();  // The officially blessed empty tuple.
const bool: Type;
const true: bool;
const false: bool;
const i64: Type;
const Symbol: Type = i64;
// const BoxedAny: Type;

// Debugging
fn print(_: Any) Unit;
fn assert_eq(_: Any, _: Any) bool;

// Math
fn add(_: i64, _: i64) i64;
fn sub(_: i64, _: i64) i64;
fn mul(_: i64, _: i64) i64;
fn div(_: i64, _: i64) i64;
fn eq(_: i64, _: i64) i64;
fn ne(_: i64, _: i64) i64;
fn lt(_: i64, _: i64) i64;
fn gt(_: i64, _: i64) i64;
fn le(_: i64, _: i64) i64;
fn ge(_: i64, _: i64) i64;

// Simple types
fn Ptr(Inner: Type) Type;  // A reference to one `Inner`
fn Slice(Inner: Type) Type;    // A reference to an unknown number of `Inner`s
// `Fn(A, B)` === `fn(A) B` but this makes it a normal function. (might want to remove the other syntax? but i like it for generic constraints). 
fn Fn(Arg: Type, Ret: Type) Type;
// A value-type like a tuple but all elements are the same type. 
fn StaticArray(inner: Type, count: i64) Type;
fn Map(Key: Type, Value: Type) Type;
// TODO: need to support using comptime args in return type
// fn static_array(Inner: Type, count: i64, element: Inner) StaticArray();
// fn static_array_uninit(Inner: Type, count: i64) StaticArray();
fn Comptime(T: Type) Type;
fn Runtime(T: Type) Type;
fn Struct(fields: Slice((Symbol, Type))) Type;

// An interned string blessed by the compiler.
// This is the type of identifiers in source files. 
// There's nothing special about it unless you're interacting with the asts in macros.
// const Symbol: Type;  

// Control flow
// fn if(cond: bool, false_branch: Fn(Any, Any), true_branch: Fn(Any, Any)) Any;

// Working with pointers
fn get(ptr: Ptr(Any)) Any;
fn set(ptr: Ptr(Any), value: Any) Unit;
fn len(ptr: Slice(Any)) i64;
fn slice(ptr: Slice(Any), first: i64, one_past_last: i64) Slice(Any);
/// The result may have more room than you asked for (which is useful for growable collections in allocators that use fixed size blocks). 
fn alloc(Element: Type, count: i64) Slice(Any); 
/// `ptr` must be exactly a slice returned by `alloc` (not a subslice of it).
fn dealloc(Element: Type, ptr: Slice(Any)) Unit;

// Inspecting the interpreter
fn is_comptime() bool;
fn is_uninit(_: Slice(Any)) bool;
fn is_oob_stack(_: Slice(Any)) bool;
@inline fn print_callstack() Unit;
fn comptime_cache_get(f: Fn(Any, Any), arg: Any) (bool, Any);
fn comptime_cache_insert(f: Fn(Any, Any), arg: Any, ret: Any) Unit;
