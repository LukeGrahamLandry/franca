
fn ptr_diff(start: rawptr, end: rawptr) i64 = end.ptr_to_int().sub(start.ptr_to_int());
fn ptr_diff_bytes() Unit; 
fn offset() Unit;
fn offset_bytes() Unit;

// TODO: put this in fn Ptr so you always get them? 
fn ptr_utils(const T: Type) Unit = {
    fn ptr_diff_bytes(start: *T, end: *T) i64 = ptr_diff(T.raw_from_ptr(start), T.raw_from_ptr(end));
    fn offset(ptr: *T, element_count: i64) *T = {
        bytes := element_count.mul(:: T.size_of());
        old := T.raw_from_ptr(ptr);
        new := old.offset(bytes);
        T.ptr_from_raw(new)
    }
    fn offset_bytes(ptr: *T, bytes: i64) *T = @as(rawptr) offset(@as(rawptr) ptr, bytes); 
    fn ptr_diff(start: *T, end: *T) i64 = ptr_diff_bytes(start, end).div(::T.size_of());
    fn ptr_to_int(ptr: *T) i64 = ptr_to_int(@as(rawptr) ptr);
    
    fn for(var first: *T, past_last: *T, const body: Fn(*T, Unit)) Unit = {
        while(=> first.ptr_to_int().ne(past_last.ptr_to_int())) {|
            body(first);
            first = first.offset(1);
        }
    }
}

/// This function does nothing, it just lies to the typechecker. 
/// It's a bit clunky to type but maybe that's good for morale since its wildly unsafe!
/// SAFETY: the pointer must be aligned correctly for the new type and valid for use as the new size. 
ptr_cast_unchecked :: fn(const From: Type, const To: Type, ptr: *From) *To #generic #inline = 
    @as(*To) @as(rawptr) ptr;

raw_from_ptr :: fn(const From: Type, ptr: *From) rawptr #generic #inline = @as(rawptr) ptr;
ptr_from_raw :: fn(const To: Type, ptr: rawptr) *To #generic #inline = @as(*To) ptr;
