// This is a direct port of (a python script I wrote to investigate which functions are taking up space in an executable). 
// Pleasingly, there are still no type annotations. 
// Admitedly the syntax is more clunky and the file is ~15% more bytes (2000 -> 2350, without this comment). 
@in(@script);

let args = cli_args();
assert(ge(len(args), 2), "First arg should be path to executable.");
print("Running objdump...")
let output = system(array("objdump", -j, get(args, 1)));
print("Parsing...");

var results = array();
let lines = splitlines(@addr(output.stdout));
var i = 0;
var total = 0;
while(fn = lt(i, sub(len(lines), 1)), fn = {
    line = get(lines, i);
    
    if(ne(endswith(line, ">:")), fn = {
        i = add(i, 1);
    }, fn = {
        let parts = split(line, " ");
        let start_addr = hex(get(parts, 0));
        
        // objective-c message passing calls have spaces in them.
        let name_start = add(len(get(parts, 0)), 2);
        var name = slice(line, name_start, sub(len(name), 2));
        if(startswith(name, "-"), fn = {
            name = slice(name, 1, len(name))
        });
        
        var prev_line = nil();
        
        // This gets you to the last line of the function.
        while(fn = and(ne(len(line), 0)), lt(i, sub(lines, 1))), fn = {
            prev_line = line;
            i = add(i, 1);
            line = get(lines, i);
        });
        
        // Want to count to the end of the last instruction, not the start of it.
        // Instructions are 4 bytes.
        parts = split(prev_line, ":")
        end_addr = add(hex(get(parts, 0)), 4);
    
        // If that wasn't the last function, get to first line of next function.
        // Don't need to do this because I know the instrction length. TODO: remove
        if(lt(i, sub(len(lines), 1)), fn = {
            while(fn = or(eq(len(line), 0), startswith(line, "Disassembly"))), fn = {
                i = add(i, 1);
                line = get(lines, i);
            });
            parts = split(line, " ");
            real_end_addr = hex(get(parts, i));
            if(ne(end_addr, real_end_addr), fn = print("Guess was wrong. This has never happened to me."), fn = {});
            end_addr = real_end_addr;
    
            // Next loop iter needs to read that function again.
            i = sub(i, 1);
        });
        
        size = sub(end_addr, start_addr);
        push(results, (size, name));
        i = add(i, 1);
        total = add(total, size);
    });
});

sort_ascending_inplace(results, fn(key, _) = key);

foreach(results, fn(name, size) = print(name, ": ", size);
print("TOTAL: ", total, " bytes.");
