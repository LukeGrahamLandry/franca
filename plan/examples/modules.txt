
//
// TO-DO: how do you decide if you want a trait or a module.
// - if you only need the vtable pointer (not a data pointer), that's probably a module. 
// - if you want to dispatch to different implementations of an interface at runtime, that's a trait. 
// - modules are things that probably only need one implementation in a given program.
// - modules are used for controling visibility. 
// - ffi is always imported as a module. 
// - a library that wants to take comptime parameters from the host meta program is a module. 
// - modules are used for caching compilation work, if nothing changed in a module and all its dependencies, 
//   dont need to recompile. beyond code understandability, this is another reason not to allow overloading across modules. 
//
// Maybe: 
// - Each file is a new module that implicitly exports everything to every other module in your program that's a top level file. 
// - Each directory is a new module. 
// 
