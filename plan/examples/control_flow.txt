
// TO-DO: Which match syntax is more pleasing?
//       Actually its trivial to support both and implement one in terms of the other. 
//       maybe the macro infers the names and parses the function bodies to give the function 
//       and you can use which ever looks nicer in whatever context. 
//       I was thinking the function version might be nicer for bootstrapping 
//       because the interp could just intercept the call and you don't need to deal with ffi to run handlers on asts.
//       but there's no reason it can't just intercept the macro call. 
//       allow builtins there too because it really is just a function call. 
//       its even easier because interp function needs ffi because values are already in lang space,
//       where as macros need to pass asts which are in interp space. 
//       Actually that's a good way to decide which should be which. 
//       Things that could reasonably work on syntax trees can easily have a version builtin to the compiler
//       
//

// this is nice when you're just forwarding the payload to a function 
fn then(self: ?T, if_present: fn(T) ?U) ?U = match(self, [
    (Some, if_present),
    (None, fn = None),
]);

fn then(self: ?T, if_present: fn(T) ?U) ?U = @match(self) {
    fn some(t: T) = if_present(t),
    fn none() = None;
]);

// maybe you can give a function expression without a new the definition
fn then(self: ?T, if_present: fn(T) ?U) ?U = @match(self) {
    if_present,
    fn none() = None;
]);
