fn main(canary: i64) i64 = {

// Implicit Return
fn four() i64 = 4;
assert_eq(four(), 4);

// Explicit Return
fn four2() i64 = return(4);
assert_eq(four2(), 4);

// Early Return
fn bail(a: i64) i64 = {
    let end = return;
    (eq(a, 0), fn=end(17), fn=())!if;
    sub(a, 1)
}

assert_eq(bail(5), 4);
assert_eq(bail(0), 17);


fn bail2(a: i64) i64 = {
    let end = return;
    let b = (eq(a, 0), fn=end(17), fn=return(a))!if;
    sub(b, 1)
}
assert_eq(bail2(5), 4);
assert_eq(bail2(0), 17);


canary
}


//
// - Stuff about c++ exceptions for when I start thinking about error handling: https://www.youtube.com/watch?v=Oy-VTqz1_58
// - Exceptions should be the same thing as non-local returns? 
// - Even the errors as values people have exceptions, they just call them panicks and look at you funny if you do it too much
// - Seems like you should be able to express them one way and let someone else decide how they're implemented depending how likely they are. 
// - If your error objects are small, treating as values makes the error path much cheaper (because you don't have to allocate + stack walk),
// and the success path slightly more expensive (because you always have to check err!=nil or whatever). 
// - Time of check vs time of use: you often want to have functions signal errors instead of checking if something is possible first
// - Zig infering combined error sets is so much nicer than rust but they don't let you include extra information on the error value. 
// - Rust is either a lot of boilerplate 'impl From' for combined exceptions or 
     a dependency to generate it (like https://crates.io/crates/anyhow),
     that perhaps throws away all the type safety you were bragging about over exceptions
// - Go I don't understand. You get the verbose handling but everything is just the error interface so
//   you don't get the niceness of functions documenting what could cause them to error in thier return type. 
// - I don't know why java checked exceptions are seen as bad but when rust does it suddenly its good. 
//   Just having better pattern matching syntax or different target audience? 
// - You want to be able to have nested errors where you add context about what you were trying to do. 
// - You want them to compose in higher order functions/iterators. 
//   Rust has a combinatorial problem with needing mut/async/err versions of everything. 
//   Maybe the magic words are "algebreic effects". 
// - The goal of being explicit fundamentally conflicts with the goal of no function colouring. 
//   But maybe it could be a compiler option how strict you want to be, 
//   so you could have some sections of code where you want to be obsessive about performace or whatever and some scripts where you don't.
//   Starting to sound like I'm reinventing 'unsafe'.
//
