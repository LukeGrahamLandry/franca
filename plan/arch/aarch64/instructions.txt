const RegI = Unique(u5);
const RegO = Unique(u5);
const Bits = @enum(u1) { W32 = 0, X64 = 1 };
const Shift = @enum(u2) { LSL = 0b00, LSR = 0b01, ASR = 0b10 };
fn JumpRel(Int: Type) = Unique(Int);  // measured in instructions, not bytes

fn add(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b0001011, shift, 0b0, a, amount, b, dest);

fn orr(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b0101010, shift, 0b0, a, amount, b, dest);

fn sub(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b1001011, shift, 0b0, a, amount, b, dest);

fn mov(sf: Bits, dest: RegO, src: RegI) = orr(sf, dest, src, 15, Shift.LSL, 0);

fn cbz(sf: Bits, offset: JumpRel(i19), val: RegI) =
    @bits(sf, 0b0110100, offset, val);
