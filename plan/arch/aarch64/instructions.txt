const RegI = Unique(u5);
const RegO = Unique(u5);
const Bits = @enum(u1) { W32 = 0, X64 = 1 };
const Shift = @enum(u2) { LSL = 0b00, LSR = 0b01, ASR = 0b10 };
fn JumpRel(Int: Type) = Unique(Int);  // measured in instructions, not bytes

fn add(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b0001011, shift, 0b0, a, amount, b, dest);

fn orr(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b0101010, shift, 0b0, a, amount, b, dest);

fn sub(sf: Bits.T, dest: RegO, a: RegI, b: RegI, shift: Shift.T, amount: u6) =
    @bits(sf, 0b1001011, shift, 0b0, a, amount, b, dest);

fn mov(sf: Bits, dest: RegO, src: RegI) = orr(sf, dest, src, 15, Shift.LSL, 0);

fn cbz(sf: Bits, offset: JumpRel(i19), val: RegI) =
    @bits(sf, 0b0110100, offset, val);

// TODO: move to macros.txt
// There are implicit range assertions because we get the bit count from the type of the ints. 
@annotation
fn bits(arg: AstExpr) AstExpr = {
    var parts: Slice(AstExpr) = arg.Tuple[];
    var expr = 0!literal_ast;
    var shift = 32;
    foreach(parts, fn(part: Ptr(AstExpr)) Unit = {
        let int: IntType = get_type_int(part);
        shift = sub(shift, int.bit_count);
        assert(ge(shift, 0));
        let next = (int.signed, 
            fn() AstExpr = new_call_ast(signed_truncate!literal_ast, new_pair_ast(part[], int.bit_count)),
            fn() AstExpr = part[]
        )!if;
        let next = new_call_ast(shift_left!literal_ast, new_pair_ast(next, shift));
        expr = new_call_ast(or!literal_ast, new_pair_ast(expr, next));
    });
    assert(eq(shift, 0));
    expr
}

assert_eq(@bits(0b101, 0b100, 0b00, 0b11), 0b1011000011);
