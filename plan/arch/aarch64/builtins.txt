//! This file defines the functions builtin to the interpreter but using inline assembly instead. 
//! It relies on a few unusual macros:
//! - { S; }!asm: Instead of generating code for the expression, evaluate it as a stream of machine code at comptime. 
//!   Inner statements may be A) u32, B) stream of u32, C) label declaration. 
//! - I!reg: Get the register assigned to store variable I at this moment. 
//!   The type of the variable must fit in a single register. 
//! - I!label: Mark a location. This does not emit an instruction, it just provides a jump target for other instructions. 
//! - I!offset: Compute the (signed) distance between the current statement and the label I. 
//! - @emit(R) E: Generate the code for the expression E putting its result in register R. 
//! - @no_cc F: Promise that calling the function F stomps no registers other than RET!reg. 
//!   This implies @inline but provides a stronger guarantee. 
//! If you hardcode registers instead of relying on the compiler to assign them for you, 
//! make sure to adhear to the current function's calling convention. 
//!
// TODO: assert_eq(target_arch(), Arch.aarch64);

@no_cc
fn add(a: i64, b: i64) i64 = {
    add(Bits.X64, RET!reg, a!reg, b!reg, Shift.LSL, 0);
}!asm;

@no_cc
fn sub(a: i64, b: i64) i64 = {
    sub(Bits.X64, RET!reg, a!reg, b!reg, Shift.LSL, 0);
}!asm;

fn if(cond: bool, if_true: Fn(Unit, T), if_false: Fn(Unit, T)) T = {
    cbz(Bits.X64, after!offset, cond!reg);
    @emit(RET!reg) if_true();
    b(done!offset);
    after!label;
    @emit(RET!reg) if_false();
    done!label;
}!asm;
