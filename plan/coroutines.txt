
// - https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
// - https://lua.org/pil/9.1.html

//
// Mar-03
// The motivating example for me is needing to call back and forth between the compiler and macros.
// But actually I probably don't even need anything fancy to make that work?
// I just need stuff to be real functions, so you pass the compiler object to the macro and
// if it wants to call a function, it can use a vtable, and it's just a normal call on the same stack.
// And maybe that triggers other macro calls but that's fine because they'd want to follow stack order anyway.
// What made it messy with the interpreter is that the compiler contains the interpreter so when you call into
// the interpreter, it can't access the compiler anymore and hard to error all the way back up the stack.
// So it felt like you were relying on the interpreter's stack for saving your state, but really it could
// have just been a normal function call if stuff was arranged better.
//
