// TO-DO: doc: @some(TraitName) is a staticlly known type, but all you know is that it implements that trait. 

struct RustPath = { name: Str, module_path: Slice(Str), verson: SemVer }; 

using RustDecl = using(RustPath, Enum(Trait | Struct | Function));

// TO-DO: figure out how to express infer array type. i guess its obvious: have syntax for it, 
//       go through and replace `Slice(T)` with `[] T` in places where I dont care. 
struct CargoLockPackage = { name: Str, version: SemVer, source: Str, checksum: Str, dependencies: [] Str };
struct CargoDotLock = { version: i64, package: [] CargoLockPackage };

// TO-DO: does one hash in a Cargo.lock inlcude all those of its dependencies? 
fn import_cargo(name: Str, version: SemVer, hash: ?ContentHash) FfiModule;

fn import_crate()

    std::rc::Rc


const RustStd; 
for T with fn move(T) T {
    const Rc(T) = RustStd.std.rc.Rc(T); 
}

fn import_rust(module: Str, name: Str, generics: Slice(Type)) fn (generics: Slice(Type)) Type;

///////////////
/// Dialect ///
///////////////

enum RustSmartPtr = Box | Rc | Weak | Cow;
enum RustCollection = Vec | Slice | StaticArray | CStr | CString;

fn rust_ptr(f: PtrSyntax | RustSmartPtr) PtrFlags = {
    @match f {
        fn(Amp, None) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NonNull | TrackLifetime),
        fn(Amp, Mut) = all(NoAlias | NonNull | TrackLifetime),
        fn(Star, nil()) | fn(Star, Mut) = all(UnsafeDeref | BitCopy),
        fn(Box) = all(NoAlias | NeedsDrop | MoveOut),
        fn(Rc) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NeedsDrop),
        fn(Rc) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NeedsDrop | OptionalDeref),
    }
}
