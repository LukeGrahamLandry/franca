@in(@module(syntax, impl=core, vis=Public));
// 
// Annotations are macros. 
// Writing `@name(args) target` calls `name(args, target)` at comptime. 
// But the annotation handler recieves things as an Ast, rather than as a value. 
// Annotation handlers are still normal functions. One may directly call another. 
//
// You can define when your annotation can be used by the types of its handler arguments. 
// - `args` are the things in the brackets.
//      If its type is Unit, the annotation must be called without brackets. 
//      If args is not an ast subtype, it will be evaluated at comptime. 
// - `target` is the expression or statement after the annotation invocation. 
//      If its type is Unit, it will not consume the item after it and the value you return will replace only the invocation itself.
//      Otherwise, the value you return will replace both the target and the invocation. 
// - It is an error for both to be unit. 
// - You can never recieve annother annotation invocation as an arument. They're just applied in sequence. 
//
// It's very good if your annotation is @pure, then the compiler (or IDE plugin) can cache it. 
// TO-DO: thats an advantage to structured side effects like AnnotationAction::Collect. 
//
// TO-DO: there's really two types of Type. 
//       1) A local type in your own program that needs to be comptime only.
//       2) The compiler working on asts but you don't want it to be running in the interpreter. 
//       Actually thats fine. A type is just a type info and I've already thought about a strategy 
//       where the interpreter calls into precompiled code if avaiable. 
//       The compiler's runtime is always someone else's comptime. 
// 

// TO-DO: maybe postfix syntax with `!` on an expression. so you could have, whatever()!await, whatever()!try, whatever()!addr, 
//       nullish coallesing: falible!if.method()!if.other() === falible.map(fn(v) = v.method().map(fn(v) = v.other()))
//       seems most useful for things that can't be functions. 
//       whatever()!unwrap, fallable!or(default) but that could be a method, i could just give in and have dot syntax.
//       becomes obvious if i use that for fields and let you have getters so you could just return functions anyway. should just make it the default. 
//       should it just be sugar? @a(b) === b!a
//       `something()!unsafe` instead of rust's `unsafe { something() }`

// TO-DO: require `;` after if target is Unit? But then you can't use it as an expression. 

//
// Builtin Function Annotations: 
// Each branch of FnFlags (in types.txt) can be applied to a function definition. 
// They don't have an immediate effect on the Ast but other parts of the compiler know they exist and check for them. 
//

// TO-DO: doc: set default visibility of items in module because its painful to put @pub everywhere. 
// TO-DO: doc: `enum A = Thing` (bame = "Thing", payload = type Thing) is not the same as `enum A = Thing()` (name = "Thing", paylaod = type Unit).
// TO-DO: doc: @in(...) at the top of a file for avoiding an extra indent

// TO-DO: get rid of this. i dont like it anymore. interp should just intercept everything it needs to when bootstrapping. 
// The target function is needed to compile the compiler. 
// While bootstrapping the compiler, 
// - Builtin: There is a version written in rust
// - Interp: It runs in the interpreter
// That's enough to compile the real version to rust and future builds call that directly. 
@annotation @intrinsic
fn boot(args: Builtin | Interp, target: FnDecl) FnDecl = match(args, [
    (Builtin, add_flag(target, BootBuiltin)),
    (Interp, add_flag(target, BootInterp)),
])
// TO-DO: allow @boot on a whole module and just iterate its decls. 

// TO-DO: allow leading `|` on enums so you can have them all off the end and look consistant. 
// TO-DO: some way to tag the default case. give annotations a way to express that they want to access the parent and generate code in that scope. 
//       so it could generate an `fn default() E`.
/// What to do with the return value of the handler. 
enum AnnotationAction = 
    // Put the resulting Ast back at the annotation call site. 
    | Replace
    // Store the result parallel to the ast so it can be retrived later. 
    // Examples: @example, @invarient. 
    // TO-DO: really you dont want ^ in either case. you just want a list
    | Save(Symbol)
    // Build up a list of all the results (and thier callsites) and pass it to a function after all calls to your annotation have finished. 
    // TO-DO: doc: this syntax for an unbounded generic 
    //            this is a function accepting a list of pairs where the first is inferred (return type of the annotation in this case) and the second is Loc. 
    // TO-DO: maybe this is always better than Save(_) since you could have a collector that does that. 
    // TO-DO: what if you want to access the target but not consume it? i guess at some point just put your list in a global
    | Collect(fn([](_, Loc)) Unit)
    // Same as above but grouped and calls the handler multiple times.
    // Examples: @switch
    | CollectMap({ K: Type, V: Type, f: fn(K, [](V, Loc))})
;

// TO-DO: doc: If the args are references, you don't consume them and they continue on to the rest of compilation. TODO: dont allow escaping. 
//       how do you decide if you want Collect or a global? i guess if you want it all at the end or as you go.
//       have a better way of expressing this than just allowing escaping references to the ast. 
@annotation 
fn annotation(args: AnnotationArg = Replace, target: FnDeclAst) Expr = {
    todo_assert(eq(args, Replace));
    // TO-DO: require that args are either by value or const. if you want to mutate a node, pass it in and return it. 
    // i was thinking for generics where it might happen multiple times but maybe its fine cause you eat it. 
    // its really the overload handler that needs to use it multiple times and not mutate. 
    // assert(not(mutates_args(target)), "Annotation must not mutate Ast node. Make a copy and return it instead.");
    const F: FnType = unwrap(expr_type(target));
    const T: Tuple(Type, 2) = F.Arg;
    set_flags(target, all(get_flags(target), Annotation | Comptime), true);
    let handler = { Arg: first(T), Target: second(T), Ret: F.Ret, f: compile_expr(F, target) };
    let prev = insert(annotation_handlers, name(target), handler);
    target
}

// Defines an annotation that does not generate code, it just leaves some data in the ast for other annotations. 
// Annotations can retrive data in the form of `struct Name = Payload;`.
// Like Rust's `#[ident(args)]` but I spell it `@ident(args)`
@annotation @pure
fn tag((name, payload): (Symbol, Type), target: Unit) TypeDecl;

@annotation @intrinsic
fn module(args: Expr, target: ()) !Expr;

@annotation @intrinsic
fn ffi(args: Target, target: ()) !Expr;

@annotation @intrinsic @pure
fn type_of(args: Expr, target: ()) !Expr;

/// puts you in place expression mode
@annotation @intrinsic @pure
fn addr(args: Expr, target: ()) !Expr;

// Try to compile the target but require a specific error. Useful for testing safety checks. 
@annotation @intrinsic @pure
fn assert_compile_error(args: ?CompileError, target: Block) CRes(());

// TO-DO: @return @break @continue

// TO-DO: handle type matching over Any.
// TO-DO: not use this if target is rust or zig
// Note: this implementation can't call methods that use match? or maybe its fine since someone else would have compiled them. 
// TO-DO: rewrite to take advantage of function params being a Pattern
@annotation @auto @pure
fn match(args: ExprAst, target: []FnDeclAst) ExprAst = {
    const E: EnumType = unwrap(expr_type(args));
    
    // Each branch function must return the same type. 
    let Out = unwrap(resolve_fold_types(map(target, fn(T: FnDeclAst) Type = Ret(T))));
    
    let handlers: Iter(Tag(E), FnDeclAst) = foreach(target, fn(f: &FnDeclAst)={
        let F: FnType = expr_type(f);
        let cases = if(eq(name(f), nil()), fn={
            // If they didn't specify a name, just look for the argument type. 
            filter(cases(E), fn(name: Symbol, Payload: Type) = eq(Payload, F.Arg))
        }, fn = {
            filter(cases(E), fn(name: Symbol, Payload: Type) = and(eq(name, F.name), eq(Payload, F.Arg)));
        });
        
        @assert(eq(len(cases), 1), "ambigous or missing match branch");
        let action = eval_expr(f);
        ((get(cases, 0)), fn(payload) Out = cast(action(payload)))
    });
    
    assert_eq(len(handlers), len(cases(E)));
    
    let join_branches = fn(prev: AstExpr, tag: Tag(E), handler: FnDeclAst) AstExpr = {
        let tag_expr = CallAst("tag_of", args, Tag(E));
        let cond_expr = CallAst("eq", (tag_expr, tag), bool);
        @if(cond_expr, handler, prev)
    };
    
    fold(handlers, quote("comptime_unreachable()"), join_branches)
}

// TO-DO: the other killer feature of this is that if you think macros are evil,
//       maybe you can configure your ide to always show the expanded form when you click into libraries (only works for pure ones). 
//       try to do impure annotations as a pure one that outputs a @comptime block.
//       allow configurable `fn render(Ast) Ast;`. could format how you like too. 

// TO-DO: support the value being an array. do enumerate if there's an extra i64 in the pattern. 
// Loop over an iterator. 
// This is a trivial wrapper around the `for` function that gives it a more familiar syntax. 
@example(same_ast("@for(i, range(0, 10)) { print(i); }", "for(range(0, 10), fn(i) = { print(i); })"));
@example(same_ast("@for((i, v), vec!(1, 2, 3)) { print(i, ".", v); }", "enumerate(vec!(1, 2, 3), fn(i, v) = { print(i, ".", v); })"));
@annotation @auto @pure
fn for((names, iter): (Pattern, AstExpr), target: WithFreeVariables) AstExpr {
    assert(completly_matches(names, target));
    let f = fn_decl(nil(), names, Unit, target);
    call_expr(for, (iter, f))
}

// @unroll to force generating each branch of a loop?

// TO-DO: replace the old `for` syntax with this. not sure if i actually want to change the name. 
// `@impl((T, U), and(allow_type(T), allow_other(U))) { ... }`
@annotation
fn impl((names, cond): (Pattern, FnDeclAst), target: BlockAst) = {
    foreach(@addr(names), fn(n)={
        // TO-DO: this wont typecheck. deal with the enum.
        assert_eq(n.type, nil(), "Generic parameters must not have type hint."); 
        n.type = Type;
    }); 
    assert(can_call(names, cond));
    todo();
}

// Conditional compilation. This can't just be normal code because toplevel doesn't run. 
@annotation @pure
fn when(arg: bool, target: AstExpr) AstExpr;

@when(any(get_target(), Java | Cplusplus | Swift | Python | JavaScript))
@annotation @pure
fn throw(arg: AstExpr, target: Unit) AstExpr;

// TO-DO: as i do more and more of these its starting to feel like i really just want trailing closure syntax like swift/kotlin. 
@example_ast("@if(x > 10) { print(x) }", "if(x > 10, fn = print(x))");
@example_ast("let x: ?i64; @if(let y = x) { print(y) }", "let x: ?i64; @match(x, { fn none() = (); fn some(y) = print(y); });"));
@annotation @auto @pure
fn if(cond: ExprAst, target: BlockAst) AstExpr;

@tag(intrinsic, { name: Symbol, args: Pattern, ret: Type });

// Same as rust
@annotation @pure
fn vec(values: TupleAst, target: Unit) ExprAst;

@annotation
fn example_ast(code: (Str, Str), target: Unit) AstExpr = todo("example <- same_ast(code)");

// TO-DO: support destructuring in args 

// TO-DO: replace this with Pattern
struct FnArg = { name: ?Symbol, T: ?ExprAst, default_value: ?ExprAst };
struct FnArgsAst = []FnArg;
@invarient(fn(f: FnArgsAst) bool = nand(is_nil(name), is_nil(T)));

@annotation
fn trait(((name, placeholder, cond): (Symbol, Symbol, BlockAst), target: [](VarDeclAst | FnDeclAst)) = {
    // TO-DO: a meta type for traits 
    // name is used for the type
    // placeholder is used as generic in later exprs
    // cond is extra requirements on types to implement
    // target is associated types/values or fn declarations or fn implementations in terms of other declarations
    todo()
}

// for pattern matching across function definitions 
@annotation(CollectMap({ K: FnSig, V: FnDeclAst, f: build_switch_body }))
fn switch(args: Unit, target: FnDeclAst);

/// Declares an outer function that matches over its argument and dispatches to one of the `cases`.
@private fn build_switch_body(sig: FnSig, cases: [](FnDeclAst, Loc)) AstExpr;

/// Useful for documenting behaviour of a function. And getting an automatic reminder when your docs get out of date. 
/// The expression is not evaluated, it just hangs out on the Ast. It should not contain free variables. 
/// The default test runner will compile and run them all, failing if they panic. 
/// Use `assert` and friends to expect certain values.
/// Equivilent to https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html
/// (but already part of your code instead of needing an extra tool to parse it out of comments).
// TO-DO: don't force type checking if not building for test currently. 
@annotation(Collect(maybe_run_examples))
fn example(args: ExprAst, target: Unit) FnDeclAst = {
    @match(args) {
        fn(args: FnDeclAst) = {
            todo("assert arg=ret=unit")
            args
        }
        fn(args) = todo("wrap in fn");
    }
}

// Run if testing
@private fn maybe_run_examples(examples: []FnDeclAst);

// TO-DO: specilizations for specific targets that return a string in the host language. 

// TO-DO: is this really better than Result(T, _) which isnt a special case? 
// Produce a result type with the error type infered based on the function body. 
// fn whatever(foo: Bar) @result(Baz) = { ... }
// TO-DO: i want the = so its consistant. maybe since that never has an ast node its fine and you just ignore. 
// TO-DO: really you want to pattern match and say "whenever you see this annotation as the return type in a function declaration"
@annotation @pure
fn result(args: Type, target: BlockAst) BlockAst;

// Provide a function that will always return true. 
// The allows declaring some constraint on values of a certain type. 
// Any time the compiler notices values of the argument type, it may choose to call `assertion`, and panic if it returns false. 
// In optimising builds, `assertion` will never be called. 
// `assertion` is no longer a normal function and cannot be called manually
// TO-DO: footgun: need @comptime when args are types? or it would be allowed to bake those constants in and crash at runtime. 
@annotation
fn invarient(assertion: FnDecl, target: Unit);

// Same as @invarient but allow the compiler to optimise assuming you didn't lie. 
// It is safety checked illegal behaviour to violate this assertion. 
// The fact that `assertion` returns true is treated as a staticlly known constant regardless of the arguments. 
// Like if you try to check the asserted condition in normal code else where the compiler might decide its redundant and remove it. 
@annotation
fn unsafe_invarient(assertion: FnDecl, target: Unit) = {
    invarient(assertion, target);
}

// Evaluate a fallible expression and return an error to the parent if not successful. 
// This can't be a normal function because it has to be able to early return. 
@annotation @pure
fn try(args: ExprAst, target: ()) ExprAst = {
    let Maybe = expr_type(args);
    // TO-DO: support actual destructuring 
    @match(Maybe) {
        fn(Result(T, E): Type)
    }
    // assert that it has a success assosiated tpye
    
    todo()
}

@trait(Fallible, F) {
    @static const HappyPath: Type;
    @static const SadPath: Type;
    
    fn as_fallible(F) (HappyPath | SadPath);
}
// TO-DO: be careful of recursion when creating types in an invarient 
@invarient(@comptime fn(T: Type) bool = is(?T, Fallible(HappyPath=T, SadPath=Unit)));
@invarient(@comptime fn(T: Type, E: Type) bool = is(Result(T, E), Fallible(HappyPath=T, SadPath=E)));

// Exit the current function and indicate an error. 
// How this is expressed depends on the return type of the function. 
// - Option(T): ignore arg and return nil.
// - Result(T, E): coerce arg to E and return Err(arg). 
// - T: panic. use `debug(arg)` as the message. 
@annotation @pure
fn error(args: ExprAst, target: ()) ExprAst; 

// Like `fn assert` but using @error on failure instead of `fn panic`
@annotation @pure
fn assert(args: ExprAst, target: ()) ExprAst; 

fn todo() Never = panic("Not yet implemented");

// TO-DO: not sure if i want to provide this cause its probably slow to walk an extra time but maybe that's a you problem 
@annotation
fn preprocess_ast(args: (), target: fn(ExprAst));

// TO-DO: comptime panic should take you to a repl where you can inspect variable values. 

// maybe use rust macro syntax to resolve ambiguity when its an expression with no postfix target. 

// TO-DO: can do a really nice thing for closure interop with rust, 
//       since i know the captures, allow expressing that as extra reference arguments
//       so you pass in the borrow every time you call and it gives it back. 

/////////////////
/// Operators ///
/////////////////

// TO-DO: its a bit odd that this implies the set varient returns whatever the set function does but normal assignment is a statement.  
//       extra important that normal doesnt flow the value through like c. 
//       but would be more consistant if normal was an expression that returned unit. 
//       problem with that is then chain assignment syntax is the same as c but wildly different, 
//       but since its unit, the type checker would trivially warn you if you made that mistake. 
/// Sugar for calling get/set means you can use it for pointer dereference!
@example_ast("let e = arr[i];", "let e = get(arr, i);");
@example_ast("arr[i] = e;", "set(arr, i, e);");
@example_ast("let v = ptr[];", "let v = get(ptr);");
@example_ast("ptr[] = v;", "set(ptr, v);");
@operator((get, set))
fn operator_subscript((arr, i, e): (ExprAst, ?ExprAst, ?ExprAst)) ExprAst = @match(i) {
    fn some(i) = @match(e) {
        fn some(e) = call_expr("set", (arr, i, e));
        fn none() = call_expr("get", (arr, i));
    }
    fn none() = @match(e) {
        fn some(e) = call_expr("set", (arr, e));
        fn none() = call_expr("get", (arr));
    }
}

/// Assert that blessed functions behave as thier syntax sugar would suggest. 
@annotation(Collect(maybe_run_examples)) @pure
fn sane_overload(arg: ExprAst, target: ()) = {
    // TO-DO: kinda want named arguments for things like this where there's lots cause its logically a constructor.
    //       maybe that means it should just be a struct and it has to wait for iterp to support that anyway.
    fn_decl(args=unit, ret=Unit, body=call_expr("prove_sane", eval_expr(arg)))
}

// TO-DO: make sure rust hash maps fit because get is owned but set is reference. 
//       i want to be able to express that without writing the trait twice. 
//       maybe allow the methods different types but they must cast to eachother? 
@impl((A, I, E, R), (and(fn get(&A, I) &E, fn set(&A, I, E) R))) {
    struct SubscriptProof(A, I, E) = {
        init: fn() A,
        // this must be valid indicies in the initial collection (so arrays should be pre-sized). 
        i: []I,
        // these must be able to go in the collection but not what starts in it. 
        e: []E,
    }
    
    fn prove_sane(proof: SubscriptProof) = {
        assert(and(eq(len(self.i), len(self.e)), gt(len(self.i), 0)));
        let arr = proof.init();
        // Can we put stuff in?
        @for((i, e), (proof.i, proof.e)) {
            assert_ne(arr[i], e);
            arr[i] = e;
            assert_eq(arr[i], e);
        }
        // Did anything get lost?
        @for((i, e), (proof.i, proof.e)) {
            assert_eq(arr[i], e);
        }
    }
}

// TO-DO: put these elsewhere 
@sane_overload({ init=fn=@vec(1, 2, 3), i=@vec(0, 1, 2), e=@vec(4, 5, 6) });
@sane_overload({ init=fn=box(1), i=@vec(unit), e=@vec(2) });
