@in(@module(name=iter, impl=core))

// - There is a trait called `Iter(T)`.
// - The type `I(_)` implements `Iter(T)` if,
//      - for any type `T`,
//          - there exists a function called `next` that maps `I(T) -> ?T`
@trait(Iter(T), I(_)) {
    @impl(T) {
        fn next(I(T)) ?T;
    }
}

@impl((T, I(_)), fn next(I(T)) ?T) {
    fn filter(I(T), fn(&T) Bool) I(T);
    fn len(I(T)) i64;
    
    fn for(iter: I(T), sink: fn(T)) {
        var value: T = next(iter);
        while(fn = ne(value, nil()), fn = {
            sink(value);
            value = next(iter);
        })
    }
    
    // Call `f` on pairs from the iterator until exauhsted. 
    fn reduce(self: I(T), f: fn(T, T) T) ?I = {
        var rolling = @try(next(self));
        @todo
    }
    
    @impl(U) {
        fn map(iter: I(T), f: fn(T) U)) I(U);
        
        // TO-DO: figure out if this is left or right. 
        fn fold(self: I(T), initial: U, f: fn(U, T) U) = {
            var rolling = initial;
            while(fn() T = @try(next(self)), fn(e: T) {
                rolling = f(rolling, e);
            })
        }
    }
}

for (Arr, T) with and(fn get(Arr, i64) T, fn length(Arr) i64) {
    fn foreach(arr: &Arr, body: fn(&T)) = 
        enumerate(arr, fn (_, v) = body(v))
    
    fn enumerate(arr: &Arr, body: fn(i64, &T)) = {
        var i = 0;
        while(fn { lt(i, len(arr)) }, fn { var v = get(arr, i); body(i, v); i = add(i, 1); })
    }
}
