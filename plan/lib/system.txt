
// TO-DO: rename @explicit_comptime to @env.
         also @env implies impure. 

struct ProcessResult = using({stdout: String, stderr: String}, Result((), i64));

struct Path = (Str);
enum FileErr = NotExists | NoPermission | Other;
fn from((s): Path) Str = s;
fn try_from(Str) ?Path;

struct Pid = (i64);
enum Forked = InParent { child: Pid } | InChild;
struct Url = (Str);

@module(name=process, impl=libc) when @module(libc) {
    @pub @env
    fn system(Str) ProcessResult;
    
    @pub @env 
    fn system(Str(Slice)) ProcessResult;
    
    @pub @runtime @impure 
    fn fork() Forked;
}

@module(name=io, impl=libc) when @module(libc) {
    @pub @env 
    fn cli_args() Slice(Str);
    
    /// At comptime, call compile error instead. 
    @pub @runtime @env 
    fn exit(status: i64) Never;
    
    /// Read from stdin. Block the thread until there's a new line character. 
    @pub @env
    fn read_line() String;
    
    @pub 
    fn input(msg: Str) String = {
        print(msg);
        read_line()
    }
}

// TO-DO: Think about how to make this sort of thing as easy as possible. 
//       Error handling especially is important to get right.
//       Have ways to configure which operations require explicit error handling.
//       ie. file system, network, allocation (kinda silly because overcommit?).
//       so you can do scripts quickly but be sure everything is checked in "production" things.
//       i like zig's infered error types and short syntax.
@module(name=files, impl=libc) when @module(libc) {
    @pub struct File;
    
    @pub struct OpenFlags = FlagSet(Create | Read | Write | Append);
    
    @pub @env 
    fn open(Path, OpenFlags) Result(File, FileErr);
    
    // Reads until the file runs out or the slice is full. 
    @pub @env 
    fn read(&File, Slice) Result(Slice, FileErr);
    
    // TO-DO: why isn't it an error if you can't write the whole thing? 
    // Returns the portion of the slice that was not written. 
    @pub @env 
    fn write(&File, Slice) Result(Slice, FileErr);

    @pub @env 
    fn read_all(Path) Result(Array(u8), FileErr);
    
    // TO-DO: its a problem that string casts to path, you might get the argument order wrong. 
    @pub @env 
    fn write_all(Path, Str, create: bool = true) Result((), FileErr);
}

@module(name=files, impl=libc, cond=RuntimeOnly) when @module(libc) {
    @pub struct Thread; 
    
    /// Safety: do not share mutable data between threads. 
    @pub @unsafe @impure 
    fn thread(fn()) Thread;
    
    /// Returns an error if the other thread panics/
    @pub @impure 
    fn join(Thread) Result((), ());
    
    @pub @impure 
    fn detatch(Thread);
}

@module(name=time, impl=libc) when @module(libc) {
    @pub struct Timer; 
    
    @pub @env 
    fn start_timer() Timer;
    @pub @env 
    fn end_timer(Timer) Duration;
}

enum HttpErr = Status(i64) | Other;
@module(name=requests, impl=libcurl) when @module(libcurl) {
    @pub @env 
    fn request_get(Url) Result(Array(u8), HttpErr);
}
