@in(@module(name=dlrc, impl=core))

//
// This is a useful type for when just want it to compile. 
// duck-typed, linear, reference-counted, copy-on-write.
// The memory management is similar to Swift's array/dict/set types. 
// A program with no type annotations should be able to use this type for everything and just fail at runtime if you make a mistake. 
// It's used for boostrapping the compiler since I want to write my type checking in this language. 
//
// This type is not Copy. You can pass it by,
// - move: give ownership to the reciever and you lose access to it
// - clone: you will NOT see mutations made by the reciever
// - share: you WILL see mutations made by the reciever 
const Dlrc = { @private ptr: *DlrcBox, @private borrowed: bool };  
// TO-DO: borrowed=true means you have to make a copy before mutating. might need to store in the box.

// This is what gets allocated on the heap and pointed to by a Dlrc
@private struct DlrcBox = { rc: i64, value: DlrcValue };

enum DlrcValue = []Dlrc | {}(Dlrc, Dlrc) | Tagged(Symbol, Dlrc) | None() | Any;

fn cast(value: DlrcValue) Dlrc = {
    var self: &DlrcBox = box(DlrcBox({ rc: 1, value: value}));
    { ptr: to_raw(self), borrowed: false }
}

// Increment the refernce count so you can pass the value but see mutations. 
fn share(self: &Dlrc) Dlrc {
    let self: *DlrcBox = get(get(self));
    set(self.rc, add(get(self.rc), 1));
    (self)
}

fn clone(self: &Dlrc) Dlrc {
    let self: Dlrc = get(self);
    ensure_unique(@addr(self));
    self
}

fn dup(self: Dlrc) (Dlrc, Dlrc) = (clone(@addr(self)), self);

fn drop(self: &Dlrc) {
    let self: *DlrcBox = get(get(self));
    set(self.rc, sub(get(self.rc), 1));
    if(eq(self.rc, 0), fn={
        let _ = box_from_raw(self);
    });
}

fn move(self: Dlrc) Dlrc = self;

fn ensure_unique(self: &Dlrc) = {
    if(ne(self.rc, 0), fn={
        set(self, { rc: 1, value: clone(self.value) })
    })
}

fn deref(self: &Dlrc) &DlrcValue = @addr(self.ptr.value);

fn deref_mut(self: &Dlrc) &DlrcValue = {
    if(self.borrowed, fn = ensure_unique(self));
    @addr(self.ptr.value)
}

@example(@assert_compile_error(Custom(COPY_ERR)) { let x: Dlrc = new(); let y = x; let z = x; });
const COPY_ERR = "Dlrc is not Copy. use `clone(d)` to pass a copy or `share(d)` to share mutable access.";
fn copy(&Dlrc) Dlrc = @compile_error(COPY_ERR);

fn get_field(self: &Dlrc, todo()) todo();
