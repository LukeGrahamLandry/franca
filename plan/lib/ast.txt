@in(@module(ast, impl=core, vis=Public))
//! These are the interface used for writing annotations.
//! See annotations.txt for usage examples. 

// TO-DO: how to give each ast a uid? 
// TO-DO: how to express that these are linear types? no copy, no alias. 

// You don't need to declare enum payloads as seperate types like this (they can be inline). 
// Sometimes its useful because it lets you write functions that take a specific case as a parameter.
enum ExprAst = Block | Call | VarAst | TupleLiteral | FnDeclAst | WithFreeVariables | CAny;
struct Block = { 
    // These are run for side effects but thier results are discarded. 
    body: []ExprAst, 
    // TO-DO: nil is the same as unit so why bother? maybe you'd like to know for better error messages? 
    /// This is returned when the block is evalutated. It's the thing at the end without a semicolon. 
    value: ?&ExprAst,
};
struct Call = { name: &ExprAst, arg: &ExprAst };
struct TupleLiteral = ([]ExprAst);
struct FnDeclAst = { Arg: LazyType, Ret: LazyType, body: &WithFreeVariables };

/// Same as interp::Value. 
enum CAny = BigNum | []CAny | {}(CAny, CAny) | Str | Type;

/// - function body: vars=parameters
/// - generic impl body: vars=generic parameters
/// - trait definition body: vars=Self and associated types
struct WithFreeVariables = (Pattern, &ExprAst);

// TO-DO: holy shit, why can't the parser generator take this as input??? 
// Name and optional type annotations that can bind values. 
// - `let <Pattern> = <ExprAst>;`
// - `fn <?Symbol>(<Pattern>) <?ExprAst> = <ExprAst>;`
enum Pattern = []Pattern | Binding; 
struct Binding = { name: ?VarAst, type: ?ExprAst };

/// Bake comptime known values into an ast. 
/// This allows specialization for generics. 
fn bind_variables(replacements: Map(VarAst, CAny), ast: WithFreeVariables) ExprAst;

/// Since types can be comptime expressions, places on the ast that we know must have a type might not be ready yet. 
/// This gives you a way to precive the difference and not just auto evaluate anything you try to look at since it might fail. 
enum LazyType = Finished(Type) | Pending(&ExprAst) | Infer();

fn try_cast(LazyType) ?Type;
fn unwrap(LazyType) Type;

enum VarKind = Let | Var | Const | FuncParam | GenericParam;
struct VarAst = { name: Symbol, uid: i64, decl: VarKind, ty: LazyType };

/// Nil: the compiler cannot infer the type. 
fn expr_type(ast: &ExprAst) ?Type;
fn eval_expr(ast: ExprAst) CAny = eval_expr(CAny, ast);
/// Calling this one is better because it lets you give a type hint. 
fn eval_expr(T: Type, ast: ExprAst) Result(T, _);

struct CommentAst = (Str);
fn get_comments(ast: ExprAst) ?CommentAst;

// TO-DO: might not want to provide this because then i need to keep parent ptrs all the time. 
fn get_parent(ast: ExprAst) ?ExprAst;

// TO-DO: figure out if this is the right name. https://stackoverflow.com/questions/134887/when-to-use-or-quote-in-lisp
//       maybe dont bother trying to feel clever and just call it parse. 
/// Manually invoke the parser on a computed string. Useful for code generation when the ast api is too verbose. 
/// The result may have free variables that you can fill in later. 
@comptime 
fn quote(Str) AstExpr;

fun same_ast(a: Str, b: Str) = assert_eq(parse_ast(a), parse_ast(b));

// Produce a constant literal. 
fn cast(Type) AstExpr;
fn empty() Pattern;

fun fn_decl(name: ?Symbol, args: Pattern = empty(), ret: ?AstExpr, body: ?AstExpr) FnDeclAst;


struct AnnotationHandler = { Arg: T, Target: T, Ret: T, f: fn(Arg, Target) Ret };
struct OverloadHandler = fn(Arg: ?Type, Ret: ?Type) ?FnDecl;

struct GenericHandler = { 
    Input: Pattern, // Map(VarAst, Type)
    // Tell the compiler what would be created if it could produce a valid Input. 
    output_fns: []FnSig,
    output_types: []TypeSig, 
    // Quickly check if an input is valid. 
    // TO-DO: run could just return a result but maybe you only want to check, idk.
    cond: fn(as_param(Input)) bool,
    // Given a valid input, bake it into the asts. 
    run: fn(as_param(Input)) AstExpr, 
};

// TO-DO: maybe drop the `Ast` suffix. its unlikely to be ambigous and if you want namespaces you can use modules for that. 
// TO-DO: think about @import(module_name) @import(module_name, func_name) @import(module_name, as, some_alias) @import(module_name, (func_name, as, some_alias))

fn parse_ast(Str) ExprAst;

// Func Arg
call_expr(for, (iter, f))

// If a function's parameter declaration uses this pattern, what type could you call it with? 
fn as_param(Pattern) TupleType;

// TO-DO: instead of this, use @annotation(Collect)
@module(compiler, all=Public) {
    //! You don't want fancy comptime execution to mean everything is a black box to the compiler. 
    
    // TO-DO: these are local to a module. 
    fn annotation_handlers() {}(Symbol, []AnnotationHandler);
    fn overload_handlers() {}(Symbol, []OverloadHandler);
}

fn CRes(T: Type) Type = Result(T, CompileError);

// This is too trivial to be its own function but will get harder when i want more advanced pattern matching. 
fn completely_matches(pattern: Pattern, (expected, _): WithFreeVariables) bool = eq(pattern, expected);

// TO-DO: this will need to do `cast` coerecion? 
// TO-DO: its fine if there are more avilabale args than consumed ones
fn can_call(available_args: Pattern, func: FnDeclAst) bool = completely_matches(pattern, arg_pattern(func));

// Find a type that all `types` can `cast` to. 
// Used for typechecking branching execution paths that rejoin eventually. 
fn resolve_fold_types(types: []Type) Result(Type, _);

// TO-DO: @static === @switch(Type, fn(T: Type) = eq(T, @Self))

// TO-DO: this should be a trait 
// TO-DO: Result(T, E) -> (T, E)
fn Destructure(@type T) StructuralPattern;
fn destructure(T) StructuralPattern; 

// TO-DO: move to types.txt
@invarient(@comptime fn(E: EnumType) bool = is(E, Structured));
@invarient(@comptime fn(S: StructType) bool = is(S, Structured));
@trait(Structured, S) {
    //! This will be used for pattern matching.
    //! The quintessential example of this trait is an enum (tagged union). 
    
    /// For an enum, this list contains the payload of each case. 
    /// When using @match, 
    @static const Raw: []Type;
    
    /// These functions must have overloads for each type in `Raw`
    @pure fn destructure(S) OneOf(Raw); 
    @pure fn restructure(OneOf(Raw)) S;
}

// TO-DO: @static syntax for declaring and defining an associated static constant for a trait.
// Blockers: 
//         Annotations need a way to access the parent block so @static can know if its in an @impl or an @trait. 
//         annotations need a precidence. does impl see @static or does static see @impl? 
//         my thought so far has been annotations can never see other annotations except @tag, 
//         ok so static needs to be an @tag 
//         - @impl: assert the condition is just a single trait name OR @static(TraitName),
//                  check it requires that constant, and save it in a CollectMap
//         - @trait: add it to the trait's 

@impl(E, EnumType) {
    @static const Raw = Payloads(E);
}