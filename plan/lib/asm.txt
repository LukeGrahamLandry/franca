

const Reg = Unique(i64);
const Label = Unique(i64);
const Num = .{ Reg: Reg, Imm: i64, }!enum;
const BinOp = .{ Add: (), Mul: (), Sub: (), Div: (), }!enum;
const Inst = .{ 
    Load: .{ dest: Reg, ptr: Reg, }!struct,
    Store: .{ ptr: Reg, src: Reg, }!struct,
    Mov: .{ dest: Reg, src: Reg }!struct,
    Bin: .{ dest: Reg, a: Num, b: Num, op: BinOp }!struct,
    Ret: (),
    Jump: Label,
    Call: .{ local: Label, global: Symbol, }!enum,
};
const Block = .{ insts: List(Inst), }!struct;
const Program = .{ blocks: List(Block), }!struct;

/*
@trait EmitAsm {
    
}
*/

// TO-DO: I'm gonna want good bit-field support for doing instruction encoding. 
//       - https://devlog.hexops.com/2022/packed-structs-in-zig/
//       - https://www.erlang.org/doc/programming_examples/bit_syntax.html
//
// TO-DO: I feel like people often write these as calling methods on a builder for each instruction, 
//       so you dont have to do multiple passes and can support outputing a data structure or the code directly. 
//       Is that better than taking a closure as an argument and calling like yield(Inst) every time? 
//       I guess they're obbiously isomorphic until you want to do multiple things like block vs inst. 
//       and then do you pass multiple closures? now you're just reinventing the builder trait but uglier. 
//       But its probably not rare to want to see the whole structure at once and its sad to manually write 
//       the builder that just stores all the calls. 
//       The thing where you have to force a noun for something that's logically a verb annoys me. 
//
