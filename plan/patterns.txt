
// I'd really like function arguments, struct fields, and variable declarations to all be the same thing.
// So what are the requirements for that feeling familiar and do they conflict?

// Normal variables
let a = 0;
let a: i64 = 0;

// Normal functions
fn z(c: i64, d: i64);
z(a, b);

// Destructing variables
let both = (1, 2);
let (a, b) = both;
const P = (i64, i64);
let (a, b): P = both;
// Still allow using tuples as values.
let a = both;

// Same for functions makes sense
fn y((c, d): P);
fn x((c, d): (i64, i64));

// should be able to pull out part and discard the rest
let (aa, _) = both;
// before it felt fine to force the type annotation on the outside
let (aa, _): P = both;
// but now why am I naming the type that I don't care about, so doing this would be nice:
let (aa: i64, _) = both;
// But then this is weird, you have to store two type annotations
let (aa: i64, _): P = both;

// So it feels like you should be able to destructure/restructure into a call without an intermediate variable.
x(a, b); y(a, b); z(a, b);
x(both); y(both); z(both);

// I want to allow specifiers, so you can say when
// - const: each used value should be baked into a new version of the function
// - let: bare struct can actually be passed by reference since we won't mutate it. (but that's a different thing than deep immutability...)
// - var: be passed by copy / have a stack slot (but really those are two different things...)
// - but still allow empty so if you don't care it doesn't have to get noisy.
fn w(var a: i64, let b: i64, const c: i64, d: i64);
w(1, 2, 3, 4);

// I guess you should be able to say you want to apply to multiple, that's fine and matches what I want for variables.
fn v(let (c: i64, d: i64));

// But then can you do this? I guess why not if I'm doing it for functions anyway,
// but it looks odd that now it looks like you're in a tuple but oops it's actually a declaration.
// Rust has `let (aa, mut b) = both` for this situation. But then `var (aa, b);` becomes `let (mut aa, mut b);`
(let aa, var b) = both;

// So then this should be allowed too.
fn u(c: i64, (var d: i64, let e: i64));
// But what if you call it like this?
u((1, 2), 3);
// Maybe that's fine, but it feels wrong, what if there was a semantic meaning?
fn scale(vec: (i64, i64), scale: i64);
let position = (1, 2);
scale(1.5, position);  // this would typecheck.
// Maybe just declare that you should be using unique types.
const Pos = Unique((i64, i64));
fn scale2(vec: Pos, scale: i64);
let pos: Pos = (1, 2);
scale2(pos, 1.5);
scale2(1.5, pos)!assert_compile_error;

// Named arguments would help.
scale(position, scale: 1.5);
// and that would go well with default arguments.
fn t(a: i64, b: i64 = 1, c: i64 = 1);
t(1, b: 2);
t(1, c: 2);
t(1, b: 12, c: 13);
// Should you be allowed to change the order? I guess why not if they're named.
t(1, c: 5, b: 6);
// But that implies you could do it for non-default too if I let just any arg be used as named.
fn s(a: i64, b: i64, c: i64);
s(c: 1, a: 2, b: 3); s(2, 3, 1); // same
// But this is a problem.
s(999, a: 1, b: 1); s(1, 1, 999); // same
// So maybe you require that all positional arguments be before named ones in the call.
// And then there's the problem of changing your argument names might screw up your callers.

// But somehow that all feels fine for structs.
const S = .{ a: i64, b: i64, c: i64 }!struct;
// Reordering seems totally normal.
let a: S = .{ c: 3, a: 2, b: 1 };
// In fact, it's the opposite. Positional fields feel uncomfortable.
// C has compound literals like this tho.
let b: S = .{ 2, 1, 3 };

// I like default field values (of some constant expression), feels like less boilerplate than forcing a constructor function.
const M = .{ a: i64, b: i64 = 6, c: i64 = 5 }!struct;
let a: M = .{ a: 1 };
let b: M = .{ a: 1, b: 66, c: 55 };
// But then if you decide you need a constructor, you have to change all the places you created the struct.
// Could define that initialization syntax as calling a function generated by the compiler.
// Which you can just define yourself if you want to retroactively add a constructor.
// But now you never know when your secretly calling a function which is a little uncomfortable too.
// A bit weird because how do you create one in init if this is what the init syntax calls?
// Maybe that syntax means something different here? But that sucks.
fn init(a: i64, b: i64 = 6, c: i64 = 5) M;

// I don't like that you'd have to write out everything twice.
// So maybe you could have an annotation to define a struct and its constructor at the same time.
@struct fn N(a: i64, b: i64 = 9, c: i64 = 8);
let a: N = .{ a: 1, b: 2 };
let a: N = init(a: 1, b: 2);
// Maybe you could even call it like this. It's kinda prettier than the .{ _ } syntax anyway.
// But then its ambiguous does N refer to the type or the init function?
// It's hard to avoid accidentally inventing Swift.
let a = N(a: 2, b: 3);

// I guess the problem is there's fundamentally two things I'm trying to use structs for.
// - put some bytes in memory, and it would be nice if the offsets had names.
// - use the type system to enforce a contract so every operation wants to run arbitrary code.
// Zig wants everything to be the first and Kotlin wants everything to be the second.
// Really the determining factor is do I allow private fields.
// It feels silly not to but in a language that lets you transmute a pointer it's kinda dumb to pretend there's any rules at all.

// A problem with my way of representing patterns,
let a = 0;  // Name=Var(a), Type=Infer
f(a);  // Name=None, Type=Var(a)
