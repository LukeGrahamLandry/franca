!!! this is how it worked on May 9 !!!
:UnquotePlaceholders

You have some macro declaration like
```
#macro fn example(e: FatExpr) FatExpr = 'something(<e>)';
```

The parser desugars the '' and <> syntax to 
    (something((e)!unquote))!quote

Then, when that function body is compiled, the quoted expression is transformed to: 
    unquote_macro_apply_placeholders(@slice (something(0!placeholder)!quote, e)))

The unquotes are replaces with placeholder indices, and the whole thing is turned into a slice. 
The first element of the slice is the template, and the rest are arguments to be subbed in. 
The first thing is not actually a !quote, its a Value::_ of that ast, but its functionally equivalent. 
The later expressions are not evaluated now, they're just normal runtime expressions, 
that will be evalualted when the macro function is called, that happen to return AST nodes. 
So that's the first time Unquote::walk is used, once when the macro is compiled, it converts !unquote to !placeholder, 
and !quote to a call to unquote_macro_apply_placeholders. 
At this point there's been no renumbering. 
Any constants declared in blocks inside the quoted expression are NOT YET hoisted out of the expression. 
Hoisting only happens after the expansion when the caller tries to actually compile a block created by the macro. 


The call to unquote_macro_apply_placeholders is not evaluated during compilation of the macro. 
It's done every time the macro is expanded at a callsite (still during comptime, just someone else's comptime). 
That slice is evaluated like normal so now there's just a bunch of ast values on the stack which are passed to 
unquo....ders (which is declared in the compiler). 
At this point, there's no <_> expressions to worry about, we just have to sub in each argument for the right !placeholder (by index). 
