/*
This is indented to be a quick overview of the syntax to access language features implemented so far. 
For more detailed examples of how they work, see the `tests` folder.

The core language is relatively small with many ergonomic features implemented in the standard library instead of the compiler, and thus not covered here. 
> Including but not limited to: match/switch statements, iteration constructs, slices, dynamic memory allocation, io, format strings, short-circuiting operators. 

## Comments

- Single line: // whatever
- Multi line: /* whatever */
    - allows nesting /* a /* b */ c */

## Statements

The top level of your program is a sequence of statements. 

- Function Declaration
    - `fn name(arg: ArgT) Ret = body;` OR `fn name(arg: ArgT) Ret = { body }` (no semicolon needed)
    - ArgT/Ret/body are expressions. 
    - Forward declarations have no body. 
    - 'fun F' === '#pub fn F'
    - arg bindings can have const/let/var specifiers. let is the default. 
- Eval Expr
    - An expression followed by a semicolon is run for side effects and its result is discarded. 
- Variable Declaration: kind name: T = value;
    - T and value are expressions.
    - kind can be var/let/const. its optional, default is var. use ':' instead of '=' for const. 
    - type can be infered from value 
    - for var, value can be '()!uninitialized'
- Variable Assignment: place = value;
    - both are expressions. 
    - place can be a variable name or pointer dereference. 
- Backpassing: let name <- call; 
    - pass the whole rest of the block as a closure with 'name' as its argument as the last argument to call. 
    - '{ let a: b <- c(d); e }' === '{ c(d, fn(a: b) = { e }) }'

The order of function and constant declarations does not matter. 

### #Hash Macros (Function)

A function declaration statement can have any number of annotations preceding it. 

- #generic
    - Allow using the argument values in the return type expression. requires #comptime currently. 
- #comptime
    - All arguments must be const. 
    - Will run during compilation as with the '::' operator. 
- #inline
- #noinline
- #c_call
- #flat_call
- #macro
    - This function defines an @At Macro. Implies #ct and #flat_call
- #outputs(T)
    - hints to the compiler that this macro will always expand to an expression of type T. requires #macro
- #ct
    - This function needs the compiler context. Generally implies it can only be called at comptime.
- #aarch64 
- #llvm 
- #when(cond)
    - the func will not be declared if the condition is false. 
- #rs
    - Translate that function into rust.
    - Used for the instruction encoding stuff that the compiler needs to call.
- #bs
    - Save the asm of that function and use that instead of trying to compile it.
    - Used for the math you need to run the output of @bits for assembling other inline asm at comptime.
- #test(A)
    - TODO: HACK
- #pub
    - allowed to be added to an overload set with other public functions
## Expressions

An expression is any number of prefixes, one inner, and then any number of suffixes. 

### Prefix

- *T === operator_star_prefix(T)
- ?T === operator_question_prefix(T)
- ::e === e!const_eval

### Inner

- Variable Access: raw identifier
- Tuple: (a, b, c)
- Struct Literal: (name: Value, a: b)
- Closure: fn(args: A) T = body
- Block: { S1; S2; e }
- Number: 16 === 0b10000 === 0x10
- String: "Hello World"
    - multiline raw: """S""" and `S`
- @At Macro: @name(A) B
- Float: 12.34
- 'e' === e!quote
- <e> === e!unquote

### Suffix

- Function Call: e(args)
    - a tuple used as arguments
- Field Access: e.name
    - returns a pointer
    - struct: compute a field offset
    - enum: access a payload (illegal to access an inactive varient)
- Dot Call: e.name(a) 
    - syntax sugar for 'name(e, a)'
    - not dynamic dispatch. nothing special about function declaration to make it a method. 
    - higher precidence than field access so you need brackets if you meant to use a callable field. 
- Dollar call: e$a
    - syntax sugar for 'e(a)'
- Trailing Lambda 
    - 'e(a){(b: B) R| c}' === 'e(a, fn(b: B) R = c)'
- Bang Macro: e!name
- e[] === e!deref
- e&  === e!addr

#### !Bang Macros

- (cond, f, t)!if
- (cond, body)!while
- e!deref
    - as a value expression: read from a pointer
    - as a place expression: refer to the place pointed to
    - e[] === e!deref
- e!addr: get the address of a variable
    - e& === e!addr
- e!slice
- e!tag: get the address of an enum value's tag
- e!type: get the type of a value. the expression is not evaluated
- e!symbol: add an identifier to the compiler's intern pool
- e!comptime_print: print the ast of the expression and the value it produces
- e!assert_compile_error
- e!asm:
- e!quote === 'e'
    - get the ast for e as a value
- e!unquote === <e>
    - only valid inside a !quote expression. 
    - evaluate 'e' and put the resulting ast in its place. 
- e!fn_ptr
- e!const_eval === ::e
    - force e to be evaluated at comptime. throw an error if it can't be done. 
- '!uninitialized' 
    - an unspecified value. it is illegal to read the value, but you can write over it. 

> '!name' === '()!name'

### @At Macros (Expr)

- '@as(T) e'
- @struct(e) 
    - treat a struct literal as a type definition
    - a product type with named fields. 
- @tagged(e)
    - treat a struct literal as the definition of a sum type with named varients. 
- '@enum(Raw) (A = B)' === '(T: Type = Unique(Raw), A: T = B)'
    - a unique type that only permits a subset of values of the backing type. 

*/
