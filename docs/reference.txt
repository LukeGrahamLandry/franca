/*
This is indented to be a quick overview of the syntax to access language features implemented so far. 
For more detailed examples of how they work, see the `tests` folder (they tend to be well commented).


## Comments

- Single line: // whatever
- Multi line: /* whatever */
    - allows nesting /* a /* b */ c */

## Statements

The top level of your program is a sequence of statements that execute at compile time. 

- Function Declaration
    - `fn name(arg: ArgT) Ret = body;` OR `fn name(arg: ArgT) Ret = { body }` (no semicolon needed)
    - ArgT/Ret/body are expressions. 
    - Forward declarations have no body and must be builtins supplied by the interpreter. 
- Eval Expr
    - An expression followed by a semicolon is run for side effects and its result is discarded. 
- Variable Declaration: kind name: T = value;
    - T and value are expressions.
    - kind can be var/let/const
    - type can be infered from value 
    - for var, value is optional, can be uninitialized
- Variable Assignment: place = value;
    - both are expressions. place is treated a bit differently but probably intuative. 

### @At Macros

A statement can have any number of annotations preceding it. 

- @comptime
    - Allow using the argument values in the return type expression. 
- @inline
- @noinline

## Expressions

An expression is any number of prefixes then one inner then any number of suffixes

### Prefix

- Type modifiers: &, *, [], {}, ^

### Inner

- Variable Access: raw identifier
- Tuple: (a, b, c)
- Struct Literal: .{ name: Value, a: b, }
- Closure: fn(args: A) T = body
- Block 
- Number
- String

### Suffix

- Function Call: e(args)
    - a tuple used as arguments
- Field Access: e.name
    - returns a pointer
    - struct: compute a field offset
    - enum: access a payload (illegal to access an inactive varient)
    
#### !Bang Macros

- e!deref
    - as a value expression: read from a pointer
    - as a place expression: refer to the place pointed to
    - e[] === e!deref
- e!addr: get the address of a variable
- e!tag: get the address of an enum value's tag
- e!type: get the type of a value. the expression is not evaluated
- e!struct: treat a struct literal as a type definition
- e!enum: treat a struct literal as an enum definition 
- e!symbol: add an identifier to the compiler's intern pool
- e!comptime_print: print the ast of the expression and the value it produces
- e!assert_compile_error

*/