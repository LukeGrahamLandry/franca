
driver :: fn(_: *ImportVTable) void = {
    outfile := "target/a.out";
    if cli_args().contains(fn(it) => it[] == "-notfirst") {
        jit_then_aot(outfile);
    } else {
        who_drives_the_driver(outfile);
    };
};

jit_then_aot :: fn(outfile: Str) void = {
    m := @ref @uninitialized Qbe.Module;
    init_default_module(m, (
        os = current_os(), 
        arch = current_arch(), 
        type = .Exe,
        exe_debug_symbol_table = true,
    ));
    
        vtable := init_driver_vtable(false);
        opts := vtable.default_build_options();
        if cli_args().contains(fn(it) => it[] == "-unsafe") {
            it := opts.safety_checks&;
            it.insert(.Bounds, false);
            it.insert(.DebugAssertions, false);
            it.insert(.InvalidTag, false);
        };
        opts.retain_function_names = true;
        src := """#include_std("lib/core.fr"); #include_std("compiler/main.fr"); """;
        c := new_with_src(vtable, src, "entry_file", opts);
        c := vtable.with(c);
        fid := or c.get_unique_named("main") {
            panic("expected exactly one function called 'main'")
        };
        self := c.data.cast()[][];
        pending := FuncId.list(temp());
        shared := init_codegen(m, c.get_alloc(), false);
        main_thread_pump(self, shared, @slice(fid), true, EmitIrA());
        seal_debug_info(m, empty(), false, empty());
    
    bytes := {m.target.finish_module}(m);
    bytes := concat(bytes, temp());
    write_entire_file_or_crash(outfile, bytes);
    drop(m);
    c'vtable'destroy_compiler(c.data);
};

who_drives_the_driver :: fn(outfile: Str) void = {
    unsafe := cli_args().contains(fn(it) => it[] == "-unsafe");
    safety := @if(unsafe, "-unsafe", "-safe");
    println(":SLOW this can take [12 seconds, 17 seconds, 7 minutes, 23 minutes] depending on settings");
    parent := get_executable_path(temp());
    DUMB_EMIT_IR := @tfmt("%=1", Foreign.ENV.DUMB_EMIT_IR);
    @if(unsafe) println("TODO: unsafe doesn't work with vm");
    
    // build the one that's compiled natively but will compile new things to easy_abi.
    // eventually this will be written in a different language. 
    args := @slice(DUMB_EMIT_IR, parent, "examples/default_driver.fr", "build", "compiler/main.fr", "-o", outfile, safety, "-keep-names");
    run_cmd_blocking(Foreign.EXE.env, args)
        || @panic("failed stage 1");
    
    // that compiler can't output executables. 
    // use it to jit one that's compiled easy_abi but compiles to native. 
    // and then use that jitted one to output a native one. 
    args := @slice(DUMB_EMIT_IR, outfile, @source_file_name(), "-notfirst", safety);
    run_cmd_blocking(Foreign.EXE.env, args)
        || @panic("failed stage 2");
    
    // the one we have now is native and outputs native
    // but still doesn't export the backend so can't run the normal default_driver. 
    // once again use it to jit new one and use the jitted one to output an exe. 
    // TODO: this step is silly, it works if you export it one earlier...
    //       but then the stabilization takes 4 steps instead of 3 so meh. 
    args := @slice(@source_file_name(), "-notfirst", safety);
    run_cmd_blocking(outfile, args)
        || @panic("failed stage 3");

    // now we have the full compiler. 
    // rebuild until it repros
    digest := Sha256'hex(read_entire_file_or_crash(temp(), outfile));
    i := 0;
    dowhile {
        @println("stabilizing; %: %", i, digest);
        i += 1;
        args := @slice("examples/default_driver.fr", "build", "compiler/main.fr", "-o", outfile, safety);
        run_cmd_blocking(outfile, args)
            || @panic("failed stabilization %", i);
        
        old := digest;
        digest = Sha256'hex(read_entire_file_or_crash(temp(), outfile));
        digest != old
    };
};

#include_std("compiler/lib.fr");

DISABLE_IMPORT_FRC :: true;
DEBUG_SPAM_LOG :: false;
