
extern_to_easy_abi_dyncall_shim :: fn(arg: *u8, ret: *u8, callee: @FnPtr(ret: *u8, arg: *u8) void) void = {
    callee(ret, arg);
}

easy_abi_emit_shim :: fn(c: *SelfHosted, fid: FuncId) void = {
    shared := c.comptime_codegen;
    handler_callee_address: rawptr = report_called_uncompiled_or_just_fix_the_problem;
    m := shared.m; 
    func := c.get_function(fid);
    c.when_debug(.Shim, fn(o) => @fmt(o, "S: create %", fmt_func(c, fid)));
    id := Qbe.no_symbol_S;
    enter_task shared { entry |
        id = m.intern(@tfmt("%__shim", fid));
        
        // create a new function
        f := temp().box_uninit(Qbe.Fn);
        f.default_init(m);
        f.lnk.no_inline = true;
        f.lnk.id = id;
        f.start = newblk(); 
        f.nblk = 1;
        target_id := c.comptime_jit_symbol_id(fid);
        entry.task = (Shim = (f = f, shim_for = target_id));
        
        input, output := (f.newtmp("input", .Kl), f.newtmp("output", .Kl));
        b := f.start;
        push(b, make_ins(.par, .Kl, output, QbeNull, QbeNull));
        push(b, make_ins(.par, .Kl, input, QbeNull, QbeNull));
        
        // call into the compiler to get the real callee
        // TODO: only right first generation
        callee := f.newtmp("callee", .Kl);
        push(b, make_ins(.arg,  .Kl, QbeNull, f.getcon(SelfHosted.int_from_ptr(c)), QbeNull));
        push(b, make_ins(.arg,  .Kw, QbeNull, f.getcon(fid.as_index()), QbeNull));
        push(b, make_ins(.call, .Kl, callee, f.getcon(handler_callee_address.int_from_rawptr()), QbeNull));

        push(b, make_ins(.arg, .Kl, QbeNull, output, QbeNull));
        push(b, make_ins(.arg, .Kl, QbeNull, input, QbeNull));
        push(b, make_ins(.call, .Kw, Qbe.Null, callee, Qbe.Null));
        
        f.ret_cls = .Kx;
        b.jmp.type = .ret0;
    };
    c.created_jit_fn_ptr_value(fid, shared.wait_for_symbol(id));
}

init_child_tls :: fn(a: Alloc, n: i64) void = {
    @if(@run(__driver_abi_version < 1512)) unreachable();
    // get_stack_base_for_tls
    aa := @uninitialized i64;
    base := i64.int_from_ptr(aa&).bit_and(bit_not(1.shift_left(n) - 1));
    t := StaticTls.ptr_from_int(base);
    
    t[] = StaticTls.ptr_from_int(get_stack_base_for_tls())[];
    
    it :: resolve_overload(print_and_exit1, Str, Never, @source_location);
    hook := bit_cast_unchecked(rawptr, @type tls(.panic_hook)[], @run wrap_with_easy_abi(it));
    t.panic_hook = hook;
    A :: import("@/lib/alloc/fixed_block.fr").BlockAlloc;
    gen := a.boxed(A, init(page_allocator));
    gen := gen.borrow();
    gen.vptr = bit_cast_unchecked(rawptr, @type gen.vptr, @run wrap_with_easy_abi(A.A));
    t.general_allocator = gen;
    tmp := a.boxed(Arena.Allocator, init(page_allocator, 1.shift_left(20)));
    t.temporary_allocator = tmp;  // TODO: not needed
    tmp := tmp.borrow();
    tmp.vptr = bit_cast_unchecked(rawptr, @type tmp.vptr, @run wrap_with_easy_abi(Arena.arena_allocator_fn));
    t.temporary_allocator_i = tmp;
}
