
@unsafe trait FfiModule for M when {
    // TODO: associated types. has an obvious generic desugar where you just test eqauality. 
    const TypeRef: Type; 
    @auto const FnRef = TypeRef;
    const ParseErr: Type;
    const Metadata: Type;
    
    fn get_struct(&M, TypeRef) Type;
    fn get_function(&M, FnRef) Type;
    fn get_child(&M, name: Str) ?&M;
    fn get_all(&M) (Map(TypeRef, Type), Map(FnRef, AnyFn));
    
    fn supported(&M) FlagSet(Target);
    fn currently_supported(self: &M) bool = contains(supported(self), get_target());
    
    fn parse_bindings(host: SrcCode) Result(M, ParseErr);
    
    // The result is franca code that may be cached by the compiler. 
    // It must include PtrFlags, StructLayout, clone/drop functions, etc.
    fn serialize(&M) SrcCode;
}

struct SrcCode = (Str, @comptime Target);

///////////////
/// Parsing ///
///////////////

enum Grammar = 
    (Str, Type, &Grammar) 
    | (Str, &Grammar) 
    | seq(Array(Grammar))
    | optional(&Grammar)
    | lit(Str)
    | is_present(&Grammar)
    | choice(Array(Grammar))
    | many(Array(Grammar))
    | many_sep(&Grammar, &Grammar)
    | hide(&Grammar)
    | ident
;

// TODO: doc: @code require that this type can be serialized to code. 
// Needs `@code` so it can be cached by the compiler. 
@code struct Parser = { T: Type, E: Type, parse: fn(Str) Result(T, E) };

// TODO: simple parser combinator impl. 
@module(parse_grammar) {
    fn combinator(&Grammar) Parser;
}

fn cast(g: &Grammar) Type = @match(g) {
    fn(name: Str, T: Type, &Grammar) 
}

@module(parse_grammar, impl=tree_walk) {
    @pub fn combinator(g: &Grammar) Parser = {
        T: as(Type, g), E: (), parse: fn(s) = {
            var out: T = default();
            @match (parse(g, @addr(out), s)) {
                fn ok(_) = Ok(out);
                fn err(_) = Err(());
            }
        }
    }
    
    fn parse(g: &@comptime Grammar, output: ?&g, s: Str) Result((Output, Str), Str) = @match(g) {
        fn(name: Str, T: Type, g: &Grammar) = parse(g, as(&T, get_field(output, name)), s);
        fn(name: Str, g: &Grammar) = parse(g, get_field(output, name), s);
        fn seq(arr: []Grammar) = reduce(arr, s, fn(s: Str, g: &Grammar) = parse(g, output, s));
        fn optional(g: &Grammar) = @match parse(),
        fn lit(want: Str) = if(starts_with(s, want), fn=Ok((), drop_first(s, len(want))), fn=Err(s)),
        fn is_present(g: &Grammar) = @match(parse(g, output, s) = {
            fn ok(_, rest) = Ok(true, rest);
            fn err(_, rest) = Ok(false, rest);
        }
        fn choice(arr: []Grammar) = ;
        fn many(Array(Grammar)) = ;
        fn many_sep(&Grammar, &Grammar) ;
        fn hide(g: &Grammar) = parse(g, nil(), s);
        fn ident() = if(contains("1234567890", first(s)), fn=Err(s)), fn={
            var found = "";
            var rest = s;
            while(fn = is_safe_identifier(first(rest)), fn={
                let (first, others) = slice_at(rest, 1);
                push(found, first);
                rest = others;
            });
            if(gt(len(found), 0), fn=Ok((found, rest)), fn=Err((s)))
        })
    }
}

///////////////////////////////////////////////////////////////

// For targeting js: 
const spec = get_resource(String, sha1("3e63dbbf28c145a7bcb2fcb6ccfb8747431fda37"), url("https://raw.githubusercontent.com/microsoft/TypeScript/d69757e3d39d48eaa798e6e542dd416f8aac2c93/src/lib/dom.generated.d.ts")); 
const js_dom = cached_type_provider(unwrap(spec), "js_dom", import_typescript_types);

fn import_typescript_types(name: Str, src: String) ModuleDecl = {
    @todo
}

// Tell me what you want and where to get it, and I'll see if they have it. 
fn get_resource(T: Type, ?ContentHash, Url) Result(Resource(T), _);

// This is overly restrictive. Many languages allow fancy unique in identifiers.
// But it feels like when I'm generating code, I don't want to tempt fate. 
// The goal is make sure you can't do arbitrary code injection by importing .d.ts files and generating source code off them. 
// TODO: When importing the cached file, have a way to specify that its not allowed comptime execution or defining function bodies. 
// TODO: can do this much faster by using character numbers
fn is_safe_identifier(i: Str) bool = and(
    not(starts_with_any(i, "1234567890")),
    contains_only(i, "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890_")
);
