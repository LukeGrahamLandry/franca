//
// This file contains types useful for representing runtime polymorphism.
// They're also useful for ffi with dynamically typed languages.  
//

//
// This is different from the way rust does it. 
// They have Any be unsized so you always have a Box<Any>, 
// but it doesn't need a double allocation because Box can hold a fat pointer inline. 
// So far, my pointer types don't do that. 
// So Box<(TypeID, Box(T))> would need two alocations. 
// You could also do it like rust's Rc so Any is unsized because its just (TypeID, T),
// but now you have to dereference the pointer to get the metadata, 
// and reallocate to turn a Box<T> into a Box<Any> (which is more obviously bad).
// Both have the problem of you can't put a trait object in an any without a double allocation.  
//
@module(any, impl=core){
    for Ref with PtrLike(Ref) {
        // - Any is not generic over the inner type, just the pointer type. 
        // - There's no object satefy restrictions, since you always cast it back to a concrete type before using. 
        struct Any(Ref) = (TypeId, Ref(Unit));
        
        fn type_id((id, _): Any(Ref)) TypeId = id;
        
        for T {
            fn any(ptr: Ref(T)) Any(Ref) = Any(type_id(T), forget_type(ptr));
            
            // Returns nil if the type in the Any is not *exactly* T. 
            fn try_cast((id, ptr): Any(Ref)) ?Ref(T) = 
                if(eq(type_id(T), id), fn = assume_type(ptr), fn = nil())
        }
    }
    
    let TypeMap(T) = HashMap(TypeId, T);
    
    for Types with eq(Types, Slice(Type)) {
        let M = FixedAnyArray(Types);
        
        fn get(&M, Key: Type) Slice(Key);
    }
    
    // When all cases of E have payload unit, eq(E, Tag(E));
    for E with is_enum(E) {
        for T {
            // Like a HashMap(Tag(E), T) but does not need dynamic memory allocation. 
            struct EnumMap(E, T) = @todo; 
            fn get(self: &EnumMap(E, T), key: Tag(E)) ?&T;
            fn set(self: &EnumMap(E, T), key: &Tag(E), value: T) ?T;
        }
    }
}

// The wizard installs all programs that do not install themselves. 
// Who installs the wizard? 
// I cry because I do not know. 

trait VTable(V) = fn get(&V, name: fields(V), Arg: Type, Ret: Type) FnPtr((&Unit, Arg), Ret);

// TODO: object safety 
for (T, V) with and(fn get_vtable(&T) &V, VTable(V)) {
    for Ref with deref(Ref) &T {
        struct Dyn(V, Ref) = (&V, Ref(Unit));
        
        fn dyn(ptr: Ref(T)) Dyn(V, Ref) = (get_vtable(ptr), ptr);
        
        fn get_vtable((v, _): Dyn(V, Ref)) &V = v;
        
        fn get((v, _): &Dyn(V), name: fields(V), Arg: Type, Ret: Type) FnPtr((&T, Arg), Ret) = 
            get(v, name, (&T, Arg), Ret)
        
        // trait A(T) = fn name(&T, Arg) Ret;
        // trait B(T) = get(&T, name, Arg, Ret) FnPtr((&T, Arg), Ret);
    }
    
    // TODO: DynArray where you have one array for each implementation of the trait 
    //     
}

//
// TODO: inheritance
//       if `B extends A` then `VTable(B) extends VTable(A) `

//
// The bit pattern for the character w is reserved for future expansion. 
//

for E with is_enum(E){
    @comptime fn cast(@type_of(E)) Map(@comptime Str, Type);
}

// TODO: maybe split meta.txt into types.txt and build.txt
// TODO: move to meta.txt
trait Struct for S when {
    // An enum is a convient way of representing a Map(Str, Type). 
    fn fields(type_of(S)) E with is_enum(E);
    
    @auto fn field_type(@type_of(S), name: @comptime Tag(fields(S))) Type = payload(fields(S), name);
    
    @auto fn get_field(&S, name: field_names(S)) &field_type(S, name);
}

// A duck is like an object in javascript/python. 
// It's like an Any but you don't need to cast it back to a statically known type before using. 
// The compiler could use the host's native object representation when targetting a dynamic language. 
trait Duck for D when {
    // A duck could be anything.
    for T {
        fn from(T) D;
        fn try_cast(D) ?T;
    }
    
    // A duck is also a hash table for some reason. 
    fn get_field(&D, name: @comptime Str) &Duck;
    fn set_field(&D, name: @comptime Str, Duck);
    
    // A duck is also a function for some reason. 
    fn call(&D, args: Slice(Duck)) Duck;
    
    // Produce the null duck (aka. goose).
    fn default() D;
    
    // Ducks can multiply.
    fn copy(&D) D;
    
    // Please don't leak your ducks.
    fn drop(&D);
    
    // Hint how you will use the duck. 
    // Fields can still be added latter, but that would be rude. 
    fn with_fields(names: Slice(@comptime Str) Duck;
}

@module(duck, impl=slow){
    struct SlowDuck = Hashmap(@comptime Str, SlowDuck);

    fn get_field(self: &SlowDuck, name: @comptime Str) ?&Duck = get(self, name);
    fn set_field(self: &SlowDuck, name: @comptime Str, value: Duck) = set(self, name, );
    
    fn call(&D, args: Slice(Duck)) Duck = panic("The SlowDuck didn't answer the phone.");
}

// TODO: use let instead of struct for type constants. 

// TODO: move these to auto_traits.txt

// TODO: base=true for modules you're just allowed to have for free from the universe. 
let MagicFlags = FlagSet(
    AutoCall 
    // Automatically apply the blanket implementations from auto_traits to new types created in this module. 
    // If this is not set, the derive becomes opt in and you can apply it on a specific type with an annotation. 
    | CompilerDerive
    // Functions you define in this module can replace the derived version. 
    | AllowOverload 
);

enum MagicFunction = 
    Copy | Cast | Drop | Move | Default
    | TryCast | Clone | Unwrap | GetField | SetField;

//
// TODO: sane_defaults.txt. preset build files to make the language feel like a different one.
// 
// Sane Defaults for $Language Programers. 
//
// Whatever your favourite programing language, this one's worse!
// But hopefully this can be everyone's second favourite language. 
//
// Jack of all trades, master of none, but better than a master of one. 
// Features will continue until moral improves.
// My theory is that's why nobody can kill c++.
//
// The general phylosophy is you don't need language features if your meta programming stuff is nice enough. 
// The thing i hate most is trying to click into a function to see how its implemented and there's nothing there. 
//
struct Dialect {
    implicit_calls: &Map(MagicFunction, MagicFlags),
    tricks: OptTricks,
    safety: SafetyChecks,
    modules: Map(Str, ModuleDecl),
    features: Features,
}

@module(log, impl=core){
    @pub struct LogTag = ();
    @pub @stack_trace @lexical_caller
    fn log(msg: Str, extra: LogTag = ()) = print(msg);
}

for S with fn eq(S, S) bool {
    struct Symbol(S) = (i64);
    
    fn eq((a): Symbol(S), (b): Symbol(S)) bool = eq(a, b);
    
    trait InternPool(S) for P(S) when {
        fn new() InternPool(S);
        fn global() ?&InternPool(S);
        intern(S, pool: &P = unwrap(global())) Symbol(S);
        get(Symbol(S), pool: &P = unwrap(global())) &S;
    }
}

// move to string.txt
@module(symbol, impl=core) when @module(HashMap){
    // TODO
}

@comptime fn language_dialect() &Dialect;

let Features = FlagSet(FunctionOverloading | NewComptimeFns | ImplicitMain | TypeInference | BlanketImpls);

// These modules don't represent dangerous capabilities that must be handed to into libraries from the main program. 
// Any library can produce these from the void. 
// They're things that are really just language features that don't need to do any io, allocation, etc. 
fn base_modules() Map(Str, ModuleDecl);

//
// Jack of all trades, master of none.
// But better than a master of one. 
//
// Whatever your favourite programing language, this one's worse!
// But hopefully this can be everyone's second favourite language. 
//
