
// TODO: doc: assosiated type when impl gets to choose. generic instantiator can choose any in some bound.
//      I guess impl setting it is just sugar for adding it to the condition of the @impl except generic code has to be able to ask for it, 
//      an impl can assign a generic param to an associated constant. 
//      the idea is that you're allowed to implement a specilized string pool and not support other types.
//      but you can also do one that can take anything thats Eq + Hash. 
@trait(InternPool, Pool) {
    const V: Type;
    const K: Type;
    const threadlocal: bool;
    
    fn eq(K, K) bool;
    
    @static fn empty() Pool;
    @pure fn insert(&Pool, V) K;
    // This isn't fallible because hopefully the only way to create a K is through the pool. 
    @pure fn get(&Pool, K) &V;
    
    // TODO: this should probably be a seperate module. 
    //       but i want an option to use the key as a pointer without passing around the pool. 
    const implicit_global: CompTag(?&Pool);
    fn deref(key: K) &V = deref(unwrap(implicit_global), key);
    
    @static fn create_global_intern_pool() ModuleDecl;
}

/// Provide an option to use the key as a pointer without passing around the pool. 
/// The implementation presumably has a private global variable storing something that implements InternPool. 
@module(name=global_intern_pool, args={ Key: Type, Value: Type, threadlocal: bool }) {
    fn intern(key: Value) Key;
    fn deref(key: Key) &Value;
}
