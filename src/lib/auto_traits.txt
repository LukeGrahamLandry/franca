
// TODO: fine grained control over which can be called implicity? 
// TODO: docs Passing Arguments: passing an argument to a function may call copy or move or cast or neither (if not mutated) or clone (if relaxed mode) or from (if relaxed mode)
// TODO: i plan to only implement the rust backend in rust and then that allows good rust ffi 
//       so it can pass me the ast and i can write other backends in this language as comptime programs.  
//       actually maybe its better to write the manual code for passing the ast over and then i can write the rust backend here too
//       and just bootstrap with the comptime interpreter. 
//       that becomes a little bit hard to think about. 
//       maybe a @bootstrapped qualifier for a function that should be precompiled when possible. 
//       or big functions (that arent comptime) jit to mir c when called at comptime. 
//       @no_interp 
// TODO: docs: you probably dont need to think about modules if you're just writing a script. 
//             they're really more about coordinating between libraries
//             and controling tradeoffs between convience and correctness. 
// TODO: docs: private functions can be overloaded within a module but cannot participate with outer functions. 
//             it is an error to declare a private function that shadows a public one. 
//             overloads of public are resolved for a given module without considering modules higher in the tree. 
//             so when you depend on a module, you can't accidently break its code by changing how overloads resolve.
//             this tunes down the spooky action at a distance 
//
// TODO: there are really two types of modules.
//       the main program should be able to change what happens when a library tries to allocate or web request.
//       but it shouldn't be able to turn off somebody's RAII
//       so im back to you need to allow different impls in different places in the tree. 
//
// deriving doesnt need to be a magic thing anymore, just use an annotation. 
// 

// - `@unsafe_trait`: it is unsafe to overload this function. 

//////////////////////
/// Implicit Calls ///
//////////////////////
//
// If you disable these modules, the compiler won't know to call the functions, 
// but that doesn't make implementations elsewhere disappear so you can still call them manually. 
// So if you don't like RAII, just disable the drop module. 
// TODO: that's not quite true because default impls are in the module. 
//
// TODO: whats the story on other modules depending on these? 
//      you dont want one guy turning it off to break libraries. 
//

@boot(builtin)
@module(drop, impl=core, transitive=false, implicit=true) {
    // The compiler calls drop when a value goes out of scope. 
    // It takes T by reference, not by value, because T might be self-referential and thus unsafe to move. 
    // # Safety: 
    // - you must call drop on the fields or they will leak. 
    // - Be very careful when implementing drop for types that implement copy, it will probably get called a lot, and must not cause a double free. 
    @pub @unsafe_trait fn drop(&T);
    
    for T with copy(T) T {
        @auto fn drop(&T) = {};
    }
    
    for T {
        // Pointers are always drop, regardless of the target type, so these are not @auto. 
        fn drop(&&T) = {};
        fn drop(&*T) = {};
    }
    
    // TODO: if you override, does it still call drop on your fields? 
    for T with for_all_fields(T, fn(F: Type) bool = fn drop(F))) {
        @auto fn drop(&T) T;
    }
}

//
// TODO: lsp that converts `thing.name(` to `name(thing`, that would make the lack of infix operators much less painful.
//       and give you a place to hang auto complete off. 
//       the problem with prefix binary operators is that I think left to right. 
//       you want to be able to say "produce A then add it to B", not "the things you will be adding are first produce A then produce B"
//       similar for turning `a +=` into `a = add(a, `, I don't really care about syntax, its just annoying that my muscle memory doesn't work. 
//
//       But on the other hand, the consistancy makes it quite verbose. 
//       Maybe I don't want to be looking at redundant stuff all the time. 
//       tbh, the main thing might be fixed by `@inc(i);` meaning `i = add(i, 1);`, but that feels kinda dumb. 
//       maybe using annotations for magic syntax where you don't actually compute the expression could be good. 
//       These ones you really do need: `@addr(x)`, `@type_of(x)`.
//       They're not just syntax sugar, you can't express them by passing to a function. 
//       This doesn't work because it forces `t` to be comptime which isn't what you meant.     
//       for T {  fn type_of(t: T) Type = T; }
//       It's still just sugar because surely you're already in a context where you know T if the compiler does. 
//       But `@type_of(t.name)` is much nicer than `unwrap(field_type(T, unwrap(field_index(T, "name"))))`
// 

@boot(builtin)
@module(copy, impl=core, transitive=false, implicit=true) {
    // # Safety: 
    // - The compiler will call `drop` on both the new and the old value. 
    //   If you override the default, that must not cause a double free. 
    // - T must be move or you can't return one safely. 
    @pub @unsafe_trait fn copy(&T) T;
    
    for T {
        // Pointers are always copy, regardless of the target type, so these are not @auto. 
        fn copy(t: &&T) &T = get(t);
        fn copy(t: &*T) *T = get(t);
    }
    
    for T with and(not(), for_all_fields(T, fn(F: Type) bool = fn copy(F) F)) {
        @intrinsic @auto 
        fn copy(t: T) T;
    }
}

@boot(builtin)
@module(move, impl=core, transitive=false, implicit=true) {
    // The compiler *may* call move instead of copy when passing to a function or assigning to a variable,
    // when the value is not used again in the previous scope. 
    // This depends on how good the compiler is at data flow analysis and tries to err on the side of caution. 
    // Implimenting this but not copy allows rust-like linear types. 
    // The clasic example is a Reference counting smart pointer would probably override this to not bother updating the count. 
    // # Safety: 
    // - T must not be self-referencial. 
    @pub @unsafe_trait fn move(&T) T;

    for T with copy(T) T {
        @auto fn move(t: T) T = t;
    }
    
    for T with for_all_fields(T, fn(F: Type) bool = fn move(F) F) {
        @auto fn move(t: T) T = t;
    }
}

@boot(builtin)
@module(cast, impl=core, transitive=false, implicit=true) {
    // Called by the compiler to coerce types during overload resolution. 
    // Smart pointers may use this to deref and provice access to the inner type. 
    @pub @unsafe_trait fn cast(From) To;
    
    for T {
        fn cast(t: T) T = unreachable("ICE: redundant self cast. broken type inference loop?");
    }
    
    fn try_cast(To: Type, T) ?To = as(?To, try_cast(T));
}

@module(clone, impl=core, transitive=false, implicit=is_relaxed()) {
    // Clone is called only automatically in Relaxed Mode. 
    
    for T with copy(T) T {
        @auto fn clone(t: T) T = t;
    }
    
    for T with for_all_fields(T, fn(F: Type) bool = fn clone(F) T)) {
        @auto fn clone(T) T;
    }
}

@module(default, impl=core, transitive=false, implicit=is_relaxed()) {
    // Default is called only automatically in Relaxed Mode. 
    
    @pub @trait fn default() T;
    
    for T with for_all_fields(T, fn(F: Type) bool = fn default() F)) {
        @auto fn default() T;
    }
}

/////////////////
/// Usability ///
/////////////////

@intrinsic 
fn builtin_stride(T: Type) ?i64 = {
    match(T, [
        (&_, 8),
        (*_, 8),
        (i64, 8),
        (f64, 8),
        (u8, 1),
        (bool, 1),
        (_, nil())
    ])
}

/// How much space T takes up as an array element. 
@intrinsic 
fn stride(T: Type) ?i64 {
    or(fn = builtin_stride(T), fn = 
        if(for_all_fields(T, fn(F) = ne(stride(F), nil()), fn = {
            var s = 0;
            for_all_fields(T, fn(F) = s = add(s, unwrap(stride(f))));
            s
        }, fn = nil())
}

for T with for_all_fields(T, fn(F: Type) bool = fn eq(F, F) bool)) {
    @auto fn eq(T) T;
}

for T with for_all_fields(T, fn(F: Type) bool = fn debug(F) String)) {
    @auto fn debug(T) String;
}

/////////////////////
/// Serialization ///
/////////////////////

enum Json = String(String) | Num(f64) | Null | Box(Json);

@module(name=json, impl=core) when @module(alloc) {
    fn to_string(Json) String;
    fn parse(Str) Json;
}

@module(name=serialize, impl=core) when @module(array) {
    for T {
        // The implementation is required to include a version number and a type id. 
        @pub @auto @unsafe
        fn serialize_unstable(T) Array(u8);
        
        // The implemenetation may assume correct type and current version. 
        @pub @auto @unsafe
        fn raw_serialize_unstable(T) Array(u8);
        
        // The implementation is required to expect a version number and a type id. 
        @pub @auto @unsafe 
        fn deserialize_unstable(Slice(u8)) T;
        
        // The implemenetation may assume correct type and current version. 
        @pub @auto @unsafe
        fn raw_deserialize_unstable(T) Array(u8);
    }
}


////////////////
/// Pointers ///
////////////////

trait ThinPtr for Ref when {
    // Require that you're not doing the rust thing where sometimes its a fat pointer and sometimes not. 
    for V when eq(stride(Ref(V)), stride(Ref(Unit))){
        // TODO: does deref need to be a seperate thing? 
        // Takes a reference so you have a lifetime to use for the result. 
        fn cast(&Ref(V)) &V;
        
        // Like casting to a void pointer in C. 
        fn forget_type(Ref(V)) Ref(Unit);
        
        // Like casting back from a void pointer in C. 
        fn assume_type(Ref(Unit)) Ref(V);
    }
}
