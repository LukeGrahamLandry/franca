//////////////////////////
/// Working with Types ///
//////////////////////////

@comptime fn and(a: Trait, b: Trait) Trait;
@comptime fn fields(V): Type;
@comptime fn stride(Type) ?i64;
@comptime fn is_enum(Type) Bool;
@comptime fn Tag(Type) Type;
@comptime fn tags(Type) Slice(Tag(Type));
@comptime fn Payload(Type, Tag(Type)) Type;
@comptime fn type_for(TypeId) Type;
@comptime fn type_id(T) TypeId;

// Combine the fields from both types into one
// using(A, B) C implies from(C) A
@comptime fn using(Type, Type) Type;

for T {
    @comptime fn comptime(fn() T) T;
    @comptime fn reflect(T) TypeInfo;
    @comptime @auto fn safe_to_leak(T) bool = true;
}

////////////////////
/// Build System ///
////////////////////

@comptime fn is_comptime() bool;
@comptime fn include_bytes(filepath: Str) Slice(u8);
@comptime fn include(file: Path) = import(read_all(file))
@comptime fn import(code: Str);

for T {
    @comptime fn eval(code: Str) T;
}

@comptime enum BuildType = Run() | Test() | Build();

// TODO: a program that walks something and removes one type anotation at a tyime and tries to compile again and sees how 
//       many can be removed before it doesnt compile in a reasonable amount of time. 
//

@comptime enum Target = Interp | C | Rust | Zig;
@comptime fn get_target() Target;
@comptime fn set_target(Target);
@comptime fn get_gc_algo() GcAlgo;
@comptime fn set_gc_algo(GcAlgo);
@comptime fn has_libc() bool = true;

fn is_comptime() bool;

@comptime enum GcAlgo = Rc | Epsilon | Deny;

when or(eq(get_target(), C), eq(get_target(), Zig)) {
    @comptime fn import_c(code: Str, mangled: bool);
}

when eq(get_target(), Rust) {
    @comptime fn import_rust(code: Str);
    
    // These types are @rust when true and use the rust standard library instead of the code in this file. 
    // This will change behaviour! Hash algos, growth strats, etc.
    @unsafe @comptime use_rust_std_impls(default: bool = false, {
        result = default,
        option = default,
        slice = default,
        
        // These types are only @rust if using the default allocator. 
        box = default,
        array = default,
        rc = default,
        hash_map = default,
    });
}

when eq(get_target(), Zig) {
    @comptime fn import_zig(code: Str);
    
    // These types are @zig when true and use the zig standard library instead of the code in this file. 
    // This will change behaviour! Hash algos, growth strats, etc.
    @unsafe @comptime use_zig_std_impls(default: bool = false, {
        option = default,
        slice = default,
        
        // These types are only @zig if using the default allocator or one imported from Zig. 
        array = default,
        hash_map = default,
    });
}
