// 
// Comptime functions for manipulating types as values. 
// Bootstraping: Always use trivial getter methods to access the fields of an @type, 
//               so the interpreter can intercept them with builtins. 
//               TODO: Actually that doesn't matter, its just calling get_field anyway? 
//

// The code in this file is special. 
// It is the only place that directly depends on the `create_meta_types` module.
// It's useful to keep the dependencies low so its easier to bootstrap. 
@in(@module(reflect, dep("declare_meta_types")))

enum Type = TagType | EnumType | StructType | UnionType | FnType;
// TODO: distinguish TypeInfo (this enum) and TypeId (index into a pool)

// TODO: use this instead of @comptime T? 
fn Const(Type) Type;

struct ConstAny = { T: Type, value: &T };

fn type_name(Type) Str;

// A struct M is a MetaType if some types can be cast to M. 
// This is implemented by all the branches of the enum `Type`.
// So you can use this to define a function that accepts a type as an argument but has a bound. 
// TODO: generate this function for all enums with TagName=PayloadName
trait MetaType for M {
    fn try_cast(T: Type) ?M = @match(T) {
        fn(m: M) = m,
        fn(_) = nil(),
    };
}

// This can be used in `when` clauses to match against meta-types.
fn is_type(T: Type, M: Type) bool = is_nil(as(M, try_cast(T))); 

@comptime fn stride(Type) ?i64;
@comptime fn Tag(Type) Type;
@comptime fn tags(Type) Slice(Tag(Type));
@comptime fn Payload(Type, Tag(Type)) Type;
@comptime fn type_for(TypeId) Type;
@comptime fn type_id(T) TypeId;
@comptime fn for_all_fields(Type, Trait) bool;

// Combine the fields from both types into one
// using(A, B) C implies from(C) A
@comptime fn using(Type, Type) Type;

for T {
    // Force the evaluation of a function to finish at compile time. 
    // This is the desugaring of assigning to a `const` variable. 
    // TODO: its a little weird that I let you mutate a `const` as long as its still compile time. 
    //       that might be a bit confusing if you have a non trivial build script so you're doing a lot at comptime. 
    //       but you'll probably still write things as normal functions so the arg types wont have @comptime even if they always happen to be const. 
    //       it feels ugly to make it `@const let` and `@const var`, you want to reward making things `const`. 
    // TODO: doc: a `const` binding forces it to be evaluated at comptime. If the value is needed at runtime, storing the result could bloat your binary. 
    //            but it also means the exe doesn't need to include the code used to generate the value. 
    // TODO: opt for size: need to know if a function is only used with const args so then
    //                     check if it would be more space to include the code or the value. 
    @comptime fn comptime(fn() T) T;
    @comptime fn reflect(T) TypeInfo;
    @comptime @auto fn safe_to_leak(T) bool = true;
}

for T {
    @comptime bit_size(T);
}
fn clear_leading_bits(value: i64, count: i64) i64;

for T with ne(stride(T), nil()) {
    /// This is not the same thing as default()!
    @unsafe zero_init() T;
}

// TODO: remove this, the one below is better? 
@comptime struct FnFlags = FlagSet(Intrinsic | Unsafe | Runtime | Comptime | C | Rust | Zig);
@comptime struct FnType = { Arg: Type, Ret: Type, flags: FnFlags };

@module(globals, impl=core) {
    fn declare(T: Type, name: @comptime Str, value: T);
    fn get(T: Type, name: @comptime Str) &T;
}

@module(thread_local, impl=core) {
    fn declare(T: Type, name: @comptime Str, value: T);
    fn get(T: Type, name: @comptime Str) &T;
}

// true when T is a value type, no references. 
// common auto methods are a no-op: field access, 
fn is_bits(T: Type) bool;

// You can mutate through the pointer but you can't change what address it it points to. 
// Java final variables have this property. 
fn Final(T: PtrType) Type;

//////////////
/// Traits ///
//////////////

// A trait is (mostly) just a (named) predicate over types. 
const Trait = { cond: fn(Type) bool, statics: []FnDecl };

fn is(Check: Type, A: Trait) bool = A.cond(Check);

// TODO: doc example: function whose body is a struct init expression. 
fn and(A: Trait, B: Trait) Trait = {
    cond: fn(T: Type) = and(A.cond(T), B.cond(T)),
    statics: todo("merge statics"),
};

fn or(A: Trait, B: Trait) Trait = {
    cond: fn(T: Type) = or(A.cond(T), B.cond(T)),
    statics: todo("merge statics"),
};

fn not(A: Trait) Trait = { 
    cond: fn(T: Type) = not(A(T).cond), 
    statics: empty(),
};

fn same_functions(Type) Trait;

/////////////////
/// Functions ///
/////////////////

struct ArgRet = { Arg: Type, Ret: Type };
struct FnType = { ArgRet, flags: FnFlags };
struct FnSig = { name: @comptime Str, type: FnType };
struct FnDecl = { at: Loc, flags: FnFlags };
struct AnyFn = { ArgRet, fn(ArgRet.Arg) ArgRet.Ret };

@module(functions, impl=core) {
    fn declare(FnSig, fn(Arg) Ret);
    fn get(FnSig) fn(Arg) Ret;
    fn infer(name: @comptime Str, Arg: ?Type, Ret: ?Type) ?FnSig;
    
    for (F, Ptr) with and([is_type(F, FnType), none(F.flags, HasCaptures), is_type(Ptr, PtrType)]) {
        struct FnPtr(P, F) = Ptr(*());
        
        // You can turn a concrete function value into a pointer. 
        fn cast(f: F) FnPtr(P, F);
        
        // You can dereference a function pointer to call it. 
        fn cast(ptr: FnPtr(P, F)) F;
    }
}

trait Callable for F when {
    // There must exist a function `fn(Type) Type` that do not panic when passed a Callable. 
    // TODO: Really what im trying to say is: 
    //       There exists `fn Sig(Type) -> ?FnType`. When you call it and the argument is F, use this definition. 
    //       otherwise return nil. so i want the general ability to overload functions on a specific value, known at comptime.
    //       pattern match accross function definitions. 
    fn Sig(@meta(F)) FnType;
    
    fn call(&F, Sig(F).Arg) Sig(F).Ret; 
}

@module(closures, impl=core) when @module(functions) {
    for F with is_type(F, FnType) {
        struct Closure(F) = { f: FnPtr(F), data: Ref(Unit) };
        
        fn call(&Closure(F), F.Arg) F.Ret;
        
        fn Sig(@meta(F)) FnType = F;
    }
}

// These are annotations (with lowercase names) with no arguments that can be applied to function definitions. 
struct FnFlags = FlagSet(
    BootBuiltin
    | BootInterp
    | Intrinsic 
    | Unsafe 
    // This function must execute at runtime (not compiletime). 
    | Runtime 
    // This function must execute at compiletime (not runtime).
    | Comptime
    | Relax 
    | Safety 
    | Auto 
    | Annotation
    // The compiler cannot reorder calls to these functions relative to eachother becasue the affect or precieve the outside world. 
    // This is transitive, you shouldn't need to manually put this on your functions
    // because the reason you're impure is likely that you're calling some other impure function. 
    // FFI is always @impure. 
    // I don't care about your crazy embeded system where dereferencing a pointer is a side affect because ptr(18) is reserved for the breaks or whatever. 
    | Impure
    | TransformCallsite
    | StackTrace
    | LexicalCaller
    /// It is a compile error to overload this function. 
    /// Functions with @ffi(c) are @unique. 
    | Unique
    | HasCaptures
    // This function references local variables on the callstack and calls to it must be inlined. 
    // You can't put a value of this type in your pockets for later. 
    | NoEscape
    // Assigning to a `const` variable also works. 
    | ExplicitComptime
    | NoPanic
    // This function may panic in safety checked builds. 
    // In unsafe release builds it will always successfully return a value. 
    // Probably should't use this if it prevents you from checking assumptions with assertions. 
    // Note: I might want to not treat infinite loops as valid for the type checker just so you can't use that to cheat. 
    // TODO: this is a bad name. it sounds like the compiler doesn't check but it means behaviour depends on build mode. 
    | OnlySafetyPanic  // TODO: one for "behaviour differs if checked"
    | InnerUnsafe
);

// A value of this type cannot be produced. 
// This is the return type of functions that terminate the program. 
@type Never;

// It is safety checked illegal behaviour to produce a value of this type. 
@type UnsafeNever;

// It is a compile error to produce a value of this type. 
@type CompileError;

/////////////
/// Enums ///
/////////////

const Symbol = @comptime Str;

// A tag is an enum with no payloads. 
// The type of a literal like `A | B | C` (TODO: does that need brackets to disambiguate enum with those types?)
const TagType = []Symbol;  
// A tagged union. Each branch has a unique tag and some payload. A type may appear as a payload multiple types. 
const EnumType = { Tag: TagType, cases: OrderedMap(Tag, Type) };

fn has_case(E: EnumType, name: ?Symbol, T: Type) bool {
    let name = or_else(name, fn = )
}

fn unit_payload(name: Symbol) (Symbol, Type) = (name, Unit);

fn unit_payload(T: TagType) EnumType = .{ 
    Tag: T, 
    cases: foreach(T, unit_payload),
};

fn is_enum(T: @type EnumType) bool = true;
fn Tag(E: @type EnumType) TagType = E.Tag;

for E with is_type(E, EnumType) {
    fn tag_of(e: &E) &Tag(E);
}

// If you can get away with using this, you wont have to generate code for all the possible cases. 
// If the tag happens to be constant for some usage of a normal enum, the optimiser should still notice. 
// This type just gives you a compile error if it can't be done. 
fn ComptimeTag(E: EnumType) EnumType = { Tag: @comptime E.Tag, cases: E.cases }

struct LayoutEntry = { T: ?Type, padding: BitSet(bit_count) }; 

struct StructLayout = Array(LayoutEntry);

// TODO: niche stuff. have a BitRange type for expressing which parts are unneeded. 
// An enum is just a tagged union. 
@intrinsic
fn pack_enum(E: EnumType) StructType = StructType({
    FieldName: (Tag | Payload),
    cases: {
        Tag: E.Tag,
        Payload: UnionType({ Names: TagType, cases: E.cases }),
    }    
});

// TODO: add to niche_optimisation examples. high bits are reserved for tag. 
// TODO: require no payload 
for E with and(is_enum(E), le(len(fields(E)), 64)) {
    struct FlagSet(E) = BitSet(len(fields(E));
    let BInt = backing_int(Tag(E));
    
    fn from(set: bool) Flags = if(set, fn = all(), fn = none());
    
    fn cast(E) Flags;
    fn set(&Flags, E, bool);
    fn get(&Flags, E) bool;
    // Falible cause it might not take up the whole int. 
    fn try_cast(v: BInt) ?Flags;
    fn cast(v: Flags) BInt = transmute(v);
    
    fn all() Flags = zero_leading_bits(cast(not(0), sub(bit_size(BInt), required_bits())));
    fn none() Flags = cast(0);
    fn any(self: Flags, options: Flags) bool = ne(none(), and(self, options));
    fn none(self: Flags, options: Flags) bool = not(any(self, options));
    fn all(self: Flags, options: Flags) bool = all(and(self, options), options);
    fn and(Flags, Flags);
    fn or(Flags);
    fn required_bits() i64 = len(fields(E));
    
    // Since they're packed, I can't give you a pointer. 
    fn get_field(self: Flags, @comptime Str) CResult()
}

// TODO: move this
for (T, E) {
    const CResult(T, E) = ComptimeTag(Result(T, @comptime E));
    
    // At runtime, you can safely assume the value is there. 
    @runtime fn cast(self: CResult(T, E)) T = unwrap(self);
}

fn Sealed(cases: []Type) EnumType;

// Like an enum in C or Java.
fn ValueEnum(Backing: Type, cases: [](Symbol, Backing)) Type;


// Like an enum with a comptime known tag. 
// Lets you write overloads for each input type seperatly 
// but call it like there's one function of the output type. 
fn OneOf([] Type) Type;

///////////////
/// Structs ///
///////////////

enum StructLayout = C | Rust | Zig | Packed | MagicJit;

@type StructType = { FieldName: TagType, fields: OrderedMap(FieldName, Type), layout: StructLayout };

@comptime @intrinsic
fn field_type(S: @type StructType, index: u64) ?Type = 

@comptime @intrinsic
fn field_index(StructType, name: Str) ?i64;

for S with StructType(S) {
    @intrinsic
    fn get_field(&S, @comptime index: u64) &unwrap(field_type(S, index));
}

@comptime 
fn field_type(S: StructType, name: Str) ?Type = then(field_index(S, name), fn(i) = get_field(S, i));

@comptime fn fields(V): Type;

// TODO: read julia's thing, seems like it might be good. https://docs.julialang.org/en/v1/manual/types/
//       i like having isbits(Type), im not sure it means it needs
// TODO: make sure its easy to express copy on write swift structs. 
//       you need a way to say that mutating a field can make the parent point somewhere else? 

// TODO: have a way to express memory on the stack with runtime known size. 
//       they're probably evil but its weird to keep the idea a secret. 
//       just dont allow them when targetting a language that doesnt expose that capability. 
//       https://lwn.net/Articles/749064/
//
// TODO: backends should always generate an ast for the target language (not just a string),
//       so you can easily run target specific safety checks, etc. 

// These are used for two things:  (TODO: maybe break appart)
//  - normal functions resolved with overloading. 
//  - marker traits used for optional safety checking.
// However, since they're called automatically by the compiler, its really useful to quickly check if that's needed.
// This is just explicit caching of which have no-op or missing implementations. 
enum AutoTrait = @trait_enum {
    // What happens when a value of this type goes out of scope? 
    @flag_trait(Drop, fn drop(&T));
    @flag_trait(Copy, fn copy(T) T);
    @flag_trait(Clone, fn clone(&T) T);
    // This type "has no self", its just a bag of bytes. 
    // Owns no memory, has no pointers, has no-op impls of all other auto-traits. 
    @flag_trait(Bits);
    // This type has a known constant size. It can be stored on the stack or as an array element. 
    @flag_trait(Sized, and(fn size_of() i64, fn stride_of() i64));
    // A reference to this type can be shared between threads.
    @flag_trait(Sync);
    // This type can be moved to another thread (the original will not access again).
    @flag_trait(Send);
    // This type can be moved to another location in memory (its not self referential).
    // This is like rust's UnPin.
    @flag_trait(Move, fn move(T) T);
    // If this type is leaked without calling its destructor, the only problem is that memory is not reclaimed. 
    @flag_trait(Leak);
    @flag_trait(Serialize);
    // You can always create a value of this type out of thin air. 
    @flag_trait(Default, fn default() T);
    // A correctly sized sequence of zero bytes is a valid value of this type.
    @flag_trait(ZeroInit, fn zero_init() T);
    // The whole thing might be shared. Useful for deeply copy-on-write types. 
    // Need some callback before giving out a mutable pointer to a field
    @flag_trait(MutationCallback, fn will_mutate(&T));
    // This type can be used in pattern matching. 
    @flag_trait(Structured, Structured);
};

@private @tag(flag_trait, (Symbol, ?Trait));

// TODO: generate the trait and an enum 
@private @annotation
fn trait_enum() ExprAst;

enum AutoHandler = 
    // The compiler can 
    | Noop 
    // The type does not implement the trait. 
    | Deny
    | Custom
;

const AutoTraits = FlagSet(AutoTrait);


trait StaticDotSyntax for S when {
    // Do not put methods here, those are function overloads. 
    // x.bar() first checks contains(fields(@type_of(x)), "bar") if it exists, call get_field and then call that function with no arguments. if not, calls bar(x). 
    @pure fn fields(@Self) Tag;
    fn get_field
    fn set_field
}

//////////////
/// Unions ///
//////////////

@type UnionType = { Names: TagType, cases: Map(Names, Type) };

fn is_union(Type) bool;

fn UntaggedUnion(Type, Type) @type UnionType;

for U with is_union(U) {
    for F in cases(U) {
        fn read_union(&U) &F;
    }
}

////////////////
/// Pointers ///
////////////////

// If you like Rust you'll probably have a fucking field day with this. 
// The intention is for this to be far too many options to think about. 
// You're supposed to choose some subset to use and never produce pointers with the other restrictions. 
// However, it lets you declare what expectations you have of a pointer, 
// that way it can be a compile error. 
// The real killer feature of this is, what i call sarcastically, "Fearless FFI".
// TODO: need to define subtype relationships
// You probably don't want to eat the branch prediction cost of using this at runtime, try to be generic over it instead. 
const PtrFlags = FlagSet(
    // Nobody else has a pointer to this memory. 
    | NoAlias
    // You can not mutate throught this pointer.
    // However, it may be aliased and the other people might mutate it. 
    | ConstantForMe
    // Other copies may not mutate the value it holds (if aliased). 
    | ConstantForOthers
    // The constant rules are really just suggestions. 
    | InteriorMutability
    // The memory this points to is garbage collected (reference counted, etc).
    // It's reasonable to just throw away the pointer and assume someone else will reclaim the memory. 
    | Collected    
    // This pointer does not have the value zero. 
    | NonNull
    // This pointer may point to invalid memory. 
    | UnsafeDeref
    // This pointer will be good forever. You can put it in your pockets for latter. 
    | Static
    // To alias this pointer, all you need to do is copy the bits. 
    // Same as the Copy trait in rust. 
    | BitCopy
    // If you want to copy this pointer and give it to someone else (without cloning the value behind it),
    // you need to call the `copy` function.   
    // Useful for reference counting.
    // TODO: should call the function that does this `alias` instead so its more clearly distinct that one expects mutation to be shared and one doesnt/
    | CallCopy
    // When you're done with this pointer, you must call the `drop` function. 
    // Useful for reference counting or RAII owned memory. 
    | NeedsDrop
    // This pointer is good for some fixed amount of time, perhaps until the current call returns. 
    // You can't just put it somewhere for later. 
    | TrackLifetime
    | RegionTag
    // You can move the value out of the pointer but then you can never use it through the pointer again. 
    | MoveOut
    // The type behind the pointer has a trivial destructor so dereferencing can just do a bitwise copy. 
    | CopyOut
    | CloneOnWrite
    // This pointer may or may not be present but you can safely check. 
    | OptionalDeref
    // Values of this type contain a runtime pointer to some allocator. 
    | HasAllocatorPtr
    // Deallocating or resizing this type requires the caller to pass in an allocator pointer. 
    // It must be the same one used to allocate this value originally. 
    | SpecificExternalAllocator
    // This is not actually a pointer. The indirection exists to set different PtrFlags on part of a struct. 
    // Types with this flag might not have a comptime known size and are often stored behind another indirection. 
    // Rust uses these often: UnsafeCell, Cell, RefCell, Mutex, RwLock. 
    | StoredInline
    // This value might be stored on the call stack. 
    // It is safe to use until the caller returns.  
    | MaybeStack
);

let PtrPrefix = FlagSet(Amp | Star | Arrow);
let PtrSuffix = FlagSet(Const | Mut | Raw | Gc);
let PtrSyntax = (PtrPrefix, ?PtrSufix);

struct PtrType = { inner: Type, flags: PtrFlags };

fn ptr_to(Type, PtrFlags) Type;

fn get_flags(@type PtrType) PtrType;
fn with_flags(@type PtrType, PtrFlags) Type;

trait Sized for T when ne(stride(T), nil());

trait Ptr for Ref(_) when {
    for V with Sized(V) {
        // This is the same as cast but may be unsafe to call depending on the Flags(Ptr).
        fn deref(&Ref(V)) &V;
        
        // This distiction allows for copy-on-write types.
        @auto fn deref_mut(self: &Ref(V)) &V = deref(self);
    }
    
    // TODO: some annotation for functions like this that are really pattern matching across definitions so they need to syntezise an outer thing to do that. 
    for T with is_trait(T, Ptr){
        for V {
            fn rebox(&V, T) T(V);
        }
        fn Flags(Ptr(V)) PtrFlags;
        fn Inner(Ptr(_)) Type;
        fn PtrTo(V) Ty(Ptr);
    }
}

//////////////
/// Arrays ///
//////////////

// TODO: doc: unnamed struct fields when unique types. 
@type ArrayType = (PtrType, ArrayFlags);

const ArrayFlags = FlagSet(
    // Zig array list has this. 
    RuntimeAllocatorPtr
    // [ArrayList<Object>, ArrayList(type), Vec<T>, std::vector<T>] have this.
    | Growable
    | IteratorInvalidation
    // Tuples have this. 
    | ComptimeKnownLength
    // Linked lists DONT have this. 
    | RandomAccess
    // C dynamic arrays DONT have this. 
    | RuntimeKnownLength
);

///////////////
/// Strings ///
///////////////

// If you like Rust you'll probably have a fucking field day with this. 
@type StrType = (ArrayType, StrFlags, StrEncoding);

const StrFlags = FlagSet(NullTerminated);

enum StrEncoding = Utf8 | Utf16 | Utf32 | Ascii | Bytes | Os; 

for (A, B) with and(is_type(A, StrType), is_type(B, StrType)) {
    fn try_from(A) B;
}

///////////////
/// Numbers ///
///////////////

const OneNumberToHoldThemAll;

enum NumRepr = SignedInt | UnsignedInt | Float | ArbitraryPreciesion;
enum Overflow = Undefined | Wrap | SafetyChecked | Allowed;
struct NumType = { NumRepr, Overflow, max: BestNumber, min: BestNumber, bits: i64, indirection: ?PtrFlags };

// TODO: think about what things need to be comptime.
//       like the types of your own program are comptime.
//       but manipulating the TypeInfo enum at runtime is fine, you just cant do anything with it.
//       but that's kinda what the compiler needs to do. 
//       unless you think of it as the compiler never having a runtime.
//       which i guess is true. theres a rust program that calls the user's comptime functions, 
//       the fact that they choose to call comptime functions that i also wrote is a coincidence.
//       there's no program written in this language that *is* "the compiler".  
//


// functions that return types must be pure so they can be cahed by the compiler and have equality work when you call with the same generics. 
// to do bindings generation where you need to reasd from the outside world, you must return a module instead.
