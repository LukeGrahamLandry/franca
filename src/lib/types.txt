// 
// Comptime functions for manipulating types as values. 
//

// The code in this file is special. 
// It is the only place that directly depends on the `create_meta_types` module.
// It's useful to keep the dependencies low so its easier to bootstrap. 
@in(@module(reflect) when @module(create_meta_types))

@type enum Type = TagType | EnumType | StructType | UnionType | FnType;

fn type_name(Type) Str;

fn is_type(Type, @type) bool; 

@comptime fn stride(Type) ?i64;
@comptime fn Tag(Type) Type;
@comptime fn tags(Type) Slice(Tag(Type));
@comptime fn Payload(Type, Tag(Type)) Type;
@comptime fn type_for(TypeId) Type;
@comptime fn type_id(T) TypeId;
@comptime fn for_all_fields(Type, Trait) bool;

// Combine the fields from both types into one
// using(A, B) C implies from(C) A
@comptime fn using(Type, Type) Type;

for T {
    @comptime fn comptime(fn() T) T;
    @comptime fn reflect(T) TypeInfo;
    @comptime @auto fn safe_to_leak(T) bool = true;
}

for T {
    @comptime bit_size(T);
}
fn clear_leading_bits(value: i64, count: i64) i64;

for T with ne(stride(T), nil()) {
    /// This is not the same thing as default()!
    @unsafe zero_init() T;
}

fn is_union(Type) bool;

fn untagged_union(Type, Type) Type with is_union($0); 

for U with is_union(U) {
    for F in cases(U) {
        fn read_union(&U) &F;
    }
}

@comptime struct FnFlags = FlagSet(Intrinsic | Unsafe | Runtime | Comptime | C | Rust | Zig);
@comptime struct FnType = { Arg: Type, Ret: Type, flags: FnFlags };

@module(globals, impl=core) {
    fn declare(T: Type, name: @comptime Str, value: T);
    fn get(T: Type, name: @comptime Str) &T;
}

@module(thread_local, impl=core) {
    fn declare(T: Type, name: @comptime Str, value: T);
    fn get(T: Type, name: @comptime Str) &T;
}

//////////////
/// Traits ///
//////////////

@comptime let Trait = fn(Type) bool;
fn and(a: Trait, b: Trait) Trait;
fn same_functions(Type) Trait;

/////////////////
/// Functions ///
/////////////////

@type FnType = { Arg: Type, Ret: Type };
struct FnSig = { name: @comptime Str, type: FnType };
struct FnDecl = { at: Loc, flags: FnFlags };

@module(functions, impl=core) {
    fn declare(FnSig, fn(Arg) Ret);
    fn get(FnSig) fn(Arg) Ret;
    fn infer(name: @comptime Str, Arg: ?Type, Ret: ?Type) ?FnSig;
    
    for F with and(is_type(F, FnType), none(F, HasCaptures)) {
        struct FnPtr(F) = (*());
        
        // You can turn a concrete function value into a pointer. 
        fn cast(f: F) FnPtr(F);
        
        // You can dereference a function pointer to call it. 
        fn cast(ptr: FnPtr(F)) F;
    }
}

trait Callable for F when {
    // There must exist functions `fn(Type) Type` that do not panic when passed a Callable. 
    fn arg_of(@type F) Type;
    fn ret_of(@type F) Type;
    
    fn call(&F, arg_of(F)) ret_of(F); 
}

@module(closures, impl=core) when @module(functions) {
    for F with is_type(F, FnType) {
        struct Closure(F) = { f: FnPtr(F), data: Ref(Unit) };
        
        fn call(&Closure(F), F.Arg) F.Ret;
        
        fn arg_of(@type F) Type;
        fn ret_of(@type F) Type;
    }
}

// These are annotations (with lowercase names) with no arguments that can be applied to function definitions. 
struct FnFlags = FlagSet(
    BootBuiltin
    | BootInterp
    | Intrinsic 
    | Unsafe 
    // This function must execute at runtime (not compiletime). 
    | Runtime 
    // This function must execute at compiletime (not runtime).
    | Comptime
    | Relax 
    | Safety 
    | Auto 
    | Annotation
    // The compiler cannot reorder calls to these functions relative to eachother becasue the affect or precieve the outside world. 
    // This is transitive, you shouldn't need to manually put this on your functions
    // because the reason you're impure is likely that you're calling some other impure function. 
    // FFI is always @impure. 
    // I don't care about your crazy embeded system where dereferencing a pointer is a side affect because ptr(18) is reserved for the breaks or whatever. 
    | Impure
    | TransformCallsite
    | StackTrace
    | LexicalCaller
    /// It is a compile error to overload this function. 
    /// Functions with @ffi(c) are @unique. 
    | Unique
    | HasCaptures
    // Assigning to a `const` variable also works. 
    | ExplicitComptime
);

/////////////
/// Enums ///
/////////////

// An enum with no payloads. 
// The type of a literal like `A | B | C` (TODO: does that need brackets to disambiguate enum with those types?)
@type TagType = Array(@comptime Str);  
@type EnumType = { Tag: TagType, cases: OrderedMap(Tag, Type) };

fn unit_payload(name: @comptime Str) (@comptime Str, Type) = (name, Unit);

fn unit_payload(T: TagType) EnumType = .{ 
    Tag: T, 
    cases: foreach(T, unit_payload),
};

fn is_enum(T: EnumType) bool = true;
fn Tag(E: EnumType) TagType = E.Tag;

for E with is_type(E, EnumType) {
    fn tag_of(e: E) Tag(E);
}

// TODO: niche stuff
// An enum is just a tagged union. 
@intrinsic
fn pack_enum(E: EnumType) StructType = StructType({
    FieldName: (Tag | Payload),
    cases: {
        Tag: E.Tag,
        Payload: UnionType({ Names: TagType, cases: E.cases }),
    }    
});

@comptime fn FlagSet(E: Type with is_enum(E)) Type;
@comptime backing_int(Type with FlagSet(E)) Type;

// TODO: add to niche_optimisation examples. high bits are reserved for tag. 
// TODO: require no payload 
for E with and(is_enum(E), le(len(fields(E)), 64)) {
    let Flags = FlagSet(E);
    let BInt = backing_int(Flags);
    
    fn from(set: bool) Flags = if(set, fn = all(), fn = none());
    
    fn cast(E) Flags;
    fn set(&Flags, E, bool);
    fn get(&Flags, E) bool;
    // Falible cause it might not take up the whole int. 
    fn try_cast(v: BInt) ?Flags;
    fn cast(v: Flags) BInt = transmute(v);
    
    fn all() Flags = zero_leading_bits(cast(not(0), sub(bit_size(BInt), required_bits())));
    fn none() Flags = cast(0);
    fn any(self: Flags, options: Flags) bool = ne(none(), and(self, options));
    fn none(self: Flags, options: Flags) bool = not(any(self, options));
    fn all(self: Flags, options: Flags) bool = all(and(self, options), options);
    fn and(Flags, Flags);
    fn or(Flags);
    fn required_bits() i64 = len(fields(E));
}

///////////////
/// Structs ///
///////////////

@type StructType = { FieldName: TagType, OrderedMap(FieldName, Type)};

@comptime @intrinsic
fn field_type(StructType, index: u64) ?Type;

@comptime @intrinsic
fn field_index(StructType, name: Str) ?i64;
    
for S with StructType(S) {
    @intrinsic
    fn get_field(&S, @comptime index: u64) &unwrap(field_type(S, index));
}

@comptime 
fn field_type(S: StructType, name: Str) ?Type = then(field_index(S, name), fn(i) = get_field(S, i));

@comptime fn fields(V): Type;

//////////////
/// Unions ///
//////////////

@type UnionType = { Names: TagType, cases: HashMap(Names, Type) };

////////////////
/// Pointers ///
////////////////

// If you like Rust you'll probably have a fucking field day with this. 
// The intention is for this to be far too many options to think about. 
// You're supposed to choose some subset to use and never produce pointers with the other restrictions. 
// However, it lets you declare what expectations you have of a pointer, 
// that way it can be a compile error. 
// The real killer feature of this is, what i call sarcastically, "Fearless FFI".
// TODO: need to define subtype relationships
// You probably don't want to eat the branch prediction cost of using this at runtime, try to be generic over it instead. 
const PtrFlags = FlagSet(
    // Nobody else has a pointer to this memory. 
    | NoAlias
    // You can not mutate throught this pointer.
    // However, it may be aliased and the other people might mutate it. 
    | ConstantForMe
    // Other copies may not mutate the value it holds (if aliased). 
    | ConstantForOthers
    // The constant rules are really just suggestions. 
    | InteriorMutability
    // The memory this points to is garbage collected (reference counted, etc).
    // It's reasonable to just throw away the pointer and assume someone else will reclaim the memory. 
    | Collected    
    // This pointer does not have the value zero. 
    | NonNull
    // This pointer may point to invalid memory. 
    | UnsafeDeref
    // This pointer will be good forever. You can put it in your pockets for latter. 
    | Static
    // To alias this pointer, all you need to do is copy the bits. 
    // Same as the Copy trait in rust. 
    | BitCopy
    // If you want to copy this pointer and give it to someone else (without cloning the value behind it),
    // you need to call the `copy` function.   
    // Useful for reference counting.
    // TODO: should call the function that does this `alias` instead so its more clearly distinct that one expects mutation to be shared and one doesnt/
    | CallCopy
    // When you're done with this pointer, you must call the `drop` function. 
    // Useful for reference counting or RAII owned memory. 
    | NeedsDrop
    // This pointer is good for some fixed amount of time, perhaps until the current call returns. 
    // You can't just put it somewhere for later. 
    | TrackLifetime
    | RegionTag
    // You can move the value out of the pointer but then you can never use it through the pointer again. 
    | MoveOut
    // The type behind the pointer has a trivial destructor so dereferencing can just do a bitwise copy. 
    | CopyOut
    | CloneOnWrite
    // This pointer may or may not be present but you can safely check. 
    | OptionalDeref
);

let PtrPrefix = FlagSet(Amp | Star | Arrow);
let PtrSuffix = FlagSet(Const | Mut | Raw | Gc);
let PtrSyntax = (PtrPrefix, ?PtrSufix);

@type PtrType = { inner: Type, flags: PtrFlags };

fn ptr_to(Type, PtrFlags) Type;

fn get_flags(@type PtrType) PtrType;
fn with_flags(@type PtrType, PtrFlags) Type;

//////////////
/// Arrays ///
//////////////

// TODO: doc: unnamed struct fields when unique types. 
@type ArrayType = (PtrType, ArrayFlags);

const ArrayFlags = FlagSet(
    // Zig array list has this. 
    RuntimeAllocatorPtr
    // [ArrayList<Object>, ArrayList(type), Vec<T>, std::vector<T>] have this.
    | Growable
    | IteratorInvalidation
    // Tuples have this. 
    | ComptimeKnownLength
    // Linked lists DONT have this. 
    | RandomAccess
    // C dynamic arrays DONT have this. 
    | RuntimeKnownLength
);

///////////////
/// Strings ///
///////////////

// If you like Rust you'll probably have a fucking field day with this. 
@type StrType = (ArrayType, StrFlags, StrEncoding);

const StrFlags = FlagSet(NullTerminated);

enum StrEncoding = Utf8 | Utf16 | Utf32 | Ascii | Bytes | Os; 

for (A, B) with and(is_type(A, StrType), is_type(B, StrType)) {
    fn try_from(A) B;
}
