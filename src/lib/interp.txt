@in(@module(name=dlrc, impl=core))

//
// This is a useful type for when just want it to compile. 
// duck-typed, linear, reference-counted, copy-on-write.
// The memory management is similar to Swift's array/dict/set types. 
// A program with no type annotations should be able to use this type for everything and just fail at runtime if you make a mistake. 
// It's used for boostrapping the compiler since I want to write my type checking in this language. 
//
// This type is not Copy. You can pass it by,
// - move: give ownership to the reciever and you lose access to it
// - clone: you will NOT see mutations made by the reciever
// - share: you WILL see mutations made by the reciever 
const Dlrc = { @private ptr: *DlrcBox, @private borrowed: bool };  
// TODO: borrowed=true means you have to make a copy before mutating. might need to store in the box.

// This is what gets allocated on the heap and pointed to by a Dlrc
@private struct DlrcBox = { rc: i64, value: DlrcValue };

enum DlrcValue = []Dlrc | {}(Dlrc, Dlrc) | Tagged(Symbol, Dlrc) | None() | Any;

fn cast(value: DlrcValue) Dlrc = {
    var self: &DlrcBox = box(DlrcBox({ rc: 1, value: value}));
    { ptr: to_raw(self), borrowed: false }
}

// Increment the refernce count so you can pass the value but see mutations. 
fn share(self: &Dlrc) Dlrc {
    let self: *DlrcBox = get(get(self));
    set(self.rc, add(get(self.rc), 1));
    (self)
}

fn clone(self: &Dlrc) Dlrc {
    let self: Dlrc = get(self);
    ensure_unique(@addr(self));
    self
}

fn dup(self: Dlrc) (Dlrc, Dlrc) = (clone(@addr(self)), self);

fn drop(self: &Dlrc) {
    let self: *DlrcBox = get(get(self));
    set(self.rc, sub(get(self.rc), 1));
    if(eq(self.rc, 0), fn={
        let _ = box_from_raw(self);
    });
}

fn move(self: Dlrc) Dlrc = self;

fn ensure_unique(self: &Dlrc) = {
    if(ne(self.rc, 0), fn={
        set(self, { rc: 1, value: clone(self.value) })
    })
}

fn deref(self: &Dlrc) &DlrcValue = @addr(self.ptr.value);

fn deref_mut(self: &Dlrc) &DlrcValue = {
    if(self.borrowed, fn = ensure_unique(self));
    @addr(self.ptr.value)
}

@example(@assert_compile_error(Custom(COPY_ERR)) { let x: Dlrc = new(); let y = x; let z = x; });
const COPY_ERR = "Dlrc is not Copy. use `clone(d)` to pass a copy or `share(d)` to share mutable access.";
fn copy(&Dlrc) Dlrc = @compile_error(COPY_ERR);

fn get_field(self: &Dlrc, todo()) todo();

/// There's a complicated dependency tree because many language features that would be builtins in most languages
/// are defined as comptime functions in this one. Even macros/annotations are really just regular functions with more flexible calling syntax. 
/// The functions in this module have implementations written in Rust, builtin to the comptime interpreter. 
/// They are safe to call during bootstraping.
/// There are implementations elsewhere in the standard library that are used by most programs. 
@in(@module(interp, when=is_bootstrapping()))

// TODO: this is dumb. the intrp just has whatever you need to bootstrap and it already knows, dont need to tell it.
//       should have runtime versions of duck-typed linear copy-on-write reference counted collections


fn TypeOf(Any) Type;
fn try_cast(T: Type, value: Any) Option(T);

fn Ptr(T: Type) Type;
fn get(ptr: Ptr(Any)) Any;
fn set(ptr: Ptr(Any), new: Any);

fn Slice(T: Type) Type;
fn push(self: Ptr(Slice(Any)), value: Any);
fn get(self: Slice(Any), i: i64) Any;
fn set(self: Slice(Any), i: i64, value: Any);

fn Option(T: Type) Type;
fn is_nil(self: Option(Any)) bool;
fn unwrap(self: Option(Any)) Any;

fn Result(T: Type, E: Type) Type;
fn is_err(self: Result(Any, Any)) bool;
fn unwrap(self: Result(Any, Any)) Any;

fn Map(K: Type, V: Type) Type;
fn get(self: Map(Any, Any), key: Any) Option(Any);
fn set(self: Map(Any, Any), key: Any, value: Any) Option(Any);

fn OrderedMap(T: Type) Type;
fn Set(T: Type) Type;

fn get_field(self: &Any, name: Symbol) Any;
fn set_field(self: &Any, name: Symbol, value: Any);

@annotation fn annotation(args: (), target: &FnDeclAst) Expr;
@annotation fn match(args: &Expr, target: []FnDeclAst) Expr;
@annotation fn impl((names, cond): ([] Ident, Fn), target: &BlockAst);
@annotation fn annotation(args: (FnDecl, FnDecl), target: Unit) ExprAst;
