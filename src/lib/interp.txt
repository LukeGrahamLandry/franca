/// There's a complicated dependency tree because many language features that would be builtins in most languages
/// are defined as comptime functions in this one. Even macros/annotations are really just regular functions with more flexible calling syntax. 
/// The functions in this module have implementations written in Rust, builtin to the comptime interpreter. 
/// They are safe to call during bootstraping.
/// There are implementations elsewhere in the standard library that are used by most programs. 
@in(@module(interp, when=is_bootstrapping()))

fn TypeOf(Any) Type;
fn try_cast(T: Type, value: Any) Option(T);

fn Ptr(T: Type) Type;
fn get(ptr: Ptr(Any)) Any;
fn set(ptr: Ptr(Any), new: Any);

fn Slice(T: Type) Type;
fn push(self: Ptr(Slice(Any)), value: Any);
fn get(self: Slice(Any), i: i64) Any;
fn set(self: Slice(Any), i: i64, value: Any);

fn Option(T: Type) Type;
fn is_nil(self: Option(Any)) bool;
fn unwrap(self: Option(Any)) Any;

fn Result(T: Type, E: Type) Type;
fn is_err(self: Result(Any, Any)) bool;
fn unwrap(self: Result(Any, Any)) Any;

fn Map(K: Type, V: Type) Type;
fn get(self: Map(Any, Any), key: Any) Option(Any);
fn set(self: Map(Any, Any), key: Any, value: Any) Option(Any);

fn OrderedMap(T: Type) Type;
fn Set(T: Type) Type;

fn get_field(self: &Any, name: Symbol) Any;
fn set_field(self: &Any, name: Symbol, value: Any);

@annotation fn annotation(args: (), target: &FnDeclAst) Expr;
@annotation fn match(args: &Expr, target: []FnDeclAst) Expr;
@annotation fn impl((names, cond): ([] Ident, Fn), target: &BlockAst);
@annotation fn annotation(args: (FnDecl, FnDecl), target: Unit) ExprAst;
