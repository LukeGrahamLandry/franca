// 
// Annotations are macros. 
// Writing `@name(args) target` calls `name(args, target)` at comptime. 
// But the annotation handler recieves things as an Ast, rather than as a value. 
// Annotation handlers are still normal functions. One may directly call another. 
//
// You can define when your annotation can be used by the types of its handler arguments. 
// - `args` are the things in the brackets.
//      If its type is Unit, the annotation must be called without brackets. 
//      If args is not an ast subtype, it will be evaluated at comptime. 
// - `target` is the expression or statement after the annotation invocation. 
//      If its type is Unit, it will not consume the item after it and the value you return will replace only the invocation itself.
//      Otherwise, the value you return will replace both the target and the invocation. 
// - It is an error for both to be unit. 
// - You can never recieve annother annotation invocation as an arument. They're just applied in sequence. 
//
// It's very good if your annotation is @pure, then the compiler (or IDE plugin) can cache it. 
// TODO: thats an advantage to structured side effects like AnnotationAction::Collect. 
//
// TODO: there's really two types of Type. 
//       1) A local type in your own program that needs to be comptime only.
//       2) The compiler working on asts but you don't want it to be running in the interpreter. 
//       Actually thats fine. A type is just a type info and I've already thought about a strategy 
//       where the interpreter calls into precompiled code if avaiable. 
//       The compiler's runtime is always someone else's comptime. 
// 
// TODO: maybe split this into ast.txt and syntax.txt

@module(ast, impl=core, vis=Public) {
    // TODO: how to give each ast a uid? 
    // TODO: how to express that these are linear types? no copy, no alias. 
    
    // You don't need to declare enum payloads as seperate types like this (they can be inline). 
    // Sometimes its useful because it lets you write functions that take a specific case as a parameter.
    enum ExprAst = Block | Call | VarAst | TupleLiteral | FnDeclAst | WithFreeVariables | CAny;
    struct Block = { 
        // These are run for side effects but thier results are discarded. 
        body: []ExprAst, 
        // TODO: nil is the same as unit so why bother? maybe you'd like to know for better error messages? 
        /// This is returned when the block is evalutated. It's the thing at the end without a semicolon. 
        value: ?&ExprAst,
    };
    struct Call = { name: &ExprAst, arg: &ExprAst };
    struct TupleLiteral = ([]ExprAst);
    struct FnDeclAst = { Arg: LazyType, Ret: LazyType, body: &WithFreeVariables };
    
    /// Same as interp::Value. 
    enum CAny = BigNum | []CAny | {}(CAny, CAny) | Str | Type;
    
    /// - function body: vars=parameters
    /// - generic impl body: vars=generic parameters
    /// - trait definition body: vars=Self and associated types
    struct WithFreeVariables = (Pattern, &ExprAst);
    
    // TODO: holy shit, why can't the parser generator take this as input??? 
    // Name and optional type annotations that can bind values. 
    // - `let <Pattern> = <ExprAst>;`
    // - `fn <?Symbol>(<Pattern>) <?ExprAst> = <ExprAst>;`
    enum Pattern = []Pattern | Binding; 
    struct Binding = { name: ?VarAst, type: ?ExprAst };
    
    /// Bake comptime known values into an ast. 
    /// This allows specialization for generics. 
    fn bind_variables(replacements: Map(VarAst, CAny), ast: WithFreeVariables) ExprAst;
    
    /// Since types can be comptime expressions, places on the ast that we know must have a type might not be ready yet. 
    /// This gives you a way to precive the difference and not just auto evaluate anything you try to look at since it might fail. 
    enum LazyType = Finished(Type) | Pending(&ExprAst) | Infer();
    
    fn try_cast(LazyType) ?Type;
    fn unwrap(LazyType) Type;
    
    enum VarKind = Let | Var | Const | FuncParam | GenericParam;
    struct VarAst = { name: Symbol, uid: i64, decl: VarKind, ty: LazyType };
    
    /// Nil: the compiler cannot infer the type. 
    fn expr_type(ast: &ExprAst) ?Type;
    fn eval_expr(ast: ExprAst) CAny = eval_expr(CAny, ast);
    /// Calling this one is better because it lets you give a type hint. 
    fn eval_expr(T: Type, ast: ExprAst) Result(T, _);

    struct CommentAst = (Str);
    fn get_comments(ast: ExprAst) ?CommentAst;
    
    // TODO: might not want to provide this because then i need to keep parent ptrs all the time. 
    fn get_parent(ast: ExprAst) ?ExprAst;
    
    // TODO: figure out if this is the right name. https://stackoverflow.com/questions/134887/when-to-use-or-quote-in-lisp
    //       maybe dont bother trying to feel clever and just call it parse. 
    /// Manually invoke the parser on a computed string. Useful for code generation when the ast api is too verbose. 
    /// The result may have free variables that you can fill in later. 
    @comptime 
    fn quote(Str) AstExpr;
    
    
    @pub fn same_ast(a: Str, b: Str) = assert_eq(parse_ast(a), parse_ast(b));
    
    // Produce a constant literal. 
    fn cast(Type) AstExpr;
    
    // TODO: consistant naming
    @pub fn function_decl(name: ?Symbol, args: Pattern, ret_type: ?AstExpr, body: ?AstExpr) FnDeclAst;
}

// TODO: maybe postfix syntax with `!` on an expression. so you could have, whatever()!await, whatever()!try, whatever()!addr, 
//       nullish coallesing: falible!if.method()!if.other() === falible.map(fn(v) = v.method().map(fn(v) = v.other()))
//       seems most useful for things that can't be functions. 
//       whatever()!unwrap, fallable!or(default) but that could be a method, i could just give in and have dot syntax.
//       becomes obvious if i use that for fields and let you have getters so you could just return functions anyway. should just make it the default. 
//       should it just be sugar? @a(b) === b!a

struct AnnotationHandler = { Arg: T, Target: T, Ret: T, f: fn(Arg, Target) Ret };
struct OverloadHandler = fn(Arg: ?Type, Ret: ?Type) ?FnDecl;
struct GenericHandler = { arg_count: i64, cond: fn([] Type) bool, f: fn([] Type) AstExpr };

@module(compiler, all=Public) {
    //! You don't want fancy comptime execution to mean everything is a black box to the compiler. 
    
    // TODO: these are local to a module. 
    fn annotation_handlers() {}(Symbol, []AnnotationHandler);
    fn overload_handlers() {}(Symbol, []OverloadHandler);;
}

// TODO: require `;` after if target is Unit? But then you can't use it as an expression. 
@in(@module(syntax, impl=core, vis=Public));

//
// Builtin Function Annotations: 
// Each branch of FnFlags (in types.txt) can be applied to a function definition. 
// They don't have an immediate effect on the Ast but other parts of the compiler know they exist and check for them. 
//

// TODO: doc: set default visibility of items in module because its painful to put @pub everywhere. 
// TODO: doc: `enum A = Thing` (bame = "Thing", payload = type Thing) is not the same as `enum A = Thing()` (name = "Thing", paylaod = type Unit).
// TODO: doc: @in(...) at the top of a file for avoiding an extra indent

// The target function is needed to compile the compiler. 
// While bootstrapping the compiler, 
// - Builtin: There is a version written in rust
// - Interp: It runs in the interpreter
// That's enough to compile the real version to rust and future builds call that directly. 
@annotation @intrinsic
fn boot(args: Builtin | Interp, target: FnDecl) FnDecl = match(args, [
    (Builtin, add_flag(target, BootBuiltin)),
    (Interp, add_flag(target, BootInterp)),
])
// TODO: allow @boot on a whole module and just iterate its decls. 


// TODO: allow leading `|` on enums so you can have them all off the end and look consistant. 
// TODO: some way to tag the default case. give annotations a way to express that they want to access the parent and generate code in that scope. 
//       so it could generate an `fn default() E`.
/// What to do with the return value of the handler. 
enum AnnotationAction = 
    // Put the resulting Ast back at the annotation call site. 
    | Replace
    // Store the result parallel to the ast so it can be retrived later. 
    // Examples: @example, @invarient. 
    // TODO: really you dont want ^ in either case. you just want a list
    | Save(Symbol)
    // Build up a list of all the results (and thier callsites) and pass it to a function after all calls to your annotation have finished. 
    // TODO: doc: this syntax for an unbounded generic 
    //            this is a function accepting a list of pairs where the first is inferred (return type of the annotation in this case) and the second is Loc. 
    // TODO: maybe this is always better than Save(_) since you could have a collector that does that. 
    // TODO: what if you want to access the target but not consume it? i guess at some point just put your list in a global
    | Collect(fn([](_, Loc)) Unit)
    // Same as above but grouped and calls the handler multiple times.
    // Examples: @switch
    | CollectMap({ K: Type, V: Type, f: fn(K, [](V, Loc))})
;

// TODO: doc: If the args are references, you don't consume them and they continue on to the rest of compilation. TODO: dont allow escaping. 
//       how do you decide if you want Collect or a global? i guess if you want it all at the end or as you go.
//       have a better way of expressing this than just allowing escaping references to the ast. 
@annotation 
fn annotation(args: AnnotationArg = Replace, target: FnDeclAst) Expr = {
    todo_assert(eq(args, Replace));
    // i was thinking for generics where it might happen multiple times but maybe its fine cause you eat it. 
    // its really the overload handler that needs to use it multiple times and not mutate. 
    // assert(not(mutates_args(target)), "Annotation must not mutate Ast node. Make a copy and return it instead.");
    const F: FnType = unwrap(expr_type(target));
    const T: Tuple(Type, 2) = F.Arg;
    set_flags(target, all(get_flags(target), Annotation | Comptime), true);
    let handler = { Arg: first(T), Target: second(T), Ret: F.Ret, f: compile_expr(F, target) };
    let prev = insert(annotation_handlers, name(target), handler);
    target
}

fn CRes(T: Type) Type = Result(T, CompileError);

fn todo_assert(cond: bool) = assert(cond, "Not yet implemented.");

@annotation @intrinsic
fn module(args: Expr, target: ()) !Expr;

@annotation @intrinsic
fn ffi(args: Target, target: ()) !Expr;

@annotation @intrinsic @pure
fn type_of(args: Expr, target: ()) !Expr;

/// puts you in place expression mode
@annotation @intrinsic @pure
fn addr(args: Expr, target: ()) !Expr;

// Try to compile the target but require a specific error. Useful for testing safety checks. 
@annotation @intrinsic @pure
fn assert_compile_error(args: ?CompileError, target: Block) CRes(());

// TODO: @return @break @continue

// TODO: not use this if target is rust or zig
// Note: this implementation can't call methods that use match? or maybe its fine since someone else would have compiled them. 
// TODO: rewrite to take advantage of function params being a Pattern
@annotation @auto @pure
fn match(args: ExprAst, target: []FnDeclAst) ExprAst = {
    const E: EnumType = unwrap(expr_type(args));
    
    // Each branch function must return the same type. 
    let Out = unwrap(resolve_fold_types(map(target, fn(T: FnDeclAst) Type = Ret(T))));
    
    let handlers: Iter(Tag(E), FnDeclAst) = foreach(target, fn(f: &FnDeclAst)={
        let F: FnType = expr_type(f);
        let cases = if(eq(name(f), nil()), fn={
            // If they didn't specify a name, just look for the argument type. 
            filter(cases(E), fn(name: Symbol, Payload: Type) = eq(Payload, F.Arg))
        }, fn = {
            filter(cases(E), fn(name: Symbol, Payload: Type) = and(eq(name, F.name), eq(Payload, F.Arg)));
        });
        
        @assert(eq(len(cases), 1), "ambigous or missing match branch");
        let action = eval_expr(f);
        ((get(cases, 0)), fn(payload) Out = cast(action(payload)))
    });
    
    assert_eq(len(handlers), len(cases(E)));
    
    let join_branches = fn(prev: AstExpr, tag: Tag(E), handler: FnDeclAst) AstExpr = {
        let tag_expr = CallAst("tag_of", args, Tag(E));
        let cond_expr = CallAst("eq", (tag_expr, tag), bool);
        @if(cond_expr, handler, prev)
    };
    
    fold(handlers, quote("comptime_unreachable()"), join_branches)
}

// Loop over an iterator. 
// This is a trivial wrapper around the `for` function that gives it a more familiar syntax. 
@example(same_ast("@for(i, range(0, 10)) { print(i); }", "for(range(0, 10), fn(i) = { print(i); })"))
@annotation @auto @pure
fn for((names, iter): (Pattern, AstExpr), target: WithFreeVariables) AstExpr {
    let f = function_decl(nil(), names, Unit, target);
    call_expr(for, iter, f);
}

// TODO: move this to iter.txt
@impl((I, T), fn next(I) ?T) {
    fn for(iter: I, sink: fn(T)) {
        var value: T = next(iter);
        while(fn = ne(value, nil()), fn = {
            sink(value);
            value = next(iter);
        })
    }
}

// TODO: replace the `for` syntax with this. not sure if i actually want to change the name. 
// `@impl((T, U), and(allow_type(T), allow_other(U))) { ... }`
@annotation
fn impl((names, cond): ([] Ident, Fn), target: BlockAst) = {
    make_fn()
    let args = struct_type(map(names, fn(name: Symbol)=()))
}


// TODO: handle type matching over Any.

/// This makes more sense as a function because you don't want to eagerly evaluate. 
@annotation @auto @pure
fn if((cond, if_true, if_false): (ExprAst, FnDecl, FnDecl), target: Unit) AstExpr {
    panic("@if(bool, fn() T, fn() T) T) not implemented on the current backend. No default available.")
}

// Find a type that all `types` can `cast` to. 
// Used for typechecking branching execution paths that rejoin eventually. 
fn resolve_fold_types(types: []Type) Result(Type, _);

// TODO: move this to iter.txt
for (T, I(_)) with is_trait(Iter, I){
    // Call `f` on pairs from the iterator until exauhsted. 
    fn reduce(self: I(T), f: fn(T, T) T) ?I = {
        var rolling = @try(next(self));
        @todo
    }
    
    for U {
        // TODO: figure out if this is left or right. 
        fn fold(self: I(T), initial: U, f: fn(U, T) U) = {
            var rolling = initial;
            while(fn() T = @try(next(self)), fn(e: T) {
                rolling = f(rolling, e);
            })
        }
    }
}

// TODO: support destructuring in args 

struct FnArg = { name: ?Symbol, T: ?ExprAst, default_value: ?ExprAst };
struct FnArgsAst = []FnArg;

@invarient(fn(f: FnArgsAst) bool = nand(is_nil(name), is_nil(T)));

@annotation
fn trait(((name, placeholder, cond): (Symbol, Symbol, BlockAst), target: [](VarDeclAst | FnDeclAst)) = {
    // TODO: a meta type for traits 
    // name is used for the type
    // placeholder is used as generic in later exprs
    // cond is extra requirements on types to implement
    // target is associated types/values or fn declarations or fn implementations in terms of other declarations
    todo()
}

// for pattern matching across function definitions 
@annotation(CollectMap({ K: FnSig, V: FnDeclAst, f: build_switch_body }))
fn switch(args: Unit, target: FnDeclAst);

/// Declares an outer function that matches over its argument and dispatches to one of the `cases`.
@private fn build_switch_body(sig: FnSig, cases: [](FnDeclAst, Loc)) AstExpr;

/// Useful for documenting behaviour of a function. And getting an automatic reminder when your docs get out of date. 
/// The expression is not evaluated, it just hangs out on the Ast. It should not contain free variables. 
/// The default test runner will compile and run them all, failing if they panic. 
/// Use `assert` and friends to expect certain values.
/// Equivilent to https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html
/// (but already part of your code instead of needing an extra tool to parse it out of comments).
// Note: we don't force type checking if not building for test currently. 
@annotation(Collect(maybe_run_examples))
fn example(args: FnDeclAst, target: Unit) FnDeclAst = args;

// Run if testing
@private fn maybe_run_examples(examples: []FnDeclAst);

// TODO: specilizations for specific targets that return a string in the host language. 

// TODO: is this really better than Result(T, _) which isnt a special case? 
// Produce a result type with the error type infered based on the function body. 
// fn whatever(foo: Bar) @result(Baz) = { ... }
// TODO: i want the = so its consistant. maybe since that never has an ast node its fine and you just ignore. 
// TODO: really you want to pattern match and say "whenever you see this annotation as the return type in a function declaration"
@annotation @pure
fn result(args: Type, target: BlockAst) BlockAst;

// Provide a function that will always return true. 
// The allows declaring some constraint on values of a certain type. 
// Any time the compiler notices values of the argument type, it may choose to call `assertion`, and panic if it returns false. 
// In optimising builds, `assertion` will never be called. 
// `assertion` is no longer a normal function and cannot be called manually
@annotation
fn invarient(assertion: FnDecl, target: Unit);

// Same as @invarient but allow the compiler to optimise assuming you didn't lie. 
// It is safety checked illegal behaviour to violate this assertion. 
// The fact that `assertion` returns true is treated as a staticlly known constant regardless of the arguments. 
// Like if you try to check the asserted condition in normal code else where the compiler might decide its redundant and remove it. 
@annotation
fn unsafe_invarient(assertion: FnDecl, target: Unit) = {
    invarient(assertion, target);
}

// TODO: Result(T, E) -> (T, E)
enum TypeStructure = Tuple(TupleType) | Struct(StructType) | Unit(Symbol);
fn Destructure(@type T) StructuralPattern;
fn destructure(T) StructuralPattern; 

// Evaluate a fallible expression and return an error to the parent if not successful. 
// This can't be a normal function because it has to be able to early return. 
@annotation @pure
fn try(args: ExprAst, target: ()) ExprAst = {
    let Maybe = expr_type(args);
    // TODO: support actual destructuring 
    @match(Maybe) {
        fn(Result(T, E): Type)
    }
    // assert that it has a success assosiated tpye
    
    todo()
}

// Exit the current function and indicate an error. 
// How this is expressed depends on the return type of the function. 
// - Option(T): ignore arg and return nil.
// - Result(T, E): coerce arg to E and return Err(arg). 
// - T: panic. use `debug(arg)` as the message. 
@annotation @pure
fn error(args: ExprAst, target: ()) ExprAst; 

// Like `fn assert` but using @error on failure instead of `fn panic`
@annotation @pure
fn assert(args: ExprAst, target: ()) ExprAst; 

fn todo() Never = panic("Not yet implemented");

// TODO: not sure if i want to provide this cause its probably slow to walk an extra time but maybe that's a you problem 
@annotation
fn preprocess_ast(args: (), target: fn(ExprAst));

// TODO: comptime panic should take you to a repl where you can inspect variable values. 

// maybe use rust macro syntax to resolve ambiguity when its an expression with no postfix target. 


// TODO: can do a really nice thing for closure interop with rust, 
//       since i know the captures, allow expressing that as extra reference arguments
//       so you pass in the borrow every time you call and it gives it back. 
