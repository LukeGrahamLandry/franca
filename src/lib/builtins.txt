// TODO: rename this file. 

struct f64 = @intrinsic;
struct i64 = @intrinsic;
struct u8 = @intrinsic;
struct bool = @intrinsic;
let Unit = ();

////////////////////
/// Control Flow ///
////////////////////

for T {
    // I don't support escaping captures, a function accepting a closure is always inlined. 
    fn if(cond: bool, a: fn() T, b: fn() T) T;
    
    fn if(cond: bool, a: fn() T) ?T = if(cond, a, fn = nil());
}

for T {
    // TODO: Flow(()) result has 1 bit of info instead of 0. dont want to always track if you breaked out of the loop. but could use it as else like python 
    enum Flow(T) = Continue() | Break(?T);
    fn from(Unit) Flow(T) = Continue;
    
    // This is guarenteed to compile to a c while loop.
    @intrinsic fn while(cond: fn() bool, body: fn() Flow(T)) ?T = {
        if(cond(), fn = {
            match(body(), [
                (Continue, fn = while(cond, body)),
                (Break, fn (res: ?T) = res)
            ])
        }, fn = nil())
    }
}

// TODO: unify this with @match
for (E, T) with is_enum(E){
    let MatchArg(T) = map(tags(E), fn (tag) = (Tag(E), fn(Payload(E, tag)) T));
    
    fn match(E, MatchArg(T)) T;
}

@intrinsic fn defer(fn());
@intrinsic fn err_defer(fn());

//////////////////
/// Falibility ///
//////////////////

@boot(interp)
@module(option, impl=core) {
    for T {
        @intrinsic enum Option(T) = Some(T) | None();
        
        fn nil() ?T = None;
        fn is_nil(t: ?T) bool = match(t, [
            (Some, fn(_) = false),
            (None, fn = true),
        ]);
        
        // This will be called implicitly in Relaxed Mode. 
        fn unwrap(maybe: ?T) T = match(maybe, [
            (Some, fn(v: T) T = v),
            (None, fn = panic(concat("Unwrap failed: ", type_name(T)))),
        ]);
        
        fn cast(self: ?T) Result(T, ()) = match(self, [
            (Some, fn(v: T) T = v),
            (None, fn = Err(())),
        ]);
        
        fn cast(self: &?T) ?&T;
        
        fn default() ?T = nil();
        
        fn cast(t: T) ?T = Some(t);
        
        for U {
            fn then(self: ?T, if_present: fn(T) ?U) ?U = match(self, [
                (Some, if_present),
                (None, fn = None),
            ]);
        }
        
        fn or_else(self: ?T, default: fn() T) T = @match(self) {
            fn some(t: T) = t;
            fn none() = default();
        ]);
        
        when fn eq(T, T) bool {
            // Either or both same but not both different. 
            fn xor(a: ?T, b: ?T) ?T = match(a, [
                (Some, fn(a: T) T = match(b, [
                    (Some, fn(b: T) T = if(eq(a, b), fn = a, fn = nil())),
                    (None, fn = a),
                ])),
                (None, fn = match(b, [
                    (Some, fn(b: T) T = b),
                    (None, fn = nil()),
                ])),
            ])
        }
    }
}

@boot(interp)
@module(result, impl=core) {
    for R, E {
        @intrinsic enum Result(R, E) = Ok(R) | Err(E);
        
        // This will be called implicitly in Relaxed Mode. 
        fn unwrap(r: Result(R, E)) R = match(r, [
            (Ok, fn(r: R) R = r),
            (Err, fn(e: E) R = panic(concat("Unwrap failed: "), debug(e))),
        ]);
        
        fn cast(r: Result(R, E)) ?R = match(r, [
            (Ok, fn(r: R) R = e),
            (Err, fn(e: E) R = nil()),
        ]);
        
        // TODO: allow fn name() Result(T, _) { ... } to infer error type from callees. comptime function to join two enums. 
    }
}

/////////////////
/// Operators ///
/////////////////  

// TODO: once i have closures, call this numbers and have a version that uses the lambda calculus thing. 
@boot(builtin)
@module(name=ops, impl=src, cond=fn = any(target(), C | Rust | Zig)) {
    when any(target(), C){
        @pub let f64 = embed_type("double");
        @pub let i64 = embed_type("int64_t");
        @pub let u8 = embed_type("uint8_t");
        @pub let bool = embed_type("_Bool");
        
        @pub fn cast(n: u8) i64 = embed_expr("(int64_t)n");
        @pub fn cast(n: u8) f64 = embed_expr("(double)n");
    }
    
    when any(targets(), Rust | Zig){
        @pub let f64 = embed_type("f64");
        @pub let u8 = embed_type("u8");
        @pub let bool = embed_type("bool");
        @pub let i64 = embed_type("i64");
    }
    
    // TODO: overflow?
    when any(target(), C | Rust | Zig) {
        for T in [f64, i64, u8] {
            @pub fn add(T, T) T = embed_expr("$0 + $1");
            @pub fn sub(T, T) T = embed_expr("$0 - $1");
            @pub fn eq(T, T) bool = embed_expr("$0 == $1");
            @pub fn mul(T, T) T = embed_expr("$0 * $1");
            @pub fn div(a: T, b: T) T = {
                sanity(fn { ne(b, 0) });
                embed_expr("$0 / $1")
            }
            @pub fn mod(a: T, b: T) T = {
                sanity(fn { ne(b, 0) });
                embed_expr("$0 % $1")
            }
            @pub fn neg(T) T = embed_expr("-$0");
            @pub fn lt(T, T) bool = embed_expr("$0 < $1");
        }
    }
}

// TODO: warning if you call these outside a `when` block with a target check
for T {
    // Use `$n` to access the nth argument of the current function. 
    // Seems fishy to use names if i just want to do a dumb replacement without parsing. 
    @comptime embed_expr(Str) T;
}
@comptime embed_type(Str) Type;

for (T, U) with fn eq(T, U) bool {
    // Functions with 'auto' have a default implementation but can be replaced by other code 
    @auto fn eq(a: U, b: T) bool = eq(b, a);
    @auto fn ne(a: T, b: U) bool = not(eq(a, b));
    @auto fn ne(a: U, b: T) bool = not(eq(a, b));
    
    fn assert_eq(a: T, b: U) = if(ne(a, b), fn = panic(concat(concat(debug(a), " != "), debug(b))));
}

for T with and(fn lt(T, T) bool, fn eq(T, T) bool) {
    @auto fn gt(a: T, b: T) bool = not(le(a, b));
    @auto fn le(a: T, b: T) bool = or(eq(a, b), lt(a, b));
    @auto fn ge(a: T, b: T) bool = or(eq(a, b), gt(a, b));
}

for T in [f64, i64, u8] {
    fn pow(a: T, b: T) T = {
        sanity(fn { or(ge(b, 0), ge(a, 1)) });
        pow_unchecked(a, b)
    }
    fn pow_unchecked(a: T, b: T) T;

    @intrinsic fn sqrt(n: f64) T = pow(n, 0.5);
    
    fn asin(n: T) Angle;
    fn acos(n: T) Angle;
    fn atan(n: T) Angle;
    fn from_degs(degs: T) Angle;
    fn from_rads(reds: T) Angle;
    fn as_degs(degs: Angle) T;
    fn as_rads(reds: Angle) T;
    
    fn default() T = 0;
}

fn default() bool = false;
fn default() Angle = 0.0;

struct Angle = (f64);

fn sin(n: Angle) f64;
fn cos(n: Angle) f64;
@intrinsic fn tan(n: Angle) f64 = div(sin(n), cos(n));

fn pi() f64 = 3.1415926535897;

fn bits(v: f64) i64;
fn try_from(v: f64) ?i64;
fn try_from(v: i64) ?f64;
fn try_from(v: f64) ?u8;
fn try_from(v: i64) ?u8;

// I want to reserve extra NaNs for niche optimisation tricks.  
@unsafe fn from_bits(n: i64) f64 = transmute(n);

for T in [bool, i64] {
    fn and(a: T, b: T) T;
    fn or(a: T, b: T) T;
    fn xor(a: T, b: T) T;
    fn not(a: T) T;
    
    fn hash(v: T, hasher: fn(i64));
}

// Short circuiting versions that take closures instead of values. 
@intrinsic fn and(fn() bool, fn() bool) bool;
@intrinsic fn or(fn() bool, fn() bool) bool;
@intrinsic fn xor(fn() bool, fn() bool) bool;

///////////////////
/// Conversions ///
///////////////////

for T {
    fn move(T);
    fn copy(ptr: &T) &T = ptr;
    fn cast(v: T) T = v;
    @auto fn debug(&T) String;
}

// This is just a way to give a type hint
fn as(T: Type, v: T) T = v;

fn blessed_nan_bits() i64;

for T {
    // No doubles
    fn combinations(Array(T)) Array((T, T));
    
    // Syntax sugar
    fn cast(&T) Ptr(T);
    fn cast(Ptr(T)) &T;
    fn cast(?T) Option(T);
    fn cast(Option(T)) ?T;
    fn cast(T) ?T = T;
}

for (F, Args, Ret) with call(F, Args) Ret {
    fn cast(F) FnPtr(F);
    fn cast(FnPtr(T)) &Unit;
    
    fn call(FnPtr(F), Args) Ret;
}

for (A, B) with eq(size_of(A), size_of(B)) {
    @unsafe fn transmute(A) B;
}

@intrinsic fn unreachable() Never = exit(1);

@safety @intrinsic fn sanity(cond: fn() Bool) = sanity(cond(), fn = "Safety check failed.")
@safety @intrinsic fn sanity(cond: fn() Bool, msg: fn() Str) = assert(cond(), msg)

fn is_unchecked() bool = {
    let r = true;
    (@safety fn = { r = false })();
    r
}

fn assert(cond: Bool, msg: Str) = assert(cond, fn = msg);
fn assert(cond: Bool, msg: fn() Str) = if(cond, fn = panic(msg()));

fn panic(msg: Str) Never = {
    print(msg);
    unreachable();
}

struct Duration = (f64);
fn as_millis(Duration) f64;
fn from_millis(f64) Duration;

@impure fn print(s: Str);
for T with debug(T) String {
    fn print(t: T) print(debug(t));
} 

fn todo_assert(cond: bool) = assert(cond, "Not yet implemented.");
