// These are all intrinsic candidates. 

fn defer(fn());

// TODO: Box and Rc should be generic over alloc
trait Allocator = and(allocate(&A, i64) Ptr(Unit), free(&A, Ptr(Unit), i64))

@comptime fn stride(Type) ?i64;

for T with ne(stride(T), nil()) {
    struct Slice(T) = { len: i64, data: &T };
    
    fn set(arr: Slice(T), i: i64, v: T) {
        sanity(fn = and(ge(i, 0), lt(i, arr.len)), "OOB");
        let ptr = offset(arr.data, i);
        set(ptr, v);
    }
    
    fn get(arr: Slice(T), i: i64) &T {
        sanity(fn = and(ge(i, 0), lt(i, arr.len)), "OOB");
        offset(arr.data, i)
    }
    
    fn len(arr: Slice(T)) i64 = arr.len;
    
    for A with Allocator(A) {
        struct Array(T, A) = { len: i64, data: &T, capacity: i64, alloc: &A };
        
        fn cast(arr: Array(T, A)) Slice(T) = Slice({ arr.len, arr.data })
        
        fn array(alloc: &A) Array(T, A) = Array({ len: 0, capacity: 0, alloc, data: nil() })
        fn array(alloc: &A, capacity: i64) Array(T, A) = {
            let data = allocate(alloc, mul(stride(T), capacity));
            Array({ len: 0, capacity, alloc, data })
        }
        
        fn reserve(arr: &Array(T, A), extra: i64) {
            if(lt(arr.capacity, total), fn = {
                let cap = max(max(add(arr.capacity, extra), mul(arr.capacity, 2)), 4);
                let new = array(arr.alloc, cap);
                enumerate(arr, fn(i, e) = set(new, i, e));
                free(arr);
                set(arr, new);
            }, fn=())
        }
        
        fn push(arr: &Array(T, A), v: T) = {
            reserve(arr, 1);
            set(len(arr), v);
        }
        
        fn drop(arr: Array(T, A)) = free(arr.data, mul(stride(T), arr.capacity))
    }
}

for T {
    // I don't support escaping captures, a function accepting a closure is always inlined. 
    fn if(cond: bool, a: fn() T, b: fn() T);
}

for (Arr, T) with and(fn get(Arr, i64) T, fn length(Arr) i64) {
    fn foreach(arr: &Arr, body: fn(&T)) = 
        enumerate(arr, fn (_, v) = body(v))
    
    fn enumerate(arr: &Arr, body: fn(i64, &T)) {
        let i = 0;
        while(fn { lt(i, len(arr)) }, fn { let v = get(arr, i); body(i, v); i = add(i, 1); })
    }
}

fn while(cond: fn() bool, body: fn()) {
    if cond() {
        body();
        while(cond, body);
    }
}

for T in [f64, i64, Angle, u8] {
    fn add(a: T, b: T) T;
    fn sub(a: T, b: T) T;
    fn neg(n: T) T = sub(0, n);
    fn eq(a: T, b: T) bool;
}

for (T, U) with eq(T, U) bool {
    // Functions with 'auto' have a default implementation but can be replaced by other code 
    @auto fn eq(a: U, b: T) bool = eq(b, a);
    @auto fn ne(a: T, b: U) bool = not(eq(a, b));
    @auto fn ne(a: U, b: T) bool = not(eq(a, b));
}

for T with and(fn lt(T, T) bool, fn eq(T, T) bool) {
    fn lt(a: T, b: T) bool;
    @auto fn gt(a: T, b: T) bool = not(le(a, b));
    @auto fn le(a: T, b: T) bool = or(eq(a, b), lt(a, b));
    @auto fn ge(a: T, b: T) bool = or(eq(a, b), gt(a, b));
}

for T in [f64, i64, u8] {
    fn mul(a: T, b: T) T;
    fn div(a: T, b: T) T {
        sanity(fn { ne(b, 0) });
        div_unchecked(a, b)
    }
    fn mod(a: T, b: T) T;
    fn pow(a: T, b: T) T {
        sanity(fn { or(ge(b, 0), ge(a, 1)) });
        pow_unchecked(a, b)
    }

    fn sqrt(n: f64) T = pow(n, 0.5);
    
    fn asin(n: T) Angle;
    fn acos(n: T) Angle;
    fn atan(n: T) Angle;
    fn degs(degs: T) Angle;
    fn rads(reds: T) Angle;
}

struct Angle = (f64);

fn sin(n: Angle) f64;
fn cos(n: Angle) f64;
fn tan(n: Angle) f64 = div(sin(n), cos(n));

fn pi() f64 {
    3.1415926535897
}

for T {
    enum Option(T) = Some(T) | None;
    
    // This will be called implicitly in prototyping builds
    fn unwrap(maybe: ?T) T;
    
}

for (A, I(A)) with next(I(A)) ?T {
    fn filter(I(A), fn(&A) Bool) I(A);
    fn len(I(A)) i64;
    
    for B {
        fn map(iter: I, f: fn(A) B)) I(B);
    }
}

@comptime fn is_enum(Type) Bool;
@comptime fn Tag(Type) Type;
@comptime fn tags(Type) Slice(Tag(Type));
@comptime fn Payload(Type, Tag(Type)) Type;

for (E, T) with is_enum(E){
    let MatchArg(T) = map(tags(E), fn (tag) = (Tag(E), fn(Payload(E, tag)) T));
    
    fn match(MatchArg(T)) T;
}

for R, E {
    enum Result(R, E) = Ok(R) | Err(E);
    
    // This will be called implicitly in prototyping builds
    fn unwrap(r: Result(R, E)) R {
        match([
            (Ok, fn(r: R) R = e),
            (Err, fn(e: E) R = panic(concat("Unwrap failed: "), debug(e))),
        ])
    }
}

// 'cast' is called implicitly by the compiler
fn cast(v: Angle) f64;
fn try_from(v: f64) ?i64;
fn try_from(v: i64) ?f64;
fn cast(v: u8) i64;
fn cast(v: u8) f64;
fn try_from(v: f64) ?u8;
fn try_from(v: i64) ?u8;

fn bits(v: f64) i64;

for T in [bool, i64] {
    fn and(a: T, b: T) T;
    fn or(a: T, b: T) T;
    fn xor(a: T, b: T) T;
    fn not(a: T) T;
    
    fn hash(v: T, hasher: fn(i64));
}

// A unique type to hang methods off 
struct StupidHash = (i64);

// Note the extra parens to destructure self 
fn hash_i64((self): &StupidHash, h: i64) {
    set(self, xor(get(self), h))
}

fn hash_i64((self): &StupidHash) i64 {
    swap(self, 0)
}

// Syntax sugar for un-named traits: 
//     for (X) with fn name(X) { ... }
//     trait __X(X) = fn name(X); for (X) with __X(X) { ... }
trait Hasher(H) = and(fn pop_hash(&H) i64, fn hash_i64(&H, i64));

@comptime fn and(a: Trait, b: Trait) Trait;

for (K, V, H) with and(and(Hasher(H), fn hash(V, fn(i64)), fn eq(K, K))) {
    fn get_hash(hasher: &H, v: T) i64 {
        hash(v, fn(n) { hash_i64(hasher, n) })
        pop_hash(hasher)
    }
    
    fn hashmap(hasher: H) HashMap(K, V, H);
    fn get(&HashMap(K, V, H), &K) ?&T;
    fn insert(&HashMap(K, V, H), K, V) ?T;
    fn len(&HashMap(K, V, H)) i64;
    fn drop(arr: HashMap(K, V, H));
    
    if (K, V) with and(and(clone(K) K), clone(V) V) {
        fn clone(&HashMap(K, V, H)) &HashMap(K, V, H);
    }
    
    // Generic structs are really just comptime functions 
    // @comptime fn HashSet(K: Type, H: Type) Type = unique(HashMap(K, Unit, H));
    struct HashSet(K, H) = HashMap(K, Unit, H);
    fn hashset(Array(K)) HashSet(K, H)
}

for T {
    fn nil() ?T;
    fn is_nil(?T) bool;
    
    fn move(T);
    fn copy(ptr: &T) &T = ptr;
    
    // You can still overload with a different return type 
    fn deref(ptr: &T) &T = ptr;
    
    fn cast(v: T) T = T;
    
    @comptime fn comptime(fn() T) T;
    @comptime fn reflect(T) TypeInfo;
    @auto fn debug(&T) Str;
}

for T with move(T) {
    @comptime @auto fn safe_to_leak(T) bool = true 

    fn box(T) Box(T);
    fn drop(Box(T));
    fn deref(&Box(T)) &T;
    
    if safe_to_leak(T) {
        fn raw(Box(T)) &T;
    } else {
        @unsafe fn raw(Box(T)) &T;
    }
    
    fn rc(T) Rc(T);
    fn clone(&Rc(T)) Rc(T);
    fn deref(&Rc(T)) &T;
    fn strong_count(&Rc(T)) i64;
    fn weak_count(&Rc(T)) i64;
    fn take(Rc(T)) ?T;
    fn drop(Rc(T));
    
    fn weak(Rc(T)) Weak(T);
    fn clone(&Weak(T)) Weak(T);
    fn deref(Weak(T)) ?&T;
    fn drop(Weak(T));
    
    fn gc(T) Gc(T);
    fn deref(Gc(T)) &T;
    fn copy(Gc(T)) Gc(T);
    
    @auto fn swap(ptr: &T, new: T) T {
        let old = get(ptr)
        set(ptr, new)
        old
    }
    
    fn set(ptr: &T, new: T);
    fn set(ptr: &T, new: &T) = set(ptr, get(new))
    fn get(ptr: &T) T;
}

for T {
    // No doubles
    fn combinations(Array(T)) Array((T, T));
    
    // Syntax sugar
    fn cast(&T) Ptr(T);
    fn cast(Ptr(T)) &T;
    fn cast(?T) Option(T);
    fn cast(Option(T)) ?T;
    fn cast(T) ?T = T;
}


@comptime fn type_for(TypeId) Type;
@comptime fn type_id(T) TypeId;

// Note: Any is not generic over the inner type, just the pointer type. 
for Ref in [Gc, Rc, Box, Ptr] {
    struct Any(Ref) = (TypeId, Ref(Unit))
    
    fn type_id((id, _): Any(Ref)) TypeId = id;
    
    for T {
        fn cast(Ref(T)) Ref(Unit);
        
        fn any(ptr: Ref(T)) Any(Ref) = Any(type_id(T), ptr);
        
        fn try_cast((id, ptr): Any(Ref)) ?Ref(T) = 
            if(eq(type_id(T), id), fn = transmute(ptr), fn = nil())
    }
}

for (A, B) with eq(size_of(A), size_of(B)) {
    @unsafe fn transmute(A) B;
}

for (From, To) in combinations([Gc, Rc, Box, Ptr]) {
    fn from(From) To;
    fn from(Any(From)) Any(To);
}

for (Ptr, T) with deref(Ptr) &T {
    @auto fn cast(ptr: Ptr) &T = deref(ptr)
}

fn unreachable() Never;

@safety fn sanity(cond: fn() Bool) = sanity(cond(), fn = "Safety check failed.")
@safety fn sanity(cond: fn() Bool, msg: fn() Str) = assert(cond(), msg)

fn assert(cond: Bool, msg: Str) = assert(cond, fn = msg)
fn assert(cond: Bool, msg: fn() Str) {
    if cond {
        panic(msg())
    }
}

fn panic(msg: Str) Never {
    print(msg);
    unreachable();
}

for T in [bool, i64, f64, Angle, u8] {
    fn copy(&T) T;
    
    fn clone(&T) T = T;
}

enum Str = Static(Slice(u8)) | Array(u8) | Rc(Array(u8)) | Char(Int)

fn concat(Str, Str) Str;
fn print(Str);
fn append(&Str, &Str);
fn len_bytes(&Str);

enum Target = Interp | Jit | C | Browser; 
@comptime fn get_target() Target;
@comptime fn is_comptime() bool;
@comptime fn include_bytes(filepath: Str) Slice(u8);
@comptime fn include(filepath: Str);
@comptime fn include_c(filepath: Str);
@comptime fn include_c_src(code: Str);

for T {
    @comptime fn eval(code: Str) T;
}
