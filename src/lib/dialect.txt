//
// Code in this language cannot be understood out of context. 
// However, a module is the boundery of that spooky action at a distance. 
// Looking at a module and its dependencies should be enough information to understand, compile, and run it. 
// Note: modules depend on a contract, not a specific implementation,
//      so the above only works if the concrete dependencies keep thier pinky promises.  
//

enum RustSmartPtr = Box | Rc | Weak | Cow;

fn rust_ptr(f: PtrSyntax | RustSmartPtr) PtrFlags = {
    @match f {
        fn(Amp, None) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NonNull | TrackLifetime),
        fn(Amp, Mut) = all(NoAlias | NonNull | TrackLifetime),
        fn(Star, nil()) | fn(Star, Mut) = all(UnsafeDeref | BitCopy),
        fn(Box) = all(NoAlias | NeedsDrop | MoveOut),
        fn(Rc) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NeedsDrop),
        fn(Rc) = all(ConstantForMe | ConstantForOthers | InteriorMutability | NeedsDrop | OptionalDeref),
    }
}

fn zig_ptr(f: PtrSyntax) PtrFlags = {
    @match f {
        fn(Star, Const) = all(ConstantForMe | UnsafeDeref | NonNull | BitCopy),
        fn(Star, nil()) = all(UnsafeDeref | NonNull | BitCopy),
    }
}

fn c_ptr(f: PtrSyntax) PtrFlags = @match f {
    fn(Star, Const) = all(ConstantForMe | UnsafeDeref | BitCopy),
    fn(Star, nil()) = all(UnsafeDeref | BitCopy),
}

fn c_ptr(f: PtrSyntax) PtrFlags = @match f {
    fn(Star, Const) = all(ConstantForMe | UnsafeDeref | BitCopy),
    fn(Star, nil()) = all(UnsafeDeref | BitCopy),
}
