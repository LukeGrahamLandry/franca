//
// Code in this language cannot be understood out of context. 
// However, a module is the boundery of that spooky action at a distance. 
// Looking at a module and its dependencies should be enough information to understand, compile, and run it. 
// Note: modules depend on a contract, not a specific implementation,
//      so the above only works if the concrete dependencies keep thier pinky promises.  
//


fn zig_ptr(f: PtrSyntax) PtrFlags = {
    @match f {
        fn(Star, Const) = all(ConstantForMe | UnsafeDeref | NonNull | BitCopy),
        fn(Star, nil()) = all(UnsafeDeref | NonNull | BitCopy),
    }
}

fn c_ptr(f: PtrSyntax) PtrFlags = @match f {
    fn(Star, Const) = all(ConstantForMe | UnsafeDeref | BitCopy),
    fn(Star, nil()) = all(UnsafeDeref | BitCopy),
}

fn c_ptr(f: PtrSyntax) PtrFlags = @match f {
    fn(Star, Const) = all(ConstantForMe | UnsafeDeref | BitCopy),
    fn(Star, nil()) = all(UnsafeDeref | BitCopy),
}
