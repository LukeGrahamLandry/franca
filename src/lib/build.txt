//
// Comptime functions for compiling your program. 
//

@comptime fn is_comptime() bool;
@comptime fn include_bytes(filepath: Str) Slice(u8);
@comptime fn include(file: Path) = import(read_all(file))
@comptime fn import(code: Str);

for T {
    @comptime fn eval(code: Str) T;
}

@comptime enum BuildType = Run() | Test() | Build();

// TODO: a program that walks something and removes one type anotation at a time and tries to compile again and sees how 
//       many can be removed before it doesnt compile in a reasonable amount of time. 
//

@comptime enum Target = Interp | C | Rust | Zig | Wasm;
@comptime fn get_target() Target;
@comptime fn set_target(Target);

@comptime fn targeting(acceptable: FlagSet(Target)) bool = any(acceptable, get_target());

// Lookup an external C ABI function by name. 
// Something else in your meta program must ensure that the symbol is linked. 
// This is the same as a definition `@c fn <name>(<Arg>) <T>` but can be called programmatically by the meta program. 
@comptime fn get_c(name: Str, Arg, T) FnPtr(@c fn(Arg) T);

when or(eq(get_target(), C), eq(get_target(), Zig)) {
    @comptime fn import_c(code: Str, mangled: bool);
}

when eq(get_target(), Rust) {
    @comptime fn import_rust(code: Str);
    
    // These types are @rust when enabled and use the rust standard library instead of the code here. 
    // This will change behaviour! Hash algos, growth strats, etc.
    // These types with allocators are only @rust if using the default allocator. 
    for name in (result | option | slice | array | box | rc | hash_map) {
        @module(name=name, impl=zig);
    }
}

when eq(get_target(), Zig) {
    @comptime fn import_zig(code: Str);
    
    // These types are @zig when enabled and use the zig standard library instead of the code here. 
    // This will change behaviour! Hash algos, growth strats, etc.
    // The types with allocators are only @zig if using the default allocator. 
    for name in (option | slice | array | hash_map | alloc) {
        @module(name=name, impl=zig);
    }
}

//
// TODO: add this to docs
// * realized this is a common goal, not a special case for collections.
//      you often want a bag of functions/types and dont really care about the implementation.
//      and the best impl depends on what the plaform provides. 
//      like roc platforms but i dont want the implementations to be a magic seperate thing 
//      written in a different host language, tho this system does allow that if that's the best option. 
// * all module impls must have same interface but I dont force writing out the signetures an extra time 
// * optional version number (SemVer)
// * every module can have @comptime build() that can fetch dependency git repos, invoke c compiler, etc. 
// * modules declare dependencies on other modules by having @module(...) expressions in thier when block. 
// * changing which impl of a module you use will affect the entire tree. 
//   you are only be allowed one runtime module impl in a program
//   the compiletime impl may change since your program controls itself. 
//   instead one module could depend on a different impl of the same module? 
// * Modules are not namespaces. Thier functions participate in overload resolution. 
// * Depending on the target, some modules have implementations directly exposing the host's standard library. 
// * Different implementations of the same module will have performace characteristics and often observably different behaviour. 
//   But that's kinda the point. Test thoroughly when switching implementations. 
// * TODO: The main entry point of the program is expressed as a module with no default implementation. @entry magically does the module boiler plate for you. 
// * TODO: functions/types inside modules default to private and must be marked part of the public interface with @pub
// * TODO: interface with zig and rust allocator api so choose container impl seperately 
//

// TODO: put these around the right blocks in impl files
@module(name=ops, impl=src, cond=RuntimeOnly);
@module(name=math, impl=libc) when @module(libc);
@module(name=default_alloc, impl=libc) when and(@module(libc), @module(default_alloc));
@module(name=alloc, impl=core);
@module(name=hash_map, impl=core) when @module(alloc);
@module(name=array, impl=core) when @module(alloc);
@module(name=slice, impl=core);
@module(name=hash_map, impl=core) when @module(alloc);
@module(name=string, impl=core) when @module(alloc);
@module(name=box, impl=core) when @module(alloc);
@module(name=rc, impl=core) when @module(alloc);
@module(name=gc, impl=rc) when @module(rc);
@module(name=gc, impl=epsilon) when @module(alloc);
@module(name=any, impl=core);
@module(name=io, impl=libc) when @module(libc);
@module(name=file, impl=libc) when @module(libc);
@module(name=thread, impl=libc) when @module(libc);
@module(name=requests, impl=libcurl) when @module(libcurl);
@module(name=libc, impl=include);
@module(name=libcurl, impl=include);

@module(name=main) {
    /// This is the entry point the user program must define. 
    fn main();
}

let ComptimeOnly = @comptime fn(e: ExecTime) bool = eq(e, Comptime);
let RuntimeOnly = @comptime fn(e: ExecTime) bool = eq(e, Runtime);
@module(name=ops, impl=interp, cond=ComptimeOnly);

// This can be called in place of a function or struct body. 
// When the compiler tries to emit that item, it inlines the string of source code you gave it. 
// This allows the standard library to easily define basic operations like addition on floats. 
// # Safety
// - The code must be valid for the current target.
// - It must produce a type or a block (with a return statement) depending on the context. 
@unsafe @comptime fn embed_src(Str) @intrinsic;

enum ExecTime = Runtime | Comptime;
@comptime fn has_module_impl(name: ModId, impl: ModId, w: ExecType = Runtime) bool;

// # Safety: Different implementations of the same module will have performace characteristics and often observably different behaviour. 
@unsafe @comptime 
fn set_module_impl(name: ModId, impl: ?ModId, w: ExecType = Runtime) Result((), String);

// TODO: move to meta.txt
// TODO: document that struct default fields go in @auto default() T; and add that to the list of implicit functions (in relaxed mode). 
struct SemVer = { major: i64 = 0, minor: i64 = 1, patch: i64 = 0 };
enum ModVersion = SemVer | ContentHash;
@comptime struct ModId = (Str, ModVersion);
// TODO: document .. operator means call default() and then change some fields. 
fn from(name: Str) ModId = (name, ..);
fn from(major: i64) SemVer = { major, .. };
fn from(Str) SemVer;

@comptime fn bake(T) Static(T);

@comptime struct ModuleDecl = { 
    name: ModId,  // What interface is exposed?  
    impl: ModId,  // What implementation is used? 
    cond: @comptime fn(ExecTime) bool = true,   // When is this implementation supported? 
};

// TODO: switch everywhere that wants to reference a module to use this. the annotation is only for declaring a new one. 
@comptime fn dep(ModId) Module;

struct Loc = { module: ?ModuleDecl, file: Path, line: ?i64, col: ?i64 };
struct FnType = { name: Str, arg: Type, ret: Type };
struct FnDecl = (FnType, Loc);

// Start trying to compile `m` (and its dependencies) and report errors that occur. 
// Some errors can be resolved by the meta program in which case compilation will continue. 
// `f` will be called once for each error that occurs until it returns nil or `m` is successfully compiled. 
// Compilation will abort without calling `f` if comptime code panics. 
@comptime 
fn run_compilation(m: ModuleDecl, f: ?fn(CompileError) ?CompileSolution = nil());

@comptime 
enum CompileError = using({ fatal: bool, at: Loc }, 
    UndeclaredIdentifier(Str)                                             // None
    | MissingModule(ModId, ExecTime)                                      // (Module)
    | OverloadConflict({ name: Str, expr: Ast, options: Slice(FnDecl)}),  // (FnDecl)
    | MissingFunctionBody({ f: FnDecl, expr: Ast }),                      // (FnDecl)
    | TypeInferenceFailed({ expr: Ast, at: Loc, options: Slice(Type) })   // (Type)
    | ModuleConflict(Array(ModuleDecl)),                                  // (Module)
    | TypeNameConflict(Array({ name: Str, expr: Ast, at: Loc })),         // (Type)
    | Custom(Any)                                                         // (Custom(Any))
);

@comptime 
enum CompileSolution = Type | FnDecl | ModuleDecl | Custom(Any); 

@comptime 
fn custom_compile_error(Any) Any;

for T {
    @comptime fn run_with_quota(Duration, @comptime fn() T) ?T;
}

enum Implicit = OptIn | OptOut; 

//
// TODO: im not sure if i like this. its probably better to just put it in a module. 
//       its the same feeling of too many get/set config methods that made me think of modules in the first place. 
//
// The intention is to make the compiler's auto traits less magical. 
// Thier definitions are a normal meta program in auto_trait.txt.
// The only special thing about the builtin ones is the compiler knows when its allowed to implicitly call them. 
// The `for <types> with <cond> { <decls> }` syntax conceptually desugars to a call to this function. 
// It is important that the callback be fast because the compiler might call it many times during overload resolution. 
// During type inference, the full type of the callsite might not be known. 
// The callback may recieve `arg` or `ret` or both, if its not enough information to infer the other type, just return nil. 
// When there are multiple derive functions for the same name, they are all called and xor-ed together.  
@comptime @intrinsic 
fn derive_auto_fn(name: Str, i: Implicit = OptIn, fn(arg: ?Type, ret: ?Type) ?FnType); 

@comptime @intrinsic 
fn derive(name: Str, arg: Type, ret: Type); 

@comptime @intrinsic 
fn underive(name: Str, arg: Type, ret: Type); 

// TODO: control which things are called implictly so you can have faster overload resolution by not letting the compiler call cast in a certain module. 


// State which version of the compiler you expect to be compiled with. 
// There are many implicit choices whose defaults might change in later versions. 
// Old compilers will error when code expects a newer one. 
// New compilers will either emulate the old version or error if its defaults are unsupported. 
// This allows behaviour like Go where you can continue using old libraries with new compilers. 
// Note: Just downloading an old compiler is not an acceptable implementation strategy
//       because that would allow libraries to circumvent sandboxing improvements. 
//       More finesse is needed to compile the old language but allow the host meta program to control permissions with old rules. 
//
// Calling this should be the first thing your meta program does. 
@comptime fn request_compiler(v: SemVer) = assert_eq(v, current_compiler);

// This is @private to disallow `request_compiler(current_compiler)`.
@private let current_compiler: SemVer = "0.1.0";

// allow restricting this so you can have sandboxed libraies. 
// TODO: maybe also have it report each call to the meta program 
@module(ffi);

// disabling this for a dependency prevents it from doing interesting comptime execution.  
// it can still use type annotations and 
@module(impure_comptime);

// another sandboxing tool. you can disable this for a library to make it less powerful. 
@module(unsafe_code);

@comptime fn compile_warning(msg: Str) = @comptime print("WARNING: ", msg);

@comptime struct Niche = FlagSet(NonNilRef | Ptr48BitEnumTag | ReserveQuietNans)
@comptime struct OptTricks = both(Niche, FlagSet());
@comptime struct SafetyChecks = both(Niche, FlagSet(SliceBounds | Ptr48BitMemRegions));

assert(nand(tricks(Ptr48BitEnumTag), safety(Ptr48BitMemRegions))

// Check which tricks are currently enabled. 
@comptime fn tricks(OptTricks) bool;
@comptime fn safety(SafetyChecks) bool;

// Runs the function and asserts that it triggers one of the given safety checks. 
// Compilation fails iff a safety check does not fire. 
@comptime fn assert_safety_checked(SafetyChecks, @comptime fn ());

for T {
    // Do not optimise out the computation that produced a value. 
    @intrinsic fn blackbox(T) T;
}

// Goal: be able to do https://github.com/LukeGrahamLandry/yorg/blob/main/src/zazm_bindgen.zig
