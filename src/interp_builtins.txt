const Type;
const Any: Type;
const Unit: Type;
const unit: Unit = ();
const bool: Type;
const true: bool;
const false: bool;
const i64: Type;

// Debugging
fn print(_: Any) Unit;
fn assert_eq(_: Any, _: Any) bool;

// Math
fn add(_: i64, _: i64) i64;
fn sub(_: i64, _: i64) i64;
fn mul(_: i64, _: i64) i64;
fn div(_: i64, _: i64) i64;
fn eq(_: i64, _: i64) i64;
fn ne(_: i64, _: i64) i64;
fn lt(_: i64, _: i64) i64;
fn gt(_: i64, _: i64) i64;
fn le(_: i64, _: i64) i64;
fn ge(_: i64, _: i64) i64;

// Simple types
fn Ptr(inner: Type) Type;
fn Slice(inner: Type) Type;
fn Fn(arg: Type, ret: Type) Type;

// Control flow
// TODO: fix expr::call to use scope
// fn if(cond: bool, false_branch: Fn(Any, Any), true_branch: Fn(Any, Any)) Any;

// Working with pointers
fn get(ptr: Slice(Any)) Any;
fn set(ptr: Slice(Any), value: Any) Unit;
fn len(ptr: Slice(Any)) i64;
fn slice(ptr: Slice(Any), first: i64, one_past_last: i64) Slice(Any);
fn alloc(T: Type, count: i64) Slice(Any); 
fn dealloc(T: Type, count: i64, ptr: Slice(Any)) Unit;

// Inspecting the interpreter
fn is_comptime() bool;
fn is_uninit(_: Slice(Any)) bool;
fn is_oob_stack(_: Slice(Any)) bool;
fn print_callstack() Unit;
fn comptime_cache_get(f: Fn(Any, Any), arg: Any) (bool, Any) Unit;
fn comptime_cache_insert(f: Fn(Any, Any), arg: Any, ret: Any) Unit;
