
fn main(unused: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

// TODO: test block comments are also a thing but they dont work

// empty statements are allowed. 
;;;;;;;

assert_eq(1, 1);  // assert_eq exists
let f = fn(u: Unit) i64 = { 5 };
assert_eq(5, f(unit));  // closure in a variable. 
assert_eq(5, fn(u: Unit) i64 = { 5 }(unit));  // closure called inline

assert_eq(5, fn() i64 = { 5 }());  // no arguments (not even Unit).
assert_eq(unit, fn() Unit = { unit }()); // return unit
assert_eq(unit, fn() Unit = { let x = 0; }());  // implicit trailing `unit`  // TODO: allow empty body 

/// simple_variables ///

assert_eq(5, fn(n: i64) i64 = { let x = 10; n }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; x }(5));
assert_eq(5, fn(n: i64) i64 = { let x = n; x }(5));
assert_eq(50, fn(n: i64) i64 = { let x = n; x = 50; x }(5));
assert_eq(16, fn(n: i64) i64 = { let x = n; x = add(1, add(add(x, x), n)); x }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; let y = x; y }(5));

let one: i64 = 1;  // variables can have type annotations 
assert_eq(one, 1);

/// simple if /// 

assert_eq(5, fn(n: i64) i64 = {
    if(eq(n, 1), fn(a: i64) i64 = { 5 }, fn(a: i64) i64 = { 10 })
}(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, fn(n: int(unit)) int(unit) = { add(add(n, n), n) } (5));

@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();

// TODO: constants and local scope. 
// let int2 = fn() Type = { i64 };
// let int3 = int2();
// assert _eq(15, fn(n: int3) int3 = { add(add(n, n), n) } (5));

// TODO: assert compile error
// @comptime fn hello() Unit = {
//    hello()
// }
// hello();

//@comptime fn ct() i64 = { 
//    assert _eq(is_comptime(), true); 
//    1
//}
//@runtime fn rt() i64 = { 
//    let c = is_comptime(); 
//    assert _eq(is_comptime(), false); 
//    1
//}
// assert _eq(ct(), rt());

////////////////
/// Pointers ///
////////////////

let v = 10;
let ptr = v!addr;  // Get the adddress of v's stack slot
assert_eq(10, get(ptr));
v = 5;
assert_eq(5, get(ptr));  // writes though var observed by ptr
set(ptr, 15);
assert_eq(15, v); // writes though ptr observed by var
assert_eq(15, get(ptr));
assert_eq(len(ptr), 1);  // v is not a tuple
assert_eq(false, is_uninit(ptr));  // there's a value in v

// It is legal to take pointer to uninitilized memory, as long as you write before you read. 
let bad;
let bad_ptr = bad!addr;
assert_eq(true, is_uninit(bad_ptr));
set(bad_ptr, 1);  // initialize the memory 
assert_eq(false, is_uninit(bad_ptr));
assert_eq(get(bad_ptr), 1);  // now we can read it
assert_eq(bad, 1);

// You can pass functions pointers to your own stack. 
fn increment(ptr_arg: Ptr(i64)) Unit = {
    let old = get(ptr_arg);
    set(ptr_arg, add(old, 1));
}

let m = 3;
increment(m!addr);
assert_eq(m, 4);

// The interpreter can catch some basic mistakes. 
fn mistake(i: i64) Ptr(i64) = {
    let my_value = add(i, i);
    my_value!addr  // oops, call frame went away
}
let very_bad_ptr = mistake(1);  // it is illegal to dereference this pointer 
assert_eq(true, is_oob_stack(very_bad_ptr));
assert_eq(false, is_oob_stack(very_bad_ptr!addr));

// You can take the address of function arguments. 
// TODO: want to pass by const reference if big so be careful about mutating (or disallow). 
fn twice(arg: i64) i64 = {
    let arg_ptr = arg!addr;
    mul(get(arg_ptr), 2)
}
let three = 3;
assert_eq(6, twice(three));

//////////////
/// Tuples ///
//////////////

let arr = tuple(1, 2, 3);
let arr_ptr = arr!addr;
// a tuple isn't treated as one *thing*, you're pointing to a range of the stack containing three values
assert_eq(len(arr_ptr), 3);  

// you can create a pointer to a sub-slice of a tuple
let second_ptr = slice(arr_ptr, 1, 2);  // start at index 1, end before index 2
assert_eq(1, len(second_ptr));  // pointing at one element
assert_eq(2, get(second_ptr)); // we can dereference as normal.
set(second_ptr, 123);
// TODO: length of slice as part of pointer type
let have: Tuple(i64, i64, i64) = get(arr_ptr);
let expected: Tuple(i64, i64, i64) = (1, 123, 3);
assert_eq(have, expected);
assert_eq(get(arr_ptr), tuple(1, 123, 3)); // the type annotations are unnessisary 
// you dont even have to write the function call
assert_eq((4, 5, 6), tuple(4, 5, 6));  

// TODO: i cant parse multiple args
//fn things(a: i64, b: i64) i64 = { 
//    add(a, b)
//}
//asser t_eq(5, things(2, 3));
//asser t_eq(5, things((2, 3)));

// in fact, tuples aren't real at all. they're just the way i represent multiple arguments and return values 
// TODO: flip
fn identity(args: Tuple(i64, i64)) Tuple(i64, i64) = { 
    let arr = args!addr;
    let a1 = slice(arr, 0, 1);
    let a2 = slice(arr, 1, 2);
    (get(a2), get(a1))
}
assert_eq((3, 2), identity((2, 3)));
assert_eq((3, 2), identity(2, 3));
assert_eq(3, 2, identity(2, 3));


unused
}


// TODO: support variadic functions where you pass a type and a pointer to a tuple
//       construct a tuple from a length and a default value (or uninit)
