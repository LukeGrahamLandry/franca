
fn main(unused: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

// TODO: test block comments are also a thing but they dont work

// empty statements are allowed. 
;;;;;;;

assert_eq(1, 1);  // assert_eq exists
let f = fn(u: Unit) i64 = { 5 };
assert_eq(5, f(unit));  // closure in a variable. 
assert_eq(5, fn(u: Unit) i64 = { 5 }(unit));  // closure called inline

assert_eq(5, fn() i64 = { 5 }());  // no arguments (not even Unit).
assert_eq(unit, fn() Unit = { unit }()); // return unit
assert_eq(unit, fn() Unit = { let x = 0; }());  // implicit trailing `unit`  // TODO: allow empty body 

/// simple_variables ///

assert_eq(5, fn(n: i64) i64 = { let x = 10; n }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; x }(5));
assert_eq(5, fn(n: i64) i64 = { let x = n; x }(5));
assert_eq(50, fn(n: i64) i64 = { let x = n; x = 50; x }(5));
assert_eq(16, fn(n: i64) i64 = { let x = n; x = add(1, add(add(x, x), n)); x }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; let y = x; y }(5));

/// simple if /// 

assert_eq(5, fn(n: i64) i64 = {
    if(eq(n, 1), fn(a: i64) i64 = { 5 }, fn(a: i64) i64 = { 10 })
}(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, fn(n: int(unit)) int(unit) = { add(add(n, n), n) } (5));

@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();

// TODO: constants and local scope. 
// let int2 = fn() Type = { i64 };
// let int3 = int2();
// assert _eq(15, fn(n: int3) int3 = { add(add(n, n), n) } (5));

// TODO: assert compile error
// @comptime fn hello() Unit = {
//    hello()
// }
// hello();

//@comptime fn ct() i64 = { 
//    assert _eq(is_comptime(), true); 
//    1
//}
//@runtime fn rt() i64 = { 
//    let c = is_comptime(); 
//    assert _eq(is_comptime(), false); 
//    1
//}
// assert _eq(ct(), rt());

////////////////
/// Pointers ///
////////////////

let v = 10;
let ptr = v!addr;  // Get the adddress of v's stack slot
assert_eq(10, get(ptr));
v = 5;
assert_eq(5, get(ptr));  // writes though var observed by ptr
set(ptr, 15);
assert_eq(15, v); // writes though ptr observed by var
assert_eq(15, get(ptr));
assert_eq(len(ptr), 1);  // v is not a tuple
assert_eq(false, is_uninit(ptr));  // there's a value in v

// It is legal to take pointer to uninitilized memory, as long as you write before you read. 
let bad;
let bad_ptr = bad!addr;
assert_eq(true, is_uninit(bad_ptr));
set(bad_ptr, 1);  // initialize the memory 
assert_eq(false, is_uninit(bad_ptr));
assert_eq(get(bad_ptr), 1);  // now we can read it
assert_eq(bad, 1);

// You can pass functions pointers to your own stack. 
fn increment(ptr_arg: Ptr(i64)) Unit = {
    let old = get(ptr_arg);
    set(ptr_arg, add(old, 1));
}

let m = 3;
increment(m!addr);
assert_eq(m, 4);

// The interpreter can catch some basic mistakes. 
fn mistake(i: i64) Ptr(i64) = {
    let my_value = add(i, i);
    my_value!addr
}
let very_bad_ptr = mistake(1);
assert_eq(true, is_oob_stack(very_bad_ptr));
assert_eq(false, is_oob_stack(very_bad_ptr!addr));

// You can take the address of function arguments. 
// TODO: want to pass by const reference if big so be careful about mutating (or disallow). 
fn twice(arg: i64) i64 = {
    let arg_ptr = arg!addr;
    mul(get(arg_ptr), 2)
}
let three = 3;
assert_eq(6, twice(three));

let arr = tuple(1, 2, 3);
let arr_ptr = arr!addr;
// a ssert_eq(len(arr_ptr), 3);

unused
}
