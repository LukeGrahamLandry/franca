fn main(unused: i64) i64 = {


assert_eq(1, 1);  
let f = fn(u: Unit) i64 = { 5 };
assert_eq(5, f(unit));  // closure in a variable. 
assert_eq(5, fn(u: Unit) i64 = { 5 }(unit));  // closure called inline

assert_eq(5, fn() i64 = { 5 }());  // no arguments (not even Unit).
assert_eq(unit, fn() Unit = { unit }()); // return unit
assert_eq(unit, fn() Unit = { let x = 0; }());  // implicit trailing `unit`  // TODO: allow empty body 
    
assert_eq(5, fn(n: i64) i64 = { let x = 10; n }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; x }(5));
assert_eq(5, fn(n: i64) i64 = { let x = n; x }(5));
assert_eq(50, fn(n: i64) i64 = { let x = n; x = 50; x }(5));
assert_eq(16, fn(n: i64) i64 = { let x = n; x = add(1, add(add(x, x), n));; x }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; let y = x; y }(5));

assert_eq(5, fn(n: i64) i64 = {
    if(eq(n, 1), fn(a: i64) i64 = { 5 }, fn(a: i64) i64 = { 10 })
}(1));

fn int(u: Unit) Type = { i64 }
assert_eq(15, fn(n: int(unit)) int(unit) = { add(add(n, n), n) } (5));


fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();


fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let b = rt();

unused
}