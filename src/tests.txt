fn main(unused: i64) i64 = {

// You'd think this would be easy but somehow no. 
// Sanity check that comments aren't parsed: 
// }

// empty statements are allowed. 
;;;;;;;

assert_eq(1, 1);  // assert_eq exists
let f = fn(u: Unit) i64 = { 5 };
assert_eq(5, f(unit));  // closure in a variable. 
assert_eq(5, fn(u: Unit) i64 = { 5 }(unit));  // closure called inline

assert_eq(5, fn() i64 = { 5 }());  // no arguments (not even Unit).
assert_eq(unit, fn() Unit = { unit }()); // return unit
assert_eq(unit, fn() Unit = { let x = 0; }());  // implicit trailing `unit`  // TODO: allow empty body 

/// simple_variables ///

assert_eq(5, fn(n: i64) i64 = { let x = 10; n }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; x }(5));
assert_eq(5, fn(n: i64) i64 = { let x = n; x }(5));
assert_eq(50, fn(n: i64) i64 = { let x = n; x = 50; x }(5));
assert_eq(16, fn(n: i64) i64 = { let x = n; x = add(1, add(add(x, x), n)); x }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; let y = x; y }(5));

/// simple if /// 

assert_eq(5, fn(n: i64) i64 = {
    if(eq(n, 1), fn(a: i64) i64 = { 5 }, fn(a: i64) i64 = { 10 })
}(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, fn(n: int(unit)) int(unit) = { add(add(n, n), n) } (5));

@does_nothing(but, parser, doesnt, choke)
@runtime fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();

// TODO: constants and local scope. 
// let int2 = fn() Type = { i64 };
// let int3 = int2();
// assert _eq(15, fn(n: int3) int3 = { add(add(n, n), n) } (5));

// TODO: assert compile error
// @comptime fn hello() Unit = {
//    hello()
// }
// hello();

//@comptime fn ct() i64 = { 
//    assert _eq(is_comptime(), true); 
//    1
//}
//@runtime fn rt() i64 = { 
//    let c = is_comptime(); 
//    assert _eq(is_comptime(), false); 
//    1
//}
// assert _eq(ct(), rt());

let v = 10;
let ptr = v!addr;
assert_eq(10, get(ptr));
v = 5;
assert_eq(5, get(ptr));

unused
}
