assert_eq(1, 1);  // assert_eq exists

let f = fn(u: Unit) i64 = { 5 };
assert_eq(5, f(unit));  // closure in a variable. 
assert_eq(5, fn(u: Unit) i64 = { 5 }(unit));  // closure called inline

assert_eq(5, fn() i64 = { 5 }());  // no arguments (not even Unit).
assert_eq(unit, fn() Unit = { unit }()); // return unit
assert_eq(unit, fn() Unit = { let x = 0; }());  // implicit trailing `unit`  // TODO: allow empty body 
    
/// simple_variables ///

assert_eq(5, fn(n: i64) i64 = { let x = 10; n }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; x }(5));
assert_eq(5, fn(n: i64) i64 = { let x = n; x }(5));
assert_eq(50, fn(n: i64) i64 = { let x = n; x = 50; x }(5));
assert_eq(16, fn(n: i64) i64 = { let x = n; x = add(1, add(add(x, x), n));; x }(5));
assert_eq(10, fn(n: i64) i64 = { let x = 10; let y = x; y }(5));

/// simple if /// 

assert_eq(5, fn(n: i64) i64 = {
    if(eq(n, 1), fn(a: i64) i64 = { 5 }, fn(a: i64) i64 = { 10) }
}(1));

/// call_in_type_annotation ///

fn int(u: Unit) Type = { i64 }
assert_eq(15, fn(n: int(unit)) int(unit) = { add(add(n, n), n) } (5));

// TODO: constants and local scope. 
// let int2 = fn() Type = { i64 };
// let int3 = int2();
// assert _eq(15, fn(n: int3) int3 = { add(add(n, n), n) } (5));

// TODO: assert compile error
// @comptime fn hello() Unit = {
//    hello()
// }
// hello();


fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();


fn rt() i64 = { 
    let c = is_comptime(); 
    assert_eq(c, false); 
    1
};

let a = rt();
