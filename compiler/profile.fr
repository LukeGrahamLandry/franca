
ENABLE_TRACY :: get_environment_variable("FRANCA_TRACY").is_some();

TraceCtx :: @if(ENABLE_TRACY, TracyZoneContext, void);

TraceZone :: @enum(i64) (EmitIr, AotPump, Backend, Scope, LoadFile, Parse, SemaFunction, SemaOverloads, Task, CallDynamic, BakeConstArgs, Wait, CloneExpr, CheckCache, ImportCache);
// TODO: can't index by pointer a const array
ZONE_COLOURS :: @static(Array(u32, enum_count(TraceZone))) @array(0x00FF0066, 0x00FF0000, 0x00FF6600, 0x0000FF00, 0x000000FF, 0x000000FF, 
    0x00FF00FF, 0x00EE00AA, 0x00AAFFAA, 0x00888800, 0x00AA0099, 0x00000001, 0x0000FF44, 0x000055FF, import_cache_colour);

import_cache_colour :: 0x335533FF;
// TODO: caller location
// :sema_regression this used to work as an overload set and pass the hint
zone_begin :: fn(zone: TraceZone) TraceCtx = {
    ::enum(TraceZone);
    @if(ENABLE_TRACY) {
        src :: {
            n := ast_alloc().alloc_zeroed(TracySourceLocation, enum_count(TraceZone));
            for_enum TraceZone { e |
                n[@as(i64) e] = (
                    name = e.name_str().sym().c_str(),
                    function = "",
                    file = "",
                    line_u32_color32 = ZONE_COLOURS.items()[e.raw()].zext().shift_left(32),
                );
            };
            n
        };
        ZONE_COLOURS;
        s := src.index(@as(i64) zone);
        ___tracy_emit_zone_begin(s, 1)
    }
};

fn zone_end(c: TraceCtx) void = {
    @if(ENABLE_TRACY, ___tracy_emit_zone_end(c), ());
}

//! https://github.com/wolfpld/tracy/blob/master/public/tracy/TracyC.h
// TODO: once I have pointer niches, use optional for nullable CStrs.
// TODO: auto generate this when I finish c_bindgen.

TracySourceLocation :: @struct(
    name: CStr, // ?
    function: CStr,
    file: CStr,
    line_u32_color32: i64,  // HACK:  TODO: non-8-aligned field
);

// TODO: i dont follow the calling convention correctly. it wants a struct of u32s passed or-ed together in one register. 
// TODO: this has been fixed on the new backend. 
//       ...but `panic! Assertion Failed: Couldn't find dominating definition for tmp 126 s in $resolve_in_overload_set_new__1543`
TracyZoneContext :: @struct(
    id_active: u64
    //id: u32,
    //active: i32,
);

fn ___tracy_emit_frame_mark_start(name: CStr) void #import("tracy");
fn ___tracy_emit_frame_mark_end(name: CStr) void #import("tracy");
fn ___tracy_emit_zone_begin(srcloc: *TracySourceLocation, active: i32) TracyZoneContext #import("tracy");
fn ___tracy_emit_zone_begin_callstack(srcloc: *TracySourceLocation, depth: i32, active: i32) TracyZoneContext #import("tracy");
// Note: these rely on the abi of slices being the same as seperate ptr/len arguments
fn ___tracy_emit_zone_text(ctx: TracyZoneContext, txt: []u8) void #import("tracy");  
fn ___tracy_emit_zone_name(ctx: TracyZoneContext, txt: []u8) void #import("tracy");
fn ___tracy_emit_zone_color(ctx: TracyZoneContext, color: u32) void #import("tracy");
fn ___tracy_emit_zone_value(ctx: TracyZoneContext, value: u64) void #import("tracy");
fn ___tracy_emit_zone_end(ctx: TracyZoneContext) void #import("tracy");
fn ___tracy_emit_memory_alloc(ptr: rawptr, size: usize, secure: i32) void #import("tracy");
fn ___tracy_emit_memory_alloc_callstack(ptr: rawptr, size: usize, depth: i32, secure: i32) void #import("tracy");
fn ___tracy_emit_memory_free(ptr: rawptr, secure: i32) void #import("tracy");
fn ___tracy_emit_memory_free_callstack(ptr: rawptr, depth: i32, secure: i32) void #import("tracy");
fn ___tracy_emit_memory_alloc_named(ptr: rawptr, size: usize, secure: i32, name: CStr) void #import("tracy");
fn ___tracy_emit_memory_alloc_callstack_named(ptr: rawptr, size: usize, depth: i32, secure: i32, name: CStr) void #import("tracy");
fn ___tracy_emit_memory_free_named(ptr: rawptr, secure: i32, name: CStr) void #import("tracy");
fn ___tracy_emit_memory_free_callstack_named(ptr: rawptr, depth: i32, secure: i32, name: CStr) void #import("tracy");
fn ___tracy_emit_message(txt: []u8, callstack: i32) void #import("tracy");
fn ___tracy_emit_messageL(txt: CStr, callstack: i32) void #import("tracy");
fn ___tracy_emit_messageC(txt: []u8, color: u32, callstack: i32) void #import("tracy");
fn ___tracy_emit_messageLC(txt: CStr, color: u32, callstack: i32) void #import("tracy");
fn ___tracy_emit_frame_mark(name: CStr) void #import("tracy"); // ?

// /Users/luke/Downloads/tracy-master/profiler/cmake-build-release/tracy-profiler
// FRANCA_TRACY=true franca examples/default_driver.fr build compiler/main.fr -o trace.out
