#include_std("core.fr"); // TODO: handle adding this in new driver. 

#include_std("codemap.fr");
#include_std("lex.fr");
#include_std("pool.fr");
#include_std("parse.fr");
#include_std("backend/walk_bc.fr");
#include_std("backend/qbe.fr");
#include_std("backend/llvm.fr");
#include_std("error_reporting.fr");
#include_std("scope.fr");
#include_std("walk_ast.fr");
#include_std("comptime.fr");
#include_std("values.fr");

VERBOSE_TEST_LOGGING :: false;

SelfHosted :: @struct(
    pool: *StringPool,
    codemap: *CodeMap,
    parser: *Parser,
    ast_alloc: *ArenaAlloc,
    scopes: *Scopes,
    vtable: *ImportVTable,
    baked: *Baked,
    last_loc: Span,
);

PRes :: Result(void, ParseErr);

// TODO: eventually this side should be filling out the vtable. 
//       especially since some of it just calls back into me (pool + parse). 

fn self_hosted_main(vtable: *ImportVTable) void #compiler #no_trace = {
    if RUNTIME_STACK_TRACE {|
        get_panic_hook()[] = new_print_trace_and_abort;
        println(">>> Compiler running in slow mode.");
    };
    
    args := cli_args();
    if args.len <= 1 {|
        panic("Expected cli argument: a path to a franca file."); // or driver shared library
    };
    // TODO: allow loading driver function from shared library 
    
    my_vtable := vtable[];
    my_vtable&.fill_self_hosted();
    run_franca_file(my_vtable&, args[1].str());
    exit(0);
}


// TODO: find it
STDLIB_PATH :: "/Users/luke/Documents/mods/infered/lib";

// TODO: print the error message!!! since this doesn't go through the rust side anymore. -- Jun 30
fn run_franca_file(vtable: *ImportVTable, path: Str) CRes(void) = {
    source: List(u8) = "#include_std(\"core.fr\"); ".clone(libc_allocator);  // TODO: column number on error on first line will be wrong but i dont care. 
    source&.read_and_push(path);  // TODO: error handling
    
    comp := {vtable.init_compiler}(.Aarch64); // TODO: comptime get the current arch
    c := vtable.with(comp);
    file := {c.vtable.add_file}(c.data, path, source.items());
    self := c.data.cast();
    
    id := self.parser.push_parse(source.items(), file);
    // TODO: handle error
    stmts := self.parser.finish_pending_stmts(id).unwrap(); // TODO: don't return RsVec -- Jun 29
    @try({c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts.items())) return;
    
    if c.get_unique_named("driver") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = callee);
        callee(vtable);
        exit(0)
    };
    
    if c.get_unique_named("main") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = void, Ret = void, ptr = callee);
        callee();
        exit(0)
    };
    
    // TODO: run tests
    
    .Ok
}

//DRIVER_API :: (libc_allocator.read_to_string("driver_api.fr")).items();

// TODO: the vtable ones leak every time!
// TODO: this should be a driver program export instead
fn get_include_std(c: *SelfHosted, name: Str) ?WaitingParse = {
    //@println("TODO: tried to import %", name);
    src := if name == "compiler" {() Str |
        {c.vtable.get_compiler_builtins_source}()
    }{|
        if name == "codegen_cranelift_intrinsics" {|
            {c.vtable.get_cranelift_builtins_source}()
        } {|
            check := @format("%/%", STDLIB_PATH, name) temp();
            // TODO: do this as one operation (error handling on read)
            if file_exists(check.items()) {|
                libc_allocator.read_to_string(check.items()).items()
            } {|
                if file_exists(name) {|
                    libc_allocator.read_to_string(name).items()
                } {|
                    return(.None);
                    "unreahcable"
                }
            }
        }
    };
    
    file := c.codemap.add_file(name, src);
    id := push_parse(c.parser, src, file);
    (Some = id)
}

fn find_std_lib() bool = {
    fn check(mut p: PathBuf) -> bool {
        p.push("lib");
        p.push("franca_stdlib_1.fr");
        if p.exists() {
            p.pop();
            let mut path = STDLIB_PATH.lock().unwrap();
            *path = Some(p);
            return true;
        }
        false
    }

    // if a project wants to supply its own version, that should take priority.
    if let Ok(mut p) = env::current_dir() {
        if check(p.clone()) {
            return true;
        }
        p.push("franca");
        if check(p.clone()) {
            return true;
        }
        p.pop();
        p.push("vendor/franca");
        if check(p.clone()) {
            return true;
        }
    }

    if let Ok(mut p) = env::current_exe() {
        p.pop();
        p.push("franca");
        if check(p.clone()) {
            return true;
        }
        // exe might be in franca/target/release/franca or franca/target/debug/deps/compiler-21be1aa281dbe5d6, so go up
        for _ in 0..5 {
            p.pop();
            if check(p.clone()) {
                return true;
            }
        }
    }

    let p = PathBuf::from("/Users/luke/Documents/mods/infered");
    if check(p) {
        return true;
    }

    false
}

// TODO: pass requested type through generic args so this isn't so clunky. -- Jun 23
fn init_self_hosted() SelfHosted #compiler = {
    a: ArenaAlloc = init(page_allocator, 1.shift_left(20));
    arena := a&.borrow().boxed(ArenaAlloc, a);
    a := arena.borrow();
    pool: StringPool = init(a);
    pool := a.boxed(StringPool, pool);
    codemap: CodeMap = init(a);
    codemap := a.boxed(CodeMap, codemap);
    t: List(ParseTask) = list(a);
    parser: Parser = (pool = pool, lex = Lexer.zeroed(), tasks = a.boxed(List(ParseTask), t), alloc = a, last = Token.zeroed());
    
    s: Scopes = (
        scopes = list(a),
        types = init(1024, a),
        constants = init(1024, a),
        already_loaded = init(a),
    );
    s := a.boxed(Scopes, s);
    s.new_scope(scope_from_index(0), 0);
    
    b: Baked = (
        values = init(1024, a),
        lookup = init(a),
        functions = init(a),
        custom_bake_constant = init(a),
    );
    b := a.boxed(Baked, b);
    
    (
        pool = pool,
        codemap = codemap,
        parser = a.boxed(Parser, parser),
        ast_alloc = arena,
        scopes = s, // TOOD: remember to c.program.pool.new_scope(ScopeId::from_index(0), Flag::TopLevel.ident(), 0);
        vtable = ImportVTable.ptr_from_int(0), // this gets filled in by the rust side.
        baked = b,
        last_loc = (low = 0, high = 0),
    )
}

// TODO: pass requested type through generic args so this isn't so clunky. -- Jun 23
fn show_error_line(self: *CodeMap, span: Span) void #compiler = {
    line := self.get_whole_line(span);
    set_colour(250, 0, 0);
    @println("> Error on line %, col % in file %", line.line, line.col, line.filename);
    unset_colour();
    println(self.source_slice(line.line_text));
}

boxed :: fn(a: Alloc, const T: Type, t: T) *T #generic = {
    out := a.alloc(T, 1);
    out.ptr[] = t;
    out.ptr
};

fn log_stmt(pool: *StringPool, s: *FatStmt) Str #compiler = FatStmt.export_log(pool, s);
fn log_expr(pool: *StringPool, s: *FatExpr) Str #compiler = FatExpr.export_log(pool, s);
fn log_pattern(pool: *StringPool, s: *Pattern) Str #compiler = Pattern.export_log(pool, s);
fn log_func(pool: *StringPool, s: *Func) Str #compiler = Func.export_log(pool, s);
fn log_lazy_type(pool: *StringPool, s: *LazyType) Str #compiler = LazyType.export_log(pool, s);

export_log :: fn(const T: Type, pool: *StringPool, self: *T) Str #generic = {
    out: List(u8) = list(temp());
    self.log(pool, out&, 0);
    out.items()
}

fn clone(self: *SelfHosted, e: *FatExpr) FatExpr = {
    {self.vtable.clone_expr}(e)
}

fn clone(self: *SelfHosted, e: *LazyType) LazyType = {
    {self.vtable.clone_type}(e)
}
