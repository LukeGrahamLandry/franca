#include_std("core.fr"); // TODO: handle adding this in new driver. 

#include_std("codemap.fr");
#include_std("lex.fr");
#include_std("pool.fr");
#include_std("parse.fr");
#include_std("backend/walk_bc.fr");
#include_std("backend/qbe.fr");
#include_std("backend/llvm.fr");
#include_std("error_reporting.fr");

// TODO: aot backends can't do this. 
// TODO: check which backend you're on!!! i forget every fucking time. 
//:: print_stacktrace_on_panic();

SelfHosted :: @struct(
    pool: *StringPool,
    codemap: *CodeMap,
    parser: *Parser,
);

// TODO: pass requested type through generic args so this isn't so clunky. -- Jun 23
fn init_self_hosted() SelfHosted #compiler = {
    a := libc_allocator;
    pool: StringPool = init(a);
    pool := a.boxed(StringPool, pool);
    codemap: CodeMap = init(a);
    codemap := a.boxed(CodeMap, codemap);
    t: List(ParseTask) = list(a);
    parser: Parser = (pool = pool, lex = Lexer.zeroed(), tasks = libc_allocator.boxed(List(ParseTask), t), alloc = a, last = Token.zeroed());
    (
        pool = pool,
        codemap = codemap,
        parser = a.boxed(Parser, parser),
    )
}

boxed :: fn(a: Alloc, const T: Type, t: T) *T #generic = {
    out := a.alloc(T, 1);
    out.ptr[] = t;
    out.ptr
};

fn log_stmt(pool: *StringPool, s: *FatStmt) Str #compiler = FatStmt.export_log(pool, s);
fn log_expr(pool: *StringPool, s: *FatExpr) Str #compiler = FatExpr.export_log(pool, s);
fn log_pattern(pool: *StringPool, s: *Pattern) Str #compiler = Pattern.export_log(pool, s);
fn log_func(pool: *StringPool, s: *Func) Str #compiler = Func.export_log(pool, s);
fn log_lazy_type(pool: *StringPool, s: *LazyType) Str #compiler = LazyType.export_log(pool, s);

export_log :: fn(const T: Type, pool: *StringPool, self: *T) Str #generic = {
    out: List(u8) = list(temp());
    self.log(pool, out&, 0);
    out.items()
}
