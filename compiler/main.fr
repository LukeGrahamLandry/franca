#include_std("lib/core.fr"); 

#include_std("codemap.fr");
#include_std("lex.fr");
#include_std("pool.fr");
#include_std("parse.fr");
#include_std("backend/walk_bc.fr");
#include_std("backend/qbe.fr");
#include_std("backend/llvm.fr");
#include_std("error_reporting.fr");
#include_std("scope.fr");
#include_std("walk_ast.fr");
#include_std("comptime.fr");
#include_std("values.fr");
#include_std("emit_bc.fr");

VERBOSE_TEST_LOGGING :: false;

SelfHosted :: @struct(
    pool: *StringPool,
    codemap: *CodeMap,
    parser: *Parser,
    ast_alloc: *ArenaAlloc,
    scopes: *Scopes,
    vtable: *ImportVTable,
    baked: *Baked,
    last_loc: Span,
    env: *ComptimeEnvironment,
    // NOTE: don't reorder the fields above this! Rust knows about them!
);

PRes :: Result(void, ParseErr);

// TODO: eventually this side should be filling out the vtable. 
//       especially since some of it just calls back into me (pool + parse). 

fn self_hosted_main(vtable: *ImportVTable) void #compiler #no_trace = {
    if RUNTIME_STACK_TRACE {|
        get_panic_hook()[] = new_print_trace_and_abort;
        println(">>> Compiler running in slow mode.");
    };
    
    :: ?Str; 
    if STDLIB_PATH.is_none() {|
        a := find_std_lib(libc_allocator);
        if a& { (lst: *List(u8)) |  // TODO: why the fuck does this need the type annotation1!!@##@!
            STDLIB_PATH[] = (Some = lst.items());
        } else {|
            panic("Could not find franca standard library."); // TODO: return error
        };
    };
    
    args := cli_args();
    if args.len <= 1 {|
        panic("Expected cli argument: a path to a franca file."); // or driver shared library
    };
    // TODO: allow loading driver function from shared library 
    
    my_vtable := vtable[];
    my_vtable&.fill_driver_vtable();
    @match(run_franca_file(my_vtable&, args[1].str())) {
        (fn Ok(_) => exit(0));
        (fn Err(e) => {
            exit(1);
        });
    };
}

// TODO: store this in SelfHosted instead of in a global -- Jul 5
STDLIB_PATH :: @static(?Str) (None = unit);

// TODO: print the error message!!! since this doesn't go through the rust side anymore. -- Jun 30
fn run_franca_file(vtable: *ImportVTable, path: Str) CRes(void) = {
    source: List(u8) = "#include_std(\"lib/core.fr\"); ".clone(libc_allocator);  // TODO: column number on error on first line will be wrong but i dont care. 
    source&.read_and_push(path);  // TODO: error handling
    
    comp := {vtable.init_compiler}(.Aarch64); // TODO: comptime get the current arch
    c := vtable.with(comp);
    file := {c.vtable.add_file}(c.data, path, source.items());
    self := c.data.cast();
    
    id := self.parser.push_parse(source.items(), file);
    // TODO: handle error
    stmts := self.parser.finish_pending_stmts(id).unwrap(); // TODO: don't return RsVec -- Jun 29
    @try({c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts.items())) return;
    
    if c.get_unique_named("driver") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = callee);
        callee(vtable);
        exit(0)
    };
    
    if c.get_unique_named("main") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = void, Ret = void, ptr = callee);
        callee();
        exit(0)
    };
    
    // TODO: run tests
    
    .Ok
}

// TODO: the vtable ones leak every time!
// TODO: this should be a driver program export instead
fn get_include_std(c: *SelfHosted, name: Str) ?WaitingParse = {
    //@println("TODO: tried to import %", name);
    src := if name == "compiler" {() Str |
        code := {c.vtable.get_compiler_builtins_source}().clone(c.get_alloc());
        fill_export_ffi(code&);
        code.items()
    }{|
        if name == "codegen_cranelift_intrinsics" {|
            {c.vtable.get_cranelift_builtins_source}()
        } {|
            lib :=  STDLIB_PATH[].unwrap();
            check := @format("%/%", lib, name) temp();
            // TODO: do this as one operation (error handling on read)
            if file_exists(check.items()) {|
                c.get_alloc().read_to_string(check.items()).items()
            } {|
                if file_exists(name) {|
                    c.get_alloc().read_to_string(name).items()
                } {|
                    return(.None);
                    "unreahcable"
                }
            }
        }
    };
    
    file := c.codemap.add_file(name, src);
    id := push_parse(c.parser, src, file);
    (Some = id)
}

// TODO: let the driver program give us the path
fn find_std_lib(a: Alloc) ?List(u8) = {
    check :: fn(p: *List(u8)) bool = {
        p.push_path_segment("lib");
        p.push_path_segment("franca_stdlib_1.fr");
        good := p.items().file_exists();
        p.pop_path_segment();
        p.pop_path_segment();
        good
    };

    // if a project wants to supply its own version, that should take priority.
    // check current directory first? 
    p := get_working_directory(a);
    p := p&;
    if(check(p), => return(Some = p[]));
    
    // TODO: also check like ./vendor/franca
    range(0, 3) { _ |
        p.pop_path_segment();
        if(check(p), => return(Some = p[]));
    };

    // TODO: this doesn't work if its a symlink to the exe. need to follow that? 
    p := get_executable_path(a).assume_owned(a);
    p := p&;
    assert(p.pop_until_endswith("/"), "path should have slashes"); // we want our folder, not our exe. 
    
    p.push_path_segment("franca");
    if(check(p), => return(Some = p[]));
    // exe might be in franca/target/release/franca or franca/target/debug/deps/compiler-21be1aa281dbe5d6, so go up
    range(0, 5) { _ |
        p.pop_path_segment();
        if(check(p), => return(Some = p[]));
    };
    .None
}

fn pop_until_endswith(self: *List(u8), suffix: []u8) bool = {
    while (=> !self.is_empty() && !self.items().ends_with(suffix)) {|
        self.pop();
    };
    !self.is_empty()
}

PATH_SEP :: "/";

fn push_path_segment(self: *List(u8), name: []u8) void = {
    if !self.items().ends_with(PATH_SEP) {|
        self.push_all(PATH_SEP);
    };
    self.push_all(name);
}

fn pop_path_segment(self: *List(u8)) bool = {
    if !self.is_empty() && self.items().ends_with(PATH_SEP) {|
        self.pop();
    };
    self.pop_until_endswith(PATH_SEP)
}

// TODO: pass requested type through generic args so this isn't so clunky. -- Jun 23
fn init_self_hosted() *SelfHosted #compiler = {
    a: ArenaAlloc = init(page_allocator, 1.shift_left(20));
    arena := a&.borrow().boxed(ArenaAlloc, a);
    a := arena.borrow();
    pool: StringPool = init(a);
    pool := a.boxed(StringPool, pool);
    codemap: CodeMap = init(a);
    codemap := a.boxed(CodeMap, codemap);
    t: List(ParseTask) = list(a);
    parser: Parser = (pool = pool, lex = Lexer.zeroed(), tasks = a.boxed(List(ParseTask), t), alloc = a, last = Token.zeroed());
    
    s: Scopes = (
        scopes = list(a),
        types = init(1024, a),
        constants = init(1024, a),
        already_loaded = init(a),
    );
    s := a.boxed(Scopes, s);
    s.new_scope(scope_from_index(0), 0);
    
    b: Baked = (
        values = init(1024, a),
        lookup = init(a),
        functions = init(a),
        custom_bake_constant = init(a),
    );
    b := a.boxed(Baked, b);
    
    // Sadly this can't use default fields, I think because it loads too early. 
    env: ComptimeEnvironment = (
        inject_function_header = .None,
        make_slice_t = .None,
        bake_os = .None,
        fat_expr_type = .None,
    );
    env := a.boxed(ComptimeEnvironment, env)
    self: SelfHosted = (
        pool = pool,
        codemap = codemap,
        parser = a.boxed(Parser, parser),
        ast_alloc = arena,
        scopes = s,
        vtable = ImportVTable.ptr_from_int(0), // this gets filled in by the rust side.
        baked = b,
        last_loc = (low = 0, high = 0),
        env = env,
    );
    a.boxed(SelfHosted, self)
}

fn get_alloc(self: *SelfHosted) Alloc = self.ast_alloc.borrow();
fn get_alloc(self: CompilerRs) Alloc = self.ast_alloc.borrow();

fn show_error_line(self: *CodeMap, span: Span) void #compiler = {
    line := self.get_whole_line(span);
    set_colour(250, 0, 0);
    @println("> Error on line %, col % in file %", line.line, line.col, line.filename);
    unset_colour();
    println(self.source_slice(line.line_text));
}

fn log_stmt(pool: *StringPool, s: *FatStmt) Str #compiler = FatStmt.export_log(pool, s);
fn log_expr(pool: *StringPool, s: *FatExpr) Str #compiler = FatExpr.export_log(pool, s);
fn log_pattern(pool: *StringPool, s: *Pattern) Str #compiler = Pattern.export_log(pool, s);
fn log_func(pool: *StringPool, s: *Func) Str #compiler = Func.export_log(pool, s);
fn log_lazy_type(pool: *StringPool, s: *LazyType) Str #compiler = LazyType.export_log(pool, s);

export_log :: fn($T: Type, pool: *StringPool, self: *T) Str #generic = {
    out: List(u8) = list(temp());
    self.log(pool, out&, 0);
    out.items()
}

fn clone(self: *SelfHosted, e: *FatExpr) FatExpr = {
    {self.vtable.clone_expr}(e)
}

fn clone(self: *SelfHosted, e: *LazyType) LazyType = {
    {self.vtable.clone_type}(e)
}
