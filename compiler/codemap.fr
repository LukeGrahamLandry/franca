// TODO: I don't think panicking on invalid spans is acceptable, 
//       given how annoying it is that the library I use does that,
//       when I might have got my spans from buggy jitted code reading garbage memory. 
//       But since I don't have error return traces, a panic is less annoying to debug. 
//       I should try to steal what zig does, but I don't want a blessed error type.
//       https://ziglang.org/documentation/master/#Error-Return-Traces
//

CodeMap :: @struct(
    files: List(File),
    total_len: u32,
);
File :: @struct(name: Str, content: Str, start: u32);

// TODO: if you name a field gpa, it shadows the argument so you can't use it in later field initializers. -- May 31
fn init(gpa: Alloc) CodeMap = 
    (files = list(gpa), total_len = 0);

// The caller is responsible for ensuring name/src outlive the codemap. 
fn add_file(self: *CodeMap, name: Str, content: Str) Span = {
    span: Span = (low = self.total_len, high = self.total_len.add(content.len.trunc()));
    self.total_len += content.len.trunc();
    self.files&.push((name = name, content = content, start = span.low));
    //@println("add file: %-%", @as(i64) span.low.zext(), @as(i64) span.high.zext());
    assert(span.len().eq(content.len), "Miscompiled????");
    span
}

fn find_single_file(self: *CodeMap, span: Span) *File = {
    @assert_ge(span.high, span.low, "invalid span");
    @assert_le(span.high, self.total_len, "span is not in codemap");
    skipped: u32 = 0;
    each(self.files){file|
        end := skipped.add(@as(u32) file.content.len.trunc());
        //@println("low:% high:% skipped:% end:%", span.low, span.high, skipped, end);
        if(span.low.ge(skipped)){|
            if(span.high.le(end)) {|
                return(file);
            };
        };
        skipped = end;
    };
    panic("span covers multiple files.")
};

fn source_slice(self: *CodeMap, span: Span) Str #compiler = {
    //@println("get source: %-%", @as(i64) span.low.zext(), @as(i64) span.high.zext());
    file := self.find_single_file(span);
    start := span.low.sub(file.start);
    file.content.subslice(start.zext(), span.len())
}

// indexes are relative to the start of self. 
fn subspan(self: Span, start: u32, end: u32) Span = {
    @assert_le(@as(i64) end.zext(), self.len(), "OOB");
    @assert_le(start, end, "invalid range");
    (low = self.low.add(start), high = self.low.add(end))
}

CodeLine :: @struct(filename: Str, line: i64, col: i64, line_text: Span);
fn get_whole_line(self: *CodeMap, span: Span) CodeLine = {
    file := self.find_single_file(span);
    line := 1; // zero indexed is unintuative for error messages
    col  := 0;
    file_start: i64 = file.start.zext();
    file_end := file_start + file.content.len;
    line_start := file_start;
    
    range(file_start, min(file_end, @as(i64) span.low.zext())) {i|
        col += 1;
        if file.content[i - file_start] == "\n".ascii() {|
            line_start = i + 1; // dont include the new line
            line += 1;
            col = 0;
        };
    };
    
    index: i64 = span.low.zext();
    while(=> index.lt(file_end).and(=> file.content[index - file_start] != "\n".ascii())) {|
        index += 1;
    };
    
    line_text: Span = (low = line_start.trunc(), high = index.trunc());
    (filename = file.name, line = line, col = col, line_text = line_text)
}

// recall: it is an error to call source_slice on one that spans multiple files. 
fn merge(a: Span, b: Span) Span = (
    low = a.low.min(b.low),
    high = a.high.max(b.high),
);

fn len(self: Span) i64 =
    (@as(u32) self.high.sub(self.low)).zext();

////////////

fn LocationMap($V: Type) Type = {
    Entry :: @struct();
    Self  :: @struct(a: Alloc, files: HashMap(Symbol, Entry));
    
    fn init(a: Alloc) Self = {
    
    }
    
    fn insert(self: *Self, key: Span, value: V) void = {
        
    }
    
    fn get(self: *Self, key: Span) ?V = {
    
    }

    Self
}

////////////

Diagnostic :: @struct(
    type: @enum(Error, Warning, Ice),
    message: List(u8),
    spans: List(Ty(Span, List(u8))),
);

fn render(self: *Diagnostic, writer: *List(u8)) void = {
    self.message.items().display(writer);
    each(self.spans) {msg|  // TODO: destructuring
        msg._1.items().display(writer); 
    };
}

// This failed when I wasn't correctly offseting for saving (u32, u32) arguments (just assuming 8 instead of 4). 
#test fn codemap_len() = {
    codemap: CodeMap = init(temp());
    wisdom := "Everything is text.";
    span   := codemap&.add_file("wisdom", wisdom);
    assert_eq(span.len(), wisdom.len);
}

#test fn test_code_map() = {
    ::assert_eq(Str);
    
    codemap: CodeMap = init(temp());
    file_a := "Hello World!";
    file_b := "This is some text.\n It has multiple lines.\n";
    span_a := codemap&.add_file("file_a", file_a);
    span_b := codemap&.add_file("file_b", file_b);
    
    assert_eq(file_a, codemap&.source_slice(span_a));
    assert_eq(file_b, codemap&.source_slice(span_b));
    
    is := span_b.subspan(5, 7);
    assert_eq("is", codemap&.source_slice(is));
    some := span_b.subspan(8, 12);
    assert_eq("some", codemap&.source_slice(some));
    
    is_some := is.merge(some);
    assert_eq("is some", codemap&.source_slice(is_some));
}
