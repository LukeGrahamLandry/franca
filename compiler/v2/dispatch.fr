CompilerDispatch :: @struct(    
    active_stack: *List(ExprAttempt), // TODO: i don't think i actually do anything with this
    const_var_in_progress: DynamicBitSet, // TODO: just store this with the expression?
    function_in_progress: DynamicBitSet, // TODO: just store this with the expression?
    active_tasks: List(*Task),
    overloads: BucketArray(OverloadSetData),
    enclosing_function: ?FuncId,  // for adding runtime callees. 
    const_bound_memo: HashMap(MemoKey, FuncId),
    yield_count: i64 = 0,
    return_labels: BucketArray(FuncId), // [LabelId]
);

Task :: @rec @struct(
    action: Action,
    waiting_for: List(*Task),
    done: bool = false,
);

TaskId :: @struct(id: i64);

ExprAttempt :: @struct(expr: *FatExpr, requested: ResultType);
VarAttempt :: @struct(name: Var, requested: ResultType);
Action :: @tagged(
    //CompileExpr: *List(ExprAttempt),
    CompileBody: FuncId,  // After this, we can generate bytecode.
    Jit: FuncId, // After this, it's safe to call a function pointer. 
    EvalConstant: VarAttempt,  // find_const. 
    ResolveOverload: @struct(os: OverloadSet, call: ExprAttempt, callsite: ?FuncId),
    FinishRecType: @struct(hole: Type, name: Var, value: *FatExpr),
);

fn init(a: Alloc) CompilerDispatch = {
    temp := a.alloc(List(ExprAttempt), 1);
    temp.ptr[] = list(a);
    (
        active_stack = temp.ptr, 
        const_var_in_progress = empty(a), 
        function_in_progress = empty(a), 
        active_tasks = list(a),
        overloads = init(10, a),
        enclosing_function = .None,
        const_bound_memo = init(a),
        return_labels = init(10, a),
    )
}

poll_in_place :: fn(self: *SelfHosted, $T: Type, $f: @Fn() Maybe(T)) Res(T) #generic = {
    pending: List(*Task) = list(self.get_alloc());
    loop {|
        value := f();
        @match(value&) {
            fn Ok(it)  => return(Ok = it[]);
            fn Err(it) => return(Err = it[]);
            fn Suspend(new_dep) => {
                new_task := self.get_alloc().alloc(Task, 1);
                new_task := new_task.ptr;
                new_task[] = (action = new_dep[][], waiting_for = list(self.get_alloc()));
                pending&.push(new_task);
                self.dispatch.active_tasks&.push(new_task);
                @try(self.poll_pending_subset(pending&)) return;
            };
        };
    }
};

// TODO: use this below
fn poll_pending_subset(self: *SelfHosted, pending: *List(*Task)) Res(void) = {
    while => !pending.is_empty() {|
        mark := __temp_alloc.mark();
        ::?**Task;
        task := pending.last().unwrap()[];
        task.waiting_for&.ordered_retain() { t | 
            !t.done
        };
        if task.waiting_for.is_empty() {|
            result := self.exec_task(task);
            @match(result) {  
                fn Err(e) => {
                    return(Err = e);
                }
                fn Ok() => {
                    if task.waiting_for.is_empty() {| // HACK: it might have added new callees
                        task.done = true;
                        pending.pop();
                    };
                };
                fn Suspend(new_dep) => {
                    new_task := self.get_alloc().alloc(Task, 1);
                    new_task := new_task.ptr;
                    new_task[] = (action = new_dep[], waiting_for = list(self.get_alloc()));
                    
                    task.waiting_for&.push(new_task);
                    pending.push(new_task);
                };
            };
        } else {|
            for task.waiting_for { dep | 
                pending.push(dep);
            };
        };
        __temp_alloc.reset_retaining_capacity(mark);
    };
    .Ok
}

fn poll_tasks(self: *SelfHosted) Result(void, *ParseErr) = {
    pending: List(*Task) = list(self.get_alloc());
    made_progress := true;
    
    while => made_progress {|
        made_progress = false;
        self.dispatch.active_tasks&.ordered_retain() { t | 
            !t.done
        };
        for self.dispatch.active_tasks { original_task |
            pending&.push(original_task); 
            // TODO: you want to do this instead but it fails a safety check??????
            // @try(self.poll_pending_subset(pending&)) return;
            while => !pending.is_empty() {|
                mark := __temp_alloc.mark();
                ::?**Task;
                task := pending.last().unwrap()[];
                task.waiting_for&.ordered_retain() { t | 
                    !t.done
                };
                if task.waiting_for.is_empty() {|
                    result := self.exec_task(task);
                    @match(result) {  
                        fn Err(e) => {
                            return(Err = e);
                        }
                        fn Ok() => {
                            made_progress = true;
                            if task.waiting_for.is_empty() {| // HACK: it might have added new callees
                                task.done = true;
                                pending&.pop();
                            };
                        };
                        fn Suspend(new_dep) => {
                            new_task := self.get_alloc().alloc(Task, 1);
                            new_task := new_task.ptr;
                            new_task[] = (action = new_dep[], waiting_for = list(self.get_alloc()));
                            
                            task.waiting_for&.push(new_task);
                            pending&.push(new_task);
                            made_progress = true;
                        };
                    };
                } else {|
                    for task.waiting_for { dep | 
                        pending&.push(dep);
                    };
                };
                __temp_alloc.reset_retaining_capacity(mark);
            };
        };
    };
    
    .Ok
}

::tagged(Action);
fn exec_task(self: *SelfHosted, task: *Task) Maybe(void) = {
    if task.waiting_for&.last() { dep |
        @debug_assert(!task.done, "task done but still has dependencies");
        return(Suspend = dep.action&);
    };
    if task.done {|
        return(.Ok);
    };
    self.dispatch.enclosing_function = .None;
    @log_event("%", self.dispatch.active_tasks.len) self;
    
    @match(task.action) {
        //fn CompileExpr(stack) => {
        //    @log_event("[TRY TASK] %", task.action&.tag());
        //    self.dispatch.active_stack = stack;
        //    while => !stack.is_empty() {|
        //        last := stack.pop().unwrap();
        //        l := stack.len;
        //        @check(self.compile_expr(last.expr, last.requested)) return;
        //        @debug_assert_eq(l, stack.len, "wip expr stack changed");
        //    };
        //}
        fn EvalConstant(v) => {
            @log_event("[TRY TASK] %: %", task.action&.tag(), self.pool.get(v.name.name)) self;
            self.new_expression_stack();
            name := v.name;
            var  := self.scopes.get_constant(name);
            var  := var.expect("var should always be known");
            @check(self.handle_declare_constant(name, var._1&, var._0&)) return;
            self.dispatch.const_var_in_progress&.unset(name.id.zext());
        }
        fn CompileBody(fid) => {
            @log_event("[TRY TASK] %: % %", task.action&.tag(), fid, self.log_name(fid)) self;
            self.new_expression_stack();
            @check(self.handle_compile_func_body(fid)) return;
            self.dispatch.function_in_progress&.unset(fid.as_index());
        }
        fn Jit(fid) => {
            @log_event("[TRY TASK] %: % %", task.action&.tag(), fid, self.log_name(fid)) self;
            func := self.get_function(fid);
            //self.codemap.show_error_line(func.loc);
            //@log_event("%", func.log(self.pool)) self;
            
            if !func.get_flag(.EnsuredCompiled) {|
                self.dispatch.function_in_progress&.set(fid.as_index());
                return(Suspend = self.wait_for(CompileBody = fid));
            };
            
            // when possible, you want to emit_bc for callees first because they might get deduplicated. 
            for func.callees { callee |
                @log_event("% calls %", fid.as_index(), callee.as_index()) self;
                if self.aarch64&.get_fn(callee).is_none() {|
                    new_task := self.get_alloc().alloc(Task, 1);
                    new_task := new_task.ptr;
                    new_task[] = (action = (Jit = callee), waiting_for = list(self.get_alloc()));
                    task.waiting_for&.push(new_task);
                } else {|
                    func := self.get_function(callee);
                    @debug_assert(func.get_flag(.EnsuredCompiled));
                };
            };
            if task.waiting_for.len != 0 {|
                @log_event("sleep on %/% callees", task.waiting_for.len, func.callees.len) self;
                return(.Ok); // HACK: caller has to check our waiting_for
            };
            
            arg_ty := @check(self.infer_arguments(fid)) return;
            ret_ty := @check(self.infer_return(fid)) return;
            
            // TODO: assert found? 
            found := @check(self.fill_in_jit_pointer(fid, func.body&)) return;
            fn fill_in_jit_pointer(self: *SelfHosted, fid: FuncId, body: *FuncImpl) Maybe(bool) = {
                if(self.aarch64&.get_fn(fid).is_some(), => return(Ok = true));
                func := self.get_function(fid);
                arg_ty := func.finished_arg.unwrap();
                ret_ty := func.finished_ret.unwrap();
                if body.is(.Normal).or(body.is(.Intrinsic)) {|
                    @log_event("codegen % %", fid, self.log_name(fid)) self;
                    @err_assert(!arg_ty.is_unknown() && !ret_ty.is_unknown(), "unknown fn types!!") return;
                    hack := self.stable_compiler_context().cast(); // because Bc::CompCtx stores a ***SelfHosted in the assembly 
                    body := hack.emit_bc_and_aarch64(fid, .Jit);
                    if(body&.is_err(), => return(Err = self.box(body.Err)));
                    return(Ok = true);
                };
                @match(body) {
                    fn Redirect(target) => {
                        ptr := or self.aarch64&.get_fn(target[]) {|
                            return(Suspend = self.wait_for(Jit = target[]))
                        };
                        // TODO: save in constants lookup too if take address 
                        self.aarch64&.extend_blanks(fid);
                        self.aarch64.dispatch[fid.as_index()] = ptr;
                    };
                    fn ComptimeAddr(_) => unreachable("ICE: comptime addr is done before.");
                    // TODO: do this before too? 
                    fn JittedAarch64(insts) => self.aarch64&.copy_inline_asm(fid, insts.items());
                    fn Merged(parts) => {
                        each parts { option |
                            if @check(self.fill_in_jit_pointer(fid, option)) return {|
                                return(Ok = true);
                            };
                        };
                    }
                    @default => return(Ok = false);
                };
                (Ok = true)
            };
            
            if func.get_flag(.TookPointerValue) {|
                ptr := self.aarch64&.get_fn(fid).expect("have jit addr");
                self.created_jit_fn_ptr_value(fid, ptr.int_from_rawptr());
            };
        }
        fn ResolveOverload(f) => {
            self.new_expression_stack();
            self.dispatch.enclosing_function = f.callsite;  // TODO: make test that fails without this.
            overloads := self.dispatch.overloads&.nested_index(f.os.as_index());
            @log_event("[TRY TASK] %: % %", task.action&.tag(), f.os, self.pool.get(overloads.name)) self;
            @debug_assert(f.call.expr.expr&.is(.Call));
            call := f.call.expr.expr.Call;
            fid := @check(self.resolve_in_overload_set(call.arg, f.call.requested, f.os)) return;
            f_value := self.to_values(FuncId, fid);
            //call.f.set(f_value, fid); // THIS TYPE CHECKS! :FUCKED
            call.f.set(f_value, FuncId);
        }
        fn FinishRecType(it) => {
            @check(self.handle_finish_rec_type(it.hole, it.name, it.value)) return;
        }
    };
    .Ok
}

fn would_block(self: *SelfHosted, action: Action) bool = {
    @match(action) {
        fn EvalConstant(v) => {
            var  := self.scopes.get_constant(v.name);
            var  := var.expect("var should always be known");
            !var._0&.is(.Value)
        };
        //fn CompileExpr(stack) => !stack.last().unwrap().is_done;
        fn TypeArg(fid)       => self.get_function(fid)[].finished_arg.is_none();
        fn TypeRet(fid)       => self.get_function(fid)[].finished_ret.is_none();
        fn CompileBody(fid)   => !self.get_function(fid).get_flag(.EnsuredCompiled);
        fn Jit(fid)           => self.aarch64&.get_fn(fid).is_none();
    }
}

fn new_expression_stack(self: *SelfHosted) void = {
    // TODO: reuse these when finished?
    //       store them in the Action like compile_expr so can skip to theend if yielded? -- Jul 29
    ::CBox(List(ExprAttempt));
    self.dispatch.active_stack = self.box(list(self.get_alloc())); 
}

fn Maybe($T: Type) Type = {
    Self :: @tagged(
        Ok: T,
        Err: *ParseErr,
        Suspend: *Action,
    );
    
    fn is_err(self: Self) bool = self&.is(.Err);
    fn unwrap(self: Self) T = {
        if self&.is(.Err) {|
            @panic("Unwrapped Maybe Err %", self.Err.msg);
        };
        ::tagged(Action);
        @assert(self&.is(.Ok), "unwrapped suspending Maybe %", self.Suspend.tag());
        self.Ok
    }
    
    fn unwrap_err(self: Self) *ParseErr = {
        if self&.is(.Err) {|
            return(self.Err);
        };
        panic("unwrap_err not err")
    }
    
    ::tagged(Self);
    Self
}

fn wait_for(s: *SelfHosted, t: Action) *Action = {
    @log_event("[YIELD] %", t&.tag()) s;
    s.dispatch.yield_count += 1;
    mem := s.get_alloc().alloc(Action, 1);
    mem.ptr[] = t;
    mem.ptr
}
