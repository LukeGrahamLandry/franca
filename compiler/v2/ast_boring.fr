fn index(comp: *SelfHosted, f: FuncId) *Func = {
    comp.functions&.nested_index(f.as_index())
}

fn ptr_ty(self: *SelfHosted, ty: Type) Type = {
    self.intern_type(Ptr = ty)
}

fn unptr_ty(c: *SelfHosted, ty: Type) ?Type = {
    @match(c.get_type(ty)) {
        fn Ptr(inner) => (Some = inner[]);
        @default => .None; // TODO: do i need to raw_type? 
    }
}

fn is_raw_unit(self: *FatExpr) bool = {
    self.ty == void && self.expr&.is(.Value) // :get_or_create_type
}

// TODO: skip through named and unique as well.
fn ptr_depth(self: *SelfHosted, ptr_ty: Type) i64 = {
    ptr_ty = self.raw_type(ptr_ty);
    d := 0;
    while => self.unptr_ty(ptr_ty) { inner |
        d += 1;
        ptr_ty = self.raw_type(inner);
    };
    d
}

fn finished_ty(self: *Func) ?FnType = {
    if self.finished_arg { arg |
        if self.finished_ret { ret |
            return(Some = (arg = arg, ret = ret, arity = @as(u16) self.arg.bindings.len().max(1).trunc()));
        };
    };
    .None
}

fn func_type(self: *SelfHosted, id: FuncId) ?Type = {
    func := self.get_function(id);
    ty := func.finished_ty().or(=> return(.None));
    (Some = self.intern_type(Fn = ty))
}

:: tagged(FuncImpl);
fn jitted_aarch64(self: *FuncImpl) ?[]u32 = {
    @match(self) {
        fn JittedAarch64(code) => {
            return(Some = code.items());
        }
        fn Merged(parts) => {
            each parts { p |
                @if_let(p) fn JittedAarch64(code) => {
                    return(Some = code.items());
                };
            };
        }
        @default => ();
    };
    
    .None
}

fn ptr_type(self: *SelfHosted, inner: Type) Type = {
    self.intern_type(Ptr = inner)
}

// This converts a const type in the compiler's binary to a type id in the target program.
// It can only be done for some core interned types (not unique ones like structs and enums).
// :get_or_create_type @builtin doesn't call this but maybe should if I ever want to be able to change the numbers. 
fn get_or_create_type(self: *SelfHosted, $T: Type) Type = {
    info :: T.get_type_info_ref();
    @inline_match(info) {
        fn Int(_) => self.intern_type(info[]);
        // Some types have hardcoded ids. 
        // they can also be used directly but doing it through this function might make it less painful to decouple them later.
        fn Bool() => bool;
        fn void() => void;
        fn VoidPtr() => rawptr;
        @default => panic("Tried to convert unsupported type from const to runtime");
    }
}

fn specific(self: ResultType) ?Type = {
    ::if(?Type);
    @match(self) {
        fn Specific(t) => if(t == UnknownType, => .None, => (Some = t));
        @default => .None;
    }
}

fn set(self: *FatExpr, value: Values, ty: Type) void = {
    @debug_assert(!ty.is_unknown());
    self.expr = (Value = (bytes = value, coerced = false));
    self.ty = ty;
    self.done = true;
}

fn synthetic_ty(expr: Expr, loc: Span, ty: Type) FatExpr = {
    (expr = expr, loc = loc, ty = ty, done = false)
}

fn clone(self: *Values, a: Alloc) Values = {
    @match(self) {
        fn Small(_) => self[];
        fn Big(f) => (Big = f.items().clone(a).rs());
    }
}

fn tuple_of(self: *SelfHosted, types: []Type) Type #compiler = {
    @switch(types.len()) {
        @case(0) => void;
        @case(1) => types[0];
        @default => {
            // TODO: always. would need to change how you go arg_ty -> prim_sig.
            if types.len > 50 {|
                first := types[0];
                cond :: fn(t: *Type) bool => t[] != first;
                if !types.contains(cond) {|
                    return(self.intern_type(Array = (
                        inner = first,
                        len = types.len.trunc(),
                    )));
                };
            };
            // TODO: dont allocate the string a billion times
            fields: List(Field) = list(types.len, self.get_alloc());
            ::from_raw(Flag);
            ::enum(Flag);
            ::?Flag;
            ::if(Symbol);
            enumerate types { (i: i64, ty: *Type) void |
                // TODO: why the fuck doesnt this work. i dont want to allocate the string every time!!!
                //       it also doesnt work if you factor out the i->Symbol as a seperate function, even if you use the allocating verion that owrks hgere]
                //       -- Jul 29 :FUCKED
                //       also doesn't work if the loop is a range instead of enumerate. 
                //       this has to be a compiler bug. 
                //name := if i <= 20 {|
                //    idx := Flag._0.raw().add(i);
                //    (@as(?Flag) idx.from_raw()).unwrap().ident()
                //} else {|
                //    s := @format("_%", i) libc_allocator;
                //    self.pool.insert_owned(s.items())
                //};
                s := @format("_%", i) libc_allocator;
                name := self.pool.insert_owned(s.items());
                fields&.push(
                    name = name,
                    ty = ty[],
                    default = .None,
                    byte_offset = 99999999999,
                    kind = .Var,
                );
            };
            self.intern_type(Struct = (
                fields = fields.rs(),
                layout_done = false,
                is_tuple = true,
                const_field_count = 0,
            ))
        };
    }
}

fn err(arg: FatExpr) FatExpr #macro = {
    if !arg.expr&.is(.Tuple) {|
        return(@{ (Err = make_error(@[arg])) });
    };
    @{
        out: List(u8) = list(temp());
        @[ format_into(@{ out& }, arg.expr.Tuple.items(), arg.loc) ];
        (Err = make_error(out.items()))
    }
}

fn make_error(msg: Str) *ParseErr = {
    mem := libc_allocator.alloc(ParseErr, 1);
    mem.ptr[] = (span = Span.zeroed(), msg = msg);
    mem.ptr
}

:: CBox(FatExpr);
:: CBox(List(FatExpr));
:: CBox(ParseErr);
fn CBox($T: Type) void = {
    fn box(self: *SelfHosted, e: T) *T = {
        out := self.get_alloc().alloc(T, 1);
        out.ptr[] = e;
        out.ptr
    }
}

fn check(v: FatExpr, ret: FatExpr) FatExpr #macro = @{
    v := @[v];
    if(!v&.is(.Ok)) {|
        if(v&.is(.Err), => { @[ret](Err = v.Err); }, => { @[ret](Suspend = v.Suspend); });
    };
    v.Ok
}

fn want(self: *LazyType) ResultType = {
    @match(self) {
        fn Finished(t) => (Specific = t[]);
        fn Returning(t) => (Returning = t[]);
        @default => .None;
    }
}

fn ty(self: *LazyType) ?Type = {
    @match(self) {
        fn Finished(t) => (Some = t[]);
        @default => .None;
    }
}

fn want(self: ?Type) ResultType = {
    @match(self) {
        fn Some(t) => (Specific = t);
        fn None() => .None;
    }
}

fn want(self: Type) ResultType = {
    if(self.is_unknown(), => return(.None));
    (Specific = self)
}

fn unwrap(self: *LazyType) Type = {
    // TODO: compiler segfaults if you write this with @match!! -- Jul 9 :FUCKED
    assert(self.is(.Finished), "type not ready");
    self.Finished
}

fn var(self: *Binding) ?Var = {
    @match(self.name) {
        fn Var(v) => (Some = v);
        @default => .None;
    }
}

fn ident(self: *Binding) ?Symbol = {
    @match(self.name) {
        fn Var(v) => (Some = v.name);
        fn Ident(v) => (Some = v);
        @default => .None;
    }
}

fn ident(self: *FatExpr) ?Symbol = {
    @match(self.expr&) {
        fn GetVar(v) => (Some = v.name);
        fn GetNamed(v)  => (Some = v[]);
        fn String(v) => (Some = v[]);
        @default => .None;
    }
}

// TODO: add i128 to the language so i can represent all u64/i64 easily. 
// TODO: cope with sign extension. maybe just switch over sizes and load a casted pointer like the old version did. 
fn int_value(value: *Values, int: IntTypeInfo) Res(i64) = {
    len := value.len();
    if len != 1 && len != 2 && len != 4 && len != 8 {|
        return(@err("bad int size %", len));
    };
    @debug_assert(value.is(.Small));
    i := if int.signed {|
        // TODO: are negative i8/i16/i32 stored sign extended? 
        value.Small._0
    } else {|
        // TODO: cope with u64
        value.Small._0
    };
    min, max := int.range();
    @debug_assert(i <= max && i >= min, "tried to coerce but value out of bounds for FROM type!?!?!!?");
    (Ok = i)
}

::if(Ty(i64, i64));
fn range(int: IntTypeInfo) Ty(i64, i64) = {
    //@println("% bits", int.bit_count);
    if int.signed {|
        // TODO: UB on i1. 
        max := 1.shift_left(int.bit_count - 1) - 1;
        (-max, max) /// TODO: is this right? 
    } else {|
        // TODO: this is wrong. you want max u64, it would be nice if i had i128 so could represent all numbers. 
        max :=  1.shift_left(int.bit_count) - 1;
        // TODO: segfault if i put 2^63 here. :fucked
        // 4611686018427387904 is a number i can put here and not die,
        // but it seems that im relying on this being wrong to pick the right overload somewhere. 
        max := if(int.bit_count == 64, => 4611686018427387904, => max);
        (0, max)
    }
}

fn tuple_types(self: *SelfHosted, ty: Type) ?[]Type = {
    @match(self.get_type(ty)) {
        fn Struct(f) => {
            out: List(Type) = list(f.fields.len, temp());
            each f.fields { f |
                if f.kind != .Const {|
                    out&.push(f.ty);
                };
            };
            (Some = out.items())
        }
        fn Named(f) => self.tuple_types(f._0);
        fn Array(f) => (Some = f.inner.repeated(f.len.zext(), temp()).items());
        @default => .None;
    }
}

fn arg_types(self: *SelfHosted, ty: Type) []Type = {
    @if_let(self.get_type(ty)) 
        fn Struct(f) => {
            if f.is_tuple {|
                types := self.tuple_types(ty);
                return(types.unwrap());
            };
        };
        
    (@list(ty) temp()).items()
}

fn remove_named(self: *Pattern, arg_name: Var, a: Alloc) void = {
    start := self.bindings.len();
    self.bindings&.ordered_retain(fn(b: *Binding) bool => @match(b.name) {
        fn Var(name) => !(name == arg_name);
        @default => true;
    });
    @debug_assert_ne(start, self.bindings.len());
    if self.bindings.is_empty() {|
        self.bindings&.push((
            name = .None,
            ty = (Finished = void),
            default = .None,
            kind = .Var,
        ), a);
    };
}

fn tuple_types(self: *SelfHosted, requested: ResultType, len: i64) Result([]ResultType, *ParseErr) = {
    :: List(ResultType);
    (Ok = @match(requested) {
        fn Specific(ty) => {
            ::?[]Type;
            types := or self.tuple_types(ty) {|
                return(@err("Type Error: found tuple but requested non-tuple %", self.log_type(ty)))
            };
            if types.len != len {| 
                return(@err("Type Error: tuple arity mismatch. expected % but found %", types.len, len));
            };
            out: List(ResultType) = list(len, temp());
            for types { ty | 
                out&.push(Specific = ty);
            };
            out.items()
        }
        fn Tuple(types) => {
            if types.len != len {| 
                return(@err("Type Error: tuple arity mismatch. expected % but found %", types.len, len));
            };
            types
        }
        // TODO: ResultType.None should work here. 
        @default => (@as(ResultType) (None = ())).repeated(len, temp()).items();
    })
}

fn from_index();

fn TagBitIndex($T: Type, $magic_offset: i64) void = {
    fn as_index(f: T) i64 = f.to_index().zext();
    
    fn to_index(f: T) u32 = {
        i := ptr_cast_unchecked(From = T, To = u32, ptr = f&)[];
        mask: u32 : 1.shift_left(magic_offset).bit_not().trunc();
        i.bit_and(mask)
    }
    
    fn from_index(idx: i64) T = {
        val: u32 = 1.shift_left(magic_offset).bit_or(idx).trunc();
        ptr_cast_unchecked(From = u32, To = T, ptr = val&)[]
    }
}

// must match ast.rs
:: TagBitIndex(OverloadSet, 28);
:: TagBitIndex(LabelId, 27);

fn unique_const(self: *SelfHosted, name: Symbol) Var = {
    // TODO: expose a function for this!
    self.scopes.dup_var(
        kind = .Const,
        name = name,
        id = 0,
        scope = from_index(0),
        block = 0,
    )
}

fn from_index(idx: i64) ScopeId = {
    val: u32 = idx.trunc();
    ptr_cast_unchecked(From = u32, To = ScopeId, ptr = val&)[]
}

:: {
    AutoClone(get_variant_type(Expr, Expr.Tag().Value));
    AutoClone(get_variant_type(Expr, Expr.Tag().Switch));
    AutoClone(get_variant_type(Expr, Expr.Tag().Call));
    AutoClone(get_variant_type(Expr, Expr.Tag().Block));
    AutoClone(get_variant_type(Expr, Expr.Tag().FieldAccess));
    AutoClone(get_variant_type(Expr, Expr.Tag().PrefixMacro));
    AutoClone(get_variant_type(Expr, Expr.Tag().PtrOffset));
    AutoClone(get_variant_type(Expr, Expr.Tag().If));
    AutoClone(get_variant_type(Expr, Expr.Tag().As));
    AutoClone(Expr);
    AutoClone(FatExpr);
    AutoClone(Stmt);
    AutoClone(FatStmt);
    AutoClone(Binding);
    AutoClone(LazyType);
    AutoClone(Values);
    AutoClone(Func);
    AutoClone(Annotation);
    AutoClone(FuncImpl);
    AutoClone(*FatExpr);
    AutoClone(*Func);
    AutoClone(?FatExpr);
    AutoClone(Ty(i64, FatExpr));
    AutoClone(Pattern);
    AutoClone(get_variant_type(Stmt, Stmt.Tag().DeclVar));
    AutoClone(get_variant_type(Stmt, Stmt.Tag().DeclVarPattern));
    AutoClone(get_variant_type(Stmt, Stmt.Tag().DeclNamed));
    AutoClone(get_variant_type(Stmt, Stmt.Tag().Set));
    AutoHash(MemoKey, TrivialHasher);
    AutoEq(MemoKey);
    fn hash(h: *TrivialHasher, s: *FuncId) void = {
        i := s[].as_index();
        h.hash(i&);
    }
    
    DeriveFmt(Bc);
    DeriveFmt(get_variant_type(Bc, Bc.Tag().CallDirect));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().CallFnPtr));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().PushConstant));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().JumpIf));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().AddrVar));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().SaveSsa));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().LoadSsa));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().LastUse));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().Ret2));
    DeriveFmt(get_variant_type(Bc, Bc.Tag().Goto));
    ::display_slice(Prim);
    ::display_slice(BbId);
    
    fn display(self: *PrimSig, out: *List(u8)) void = {
        @fmt(out, "%", self.args);
        if self.no_return {|
            @fmt(out, " #never");
        };
        if self.first_arg_is_indirect_return {|
            @fmt(out, " #big");
        };
    }
};

MarkNotDone :: @struct(_hack : i64);
:: WalkAst(MarkNotDone, void);

fn handle_expr(self: *MarkNotDone, expr: *FatExpr) Result(DoMore, void) #once = {
    expr.done = false;
    (Ok = DoMore.Continue)
}

fn handle_stmt(self: *MarkNotDone, stmt: *FatStmt) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_func(self: *MarkNotDone, func: *Func) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_type(self: *MarkNotDone, ty: *LazyType) Result(DoMore, void) #once = (Ok = .Continue);
fn handle_pattern(self: *MarkNotDone, p: *Pattern) Result(DoMore, void) #once = (Ok = .Continue);


// this currently works but probably only loosly overlaps with being correct because its nap time. 
fn adjust_int_length(value: *Values, int: *IntTypeInfo) void = {
    @assert(value.is(.Small), "ICE: big value for int");
    byte_count := value.Small._1&;
    value := value.Small._0&;
    want_byte_count: u8 = ((int.bit_count + 7) / 8).trunc();
    if want_byte_count * 8 != int.bit_count.trunc() {|
        // weird ints are stored dumby currently 
        want_byte_count = 8;
    };
    i := byte_count[];
    while => byte_count[] > want_byte_count {|
        byte_count[] -= 1;
        //if int.signed {
        //    debug_assert_eq!(*value & (255 << i), 255);
        //} else {
        //    debug_assert_eq!(*value & (255 << i), 0);
        //}
        i -= 1;
    };
    i := byte_count[];
    while => byte_count[] < want_byte_count {|
        byte_count[] += 1;
        i += 1;
        //if int.signed {
        //    debug_assert_eq!(*value & (255 << i), 255);
        //} else {
        //    debug_assert_eq!(*value & (255 << i), 0);
        //}
    };
}

fn is_const(self: *FatExpr) bool = {
    @match(self.expr&) {
        fn Value() => true; 
        fn Tuple(parts) => {
            each parts { part |
                if(!part.is_const(), => return(false));
            };
            true
        }
        fn String() => true;
        @default => false;
    }
}