Token :: @struct(type: TokenType, span: Span);
TokenType :: @tagged(
    Symbol: Str,
    Number: i64,
    Float: f64,
    Quoted: @struct(s: Str, escapes: bool),
    Qualifier: VarType,
    Op: Operator,
    EqOp: Operator,
    Error: LexErr,
    // Bit count means leading zeros are observable.
    BinaryNum: @struct(bit_count: u8, value: u64),
    LeftSquiggle, RightSquiggle, LeftParen, RightParen, LeftSquare, RightSquare, LeftAngle, RightAngle,
    Bang, Dot, At, Comma, Colon, Semicolon, DoubleSquare, Hash, FatRightArrow, LeftArrow, DoubleColon, 
    Star, Amp, Question, Pipe,
    Fn, Equals, Eof,
);
Operator :: @enum(Plus, Minus, Star, Slash);
LexErr :: @tagged(
    Unexpected: i64,
    UnterminatedStr,
    NumParseErr,
    /// C has it mean octal which I don't really like but I don't want to accept the same syntax and mean something different.
    DenyLeadingZero,
    ThatsNotANormalQuoteDidYouCopyPasteFromAPdf,
    TooManyBits,
);
VarType :: @enum(Let, Var, Const);

Lexer :: @struct(
    root: Span,
    src: Str,
    start := 0,
    current := 0,
    token: Token = ()!uninitialized,
);

// TODO: need be be able to find the ResAddr cause it might not be on top of the stack. (early return from flat_call: big ret/arg value )
fn peek(self: *Lexer) *Token = self.token&;

fn pop(self: *Lexer) *Token = {
    
    
    self.token&
}

fn init(root: Span, src: Str) Lexer = {
    self: Lexer = (root = root, src = src);
    self&.pop(); // get the first token ready. 
    self

}


#test fn lexer_doesnt_crash() = {
    codemap: CodeMap = init(libc_allocator);
    src := "println(\"hello world\"";
    span := codemap&.add_file("test", src);
    self: Lexer = init(root = span, src = src);
    self&.peek();
    self&.pop();
}

