// 
// "incremental" is really not the right word for this. 
// it's just a binary serialization format for compiler state, not like only-recompile-functions-that-changed magic. 
// used in two ways: 
// - invisible speedup when running scripts/drivers directly (like `franca a.fr`)
// - as an api for alternative frontends (like examples/import_c/ffi.fr/include())
// 
#use("@/backend/incremental.fr");

fn read_cached(a: Alloc, path: Str) ?*Header = {
    bytes := read_entire_file(a, path) || return(.None);
    if(bytes.len < 8, => return(.None));
    magic8 := ptr_cast_unchecked(u8, u64, bytes.ptr)[];
    if magic8 != MAGIC {
        a.dealloc(u8, bytes);
        return(.None);
    };
    (Some = check(bytes).or(fn(_) => return(.None)))
}

// The first Dep in cached .frc files is the hash of the compiler itself. 
self_filename :: "$franca/compiler";
// TODO: im just vaugly hoping this runs after all files have been loaded 
//       (which it does not in fact. backend/__/emit.fr is through a vtable so happens late)
self_hash :: @static(Array(u32, 8)) Array(u32, 8).zeroed();

// TODO: THIS BEHAVIOUR IS CONSIDERED DISRESPECTFUL.
//       this is a fragile compilation order HACK that user code really shouldn't do 
//       but it's kinda cute that it works. This gets called from main() and the extra 
//       indirection with a forced shim ensures that comptime_compute_self_hash() runs 
//       after all files have been loaded (even the ones through a shim in Qbe.Target vtable). 
//       this will definitly come back to haunt me because i only test it manually by uncommenting 
//       a print and eyeballing the list of files.    -- May 26, 2025
set_self_hash :: fn() void #inline = {
    hack :: @as(@FnPtr() Array(u32, 8)) comptime_compute_self_hash;
    self_hash[] = hack();
};

fn comptime_compute_self_hash() Array(u32, 8) = :: {
    fr   := current_compiler_context();
    self := fr.data.cast()[][];
    hash := zeroed Array(u32, 8);
    @if(!IS_BOOTSTRAPPING) // :UpdateBoot
    each self.codemap.files { it |
        // uncomment to check that the compilation order hack with set_self_hash is working. 
        if is_cachable(it.name) {
            // @println("% %", it.name, it.hash&);
            hash = add(hash, it.hash);
        }
    };
    hash
}

fn add(a: Array(u32, 8), b: Array(u32, 8)) Array(u32, 8) = {
    range(0, 8) { i |
        a&[i] = add(a&[i], b&[i]);
    };
    a
}

// TODO: you'll never hit the cache for !/backend_lib_fr.frc when compiling the compiler itself and then recompiling with the new compiler etc. 
//       tho maybe thats the behaviour you want, hard to think about. 
// TODO: hella redundant work. should only load+hash each file once (including across multiple CompCtx in the same process). 
fn files_unchanged(header: *Header) bool = {
    if(header.dep.count <= 1, => return(false));
    
    it: *Dep = header.get(0);
    if(header.get(it.filename) != self_filename, => return(false));
    if(self_hash.items() != it.hashcode&.items(), => return(false));
    cache_dir := cache_dir();
    
    // TODO: save this work of loading + hashing the files even if they changed
    range(1, header.dep.count.zext()) { i |
        continue :: local_return;
        it: *Dep = header.get(@as(u32) i.trunc());
        filename := header.get(it.filename);
        
        break :: fn() Never => {
            if false {
                @println("A"); // TODO
            };
            return(false);
        };
        
        if filename.starts_with("!/") {
            // this dep is another frc file added by import_frc. check transitive dependencies. 
            path := @tfmt("%%", cache_dir, filename.rest(2));
            src := temp().get_include_std(path) || break();
            result := check(src);
            result := result.or(fn(_) => break());  // invalid frc
            (it.hashcode == result.all_deps) || break();  // we disagree about what's supposed to be in the file
            files_unchanged(result) || break();  // out of date
        } else {
            filename := filename.rest(2);
            src := temp().get_include_std(filename) || break();
            if(src.len != it.file_len.zext(), => break());
            hashcode := Sha256'hash(src);
            if(hashcode&.items() != it.hashcode&.items(), => break());
        };
    };
    true
}

fn compile_cached(header: *Header, to_free: *?Ty(*QbeModule, *Crash'LocationResolverNode)) (@FnPtr(*ImportVTable) void) = {
    a := general_allocator();
    m := a.box_uninit(QbeModule);
    backend'init_module(m, (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .JitOnly,
    ));
    
    z := zone_begin(.AotPump);
    backend'load_all(header, m);
    zone_end(z);
    
    import("@/backend/meta/qbe_frontend.fr")'fill_from_libc(m);
    
    i := header.entry_sym;
    name := header.get(header.get(i)[].name);
    cc := m.get_addr(name) || @panic("ICE: lost %", name);
    r := push_resolver(QbeModule, m, find_ip_in_module);
    to_free[] = (Some = (m, r));
    m.make_exec();
    assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = cc)
}

fn write_deps(writer: *Writer, codemap: *CodeMap, start_path: Str) u32 = {
    writer.dep&.reserve(codemap.files.len+1);
    writer.dep&.push(
        file_len = 0,
        filename = writer.push(self_filename),
        hashcode = self_hash[],
    );
    
    entry_dep := Qbe.no_symbol;
    goal_start_path := @tfmt("@/%", start_path);
    each codemap.files { it |
        if is_cachable(it.name) {
            if entry_dep == Qbe.no_symbol && it.name == goal_start_path /*:SLOW*/ {
                entry_dep = writer.dep.len.trunc();
            };
        
            writer.dep&.push(
                file_len = it.content.len.trunc(),
                filename = writer.push(it.name),
                hashcode = it.hash,
            );
        }
    };
    entry_dep
}

fn write_cache(m: *QbeModule, c: CompCtx, fid: FuncId, outpath2: Str, start_path: Str) *Header = {
    self := c.data.cast()[][];
    
    @if(!enable_incremental()) @panic("write_cache");
    writer := m.save.unwrap();
    backend'writer_finish_imports(writer, m);
    
    entry_dep := write_deps(writer, self.codemap, start_path);
    name := c.fmt_fn_name(fid);
    ::enum(@type m.goal.type);
    meta: Meta = (
        arch_os = @if(m.goal.type == .CachedEarly, 0x0F0F, pack_current_target()),
        entry_sym = (off = writer.map_sym(m, m.intern(name)).trunc()),
        entry_dep = (off = entry_dep),
    );
    chunks := writer.to_bytes(meta, m);
    bytes := concat(chunks, general_allocator());  // not c.get_alloc because we're going to drop the compiler at the end
    
    write_entire_file_or_crash(outpath2, bytes);
    if(show_backend_stats(), => @eprintln(">>> save: %", outpath2));
    
    ::Result(*Header, Str);
    check(bytes).or(fn(e) => @panic("ICE: generated an invalid frc file: %", e))
}

fn is_cachable(name: Str) bool = !(false 
    // the fill_export_ffi string that has virtual addresses in it.
    // can't just ignore in files_unchanged() because this would break repro. 
    || name == "compiler" 
    // the generated src string in load_file_in_compiler. 
    // redundant with entry_dep anyway. 
    || name == "-"
    // from an `import("{ foo };")`.
    || name == import_literal_file_name 
);

// TODO: this is dumb: ./a.fr vs a.fr, also unreadable is sad
// Also this is very collidable but it's fine beacuse the cache file contains the path of the entry_dep. 
// I considered using hash of the path but it's annoying to need to dump_bin to see what's in your cache dir. 
fn choose_cache_filename(path: Str) Str = {
    out := u8.list(path.len+25, temp());
    out&.push_all(cache_dir());
    out&.push_all(mangle_name_for_cache(path));
    out.items()
}

fn mangle_name_for_cache(path: Str) Str = {
    out := u8.list(path.len, temp());
    for path { c |
        if c.is_ascii_alpha() || c.is_ascii_digit() {
            out&.push(c);
        } else {
            out&.push("_".ascii());
        }
    };
    out&.push_all(".frc");
    out.items()
}

fn cache_dir() Str = 
    @tfmt("%/cache/", get_environment_variable("FRANCA_TARGET_DIR") || "target/franca");

// one per (CompCtx, Header) pair.
FrcModule :: @struct {
    header: *Header;
    scope: ScopeId;
    sym: []u32;  // [One(Sym)] = FuncId or BakedVarId
    sym_ty: []One(FTy); // [One(Sym)]
    fty: []Type; // [One(FTy)] 
    data_symbols: []Ty(One(Sym), DynamicImport);
};

// one per (CodegenWorker, Header) pair. 
// ie. comptime vs runtime has seperate QbeModule so needs some import state stored seperately. 
// this is created lazily the first time you call move_from_module. 
FrcModuleInstance :: @struct {
    module: *FrcModule;
    syms: []Qbe.Sym; // [One(Sym)]
    type_offset: i64; // TODO: this could go away if there was an extra layer of indirection for RType (like i already do for RCon)
};

// translate header.root_scope into FrcImport entries in a new ScopeId. 
// TODO: this is what i want but is not the case now... (because instance.syms needs the mangled names so need to reserve FuncId-s upfront)
// no work to actually translate into Func/BakedValue graph is done yet. 
// thing are loaded lazily the first time they're referenced (just like normal franca code). 
fn import_frc(self: *SelfHosted, bytes: []u8) CRes(ScopeId) = {
    zone := zone_begin(.ImportCache);
    header := or check(bytes) { e |
        zone_end(zone);
        return(@err("import_frc failed: %", e))
    };
    
    if header.dep.count > 0 {
        fake_path := (@tfmt("!/%", header.get(header.debug_name))).shallow_copy(self.get_alloc());
        self.codemap.add_file(fake_path, bytes, header.all_deps);  // TODO: rehashing every time is sad
    };
    
    scope := self.scopes.new_scope(TOP_LEVEL_SCOPE, self.get_alloc(), zeroed Span); // TODO: location info
    
    // TODO: some configuration to make it save these somewhere you can look at them. 
    //       should do the same with add_function, macro returns, import("{"), etc. 
    //       debugging macros really sucks currently. 
    //write_entire_file("target/a.frc", bytes);
    
    a := self.get_alloc();
    module := a.boxed(FrcModule, (
        header = header, 
        scope = scope,
        sym = a.alloc_init(u32, zext header.sym.count, fn(_) => Qbe.no_symbol), 
        sym_ty = a.alloc_init(One(FTy), zext header.sym.count, fn(_) => (off = Qbe.no_symbol)), 
        fty = a.alloc_zeroed(Type, zext header.fty.count),
        data_symbols = empty(),
    ));
    @err_assert(header.fty.count != 0, "tried to import_frc without frontend type info (fty)") return;
    
    sym_ty := module.sym_ty;
    range(0, FTy.COUNT) { i |  // builtin types
        module.fty[i] = bit_cast_unchecked(u32, Type, trunc i);
    };
    module_handle := FrcModule.int_from_ptr(module);
    
    root_scope := header.get(header.root_scope);
    data_symbols := Ty(One(Sym), DynamicImport).list(self.get_alloc());
    for(header, root_scope.payload.fields) { i, it |
        name := self.pool.insert_owned(header.get(it.name));
        loc := zeroed Span;  // TODO
        type: LazyType = (PendingEval = (
            expr = (FrcImport = (module = module_handle, index = it.type.off, table = FTY_TABLE)), 
            ty = Type, done = false, loc = loc,
        ));
        is_type := it.type.off == FTy.TYPE || it.type.off == FTy.SCOPE;
        expr: FatExpr = (ty = UnknownType, done = false, loc = loc, expr = (FrcImport = (
            module = module_handle, 
            index = it.payload.offset, 
            table = @if(is_type, FTY_TABLE, SYM_TABLE),
        )));
        ::enum(FTy.Tag);
        is_function := header.get(it.type)[].tag == .Func;
        if !is_type {
            // sema_frc_import_fid() needs this information and it's a lot less painful 
            // to just store it now than to look it up through the scope later. 
            // TODO: need to make this work for anon functions tho
            sym_ty[zext it.payload.offset] = it.type;
        };
        
        // TODO: I don't like this. 
        //       for data imports, we can't make a shim and we don't have a FuncId or BakedVarId to track a dependency on, 
        //       so have to do extra work up front before we even know if it will be reachable. 
        if it.type.off == FTy.RAWPTR {
            i := it.payload.sym;
            sym := header.get(it.payload.sym);
            ::enum(Seg);
            if sym.segment == .Import {
                data := as_data_import(self, header, i);
                expr.expr = (DataSymbol = data);
                push(data_symbols&, (it.payload.sym, data));
            };
        };
        
        if is_function {
            // better not to say FnPtr because that forces a jit shim to immediate_eval_constant
            type = (Finished = FuncId);
        };
        
        self.add_to_scope(scope, name, type, expr);
    };
    module.data_symbols = data_symbols.items();
    zone_end(zone);
    (Ok = scope)
}

fn as_data_import(self: *SelfHosted, h: *Header, i: One(Sym)) DynamicImport = {
    it := h.get(i);
    lib := h.get(h.get(it.imp.lib)[].name);
    name := self.pool.insert_owned(h.get(it.name));
    self.dyn_import(name, self.pool.insert_owned(lib), it.imp.weak)
}

fn sema_frc_import(self: *SelfHosted, expr: *FatExpr) Maybe(void) = {
    @debug_assert(expr.expr&.is(.FrcImport), "expected FrcImport");
    import := expr.expr.FrcImport;
    module := FrcModule.ptr_from_int(import.module); header := module.header;
    @debug_assert_eq(header.magic_v, MAGIC);
    loc := zeroed Span; // TODO
    if import.table == FTY_TABLE {
        type := self.import_type(module, @as(One(FTy)) (off = import.index));
        @check(self.return_macro_type(expr, type)) return;
        return(.Ok)
    };
    
    if(import.table != SYM_TABLE, => panic("invalid FrcImport.table")); 
    
    i := import&.get_sym();
    it := header.get(i);
    caller_name := header.get(it.name);
    ::enum(@type it.segment);
    
    type := module.sym_ty[zext import.index];
    if type.off == Qbe.no_symbol {
        return(@err("% wasn't referenced from the root scope so we don't know it's type", caller_name));
    };
    is_function := header.get(type)[].tag == .Func;
    
    if it.segment == .Import && !is_function {
        //@println("import data: %", caller_name);
        // TODO: do this at the beginning since we have to anyway and otherwise it's redundant
        expr.expr = (DataSymbol = as_data_import(self, header, i));
        expr.ty = self.import_type(module, type);
        return(.Ok);
    }

    if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
        // let emit_ir.fr deal with it
        //@println("local data: %", caller_name);
        expr.ty = self.import_type(module, type);
        expr.done = true;
        return(.Ok);
    }
    
    // TODO: Alias
    @debug_assert(@is(it.segment, .Import, .Code, .MachineCode), "TODO: import_frc %", it.segment);
    
    fid := @try(self.sema_frc_import_fid(module, i)) return;
    self.set(expr, FuncId, fid);
    .Ok
}

fn sema_frc_import_fid(self: *SelfHosted, module: *FrcModule, i: One(Sym)) CRes(FuncId) #once = {
    h := module.header;
    slot := module.sym[zext i.off]&;
    if slot[] != Qbe.no_symbol {
        return(Ok = bit_cast_unchecked(u32, FuncId, slot[]));
    };
    
    type := self.import_type(module, module.sym_ty[zext i.off]);
    info := self.get_type(type);
    it := h.get(i);
    caller_name := h.get(it.name);
    @debug_assert_ne(type, UnknownType, "must know signeture of imported function");
    @err_assert(info.is(.FnPtr), "expected function type for '%' but found %", caller_name, self.log_type(type)) return;
    loc := zeroed Span; // TODO
    name := self.pool.insert_owned(caller_name);
    
    ::enum(Seg);
    if it.segment == .Import && it.imp.temporary_funcid != 0 && it.imp.temporary_funcid != Qbe.no_symbol {
        //@println("existing function: %", caller_name);
        slot[] = it.imp.temporary_funcid;
        return(Ok = bit_cast_unchecked(u32, FuncId, slot[]));
    }

    fid := self.add_function(empty_fn(info.FnPtr.ty, name, loc));
    func := self.get_function(fid);
    slot[] = bit_cast_unchecked(FuncId, u32, fid);
    
    types := self.comp().arg_types(func.finished_arg.Some);
    variadic := types.len > 0 && types[types.len - 1] == CVariadicType;
    if variadic {
        // the printf in examples/import_wuffs/test.fr (the hello-wuffs-c example) hits this.  
        // it's bad if create_import_body doesn't find the symbol and calls create_jit_shim. 
        // i just don't have a test where that comes up correctly 
        // (because when linking libc, you'll find printf, and if not, it wouldn't work anyway)
        func.set_flag(.AvoidJitShim);
    };
    
    func.set_flag(.ResolvedBody);
    func.set_flag(.ResolvedSign);
    func.set_flag(.EnsuredCompiled);
    func.set_flag(.BodyIsSpecial);
    func.set_flag(.YesContext);
    if it.segment != .Import {
        //@println("local function: %", caller_name);
        if it.segment == .MachineCode {
            func.body = (Asm = (
                arm64 = h.get(it.asm.arm64),
                amd64 = h.get(it.asm.amd64),
                rv64 = h.get(it.asm.rv64),
                wasm32 = h.get(it.asm.wasm32),
            ));
        } else {
            func.body = (FrcImport = (module = FrcModule.int_from_ptr(module), index = i.off, table = SYM_TABLE));
            msg :: "TODO: this won't work if did_regalloc on amd64 because it doesn't see RMem. maybe i should just store those differently\n%";
            //@err_assert(it.fnc.tmp != Qbe.no_symbol, msg, caller_name) return; // TODO
            for(h, it.fnc.con) { _, con |
                if con.sym != Qbe.no_symbol_S {
                    sym := @as(One(Sym)) (off = con.sym.id);
                    
                    //@println("- callee %", h.get(h.get(sym)[].name));
                    // TODO: i think this doesn't super matter until i start handing out func-ids lazily
                    // TODO: need to track the Dat dependencies too somehow. maybe give up and just use 
                    //       emitir.pending for this as well like old FuncImpl.Ir did. 
                    if @try(self.get_fid(module, sym)) return { fid |
                        // TODO: mutual_ cycles?
                        func.callees&.push(fid, self.get_alloc());
                    };
                }
            };
        };
    } else {
        //@println("import function: %", caller_name);
        lib := h.get(h.get(it.imp.lib)[].name);
        lib := self.pool.insert_owned(lib);
        @try(self.create_import_body(func, fid, lib, it.imp.weak)) return;
    };
    fill_bindings(func, self.comp(), types);
    (Ok = fid)
}

// TODO: special alignment, #use
fn import_type(self: *SelfHosted, module: *FrcModule, i: One(FTy)) Type = {
    slot := module.fty[zext i.off]&; header := module.header;
    if(slot[] != UnknownType, => return(slot[]));
    it := header.get(i);
    ::enum(@type it.tag);
    nominal := @is(it.tag, .Struct, .Union, .Tagged, .Alias);
    
    ::if(Type);
    if !nominal {
        info := self.import_type_info(module, it);
        id := self.intern_type(info);
        slot[] = id;
        id
    } else {
        id := self.intern_type(.Placeholder);  // avoid cycles
        slot[] = id;
        info := self.import_type_info(module, it);
        self.get_type(id)[] = info;  // go directly to jail do not pass go do not collect two hundred dollars 
        id
    }
}

fn import_type_info(self: *SelfHosted, module: *FrcModule, it: *FTy) TypeInfo = {
    if @is(it.tag, .Params, .Struct, .Union) {
        is_tuple := it.tag == .Params;
        fields := Field.list(it.payload.fields.count.zext(), self.get_alloc());
        j := 0;
        for(module.header, it.payload.fields) { i, it |
            ::if(Symbol); ::enum(Flag);
            fields&.push(
                name = if is_tuple {
                    get_tuple_field_name(self.comp(), j)
                } else {
                    self.pool.insert_owned(module.header.get(it.name))
                },
                ty = import_type(self, module, it.type),
                nullable_tag = zeroed(*Annotations),
                default = zeroed(Var),
                // TODO: decide if this should go in Fld.payload or if i want to use that slot for default value
                byte_offset = FIELD_LAYOUT_NOT_DONE,
            );
            j += 1;
        };
        
        return(Struct = (
            is_tuple = is_tuple,
            is_union = it.tag == .Union,
            fields = fields.as_raw(),
            layout_done = false,
            scope = NOSCOPE,
        ));
    };
    
    @match(it.tag) {
        fn Ptr() => (Ptr = import_type(self, module, it.payload.array.inner));
        fn Array() => (Array = (
            inner = import_type(self, module, it.payload.array.inner), 
            len = it.payload.array.count,
        ));
        fn Func() => (FnPtr = (ty = (
            arg = import_type(self, module, it.payload.func.arg), 
            ret = import_type(self, module, it.payload.func.ret), 
            unary = module.header.get(it.payload.func.arg)[].tag != .Params,
        )));
        fn Number() => {
            @assert(!it.payload.int.bitfield, "TODO: bitfields");
            (Int = (bit_count = zext it.payload.int.bits, signed = it.payload.int.signed))
        }
        fn Enum() => {
            sequential, last := (true, -1);
            args := Ty(Symbol, Values).list(zext it.payload.fields.count, self.get_alloc());
            
            for(module.header, it.payload.fields) { i, it |
                name := self.pool.insert_owned(module.header.get(it.name));
                val: i64 = it.payload.offset.zext();
                sequential = sequential && val == last + 1;
                last = val;
                // TODO
                //@debug_assert_eq(it.type.off, FTy.U32, "expected enum value u32");
                push(args&, (name, self.to_values(u32, trunc val)));
            };
            
            raw := u32;  // TODO: non-u32 // :get_or_create_type 
            (Enum = (raw = raw, fields = args.as_raw(), sequential = sequential))
        }
        fn Alias() => (Named = (import_type(self, module, it.payload.alias), Flag.SYMBOL_ZERO.ident()));
        fn Tagged() => {
            cases := Ty(Symbol, Type).list(self.get_alloc());
            for(module.header, it.payload.fields) { i, it |
                name := self.pool.insert_owned(module.header.get(it.name));
                type := import_type(self, module, it.type);
                push(cases&, (name, type));
            };
            (Tagged = (tag = i64, cases = cases.as_raw()))
        }
        @default => @panic("todo: %", it.tag);
    }
}

FTY_TABLE :: 0;
SYM_TABLE :: 1;

fn move_from_module(emit_ir: *EmitIr, import: *FrcImport) CRes(CodegenTask) = {
    zone := zone_begin(.ImportCache);
    module       := FrcModule.ptr_from_int(import.module); 
    header, m, f := (module.header, emit_ir.m, emit_ir.f);
    self := emit_ir.program.data.cast()[][];
    instance := @try(find_module(self, emit_ir.shared, module)) return;
    @debug_assert(identical(m, f.globals), "move_from_module bad f.m");

    i := import.get_sym();
    it := header.get(i);
    ::enum(@type it.segment);
    
    if it.segment == .Alias {
        // TODO: mostly untested because import_module caching is disabled currently  -- Oct 13, 2025
        target := instance.syms[it.alias.off.zext()];
        return(Ok = (Bounce = (lnk = f.lnk&, target = target)));
    };
    
    // TODO: this won't work if did_regalloc on amd64 because it doesn't see RMem. maybe i should just store those differently
    @if(it.segment == .Code) for(header, it.fnc.con) { _, con |
        if con.sym != Qbe.no_symbol_S {
            sym := @as(One(Sym)) (off = con.sym.id);
            it := header.get(sym);
            if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
                // this sets inst.syms[sym.off]
                id := @try(import_baked_var(self, emit_ir.shared, instance, sym)) return;
                // this recurses through relocations
                emit_ir.reference_constant(id);
            };
            
            // Since we don't run fold.fr, symbols won't be marked so they won't be emitted 
            // if they're an inlinable export from CompCtx to the FrcModule and only used there. 
            // like bf/via_wasm.fr/env'putchar(). forgetting this manifiests as the function appearing 
            // in the bytes passed to frc_import() but as .Invalid in the frontend's cache file. 
            id := instance.syms[con.sym.id.zext()];
            use_symbol(m, id) { s | 
                mark_referenced(m, id, s);
            };
        }
    };
    
    did_regalloc := load(header, f, i, instance.syms);
    if !did_regalloc {
        apply_type_offset(f, instance.type_offset);
    };
    zone_end(zone);
    
    // rn not adding anything to `pending`, trusting that sema_frc_import() put them in callees for someone else to pickup
    
    (Ok = (FromCache = (f = f, did_regalloc = did_regalloc)))
}

// TODO: this doesn't interact with comptime in the way i want it to but neither did the old import_c/ffi.fr so it's a good starting point. 
import_baked_var :: fn(self: *SelfHosted, shared: *FrontendCodegen, inst: *FrcModuleInstance, sym: One(Sym)) CRes(BakedVarId) = {
    module := inst.module;
    h := module.header;
    it := h.get(sym);
    ::enum(@type it.segment);
    @debug_assert(@is(it.segment, .MutableData, .ConstantData, .ZeroInitData), "import_baked_var(%, %)", it.segment, h.get(it.name));
    ::enum(FTy.Tag);
    ty := module.sym_ty[zext sym.off];
    if ty.off != Qbe.no_symbol {
        @debug_assert(h.get(ty)[].tag == .Ptr || ty.off == FTy.RAWPTR, "symbols are always pointers");
    };  // else just means not referenced from root scope. kinda lame. 
    
    slot := module.sym[zext sym.off]&;
    if slot[] != Qbe.no_symbol {
        id := bit_cast_unchecked(u32, BakedVarId, slot[]);
        @debug_assert_ult(@as(i64) zext id.id, self.baked.values.len);

        // :TheOtherWayDoesNotWorkOnExamplesTerminal
        // TODO: don't do this every time but find_module puts junk in there
        //if inst.syms[zext sym.off].id == Qbe.no_symbol {
            inst.syms[zext sym.off] = shared.m.intern(self.comp().mangle_name(id)); 
        //}
        //@println("reuse % = g%", h.get(it.name), id.id);
        return(Ok = id);
    };
    
    // reserve early to not get fucked by cycles
    dest, id := reserve_baked(self, .None);
    slot[] = bit_cast_unchecked(BakedVarId, u32, id);
    inst.syms[zext sym.off] = shared.m.intern(self.comp().mangle_name(id));
    
    // TODO: should be able to do this but i guess cycles
    //       actually i think its because of use_got_instead_of_patches
    //       but i should change how that works because i don't like fixup_arm64 getting called with kind=Pending
    //use_symbol(shared.m, inst.syms[zext sym.off]) { s |
    //    s.pledge_local = true;
    //};
    //@println("bake % = g%", h.get(it.name), id.id);
    
    Template :: @type dest.template;
    template: Template = @if(it.dat.bytes.off == Qbe.no_symbol, 
        (Zeroes = it.dat.bytes.count.zext()),
        (Bytes = h.get(it.dat.bytes)),
    );
    relocs := self.get_alloc().alloc_uninit(BakedReloc, it.dat.rel.count.zext());
    r := 0; 
    for(h, it.dat.rel) { i, it |
        target := zeroed(@type relocs[r].target);
        xx := @as(One(Sym)) (off = it.id.id);
        if @try(self.get_fid(module, xx)) return { fid | 
            target = (FuncId = fid);
        } else {
            target = (BakedVarId = @try(import_baked_var(self, shared, inst, xx)) return);
        };
        //@println("[%; %]%(%)+%", r, it.off, h.get(h.get(xx)[].name), target.BakedVarId.id, it.addend);
        relocs[r] = (target = target, off = it.off, addend = it.addend);
        r += 1;
    };
    @debug_assert_eq(relocs.len, r);
    loc := zeroed Span; // TODO
    // TODO: align
    // TODO: transfer .name if it's not mangled
    dest[] = (template = template, relocations = relocs, loc = loc, need_reify = true); 
    
    (Ok = id)
};

fn emit_import_ref(self: *EmitIr, it: *FrcImport, p: Placement) CRes(Qbe.Ref) = {
    inst := @try(self.find_module(it)) return;
    @debug_assert_eq(it.table, SYM_TABLE);
    id := @try(import_baked_var(self.program.data.cast()[][], self.shared, inst, (off = it.index))) return;
    ref := self.as_ref(AddrOf = id);
    //@println("emit_import_ref g%", id.id);
    (Ok = self.scalar_result(p, ref, i64))  // :get_or_create_type
} 

fn find_module(self: *EmitIr, it: *FrcImport) CRes(*FrcModuleInstance) = 
    find_module(self.program.data.cast()[][], self.shared, Incr'FrcModule.ptr_from_int(it.module));

fn find_module(self: *SelfHosted, shared: *FrontendCodegen, module: *FrcModule) CRes(*FrcModuleInstance) = {
    a := self.get_alloc();
    imp := shared.frc_imports&;
    ::ptr_utils(@type module[]);
    xx := imp.items().find(fn(it) => identical(it.module, module));  // :ThisIsNotOkBecauseMemoryWillBeReused
    (Ok = xx || {
        @assert_ne(shared.frc_imports.cap, shared.frc_imports.len, "ICE: too many imported modules. TODO: use something with pointer stability");
        h := module.header;
        syms := a.alloc_uninit(Qbe.Sym, zext h.sym.count);
        imp.push_assume_capacity(
            module = module,
            syms = syms,
            type_offset = read_types(h, shared.m),
        );

        // TODO: i want to do this lazily but i need the mangled names before i can start compiling anything
        for(h, h.all(Sym)) { i, it |
            continue :: local_return;
            
            if @try(self.get_fid(module, i)) return { fid |
                name := self.comp().fmt_fn_name(fid);
                syms[i.off.zext()] = shared.m.intern(name);
                //@println("prep fid for % sym=%", name, syms[i.off.zext()].id)
            } else {
                name_s := h.get(it.name);
                ::enum(@type it.segment);
                // :TheOtherWayDoesNotWorkOnExamplesTerminal
                //if it.segment == .Import {
                    syms[i.off.zext()] = shared.m.intern(name_s);
                //} else { // TODO
                    // it's local data. it will get baked to `g%` instead of this name. 
                    //syms[i.off.zext()] = Qbe.no_symbol_S;
                //}
                if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
                    _ := @try(import_baked_var(self, shared, imp[imp.len - 1]&, i)) return;
                }
            }
        };
        
        // HACK to make data imports work
        for module.data_symbols { it |
            sym, info := it;
            enter_task shared { entry |
                id := shared.m.intern(self.pool.get(info.name));
                if shared.m.goal.type == .JitOnly && info.comptime != 0 {
                    lnk := temp().boxed(Qbe.Lnk, (id = id));
                    entry.task = (JitImport = (lnk = lnk, addr = rawptr_from_int(info.comptime)));
                } else {
                    arg := temp().boxed(Ty(@slice(Qbe.Sym, Str, bool)), 
                        (id, self.pool.get(info.lib), info.weak));
                    entry.task = (SetLibrary = arg.slice(1));
                }
            };
        };
        
        imp[imp.len - 1]&
    })
}

// Ok(None) means it's data 
fn get_fid(self: *SelfHosted, module: *FrcModule, i: One(Sym)) CRes(?FuncId) = {
    h := module.header;
    ty := module.sym_ty[zext i.off];
    if ty.off == Qbe.no_symbol {
        // this symbol wasn't named in the root scope. 
        // (for now this just means it's a .L.._ import_c string literal -- Jun 8, 2025)
        // TODO: need to allow anon functions so really the module should be providing types for all the 
        //       symbols seperatly from the scope thing? 
        return(Ok = .None); 
    };
    
    ::enum(FTy.Tag);
    if h.get(ty)[].tag != .Func {
        it := h.get(i);
        @err_assert(!@is(it.segment, .Code, .MachineCode), "function value '%' must have function type", h.get(it.name)) return;
        return(Ok = .None);
    };
    
    fid := @try(sema_frc_import_fid(self, module, i)) return;
    (Ok = (Some = fid))
}

fn get_sym(import: *FrcImport) One(Sym) = {
    @debug_assert_eq(import.table, SYM_TABLE);
    (off = import.index)
}

fn as_bytes(header: *Header) []u8 = 
    (ptr = bit_cast_unchecked(*Header, *u8, header), len = header.meta.filelen.zext());

// TODO: return and error instead of crashing but need to pre-fmt it because the caller doesn't have our compiler instance. 
// It's fine to just pass in the *BuildOptions from the parent compiler instance, init_compiler makes a copy. 
cached_compile_module :: fn(path: Str, opts: *BuildOptions, out_alloc: Alloc) CRes([]u8) = {
    zone := zone_begin(.CheckCache);
    @assert(path.starts_with("@/"), "cached_compile_module path must start with @");
    path_unprefixed := path.rest(2);
    
    cachepath := choose_cache_filename(path_unprefixed);
    @if(enable_incremental())
    if read_cached(out_alloc, cachepath) { header |
        B :: local_return;
        break :: fn() => {
            out_alloc.dealloc(u8, header.as_bytes());
            B();
        };
        
        t := Incremental'pack_current_target();
        if(header.arch_os.bit_and(t) != t, => break());
        if(header.entry_dep.off == Qbe.no_symbol, => break());
        entry_dep := header.get(header.entry_dep);
        if(header.get(entry_dep.filename) != path, => break());
        
        if(!files_unchanged(header), => break());
        if(show_backend_stats(), => @eprintln(">>> hit: %", cachepath));
        zone_end(zone);
        return(Ok = header.as_bytes());
    };
    zone_end(zone);
    
    zone := zone_begin(.ImportCache);
    out := "";
    push_dynamic_context {
        context(DefaultContext)[].comptime = zeroed rawptr;
        mark := mark_temporary_storage();
        start := timestamp();
        vtable := init_driver_vtable();
        src := @tfmt("""#include_std("lib/core.fr"); MODULE_EXPORTS :: import("%").exports;""", path);
        compiler := new_with_src(vtable, src, opts);
        self := compiler.cast()[][];
        
        m := self.get_alloc().box_uninit(QbeModule);
        // TODO: "need to be consistant about how to handle modules like this that don't actually compile anything"
        init_default_module_dyn(m, vtable, (
            os = .macos, 
            arch = .aarch64, 
            type = .CachedEarly,
        ));
        
        c: ExportCtx = (
            self = self, 
            m = m,
            writer = m.save.unwrap(),
            types = init(self.get_alloc()),
        );
        
        // TODO: making everyone remember to do this is kinda lame
        range(0, FTy.COUNT) { i |
            c.types&.insert(bit_cast_unchecked(u32, Type, i.trunc()), (off = i.trunc()));
            c.writer.fty&.push(zeroed Incremental.FTy);   // skip builtin types so offsets work out
        };
        
        bytes := build_the_exports_scope(c&, path_unprefixed);
        // TODO: pre-format this error and return it
        bytes := self.unwrap_report_error([][]u8, bytes);
        bytes := bytes.concat(out_alloc);
        end := timestamp();
        
        drop(m);
        vtable'destroy_compiler(compiler);
        context(DefaultContext)[].comptime = zeroed rawptr;
        reset_temporary_storage(mark);
        
        if make_dirs(cache_dir()) && write_entire_file(cachepath, bytes) {
            if(show_backend_stats(), => @eprintln(">>> save: % in %ms", cachepath, end - start));
        }
        // (else: it's fine if you fail to write the cache, it's just slower next time)
        
        out = bytes;
    };
    zone_end(zone);
    (Ok = out)
};

ExportCtx :: @struct {
    self: *SelfHosted;
    m: *QbeModule;
    writer: *Writer;
    types: HashMap(Type, One(FTy));
};

// TODO: need to include deps 
fn build_the_exports_scope(c: *ExportCtx, start_path: Str) CRes([][]u8) = {
    fns, names := @try(collect_fns_from_exports(c)) return;
    // This is kinda copy-paste fusion adventure of emit_qbe_included and finish_qbe_module. 
    
    fr := c.self.comp();
    shared := init_codegen(c.m, fr.get_alloc(), true);
    funcs_done := main_thread_pump(fr, shared, fns, false);
    @debug_assert(c.m.inlinable_but_referenced_later.len == 0);
    
    backend'writer_finish_imports(c.writer, c.m);
    root_scope := export_root_scope(c, fns, funcs_done&, names);
    entry_dep := write_deps(c.writer, c.self.codemap, start_path);
    
    meta: Incremental.Meta = (
        arch_os = 0x0F0F,
        entry_dep = (off = entry_dep),
        root_scope = root_scope,
        // TODO: don't call this debug_name if im going to use it for stuff
        debug_name = c.writer.push(mangle_name_for_cache(start_path)),
    );
    bytes := c.writer.to_bytes(meta, c.m);
    (Ok = bytes)
}

// TODO: this is kinda dumb, i shouldn't need to export everything just to give it type info it needs for shims.  
//       should use FTy.Abi for everything that isn't explicitly exported. 
export_root_scope :: fn(c: *ExportCtx, fns: []FuncId, funcs_done: *DynamicBitSet, names: []Str) One(FTy) = {
    decls := Fld.list(temp());

    range(0, fns.len) { i | 
        fid, export_name := (fns[i], names[i]);
        name := c.self.comp().fmt_fn_name(fid);
        id := c.m.intern(name);
        idx := c.writer.map_sym(c.m, id);
        
        
        func := c.self.get_function(fid);
        // TODO: copy paste
        f_ty := func.finished_ty() || @panic("unfinished type for %", c.self.comp().log(func));
        f_ty := c.self.intern_type(FnPtr = (ty = f_ty));
        f_ty := export_type(c, f_ty);
        
        decls&.push(
            name = c.writer.push(export_name),
            type = f_ty,
            payload = (offset = trunc idx)
        );
    };
    symbols_exported: Qbe.BSet = init_bitset(c.writer.sym.len + c.self.functions.len);
    i := 0;
    each c.self.functions& { func |
        continue :: local_return;
        fid: FuncId = i.from_index();
        i += 1;
        if(!funcs_done.get(i-1), => continue());
        i := ();

        c.self.last_loc = func.loc;
        name := c.self.comp().fmt_fn_name(fid);
        id := c.m.intern(name);
        idx := c.writer.map_sym(c.m, id);
        symbols_exported&.bsset(idx);
        
        f_ty := func.finished_ty() || @panic("unfinished type for %", c.self.comp().log(func));
        f_ty := c.self.intern_type(FnPtr = (ty = f_ty));
        f_ty := export_type(c, f_ty);
        
        decls&.push(
            name = c.writer.sym[idx].name,
            type = f_ty,
            payload = (offset = trunc idx)
        );
        
        @if_let(func.body&) fn DynamicImport(it) => {
            id := c.m.intern(c.self.comp().get_string(it.name));
            idx := c.writer.map_sym(c.m, id);
            symbols_exported&.bsset(idx);
            decls&.push(
                name = c.writer.sym[idx].name,
                type = f_ty,
                payload = (offset = trunc idx)
            );
        };
    };
    
    range(0, c.writer.sym.len) { idx |
        if !symbols_exported&.bshas(idx) {
            decls&.push(
                name = c.writer.sym[idx].name,
                type = (off = FTy.RAWPTR),
                payload = (offset = trunc idx)
            );
        }
    };
    
    save_fields(c.writer, .Scope, decls.items())
};

// TODO: why's it think SelfHosted is undeclared if these are overload sets

export_type :: fn(c: *ExportCtx, type: Type) One(FTy) = {
    // TODO: use get_or_insert but be careful not to hold the pointer. 
    if c.types&.get(type) { it |
        return(it);
    };
    id := c.writer.fty.len;
    out: One(FTy) = (off = trunc id);
    c.writer.fty&.push(zeroed FTy);
    c.types&.insert(type, out);
    c.writer.fty[id] = c.export_type_info(type);
    out
};

export_type_info :: fn(c: *ExportCtx, type: Type) FTy = {
    writer := c.m.save.unwrap();
    @match(c.self.get_type(type)) {
        fn Int(it) => (
            tag = .Number, 
            payload = (int = (bits = it.bit_count.trunc(), signed = it.signed)),
        );
        // TODO: wrong if the backing type is not a small integer
        fn Enum(it) => {
            args := Fld.list(it.fields.len, temp());
            inner := export_type(c, it.raw);
            for it.fields { it |
                name, value := it;
                args&.push(
                    name = writer.push(c.self.pool.get(name)),
                    type = inner,
                    payload = (offset = trunc value.Small._0),
                );
            };
            save_fields_fty(writer, .Enum, args.items())
        }
        fn Ptr(it) => (
            tag = .Ptr, 
            payload = (array = (
                inner = c.export_type(it[]),
            )),
        );
        fn Array(it) => (
            tag = .Array,
            payload = (array = (
                inner = c.export_type(it.inner), 
                count = it.len,
            )),
        );
        fn Struct(it) => {
            args := Fld.list(it.fields.len, temp());
            each it.fields { it |
                args&.push(
                    name = writer.push(c.self.pool.get(it.name)),
                    type = c.export_type(it.ty),
                    payload = (offset = it.byte_offset.trunc()), 
                );
            };
            tag: FTy.Tag = @if(it.is_union, .Union, @if(it.is_tuple, .Params, .Struct));
            save_fields_fty(c.writer, tag, args.items())
        }
        fn Tagged(it) => {
            args := Fld.list(it.cases.len, temp());
            for it.cases { it |
                name, type := it;
                args&.push(
                    name = writer.push(c.self.pool.get(name)),
                    type = c.export_type(type),
                    payload = (offset = 0), 
                );
            };
            save_fields_fty(c.writer, .Tagged, args.items())
        }
        fn FnPtr(it) => (
            tag = .Func,
            payload = (func = (
                arg = c.export_type(it.ty.arg), 
                ret = c.export_type(it.ty.ret), 
            )),
        );
        fn Named(it) => (
            tag = .Alias,
            payload = (alias = c.export_type(it._0)),
        )
        @default => {
            info := c.self.get_info(type);
            if info.loc.low != 0 {
                c.self.last_loc = (low = info.loc.low, high = info.loc.low + 1);
            };
            e: CRes(void) = @err("TODO: export confusing type %", c.self.log_type(type));
            c.self.report_error(e.Err, true)
        };
    }
};

// for now it's just always the toplevel identifier `exports` but eventually i should expose a more powerful api
collect_fns_from_exports :: fn(c: *ExportCtx) CRes(Ty([]FuncId, []Str)) = {
    value := c.self.poll_in_place(?Values, => c.self.find_in_scope(TOP_LEVEL_SCOPE, c.self.pool.insert_owned("MODULE_EXPORTS"), ScopeId));
    value := @try(value) return;
    value := @unwrap(value, "ICE: import_module() didn't find exports variable") return;
    s := ScopeId.assume_cast(value&)[];
    
    scope := c.self.scopes[s].lookup&;
    fns := FuncId.list(c.self.get_alloc());
    names := Str.list(c.self.get_alloc());
    each c.self.scopes[s].lookup& { name, var | 
        continue :: local_return;
        @if(var.kind != .Const) continue();
        
        value := c.self.poll_in_place(?Values, => c.self.find_in_scope(s, name, FuncId));
        value := @try(value) return;
        value := value.unwrap();
        fid := FuncId.assume_cast(value&)[];
        
        push(fns&, fid);
        push(names&, c.self.pool.get(name));
    };
    (Ok = (fns.items(), names.items()))
};

#use("@/lib/collections/bit_set.fr");
#use("@/backend/lib.fr");
