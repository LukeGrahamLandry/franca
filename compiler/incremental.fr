// 
// "incremental" is really not the right word for this. 
// it's just a binary serialization format for compiler state, not like only-recompile-functions-that-changed magic. 
// used in two ways: 
// - invisible speedup when running scripts/drivers directly (like `franca a.fr`)
// - as an api for alternative frontends (like examples/import_c/ffi.fr/include())
// 
#use("@/backend/incremental.fr");

fn read_cached(a: Alloc, path: Str) ?*Header = {
    bytes := read_entire_file(a, path) || return(.None);
    magic8 := ptr_cast_unchecked(u8, u64, bytes.ptr)[];
    if(magic8 != MAGIC, => return(.None));
    (Some = check(bytes))
}

// The first Dep in cached .frc files is the hash of the compiler itself. 
self_filename :: "@self";
// TODO: im just vaugly hoping this runs after all files have been loaded 
//       (which it does not in fact. backend/__/emit.fr is through a vtable so happens late)
self_hash :: @static(Array(u32, 8)) Array(u32, 8).zeroed();

// TODO: THIS BEHAVIOUR IS CONSIDERED DISRESPECTFUL.
//       this is a fragile compilation order HACK that user code really shouldn't do 
//       but it's kinda cute that it works. This gets called from main() and the extra 
//       indirection with a forced shim ensures that comptime_compute_self_hash() runs 
//       after all files have been loaded (even the ones through a shim in Qbe.Target vtable). 
//       this will definitly come back to haunt me because i only test it manually by uncommenting 
//       a print and eyeballing the list of files.    -- May 26, 2025
set_self_hash :: fn() void #inline = {
    hack :: @as(@FnPtr() Array(u32, 8)) comptime_compute_self_hash;
    self_hash[] = hack();
};

fn comptime_compute_self_hash() Array(u32, 8) = :: {
    fr   := current_compiler_context();
    self := fr.data.cast()[][];
    hash := zeroed Array(u32, 8);
    @if(!IS_BOOTSTRAPPING) // :UpdateBoot
    each self.codemap.files { it |
        // uncomment to check that the compilation order hack with set_self_hash is working. 
        if is_cachable(it.name) {
            // println(it.name);
            hash = bit_xor(hash, it.hash);
        }
    };
    hash
}

fn bit_xor(a: Array(u32, 8), b: Array(u32, 8)) Array(u32, 8) = {
    range(0, 8) { i |
        a&[i] = bit_xor(a&[i], b&[i]);
    };
    a
}

fn files_unchanged(header: *Header) bool = {
    if(header.dep.count <= 1, => return(false));
    
    it: *Dep = header.get(0);
    if(header.get(it.filename) != self_filename, => return(false));
    if(self_hash.items() != it.hashcode&.items(), => return(false));
    
    // TODO: save this work of loading + hashing the files even if they changed
    range(1, header.dep.count.zext()) { i |
        continue :: local_return;
        it: *Dep = header.get(@as(u32) i.trunc());
        filename := header.get(it.filename);
        src      := temp().get_include_std(filename) || return(false);
        if(src.len != it.file_len.zext(), => return(false));
        hashcode := Sha256'sha256(src);
        if(hashcode&.items() != it.hashcode&.items(), => return(false));
    };
    true
}

fn compile_cached(header: *Header) (@FnPtr(*ImportVTable) void) = {
    a := general_allocator();
    m := a.box(QbeModule);
    init_default_module(m, (
        arch = query_current_arch(), 
        os = query_current_os(), 
        type = .JitOnly,
    ));
    
    z := zone_begin(.AotPump);
    compile_all_symbols(header, m);
    zone_end(z);
    
    import("@/backend/meta/qbe_frontend.fr")'fill_from_libc(m);
    
    i := header.entry_sym;
    name := header.get(header.get(i)[].name);
    cc := m.get_addr(name) || @panic("ICE: lost %", name);
    _ := push_resolver(QbeModule, m, find_ip_in_module);
    m.make_exec();
    assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = cc)
}

fn write_cache(m: *QbeModule, c: CompCtx, fid: FuncId, outpath2: Str, start_path: Str) *Header = {
    self := c.data.cast()[][];
    
    @if(!enable_incremental()) @panic("write_cache");
    writer := m.save.unwrap();
    finish_imports(writer, m);
    
    writer.dep&.reserve(self.codemap.files.len+1);
    writer.dep&.push(
        file_len = 0,
        filename = writer.push(self_filename),
        hashcode = self_hash[],
    );
    
    entry_dep := Qbe.no_symbol;
    each self.codemap.files { it |
        if is_cachable(it.name) {
            if entry_dep == Qbe.no_symbol && it.name == start_path /*:SLOW*/ {
                entry_dep = writer.dep.len.trunc();
            };
        
            writer.dep&.push(
                file_len = it.content.len.trunc(),
                filename = writer.push(it.name),
                hashcode = it.hash,
            );
        }
    };
    
    name := c.fmt_fn_name(fid);
    meta: Meta = (
        arch_os = pack_current_target(),
        entry_sym = (off = writer.map_sym(m, m.intern(name)).trunc()),
        entry_dep = (off = entry_dep),
    );
    chunks := writer.to_bytes(meta, m);
    bytes := concat(chunks, general_allocator());
    
    write_entire_file_or_crash(outpath2, bytes);
    if(show_backend_stats(), => @eprintln(">>> save: %", outpath2));
    
    check(bytes)
}

fn is_cachable(name: Str) bool = !(false 
    // the fill_export_ffi string that has virtual addresses in it.
    // can't just ignore in files_unchanged() because this would break repro. 
    || name == "compiler" 
    // the generated src string in load_file_in_compiler. 
    // redundant with entry_dep anyway. 
    || name == "-"
    // from an `import("{ foo };")`.
    || name == import_literal_file_name 
);

// TODO: this is dumb: ./a.fr vs a.fr, also unreadable is sad
// Also this is very collidable but it's fine beacuse the cache file contains the path of the entry_dep. 
// I considered using hash of the path but it's annoying to need to dump_bin to see what's in your cache dir. 
fn choose_cache_filename(path: Str) Str = {
    out := u8.list(path.len+25, temp());
    out&.push_all(cache_dir());
    for path { c |
        if c.is_ascii_alpha() || c.is_ascii_digit() {
            out&.push(c);
        } else {
            out&.push("_".ascii());
        }
    };
    out&.push_all(".frc");
    out.items()
}

fn cache_dir() Str = 
    @tfmt("%/cache/", get_environment_variable("FRANCA_TARGET_DIR") || "target/franca");

// one per (CompCtx, Header) pair.
FrcModule :: @struct {
    header: *Header;
    scope: ScopeId;
    sym: []u32;  // [One(Sym)] = FuncId or BakedVarId
    sym_ty: []One(FTy); // [One(Sym)]
    fty: []Type; // [One(FTy)] 
};

// one per (CodegenWorker, Header) pair. 
// ie. comptime vs runtime has seperate QbeModule so needs some import state stored seperately. 
// this is created lazily the first time you call move_from_module. 
FrcModuleInstance :: @struct {
    module: *FrcModule;
    syms: []Qbe.Sym; // [One(Sym)]
    type_offset: i64; // TODO: this could go away if there was an extra layer of indirection for RType (like i already do for RCon)
};

// translate header.root_scope into FrcImport entries in a new ScopeId. 
// TODO: this is what i want but is not the case now... (because instance.syms needs the mangled names so need to reserve FuncId-s upfront)
// no work to actually translate into Func/BakedValue graph is done yet. 
// thing are loaded lazily the first time they're referenced (just like normal franca code). 
fn import_frc(self: *SelfHosted, bytes: []u8) CRes(ScopeId) = {
    header := check(bytes);  // TODO: return error if the magic fails
    scope := self.scopes.new_scope(TOP_LEVEL_SCOPE, self.get_alloc(), zeroed Span); // TODO: location info
    
    // TODO: some configuration to make it save these somewhere you can look at them. 
    //       should do the same with add_function, macro returns, import("{"), etc. 
    //       debugging macros really sucks currently. 
    //write_entire_file("target/a.frc", bytes);
    
    a := self.get_alloc();
    module := a.box(FrcModule);
    module[] = (
        header = header, 
        scope = scope,
        sym = a.alloc_init(u32, zext header.sym.count, fn(_) => Qbe.no_symbol), 
        sym_ty = a.alloc_init(One(FTy), zext header.sym.count, fn(_) => (off = Qbe.no_symbol)), 
        fty = a.alloc_zeroed(Type, zext header.fty.count),
    );
    @err_assert(header.fty.count != 0, "tried to import_frc without frontend type info (fty)") return;
    
    sym_ty := module.sym_ty;
    range(0, FTy.COUNT) { i |  // builtin types
        module.fty[i] = bit_cast_unchecked(u32, Type, trunc i);
    };
    module := FrcModule.int_from_ptr(module);
    
    root_scope := header.get(header.root_scope);
    for(header, root_scope.payload.fields) { i, it |
        name := self.pool.insert_owned(header.get(it.name));
        loc := zeroed Span;  // TODO
        type: LazyType = (PendingEval = (
            expr = (FrcImport = (module = module, index = it.type.off, table = FTY_TABLE)), 
            ty = Type, done = false, loc = loc,
        ));
        is_type := it.type.off == FTy.TYPE || it.type.off == FTy.SCOPE;
        expr: FatExpr = (ty = UnknownType, done = false, loc = loc, expr = (FrcImport = (
            module = module, 
            index = it.payload.offset, 
            table = @if(is_type, FTY_TABLE, SYM_TABLE),
        )));
        if !is_type {
            // sema_frc_import_fid() needs this information and it's a lot less painful 
            // to just store it now than to look it up through the scope later. 
            // TODO: need to make this work for anon functions tho
            sym_ty[zext it.payload.offset] = it.type;
        };
        
        if header.get(it.type)[].tag == .Func {
            // better not to say FnPtr because that forces a jit shim to immediate_eval_constant
            type = (Finished = FuncId);
        };
        
        self.add_to_scope(scope, name, type, expr);
    };
    //println("done filling scope!");
    
    (Ok = scope)
}

fn sema_frc_import(self: *SelfHosted, expr: *FatExpr) Maybe(void) = {
    @debug_assert(expr.expr&.is(.FrcImport), "expected FrcImport");
    import := expr.expr.FrcImport;
    module := FrcModule.ptr_from_int(import.module); header := module.header;
    @debug_assert_eq(header.magic_v, MAGIC);
    loc := zeroed Span; // TODO
    if import.table == FTY_TABLE {
        type := self.import_type(module, @as(One(FTy)) (off = import.index));
        @check(self.return_macro_type(expr, type)) return;
        return(.Ok)
    };
    
    if(import.table != SYM_TABLE, => panic("invalid FrcImport.table")); 
    
    i := import&.get_sym();
    it := header.get(i);
    caller_name := header.get(it.name);
    ::enum(@type it.segment);
    
    type := module.sym_ty[zext import.index];
    if type.off == Qbe.no_symbol {
        return(@err("% wasn't referenced from the root scope so we don't know it's type", caller_name));
    };
    is_function := header.get(type)[].tag == .Func;
    
    if it.segment == .Import && !is_function {
        //@println("import data: %", caller_name);
        lib := header.get(header.get(it.imp.lib)[].name);
        name := self.pool.insert_owned(caller_name);
        expr.expr = (DataSymbol = (name = name, lib = self.pool.insert_owned(lib), comptime = 0, weak = it.imp.weak));
        expr.ty = self.import_type(module, type);
        return(.Ok);
    }

    if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
        // let emit_ir.fr deal with it
        //@println("local data: %", caller_name);
        expr.ty = self.import_type(module, type);
        expr.done = true;
        return(.Ok);
    }
    
    @debug_assert(@is(it.segment, .Import, .Code, .MachineCode), "TODO: import_frc %", it.segment);
    
    fid := @try(self.sema_frc_import_fid(module, i)) return;
    self.set(expr, FuncId, fid);
    .Ok
}

fn sema_frc_import_fid(self: *SelfHosted, module: *FrcModule, i: One(Sym)) CRes(FuncId) #once = {
    h := module.header;
    slot := module.sym[zext i.off]&;
    if slot[] != Qbe.no_symbol {
        return(Ok = bit_cast_unchecked(u32, FuncId, slot[]));
    };
    
    type := self.import_type(module, module.sym_ty[zext i.off]);
    info := self.get_type(type);
    it := h.get(i);
    caller_name := h.get(it.name);
    @debug_assert_ne(type, UnknownType, "must know signeture of imported function");
    @err_assert(info.is(.FnPtr), "expected function type for '%' but found %", caller_name, self.log_type(type)) return;
    loc := zeroed Span; // TODO
    name := self.pool.insert_owned(caller_name);
    
    ::enum(Seg);
    if it.segment == .Import && it.imp.temporary_funcid != 0 && it.imp.temporary_funcid != Qbe.no_symbol {
        //@println("existing function: %", caller_name);
        slot[] = it.imp.temporary_funcid;
        return(Ok = bit_cast_unchecked(u32, FuncId, slot[]));
    }

    fid := self.add_function(empty_fn(info.FnPtr.ty, name, loc));
    func := self.get_function(fid);
    slot[] = bit_cast_unchecked(FuncId, u32, fid);
    
    func.set_flag(.ResolvedBody);
    func.set_flag(.ResolvedSign);
    func.set_flag(.EnsuredCompiled);
    func.set_flag(.BodyIsSpecial);
    //func.set_flag(.AvoidJitShim);  // TODO: this is unfortunate
    if it.segment != .Import {
        //@println("local function: %", caller_name);
        func.body = (FrcImport = (module = FrcModule.int_from_ptr(module), index = i.off, table = SYM_TABLE));
        @assert_ne(it.segment, .MachineCode, "TODO: machine code");

        msg :: "TODO: this won't work if did_regalloc on amd64 because it doesn't see RMem. maybe i should just store those differently";
        @err_assert(it.fnc.tmp != Qbe.no_symbol, msg) return;
        for(h, it.fnc.con) { _, con |
            if con.sym != Qbe.no_symbol_S {
                sym := @as(One(Sym)) (off = con.sym.id);
                
                //@println("- callee %", h.get(h.get(sym)[].name));
                // TODO: i think this doesn't super matter until i start handing out func-ids lazily
                // TODO: need to track the Dat dependencies too somehow. maybe give up and just use 
                //       emitir.pending for this as well like old FuncImpl.Ir did. 
                if @try(self.get_fid(module, sym)) return { fid |
                    // TODO: mutual_ cycles?
                    func.callees&.push(fid, self.get_alloc());
                };
            }
        }
    } else {
        //@println("import function: %", caller_name);
        lib := h.get(h.get(it.imp.lib)[].name);
        lib := self.pool.insert_owned(lib);
        @try(self.create_import_body(func, fid, lib, it.imp.weak)) return;
    };
    fill_bindings(func, self.comp(), self.comp().arg_types(func.finished_arg.Some));
    (Ok = fid)
}

// TODO: special alignment, #use
fn import_type(self: *SelfHosted, module: *FrcModule, i: One(FTy)) Type = {
    slot := module.fty[zext i.off]&; header := module.header;
    if(slot[] != UnknownType, => return(slot[]));
    it := header.get(i);
    ::enum(@type it.tag);
    nominal := @is(it.tag, .Struct, .Union, .Tagged, .Alias);
    
    ::if(Type);
    if !nominal {
        info := self.import_type_info(module, it);
        id := self.intern_type(info);
        slot[] = id;
        id
    } else {
        id := self.intern_type(.Placeholder);  // avoid cycles
        slot[] = id;
        info := self.import_type_info(module, it);
        self.get_type(id)[] = info;  // go directly to jail do not pass go do not collect two hundred dollars 
        id
    }
}

fn import_type_info(self: *SelfHosted, module: *FrcModule, it: *FTy) TypeInfo = {
    if @is(it.tag, .Params, .Struct, .Union) {
        is_tuple := it.tag == .Params;
        fields := Field.list(it.payload.fields.count.zext(), self.get_alloc());
        j := 0;
        for(module.header, it.payload.fields) { i, it |
            ::if(Symbol); ::enum(Flag);
            fields&.push(
                name = if is_tuple {
                    get_tuple_field_name(self.comp(), j)
                } else {
                    self.pool.insert_owned(module.header.get(it.name))
                },
                ty = import_type(self, module, it.type),
                nullable_tag = zeroed(*Annotations),
                default = zeroed(Var),
                // TODO: decide if this should go in Fld.payload or if i want to use that slot for default value
                byte_offset = FIELD_LAYOUT_NOT_DONE,
            );
            j += 1;
        };
        
        return(Struct = (
            is_tuple = is_tuple,
            is_union = it.tag == .Union,
            fields = fields.as_raw(),
            layout_done = false,
            scope = NOSCOPE,
        ));
    };
    
    @match(it.tag) {
        fn Ptr() => (Ptr = import_type(self, module, it.payload.array.inner));
        fn Array() => (Array = (
            inner = import_type(self, module, it.payload.array.inner), 
            len = it.payload.array.count,
        ));
        fn Func() => (FnPtr = (ty = (
            arg = import_type(self, module, it.payload.func.arg), 
            ret = import_type(self, module, it.payload.func.ret), 
            unary = module.header.get(it.payload.func.arg)[].tag != .Params,
        )));
        fn Number() => {
            @assert(!it.payload.int.bitfield, "TODO: bitfields");
            (Int = (bit_count = zext it.payload.int.bits, signed = it.payload.int.signed))
        }
        fn Enum() => {
            sequential, last := (true, -1);
            args := Ty(Symbol, Values).list(zext it.payload.fields.count, self.get_alloc());
            
            for(module.header, it.payload.fields) { i, it |
                name := self.pool.insert_owned(module.header.get(it.name));
                val: i64 = it.payload.offset.zext();
                sequential = sequential && val == last + 1;
                last = val;
                @debug_assert_eq(it.type.off, FTy.U32);
                push(args&, (name, self.to_values(u32, trunc val)));
            };
            
            raw := u32;  // TODO: non-u32 // :get_or_create_type 
            (Enum = (raw = raw, fields = args.as_raw(), sequential = sequential))
        }
        @default => @panic("todo: %", it.tag);
    }
}

FTY_TABLE :: 0;
SYM_TABLE :: 1;

fn move_from_module(emit_ir: *EmitIr, import: *FrcImport) CRes(CodegenTask) = {
    module       := FrcModule.ptr_from_int(import.module); 
    header, m, f := (module.header, emit_ir.m, emit_ir.f);
    self := emit_ir.program.data.cast()[][];
    instance := @try(find_module(self, emit_ir.shared, module)) return;
    @debug_assert(identical(m, f.globals), "move_from_module bad f.m");

    i := import.get_sym();
    it := header.get(i);
    ::enum(@type it.segment);
    // TODO: this won't work if did_regalloc on amd64 because it doesn't see RMem. maybe i should just store those differently
    @if(it.segment == .Code) for(header, it.fnc.con) { _, con |
        if con.sym != Qbe.no_symbol_S {
            sym := @as(One(Sym)) (off = con.sym.id);
            it := header.get(sym);
            if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
                // this sets inst.syms[sym.off]
                id := @try(import_baked_var(self, emit_ir.shared, instance, sym)) return;
                // this recurses through relocations
                emit_ir.reference_constant(id);
            };
            
            // Since we don't run fold.fr, symbols won't be marked so they won't be emitted 
            // if they're an inlinable export from CompCtx to the FrcModule and only used there. 
            // like bf/via_wasm.fr/env'putchar(). forgetting this manifiests as the function appearing 
            // in the bytes passed to frc_import() but as .Invalid in the frontend's cache file. 
            id := instance.syms[con.sym.id.zext()];
            use_symbol(m, id) { s | 
                mark_referenced(m, id, s);
            };
        }
    };
    
    did_regalloc := load(header, f, i, instance.syms);
    if !did_regalloc {
        apply_type_offset(f, instance.type_offset);
    };
    // rn not adding anything to `pending`, trusting that sema_frc_import() put them in callees for someone else to pickup
    
    (Ok = (FromCache = (f = f, did_regalloc = did_regalloc)))
}

// TODO: this doesn't interact with comptime in the way i want it to but neither did the old import_c/ffi.fr so it's a good starting point. 
import_baked_var :: fn(self: *SelfHosted, shared: *CodegenShared, inst: *FrcModuleInstance, sym: One(Sym)) CRes(BakedVarId) = {
    module := inst.module;
    h := module.header;
    it := h.get(sym);
    ::enum(@type it.segment);
    @debug_assert(@is(it.segment, .MutableData, .ConstantData, .ZeroInitData), "import_baked_var(%, %)", it.segment, h.get(it.name));
    ::enum(FTy.Tag);
    ty := module.sym_ty[zext sym.off];
    if ty.off != Qbe.no_symbol {
        @debug_assert_eq(h.get(ty)[].tag, .Ptr, "symbols are always pointers");
    };  // else just means not referenced from root scope. kinda lame. 
    
    slot := module.sym[zext sym.off]&;
    if slot[] != Qbe.no_symbol {
        id := bit_cast_unchecked(u32, BakedVarId, slot[]);
        @debug_assert_lt(@as(i64) zext id.id, self.baked.values.len);

        // :TheOtherWayDoesNotWorkOnExamplesTerminal
        // TODO: don't do this every time but find_module puts junk in there
        //if inst.syms[zext sym.off].id == Qbe.no_symbol {
            inst.syms[zext sym.off] = shared.m.intern(@tfmt("g%", id.id)); 
        //}
        //@println("reuse % = g%", h.get(it.name), id.id);
        return(Ok = id);
    };
    
    // reserve early to not get fucked by cycles
    dest, id := reserve_baked(self, .None);
    slot[] = bit_cast_unchecked(BakedVarId, u32, id);
    inst.syms[zext sym.off] = shared.m.intern(@tfmt("g%", id.id));
    //@println("bake % = g%", h.get(it.name), id.id);
    
    Template :: @type dest.template;
    template: Template = @if(it.dat.bytes.off == Qbe.no_symbol, 
        (Zeroes = it.dat.bytes.count.zext()),
        (Bytes = h.get(it.dat.bytes)),
    );
    relocs := self.get_alloc().alloc(BakedReloc, it.dat.rel.count.zext());
    r := 0; 
    for(h, it.dat.rel) { i, it |
        target := zeroed(@type relocs[r].target);
        xx := @as(One(Sym)) (off = it.id.id);
        if @try(self.get_fid(module, xx)) return { fid | 
            target = (FuncId = fid);
        } else {
            target = (BakedVarId = @try(import_baked_var(self, shared, inst, xx)) return);
        };
        //@println("[%; %]%(%)+%", r, it.off, h.get(h.get(xx)[].name), target.BakedVarId.id, it.addend);
        relocs[r] = (target = target, off = it.off, addend = it.addend);
        r += 1;
    };
    loc := zeroed Span; // TODO
    // TODO: align
    dest[] = (template = template, relocations = relocs, loc = loc, need_reify = true); 
    
    (Ok = id)
};

fn emit_import_ref(self: *EmitIr, it: *FrcImport, p: Placement) CRes(Qbe.Ref) = {
    inst := @try(self.find_module(it)) return;
    @debug_assert_eq(it.table, SYM_TABLE);
    id := @try(import_baked_var(self.program.data.cast()[][], self.shared, inst, (off = it.index))) return;
    ref := self.as_ref(AddrOf = id);
    //@println("emit_import_ref g%", id.id);
    (Ok = self.scalar_result(p, ref, i64))  // :get_or_create_type
} 

fn find_module(self: *EmitIr, it: *FrcImport) CRes(*FrcModuleInstance) = 
    find_module(self.program.data.cast()[][], self.shared, Incr'FrcModule.ptr_from_int(it.module));

fn find_module(self: *SelfHosted, shared: *CodegenShared, module: *FrcModule) CRes(*FrcModuleInstance) = {
    a := self.get_alloc();
    imp := shared.frc_imports&;
    ::ptr_utils(@type module[]);
    xx := imp.items().find(fn(it) => identical(it.module, module));
    (Ok = xx || {
        @assert_ne(shared.frc_imports.cap, shared.frc_imports.len, "ICE: too many imported modules. TODO: use something with pointer stability");
        h := module.header;
        syms := a.alloc(Qbe.Sym, zext h.sym.count);
        imp.push_assume_capacity(
            module = module,
            syms = syms,
            type_offset = read_types(h, shared.m),
        );

        // TODO: i want to do this lazily but i need the mangled names before i can start compiling anything
        for(h, h.all(Sym)) { i, it |
            continue :: local_return;
            
            if @try(self.get_fid(module, i)) return { fid |
                name := self.comp().fmt_fn_name(fid);
                syms[i.off.zext()] = shared.m.intern(name);
                //@println("prep fid for % sym=%", name, syms[i.off.zext()].id)
            } else {
                name_s := h.get(it.name);
                ::enum(@type it.segment);
                // :TheOtherWayDoesNotWorkOnExamplesTerminal
                //if it.segment == .Import {
                    syms[i.off.zext()] = shared.m.intern(name_s);
                //} else { // TODO
                    // it's local data. it will get baked to `g%` instead of this name. 
                    //syms[i.off.zext()] = Qbe.no_symbol_S;
                //}
                if @is(it.segment, .MutableData, .ConstantData, .ZeroInitData) {
                    _ := @try(import_baked_var(self, shared, imp[imp.len - 1]&, i)) return;
                }
            }
        };
        
        imp[imp.len - 1]&
    })
}

// Ok(None) means it's data 
fn get_fid(self: *SelfHosted, module: *FrcModule, i: One(Sym)) CRes(?FuncId) = {
    h := module.header;
    ty := module.sym_ty[zext i.off];
    if ty.off == Qbe.no_symbol {
        // this symbol wasn't named in the root scope. 
        // (for now this just means it's a .L.._ import_c string literal -- Jun 8, 2025)
        // TODO: need to allow anon functions so really the module should be providing types for all the 
        //       symbols seperatly from the scope thing? 
        return(Ok = .None); 
    };
    
    ::enum(FTy.Tag);
    if h.get(ty)[].tag != .Func {
        it := h.get(i);
        @err_assert(!@is(it.segment, .Code, .MachineCode), "function value '%' must have function type", h.get(it.name)) return;
        return(Ok = .None);
    };
    
    fid := @try(sema_frc_import_fid(self, module, i)) return;
    (Ok = (Some = fid))
}

fn get_sym(import: *FrcImport) One(Sym) = {
    @debug_assert_eq(import.table, SYM_TABLE);
    (off = import.index)
}
