//! There are two contexts for compile-time execution in this language. 
//! - fill_driver_vtable: The driver program where you're logically aware of the outside world and might have multiple compiler instances doing different things. 
//! - fill_export_ffi: Within the program like '::' expressions and macros, where you're only aware of the current compiler instance. 
//! In the latter, you don't manually pass the compiler context pointer to every function. 
//! These corrispond to Zig's build.zig vs comptime and Rust's build.rs vs proc-macros/const-fns. 

fn fill_driver_vtable(vtable: *ImportVTable) void = {
    vtable.add_file = add_file;
    vtable.parse_stmts = parse_stmts;
    vtable.intern_string = intern_string;
    vtable.get_string = get_string;
    vtable.emit_llvm = emit_llvm; // TODO: have a compile option to not include the things you don't need for bootstrapping. so i can commit a smaller blob. 
}

CompilerRs :: ***SelfHosted;  // TODO: really this should be a new type so you can't accidently implement call functions by just adding extra indirection. hopefully the number of pointers makes it clear something's weird. 
fn cast(c: Compiler) CompilerRs #unsafe_noop_cast;
fn cast(c: CompilerRs) Compiler #unsafe_noop_cast;

fn add_file(c: Compiler, name: Str, content: Str) Span = {
    c := c.cast();
    c.codemap.add_file(name, content)
}

fn parse_stmts(c: Compiler, f: *Span) Result(Slice(FatStmt), ParseErr) = {
    c := c.cast();
    source := c.codemap.source_slice(f[]);
    id := c.parser.push_parse(source, f[]);
    stmts := @try(c.parser.finish_pending_stmts(id)) return; // TODO: don't return RsVec -- Jun 29
    (Ok = stmts.items())
}

fn intern_string(c: Compiler, s: Str) Symbol = {
    c := c.cast();
    c.pool.insert_owned(s)
}

fn get_string(c: Compiler, s: Symbol) Str = {
    c := c.cast();
    c.pool.get(s)
}

// TODO: this is only called in the compiler. because of the annoying two types for compiler data pointer. 
fn get_baked(c: Compiler, id: BakedVarId) BakedVar = {
    val := c.cast()[][].get_baked(id); 
    val._1
}

/////////////////////////////////////////////////////////////////////////////////

fn fill_export_ffi(out: *List(u8)) void = {
    // TODO: fix error message if you forget a semi-colon in the string. 
    @fmt(out, "fn lookup_baked(addr: i64) ?BakedVarId #ct #comptime_addr(%);\n", lookup_baked);
    lookup_baked: rawptr : fn(c: CompilerRs, addr: i64) ?BakedVarId = c.baked.lookup&.get(addr);
    
    @fmt(out, "fn cache_baked(addr: i64, id: BakedVarId) ?BakedVarId #ct #comptime_addr(%);\n", cache_baked);
    cache_baked: rawptr : fn(c: CompilerRs, addr: i64, id: BakedVarId) void = {
        c.baked.lookup&.insert(addr, id); // TODO: error if collide? 
    };
    
    @fmt(out, "fn dyn_bake_relocatable_value(raw_bytes: Slice(u8), ty: Type, force_default_handling: bool) Slice(BakedEntry) #ct #comptime_addr(%);\n", dyn_bake_value);
    dyn_bake_value: rawptr : fn(c: CompilerRs, bytes: Slice(u8), ty: Type, force_default_handling: bool) Slice(BakedEntry) = {
        r := c.emit_relocatable_constant_body(bytes, ty, force_default_handling); // TODO: sad extra binding forces it to instantiate the type. 
        r.unwrap()
    };
    
    // TODO: remove compiler_builtin_transform_callsite and just use these? it feels a bit sad to add the extra indirection tho. 
    @fmt(out, "fn if(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", node_macro(.if));
    @fmt(out, "fn slice(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", node_macro(.slice));
    // TODO: make uninitialized one of these. 
    
    fn node_macro($name: Flag) rawptr = 
        (fn(c: CompilerRs, e: FatExpr) FatExpr = {
            out := c[][].get_alloc().alloc(FatExpr, 1);
            out.ptr[] = e;
            (expr = (SuffixMacro = (name = name.ident(), arg = out.ptr)), loc = e.loc, ty = UnknownType, done = false)
        });
    
    @fmt(out, "fn operator_star_prefix(T: Type) Type #fold #ct #comptime_addr(%);\n", ptr);
    ptr: rawptr : fn(c: Compiler, inner: Type) Type = {
        {c.vtable.intern_type}(c, (Ptr = inner))
    };
    @fmt(out, "fn Label(Ret: Type) Type #fold #ct #comptime_addr(%);\n", label);
    label: rawptr : fn(c: Compiler, inner: Type) Type = {
        {c.vtable.intern_type}(c, (Label = inner))
    };
    
    // These only exist for debugging the compiler when everything's broken so can't even compile the one defined in the language.
    @fmt(out, "fn debug_log_int(i: i64) void #comptime_addr(%);\n", @as(rawptr) :: (fn(i: i64) void = println(i)));
    @fmt(out, "fn debug_log_str(i: Str) void #comptime_addr(%);\n", @as(rawptr) :: (fn(i: Str) void = println(i)));
    
    @fmt(out, "fn str(i: Symbol) Str #ct #fold #comptime_addr(%);\n", str);
    str: rawptr : fn(c: CompilerRs, i: Symbol) Str = {
        c.pool.get(i)
    };
    
    @fmt(out, "fn sym(i: Str) Symbol #ct #fold #comptime_addr(%);\n", sym);
    sym: rawptr : fn(c: CompilerRs, i: Str) Symbol = {
        c.pool.insert_owned(i)
    };
    
    @fmt(out, "fn get_comptime_environment() *ComptimeEnvironment #ct #comptime_addr(%);\n", env);
    env: rawptr : fn(c: CompilerRs) *ComptimeEnvironment = {
        c[][].env
    };
    
    @fmt(out, "fn by_the_way_you_are_compiling_the_compiler_right_now_just_a_helpful_hint() void #ct #comptime_addr(%);\n", note);
    note: rawptr : fn(c: CompilerRs) void = {
        // This just gives a place to assert we haven't got any weird feature flags turned on while porting stuff over from rust. 
        // It gets a bit scary if the first thing you try to compile is accidentally the compiler so if it miscompiles you're fucked now. 
        // It's philosophically important that we don't actually change behaviour based on this information tho. 
    };
    
    @fmt(out, "fn compile_error(msg: Str, loc: Span) Never #ct #comptime_addr(%);\n", report_err);
    report_err: rawptr : fn(c: CompilerRs, msg: Str, loc: Span) Never = {
        // TODO: command line arg to show more context? 
        println("=== ERROR ===");
        println(msg);
        c[][].codemap.show_error_line(loc);
        panic("Comptime reported error.")
    };
    
    // TODO: this should work but "unsafe precondition violated". -- Jul 6
    //@fmt(out, "fn ast_alloc() Alloc #ct #comptime_addr(%);\n", the_allloc);
    //the_allloc: rawptr : fn(c: CompilerRs) Alloc = {
    //    c[][].get_alloc()
    //};
    
    // TODO: version of this that allows caching? but have to think more about when you're allowed to deduplicate.
    @fmt(out, "fn bake_value(v: BakedVar) BakedVarId #ct #comptime_addr(%);\n", bake_var);
    bake_var: rawptr : fn(c: CompilerRs, v: BakedVar) BakedVarId = {
        c[][].put_baked(v, .None)
    };
}

//////////////////////////////////////////////////////////////////////////////
// these are just stupid helpers to deal with the awquard multiple compiler types for calling into the rust code. 

fn check_for_new_aot_bake_overloads(comp: CompilerRs) CRes(void) = {
    {comp[][].vtable.check_for_new_aot_bake_overloads}(comp.cast())
}

fn index(comp: CompilerRs, f: FuncId) *Func = {
    {comp[][].vtable.get_function}(comp.cast(), f)
}

fn slot_count(c: CompilerRs, ty: Type) u16 = {
    info := c.get_info(ty);
    info.size_slots
}

fn raw_type(c: CompilerRs, ty: Type) Type = {
    loop {|
        @match(c.get_type(ty)) {
            fn Named(f) => {
                ty = f._0;
            }
            fn Enum(f) => {
                ty = f.raw;
            }
            @default => {
                return(ty);
            };
        };
    };
    ty
}

fn unptr_ty(c: CompilerRs, ty: Type) ?Type = {
    @match(c.get_type(ty)) {
        fn Ptr(inner) => (Some = inner[]);
        @default => .None; // TODO: do i need to raw_type? 
    }
}



///////////////////
// TODO: should these go somewhere else? they used to be in ast.rs

fn finished_ty(self: *Func) ?FnType = {
    if self.finished_arg { arg |
        if self.finished_ret { ret |
            return(Some = (arg = arg, ret = ret, arity = @as(u16) self.arg.bindings.len().max(1).trunc()));
        };
    };
    .None
}

