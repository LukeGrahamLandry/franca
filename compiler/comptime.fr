fn fill_self_hosted(vtable: *ImportVTable) void = {
    vtable.add_file = add_file;
    vtable.parse_stmts = parse_stmts;
    vtable.intern_string = intern_string;
    vtable.get_string = get_string;
    vtable.emit_llvm = emit_llvm; // TODO: have a compile option to not include the things you don't need for bootstrapping. so i can commit a smaller blob. 
}

CompilerRs :: ***SelfHosted;  // TODO: really this should be a new type so you can't accidently implement call functions by just adding extra indirection. hopefully the number of pointers makes it clear something's weird. 
fn cast(c: Compiler) CompilerRs #unsafe_noop_cast;
fn cast(c: CompilerRs) Compiler #unsafe_noop_cast;

fn add_file(c: Compiler, name: Str, content: Str) Span = {
    c := c.cast();
    c.codemap.add_file(name, content)
}

fn parse_stmts(c: Compiler, f: *Span) Result(Slice(FatStmt), ParseErr) = {
    c := c.cast();
    source := c.codemap.source_slice(f[]);
    id := c.parser.push_parse(source, f[]);
    stmts := @try(c.parser.finish_pending_stmts(id)) return; // TODO: don't return RsVec -- Jun 29
    (Ok = stmts.items())
}

fn intern_string(c: Compiler, s: Str) Symbol = {
    c := c.cast();
    c.pool.insert_owned(s)
}

fn get_string(c: Compiler, s: Symbol) Str = {
    c := c.cast();
    c.pool.get(s)
}

// TODO: this is only called in the compiler. because of the annoying two types for compiler data pointer. 
fn get_baked(c: Compiler, id: BakedVarId) BakedVar = {
    val := c.cast()[][].get_baked(id); 
    val._1
}

//////////////////////////////////////////////////////////////////////

fn fill_export_ffi(out: *List(u8)) void = {
    // TODO: fix error message if you forget a semi-colon in the string. 
    @fmt(out, "fn lookup_baked(addr: i64) ?BakedVarId #ct #comptime_addr(%);\n", lookup_baked);
    lookup_baked: rawptr : fn(c: CompilerRs, addr: i64) ?BakedVarId = c.baked.lookup&.get(addr);
    
    @fmt(out, "fn cache_baked(addr: i64, id: BakedVarId) ?BakedVarId #ct #comptime_addr(%);\n", cache_baked);
    cache_baked: rawptr : fn(c: CompilerRs, addr: i64, id: BakedVarId) void = {
        c.baked.lookup&.insert(addr, id); // TODO: error if collide? 
    };
}


