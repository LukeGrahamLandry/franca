//! There are two contexts for compile-time execution in this language. 
//! - fill_driver_vtable: The driver program where you're logically aware of the outside world and might have multiple compiler instances doing different things. 
//! - fill_export_ffi: Within the program like '::' expressions and macros, where you're only aware of the current compiler instance. 
//! In the latter, you don't manually pass the compiler context pointer to every function. 
//! These corrispond to Zig's build.zig vs comptime and Rust's build.rs vs proc-macros/const-fns. 

fn fill_driver_vtable(vtable: *ImportVTable) void = {
    vtable.add_file = add_file;
    vtable.parse_stmts = parse_stmts;
    vtable.intern_string = intern_string;
    vtable.get_string = get_string;
    vtable.emit_llvm = emit_llvm; // TODO: have a compile option to not include the things you don't need for bootstrapping. so i can commit a smaller blob. 
    vtable.get_fns_with_tag = get_fns_with_tag;
    vtable.get_function = fn(c: Compiler, f: FuncId) *Func = {
        c.cast()[][].get_function(f)
    };
    @if(ENABLE_QBE_BACKEND) {
        vtable.emit_qbe = emit_qbe; // TODO: have a compile option to not include the things you don't need for bootstrapping. so i can commit a smaller blob. 
    };
}

CompilerRs :: ***SelfHosted;  // TODO: really this should be a new type so you can't accidently implement call functions by just adding extra indirection. hopefully the number of pointers makes it clear something's weird. 
fn cast(c: Compiler) CompilerRs #unsafe_noop_cast;
fn cast(c: CompilerRs) Compiler #unsafe_noop_cast;

fn add_file(c: Compiler, name: Str, content: Str) Span = {
    c := c.cast();
    c.codemap.add_file(name, content)
}

fn parse_stmts(c: Compiler, f: *Span) Result(Slice(FatStmt), ParseErr) = {
    c := c.cast();
    source := c.codemap.source_slice(f[]);
    id := c.parser.push_parse(source, f[]);
    stmts := @try(c.parser.finish_pending_stmts(id)) return; // TODO: don't return RsVec -- Jun 29
    (Ok = stmts.items())
}

fn intern_string(c: Compiler, s: Str) Symbol = {
    c := c.cast();
    c.pool.insert_owned(s)
}

fn get_string(c: Compiler, s: Symbol) Str = {
    c := c.cast();
    c.pool.get(s)
}

// TODO: this is only called in the compiler. because of the annoying two types for compiler data pointer. 
fn get_baked(c: Compiler, id: BakedVarId) BakedVar = {
    val := c.cast()[][].get_baked(id); 
    val._1
}

fn get_fns_with_tag(c: Compiler, tag: Symbol) [] FuncId = {
    c := c.cast();
    found: List(FuncId) = list(temp());
    i: u32 = 0;
    each c.functions& { func |
        continue :: local_return;
        // TODO: defer { i += 1; };
        if(!func.get_flag(.NotEvilUninit), => { i += 1; continue() });
        each func.annotations { a |
            if a.name == tag {|
                found&.push(funcid_from_index(i));
                i += 1; 
                continue();
            };
        };
        i += 1; 
    };
    found.items()
}

/////////////////////////////////////////////////////////////////////////////////

fn fill_export_ffi(out: *List(u8)) void = {
    // TODO: fix error message if you forget a semi-colon in the string. 
    @fmt(out, "fn lookup_baked(addr: i64) ?BakedVarId #ct #comptime_addr(%);\n", lookup_baked);
    lookup_baked: rawptr : fn(c: CompilerRs, addr: i64) ?BakedVarId = c.baked.lookup&.get(addr);
    
    @fmt(out, "fn cache_baked(addr: i64, id: BakedVarId) ?BakedVarId #ct #comptime_addr(%);\n", cache_baked);
    cache_baked: rawptr : fn(c: CompilerRs, addr: i64, id: BakedVarId) void = {
        c.baked.lookup&.insert(addr, id); // TODO: error if collide? 
    };
    
    @fmt(out, "fn dyn_bake_relocatable_value(raw_bytes: Slice(u8), ty: Type, force_default_handling: bool) Slice(BakedEntry) #ct #comptime_addr(%);\n", dyn_bake_value);
    dyn_bake_value: rawptr : fn(c: CompilerRs, bytes: Slice(u8), ty: Type, force_default_handling: bool) Slice(BakedEntry) = {
        r := c[][].emit_relocatable_constant_body(bytes, ty, force_default_handling); // TODO: sad extra binding forces it to instantiate the type. 
        r.unwrap()
    };
    
    @fmt(out, "fn if(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", if_node);
    if_node: rawptr : fn(c: CompilerRs, e: FatExpr) FatExpr = {
        assert(e.expr&.is(.Tuple), "@if expected tuple");
        parts := e.expr.Tuple&;
        (expr = (If = (cond = parts.index(0), if_true = parts.index(1), if_false = parts.index(2))), loc = e.loc, ty = UnknownType, done = false)
    };
    @fmt(out, "fn slice(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", slice_node);
    slice_node: rawptr : fn(c: CompilerRs, e: FatExpr) FatExpr = {
        e := c[][].box(e);
        (expr = (Slice = e), loc = e.loc, ty = UnknownType, done = false)
    };
    @fmt(out, "fn _uninitialized(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", uninit_node);
    uninit_node: rawptr : fn(c: CompilerRs, e: FatExpr) FatExpr = {
        (expr = .Uninitialized, loc = e.loc, ty = UnknownType, done = false)
    };
    @fmt(out, "fn loop(e: FatExpr) FatExpr #macro #ct #comptime_addr(%);\n", loop_node);
    loop_node: rawptr : fn(c: CompilerRs, e: FatExpr) FatExpr = {
        e := c[][].box(e);
        (expr = (Loop = e), loc = e.loc, ty = UnknownType, done = false)
    };
    
    @fmt(out, "fn operator_star_prefix(T: Type) Type #fold #ct #comptime_addr(%);\n", ptr);
    ptr: rawptr : fn(c: Compiler, inner: Type) Type = {
        c.cast()[][].intern_type((Ptr = inner))
    };
    @fmt(out, "fn Label(Ret: Type) Type #fold #ct #comptime_addr(%);\n", label);
    label: rawptr : fn(c: Compiler, inner: Type) Type = {
        c.cast()[][].intern_type(Label = inner)
    };
    
    // These only exist for debugging the compiler when everything's broken so can't even compile the one defined in the language.
    @fmt(out, "fn debug_log_int(i: i64) void #comptime_addr(%);\n", @as(rawptr) :: (fn(i: i64) void = println(i)));
    @fmt(out, "fn debug_log_str(i: Str) void #comptime_addr(%);\n", @as(rawptr) :: (fn(i: Str) void = println(i)));
    
    @fmt(out, "fn str(i: Symbol) Str #ct #fold #comptime_addr(%);\n", str);
    str: rawptr : fn(c: CompilerRs, i: Symbol) Str = {
        c.pool.get(i)
    };
    
    @fmt(out, "fn sym(i: Str) Symbol #ct #fold #comptime_addr(%);\n", sym);
    sym: rawptr : fn(c: CompilerRs, i: Str) Symbol = {
        c.pool.insert_owned(i)
    };
    
    @fmt(out, "fn get_comptime_environment() *ComptimeEnvironment #ct #comptime_addr(%);\n", env);
    env: rawptr : fn(c: CompilerRs) *ComptimeEnvironment = {
        c[][].env
    };
    
    @fmt(out, "fn by_the_way_you_are_compiling_the_compiler_right_now_just_a_helpful_hint() void #ct #comptime_addr(%);\n", note);
    note: rawptr : fn(c: CompilerRs) void = {
        // This just gives a place to assert we haven't got any weird feature flags turned on while porting stuff over from rust. 
        // It gets a bit scary if the first thing you try to compile is accidentally the compiler so if it miscompiles you're fucked now. 
        // It's philosophically important that we don't actually change behaviour based on this information tho.
        assert(!INCLUDE_NEW_SEMA, "INCLUDE_NEW_SEMA"); 
    };
    
    @fmt(out, "fn compile_error(msg: Str, loc: Span) Never #ct #comptime_addr(%);\n", report_err);
    report_err: rawptr : fn(c: CompilerRs, msg: Str, loc: Span) Never = {
        // TODO: command line arg to show more context? 
        println("=== ERROR ===");
        println(msg);
        c[][].codemap.show_error_line(loc);
        panic("Comptime reported error.")
    };
    
    // TODO: this should work but "unsafe precondition violated". -- Jul 6
    //@fmt(out, "fn ast_alloc() Alloc #ct #comptime_addr(%);\n", the_allloc);
    //the_allloc: rawptr : fn(c: CompilerRs) Alloc = {
    //    c[][].get_alloc()
    //};
    
    // TODO: version of this that allows caching? but have to think more about when you're allowed to deduplicate.
    @fmt(out, "fn bake_value(v: BakedVar) BakedVarId #ct #comptime_addr(%);\n", bake_var);
    bake_var: rawptr : fn(c: CompilerRs, v: BakedVar) BakedVarId = {
        c[][].put_baked(v, .None)
    };
    
    // Generated for @BITS to bootstrap encoding for inline asm.
    @fmt(out, "fn __shift_or_slice(ints: Slice(i64)) u32 #no_tail #fold #comptime_addr(%);\n", shift_or_slice);
    shift_or_slice: rawptr : fn(ints: []i64) u32 = {
        //::display_slice(i64);
        //@println("%", ints);
        @assert(ints.len < 32, "% is too many args for fold_shift_or", ints.len);
        acc := 0;
        range(0, ints.len / 3) { i |
            //@print("% ", acc); // :debug
            x := ints[i * 3];
            sh := ints[i * 3 + 1];
            size_info := ints[i * 3 + 2]; // HACK. masking fixed maual_mmap. u16 has garabge memory where read as u64.
            bit_count := size_info.abs();
            is_signed := size_info < 0;
            if is_signed {|
                x = signed_truncate(x, bit_count).zext();
            };
            @assert(sh < 32, "% too much shift", sh);
            //@assert(x.shift_left(sh) <= 1.shift_left(32), "% << %", x, sh);
            mask := 1.shift_left(bit_count) - 1;
            acc = acc.bit_or(x.bit_and(mask).shift_left(sh));
        };
        //@println("%", acc); // :debug
        @assert(acc > 0 && acc <= MAX_u32.zext(), "% is not a valid u32", acc);
        acc.trunc()
    };
 
    
    @fmt(out, "fn number_of_functions() i64 #ct #comptime_addr(%);\n", num_f);
    num_f: rawptr : fn(c: CompilerRs) i64 = {
        c.functions.len
    };
    
    @fmt(out, "fn safety_check_enabled(check: SafetyCheck) bool #ct #comptime_addr(%);\n", safe);
    safe: rawptr : fn(c: CompilerRs, check: SafetyCheck) bool = {
        build_options := BuildOptions.ptr_from_raw(c.env.build_options);
        if(check.raw() >= build_options.safety_checks&.len(), => return(true)); // allow adding new safety checks and then bootstrapping. 
        build_options.safety_checks&.index(check)[]
    }
}

//////////////////////////////////////////////////////////////////////////////
// these are just stupid helpers to deal with the awquard multiple compiler types for calling into the rust code. 

fn check_for_new_aot_bake_overloads(comp: CompilerRs) CRes(void) = {
    {comp[][].vtable.check_for_new_aot_bake_overloads}(comp.cast())
}

fn index(comp: CompilerRs, f: FuncId) *Func = {
    comp[][].get_function(f)
}
