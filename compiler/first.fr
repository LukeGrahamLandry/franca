#include_std("core.fr"); // TODO: handle adding these here. 
#include_std("main.fr");

// TODO: this whole thing where you have to write your program inside out is really annoying. 
//       I want the user program to be in charge and call into the compiler as a library. 
UserData :: @struct(
    vtable: *ImportVTable,
);

resolve_comptime_import :: fn(userdata: rawptr, c: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = {
    userdata := UserData.ptr_from_raw(userdata);
    // TODO: can't call @println here??
    println("Asked for a function");
    .None
};

// TODO: less ass field lookup and call syntax
// TODO: compiler needs to check type / find right overload of this function. 
fn driver(vtable: *ImportVTable) void #export = {
    s :: @symbol("Hello World").c_str();
    println("Hello World");
    println(s);
    
    args := cli_args();
    for(args){ arg |
        @println("- %", arg);
    };
    
    src := temp().read_to_string("main.fr");
    comp := vtable.new_with_src(src.items(), .Aarch64);
    my_vtable: ExportVTable = (
        resolve_comptime_import = (Some = resolve_comptime_import!fn_ptr),
    );
    data: UserData = (vtable = vtable);

    {vtable.give_vtable}(comp, my_vtable&, UserData.raw_from_ptr(data&));
    
    c := vtable.with(comp);
    tests := c.get_tagged("test");

    for(tests) {fid|
        ptr := c.get_jitted(fid);
        f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
        f();
    };
    println(tests.len);
    
    
    ir_text := emit_llvm(c, temp(), tests, .TestRunnerMain);
    test_exe := "target/tests.exe";
    build_llvm(ir_text, ("-o", test_exe)!slice);
    success := run_cmd_blocking(test_exe, empty());
    assert(success, "tests failed");
    
    
    tests := c.get_tagged("compiler");
    
    
    ir_text := emit_llvm(c, temp(), tests, .ExportWithNames);
    test_exe := "target/tests.exe";
    build_llvm(ir_text, ("-o", "target/libfranca.o", "-c")!slice);
    success := run_cmd_blocking("/usr/bin/ar", ("rc", "target/libfranca.a", "target/libfranca.o")!slice);
    assert(success, "link failed");
    
    
    save_exports_as_dylib(vtable);
}

// TODO: return result
fn build_llvm(ir: BucketArray(u8), args: Slice(Str)) void = {
    out := open_temp_file();
    for(ir&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());   
    args: List(Str) = args.clone(temp());
    args&.push("-x"); // don't check the file extension of source files that follow. 
    args&.push("ir"); 
    args&.push(out&.s_name());
    @println("%", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "ICE: generated invalid llvm ir");
    out.remove();
}

fn save_exports_as_dylib(vtable: *ImportVTable) void = {
    driver_src := temp().read_to_string("first.fr");
    comp := vtable.new_with_src(driver_src.items(), .Aarch64);
    c := vtable.with(comp);
    exports := c.get_tagged("export");
    
    ir := c.emit_llvm(temp(), exports, .ExportWithNames);
    
    // Note: remember to truncate if you stop using a temp file!
    file := open_temp_file();
    for (ir&) { bucket |
        file.fd&.write(bucket);
        //println(bucket);
    };
    
    args: List(Str) = list(temp());
    args&.push("-dynamiclib");
    args&.push("-o");
    args&.push("target/build_compiler.dylib");
    //args&.push("-Os");
    
    // don't check the file extension of source files that follow. 
    args&.push("-x"); 
    args&.push("ir"); 
    args&.push(file&.s_name());
    @println("%", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "ICE: generated invalid llvm ir");
    file.remove();
}

::display_slice(Str);