DO_TESTS :: false;

ENABLE_TRACY_ :: false;
ENABLE_LSP_   :: false;
ENABLE_QBE_BACKEND_ :: false; // TODO: error message if you try to use when disabled instead of just calling a null function pointer. 
REPLACE_COMPILER :: false;
 
fn load_src(vtable: *ImportVTable, include_cranelift: bool) Ty(CompCtx, *ComptimeLibs) = {
    src := temp().read_to_string("compiler/main.fr");
    @fmt(src&, ";ENABLE_TRACY :: %;\n", ENABLE_TRACY_);
    @fmt(src&, ";ENABLE_LSP   :: %;\n", ENABLE_LSP_);
    @fmt(src&, ";ENABLE_QBE_BACKEND :: %;\n", ENABLE_QBE_BACKEND_);
    @fmt(src&, ";ENABLE_LOGGING_CALLBACKS :: false;\n");
    @fmt(src&, ";DO_TERMINAL_COLOURS :: true;\n");
    @fmt(src&, ";INCLUDE_COMPTIME_CRANELIFT :: %;\n", include_cranelift);
    
    opts := vtable.default_build_options();
    opts.deduplicate_bytecode = true;
    opts.retain_function_names = false;
    opts.debug_info = false;
    spam := false;
    args := cli_args();
    for args { extra |
        if extra.str() == "-no-deduplication" {
            opts.deduplicate_bytecode = false;
        };
        if extra.str() == "-keep-names" {
            opts.retain_function_names = true;
        };
        if extra.str() == "-debug-info" {
            opts.debug_info = true;
        };
        if extra.str() == "-spam" {
            spam = true;
        };
        if extra.str() == "-x86" {
            // you don't need this just to target x86, only when running on it. 
            // opts.comptime_jit = .Cranelift;
        };
    };
    @fmt(src&, ";DEBUG_SPAM_LOG :: %;\n", spam);
    
    comp := vtable.new_with_src(src.items(), opts);
    c := vtable.with(comp);
    
    libs := c.empty_libs();
    libs := temp().boxed(ComptimeLibs, libs);
    libs.intercept_imports();
    if(ENABLE_TRACY_, => libs.add_lib(tracy_lib));
    if(ENABLE_LSP_, => libs.add_lib(wuffs_lib));
    
    // TODO: but we're not there yet as a society 
    //exports := c.get_tagged("export_builtin_ct");

    (c, libs)
}

// TODO: less ass field lookup and call syntax
// TODO: compiler needs to check type / find right overload of this function. 
// TODO: allow runtime #import without building the dylib if not needed at comptime. 
fn driver(vtable: *ImportVTable) void = {
    //driver_lsp_entry(vtable);
    
    if !file_exists("compiler/main.fr") {
        panic("Working directory must be top level of the franca repository");
    };
    start := timestamp();
    
    do_build := true;
    do_replace := false;
    args := cli_args();
    use_new_entry_point := false;
    x86 := false;
    arch := Arch.Aarch64;
    include_cranelift := false;
    for args { arg |
        if arg.str() == "-no-build" {
            do_build = false;
        };
        if arg.str() == "-replace-compiler" {
            do_replace = true;
        };
        if arg.str() == "-v2" {
            use_new_entry_point = true;
        };
        if arg.str() == "-x86" {
            x86 = true;
            arch = .X86_64;
        };
        if arg.str() == "-include-cranelift" {
            include_cranelift = true;
        };
    };
    c, libs := load_src(vtable, include_cranelift);
    
    ::if([]FuncId);
    exports: []FuncId = if use_new_entry_point {
        new_main := c.get_unique_named("main").unwrap();
        (@list(new_main) temp()).items()
    } else {
        c.get_tagged("compiler")
    };
    
    ir_text := {c.vtable.emit_llvm}(c, temp(), exports, .ExportWithNames, arch);
    @println("Emitted % bytes of llvm ir.", ir_text.len);  // useful to see when i start trying to deduplicate bytecode. 
    end := timestamp();
    if !DO_TESTS {
        // TODO: don't print it if we didn't have cached dependencies. 
        @println("Frontend time: % ms.", end.sub(start)); 
    };
    
    if false {
        build_with_qbe(c, exports);
    };
    fn build_with_qbe(c: CompCtx, exports: []FuncId) void = {
        QBE_PATH :: "/Users/luke/Documents/mods/infered/bindings/qbe/qbe";
        // `/usr/bin/gcc` isn't actually gcc for me, its an older clang but its 25% faster than what i have thats called clang
        // real gcc is 6% faster again than that. 
        ASSEMBLER_PATH :: "/opt/homebrew/Cellar/gcc/14.1.0_2/bin/gcc-14"; 
        ir_text := {c.vtable.emit_qbe}(c, temp(), exports, .ExportWithNames);
        // TODO: clean up this hack for inline asm
        ::?List(u8);
        inline_asm_functions := ir_text&.pop_current_bucket().unwrap();

        ir_out := open_temp_file();
        for(ir_text&){bucket|
            ir_out.fd&.write(bucket).unwrap();
        };
        @println("Write qbe ir to %", ir_out&.s_name());
        
        start := timestamp();
        args: List(Str) = list(temp());
        args&.push("-o");
        args&.push(asm_out);
        args&.push(ir_out&.s_name());
        success := run_cmd_blocking(QBE_PATH, args.items()); 
        @assert(success, "qbe failed");
        end := timestamp();
        @println("QBE time: % ms.", end.sub(start)); 
        
        asm_out :: "target/franca_test_temp.s"; // TODO: the version of tmp file that lets you have an extension because it wants the .s
        append_to_file(asm_out, inline_asm_functions.items());
        // TOdO: pass the right mode in write_entire_file or this has to exist first
        //
        start := timestamp();
        args: List(Str) = list(temp());
        args&.clear();
        args&.push(asm_out);
        args&.push("-o");
        args&.push("target/franca/libfranca_qbe.o");
        args&.push("-c");
        println("Run assembler");
        success := run_cmd_blocking(ASSEMBLER_PATH, args.items()); 
        assert(success, "as failed");
        end := timestamp();
        @println("ASM time: % ms.", end.sub(start)); 
        
        run_cmd_blocking("/usr/bin/ar", @slice (
            "rc", "target/franca/libfranca_qbe.a", "target/franca/libfranca_qbe.o"
        )).assert("link failed");
        
        //args := libs.get_aot_objects();
        args: List(Str) = list(temp());
        args&.push_all(@slice("target/release/libfranca.a", "target/franca/libfranca_qbe.o", "-o", "target/release/franca_qbe"));
        run_cmd_blocking("clang", args.items()).assert("link failed");
    };
    
    fn fmt_str(fmt_args: FatExpr) FatExpr #macro = @{
        (@format(@[fmt_args]) temp()).items()
    };
    
    arch_path := if(x86, => "x86_64-apple-darwin", => "aarch64-apple-darwin");
    out_dir := @fmt_str("target/franca/%", arch_path);
    
    if do_build {
        if use_new_entry_point {| // note: exits!
            start := timestamp();
            args := clone(@slice ("-o", @fmt_str("%/franca2.o", out_dir), "-c", "-Os", "-g"), temp());
            if x86 {
                args&.push_all(@slice("-target", "x86_64-apple-darwin"));
            };
            build_llvm(ir_text, args.items());  // "-mllvm", "-hot-cold-split=true",
            end := timestamp();
            @println("LLVM time: % ms.", end.sub(start));
            args := clone(@slice ("-o", @fmt_str("%/franca2", out_dir), @fmt_str("%/franca2.o", out_dir)), temp());
            if include_cranelift {
                cl_path := if(x86, 
                    => "crates/comptime_cranelift/target/x86_64-apple-darwin/release/libcomptime_cranelift.a", 
                    => "crates/comptime_cranelift/target/release/libcomptime_cranelift.a");
                args&.push(cl_path);
                if x86 {
                    args&.push_all(@slice("-target", "x86_64-apple-darwin"));
                };
            };
            run_cmd_blocking("clang", args.items()).assert("link failed");
            exit(0);
        };
        
        start := timestamp();
        args := clone(@slice ("-o", @fmt_str("%/libselffranca.o", out_dir), "-c", "-Os"), temp());
        
        if x86 {
            args&.push_all(@slice("-target", "x86_64-apple-darwin"));
        };
        build_llvm(ir_text, args.items());
        end := timestamp();
        @println("LLVM time: % ms.", end.sub(start)); 
        
        // build.rs needs this if it wants to build the binary (it won't take a .o file)
        run_cmd_blocking("/usr/bin/ar", @slice (
            "rc", @fmt_str("%/libselffranca.a", out_dir), @fmt_str("%/libselffranca.o", out_dir)
        )).assert("link failed");
        
        // to use tracy, we need to use clang to build the binary so it can find libc++,
        // so we need to have the rust code as a .a file. 
        // TODO: is my fucking with the target dir confusing its incremental?
        //run_cmd_blocking("/Users/luke/.cargo/bin/cargo", @slice (
        //    "build", "--release", "--lib",
        //)).assert("cargo failed");
        // node: this makes a much much larger binary than if cargo does it. 
        //       i suspect im linking in the whole rust std or something? 
        args := libs.get_aot_objects();
        // TODO: should output then move cause i think it deletes if it fails. and save the old one for a bit cause its scary. 
        if do_replace {
            compiler_exe_path := @fmt_str("%/franca", out_dir);
            save_temp_file := open_temp_file();
            rust_path := if(x86, => "target/x86_64-apple-darwin/release/libfranca.a", => "target/release/libfranca.a");
            rename(compiler_exe_path.maybe_borrow_cstr(temp()), save_temp_file&.c_name());
            @println("Replacing your compiler at '%' with the new one. \nThe old one was saved at '%' (NOTE: THATS A TEMP FILE!)", compiler_exe_path, save_temp_file&.s_name());
            args&.push_all(@slice(rust_path, @fmt_str("%/libselffranca.o", out_dir), "-o", compiler_exe_path, "-g"));
            if x86 {
                args&.push_all(@slice("-target", "x86_64-apple-darwin"));
            };
            if include_cranelift {
                cl_path := if(x86, 
                    => "crates/comptime_cranelift/target/x86_64-apple-darwin/release/libcomptime_cranelift.a", 
                    => "crates/comptime_cranelift/target/release/libcomptime_cranelift.a");
                args&.push(cl_path);
            };
            @println("%", args.items());
            run_cmd_blocking(CLANG_PATH, args.items()).assert("link failed");
        } else {
            println("SKIPPED REPLACING COMPILER");
        };
    } else {
        println("SKIPPED RUNNING LLVM");
    };
    
    //render_dependencies(c, exports);
    
    //build_llvm(ir_text, @slice ("-o", "target/libfranca.o", "-c", "-target", "x86_64-apple-darwin")); // "-O2"
    //success := run_cmd_blocking("/usr/bin/ar", @slice ("rc", "target/x86_64-apple-darwin/libfranca.a", "target/libfranca.o"));
    //assert(success, "link failed");
}

fn render_dependencies(c: CompCtx, fns: []FuncId) void = {
    out: List(u8) = list(temp());
    out&.push_all("digraph {\n");
    pending: List(FuncId) = list(temp());
    pending&.push_all(fns);
    done: BitSet = empty();
    
    while => !pending.is_empty() {
        continue :: local_return;
        f := pending&.pop().unwrap();
        if done&.get(f.to_index().zext()) {
            continue();
        };
        done&.set(f.to_index().zext(), temp());
        
        func := {c.vtable.get_function}(c.data, f);
        real_name := {c.vtable.get_string}(c.data, func.name);
        @fmt(out&, "% [label = \"%\"]\n", f.to_index(), real_name);
        @println("[%: %]", f.to_index(), real_name);
        for func.mutual_callees { cc |
            pending&.push(cc);
            @fmt(out&, "% -> %\n", f.to_index(), cc.to_index());
            func := {c.vtable.get_function}(c.data, cc);
            @println("  - %: %", cc.to_index(), {c.vtable.get_string}(c.data, func.name));
        };
        for func.callees { cc |
            pending&.push(cc);
            @fmt(out&, "% -> %\n", f.to_index(), cc.to_index());
            func := {c.vtable.get_function}(c.data, cc);
            @println("  - %: %", cc.to_index(), {c.vtable.get_string}(c.data, func.name));
        };
    };
    out&.push_all("}");
    
    path := "callgraph.dot".maybe_borrow_cstr(temp());
    remove(path);
    s := out.items();
    flag := (@as(i64) OpenFlag.Write).bit_or(@as(i64) OpenFlag.Create);
    fd := open(path, flag).unwrap();
    write(fd, s.ptr, s.len).unwrap();
    fd.close();
}

// TODO: return result
fn build_llvm(ir: BucketArray(u8), args: Slice(Str)) void = {
    out := open_temp_file();
    for(ir&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());   
    args: List(Str) = args.clone(temp());
    args&.push("-x"); // don't check the file extension of source files that follow. 
    args&.push("ir"); 
    args&.push("-g"); 
    args&.push(out&.s_name());
    @println("%", args.items());
    success := run_cmd_blocking("clang", args.items());
    assert(success, "ICE: generated invalid llvm ir");
    
    // i really hope this changes every time just because i iterate over rust hashtables somewhere. 
    //s := out&.s_name();
    //run_cmd_blocking("shasum", (ptr = s&, len = 1));
    out.remove();
}

::display_slice(Str);

fn driver_lsp_entry(vtable: *ImportVTable) Compiler = {
    c, libs := load_src(vtable);
    // TODO: dumb that im actually generating bc+asm for them
    exports := c.get_tagged("compiler");
    
    for exports { fid |
        ptr := c.get_jitted(fid);
    };
    
    c.data
}
