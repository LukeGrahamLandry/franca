#include_std("ffi.fr");

// TODO: less ass field lookup and call syntax
// TODO: compiler needs to check type / find right overload of this function. 
fn driver(vtable: *ImportVTable) Unit #export = {
    println("Hello World");
    args := cli_args();
    for(args){ arg |
        @println("- %", arg);
    };
    comp := {vtable.init_compiler}(.Aarch64);
    src := libc_allocator.read_to_string(:: @symbol("main.fr").c_str());
    file := {vtable.add_file}(comp, "main.fr", src&.items());
    stmts := {vtable.parse_stmts}(comp, file).unwrap();
    {vtable.make_and_resolve_and_compile_top_level}(comp, stmts).unwrap();
    sym_test := {vtable.intern_string}(comp, "test");
    tests := {vtable.get_fns_with_tag}(comp, sym_test);
    for(tests) {fid|
        res := {vtable.compile_func}(comp, fid, .Jit).unwrap();
        ptr := {vtable.get_jitted_ptr}(comp, fid).unwrap();
        {vtable.make_jitted_exec}(comp);
        f := assume_types_fn(Arg = Unit, Ret = Unit, ptr = ptr);
        f();
    };
    println(tests.len);
}

// TODO: HACK HACK HACK. use fseek 
fn read_to_string(alloc: Alloc, path: CStr) List(u8) = {
    HACK_MAX :: 999999;
    bytes: List(u8) = list(HACK_MAX, alloc);
    flag := (@as(i64) OpenFlag.Read);
    f := open(path, flag);
    // TODO: i32 overloads
    // TODO: print filepath if failed to open
    //if(f.fd.lt(0)) {|
    //    panic("failed open!");
    //};
    real_len: i64 = read(f, bytes.maybe_uninit.ptr, bytes.maybe_uninit.len);
    if(real_len.lt(0)) {|
        panic("failed read!");
    };
    @println("read % bytes", real_len);
    if(real_len.gt(HACK_MAX)) {|
        panic("miscompiled?? read more than max!!!");
    };
    bytes.len = real_len;
    close(f);
    bytes
}
