DO_TESTS :: false;

// TODO: less ass field lookup and call syntax
// TODO: compiler needs to check type / find right overload of this function. 
// TODO: factor out resolve_comptime_import stuff. allow runtime #import without building the dylib if not needed at comptime. 
fn driver(vtable: *ImportVTable) void #export = {
    do_build := true;
    args := cli_args();
    for(args){ arg |
        if arg.str() == "-no-build" {|
            do_build = false;
        };
    };
    
    arch_os := {vtable.comptime_arch}(); 
    tracy := tracy_lib.build_foreign_cached(arch_os, .Static);
    tracy := tracy.unwrap();
    UserData :: @struct(
        vtable: *ImportVTable,
        lib: DlHandle,
    );
    
    resolve_comptime_import :: fn(userdata: rawptr, comp: Compiler, f: FuncId, lib_name: Symbol, fn_name: Symbol) ?rawptr = {
        userdata := UserData.ptr_from_raw(userdata);
        // TODO: can't call @println here?? oh it doesnt like when no %s?
        sym := {userdata.vtable.intern_string}(comp, "tracy");
        fn_name := {userdata.vtable.get_string}(comp, fn_name);
        ret :: return;
        if(sym.eq(lib_name)){|
            fn_name := fn_name.maybe_borrow_cstr(temp());
            f := dlsym(userdata.lib, fn_name);
            assert(f.is_null().not(), "bad function name");
            ret((Some = f));
        };
        .None
    };

    dylib_path := tracy_lib.build_foreign_cached(arch_os, .Dynamic);  // TODO: should be able to unwrap in the same expression like you can later but it hasn't been instantated yet. 
    dylib_path := dylib_path.unwrap(); 

    dylib_path_c := dylib_path.maybe_borrow_cstr(temp());
    lib := dlopen(dylib_path_c, DlFlag.Lazy);
    assert(lib.lib.is_null().not(), "failed to open tracy for comptime");
    @println("Opened %", dylib_path);
    my_vtable: ExportVTable = (
        resolve_comptime_import = (Some = resolve_comptime_import),
    );
    data: UserData = (vtable = vtable, lib = lib);
    
    ////////////////////////
    
    start := timestamp();
    src := temp().read_to_string("main.fr");
    comp := vtable.new_with_src(src.items(), .Aarch64);
    {vtable.give_vtable}(comp, my_vtable&, UserData.raw_from_ptr(data&));
    
    c := vtable.with(comp);

    if DO_TESTS {|
        tests := c.get_tagged("test");
        for tests { fid |
            ptr := c.get_jitted(fid);
            f := assume_types_fn(Arg = void, Ret = void, ptr = ptr);
            f();
        };
        println(tests.len);
        
        // recall: you can always use emit_llvm directly instead of through the vtable to jit the newest version instead of using the old one if you broke something
        ir_text := {c.vtable.emit_llvm}(c, temp(), tests, .TestRunnerMain);
        test_exe := "target/tests.exe";
        build_llvm(ir_text, @slice ("-o", test_exe));
        success := run_cmd_blocking(test_exe, empty());
        assert(success, "tests failed");
    };
    
    exports := c.get_tagged("compiler");
    
    ir_text := {c.vtable.emit_llvm}(c, temp(), exports, .ExportWithNames);
    end := timestamp();
    if !DO_TESTS {|
        @println("Frontend time: % ms.", end.sub(start)); 
    };
    @println("Emitted % bytes of llvm ir.", ir_text.len);  // useful to see when i start trying to deduplicate bytecode. 

    if do_build {|
        start := timestamp();
        build_llvm(ir_text, @slice ("-o", "target/libfranca.o", "-c", "-Os")); // "-O2"
        success := run_cmd_blocking("/usr/bin/ar", @slice ("rc", "target/aarch64-apple-darwin/libfranca.a", "target/libfranca.o"));
        assert(success, "link failed");
        end := timestamp();
        @println("LLVM time: % ms.", end.sub(start)); 
    } else {|
        println("SKIPPED RUNNING LLVM");
    };
    
    //build_llvm(ir_text, @slice ("-o", "target/libfranca.o", "-c", "-target", "x86_64-apple-darwin")); // "-O2"
    //success := run_cmd_blocking("/usr/bin/ar", @slice ("rc", "target/x86_64-apple-darwin/libfranca.a", "target/libfranca.o"));
    //assert(success, "link failed");
}

// TODO: return result
fn build_llvm(ir: BucketArray(u8), args: Slice(Str)) void = {
    out := open_temp_file();
    for(ir&){bucket|
        out.fd&.write(bucket);
    };
    @println("Write llvm ir to %", out&.s_name());   
    args: List(Str) = args.clone(temp());
    args&.push("-x"); // don't check the file extension of source files that follow. 
    args&.push("ir"); 
    args&.push(out&.s_name());
    @println("%", args.items());
    success := run_cmd_blocking(CLANG_PATH, args.items());
    assert(success, "ICE: generated invalid llvm ir");
    out.remove();
}

::display_slice(Str);
