Compiler :: @struct(_: rawptr);
ArcFile :: @struct(_: rawptr);

ExportVTable :: @struct(

);

ImportVTable :: @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    get_stats: @FnPtr() *Stats!builtin,
    init_compiler: @FnPtr(comptime_arch: TargetArch!builtin) Compiler,
    find_unqiue_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_exports: @FnPtr(c: Compiler) Slice(FuncId),
    get_tests: @FnPtr(c: Compiler) Slice(FuncId),
    get_tests_broken: @FnPtr(c: Compiler) Slice(FuncId),
    // TODO: you can't just give it the slice from get_exports/tests because that will alias the vec that might grow, but the idea is this will go away soon anyway. 
    emit_c: @FnPtr(c: Compiler, fns: Slice(FuncId), add_test_runner: bool) CRes(Str),
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle!builtin) CRes(Unit),
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(*u8),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func,
    lookup_filename: @FnPtr(c: Compiler, span: Span!builtin) Str,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) ArcFile, 
    parse_stmts: @FnPtr(c: Compiler, f: ArcFile) CRes(Slice(FatStmt)),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(Unit),
);
