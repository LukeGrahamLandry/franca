Compiler :: @struct(_: rawptr);
ArcFile :: @struct(_: rawptr);
fn CRes(const T: Type) Type = Result(T, rawptr);
   
TargetArch :: @enum(i64) (Aarch64 = 1, Cranelift = 3);
ExecStyle :: @enum(i64) (Jit = 0, Aot = 1);
ExportVTable :: @struct(

);

ImportVTable :: @struct(
    intern_string: @FnPtr(c: Compiler, s: Str) Symbol,
    get_string: @FnPtr(c: Compiler, s: Symbol) Str,
    get_stats: @FnPtr() *Stats!builtin,
    init_compiler: @FnPtr(comptime_arch: TargetArch) Compiler,
    find_unique_func: @FnPtr(c: Compiler, name: Symbol) ?FuncId,
    // TODO: i want the meta program to be tracking these instead. 
    get_exports: @FnPtr(c: Compiler) Slice(FuncId),
    get_tests: @FnPtr(c: Compiler) Slice(FuncId),
    get_tests_broken: @FnPtr(c: Compiler) Slice(FuncId),
    // TODO: you can't just give it the slice from get_exports/tests because that will alias the vec that might grow, but the idea is this will go away soon anyway. 
    emit_c: @FnPtr(c: Compiler, fns: Slice(FuncId), add_test_runner: bool) CRes(Str),
    compile_func: @FnPtr(c: Compiler, f: FuncId, when: ExecStyle) CRes(Unit),
    get_jitted_ptr: @FnPtr(c: Compiler, f: FuncId) CRes(rawptr),
    get_function: @FnPtr(c: Compiler, f: FuncId) *Func!builtin,
    lookup_filename: @FnPtr(c: Compiler, span: Span!builtin) Str,
    add_file: @FnPtr(c: Compiler, name: Str, content: Str) ArcFile, 
    parse_stmts: @FnPtr(c: Compiler, f: ArcFile) CRes(Slice(FatStmt)),
    make_and_resolve_and_compile_top_level: @FnPtr(c: Compiler, body: Slice(FatStmt)) CRes(Unit),
    make_jitted_exec: @FnPtr(c: Compiler) Unit,
);
