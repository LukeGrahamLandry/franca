AstExternal :: import("@/compiler/ast_external.fr");
#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");
#use("@/lib/sys/process.fr");
#use("@/lib/sys/fs.fr");

// TODO: exec every time so you can run tests after the first compile error
fn driver(vtable: *ImportVTable) void = {
    // :FUCKED you can't move this variable declaration down
    franca_path := get_executable_path(temp());  // TODO: cli arg to set this 
    passed := 0;
    failed := 0;
    ::FmtPad(Str);
    tests := collect_tests(vtable);
    
    // TODO: do these once for every execution strategy:  jit+aot+cached+reloc+dynamic
    full, expect_dot_count := gen_full_test_program(tests&);
    ok, out, err := compile_and_run(vtable, full);
    if ok {
        println(out.items());
        passed = tests.raw.len_including_tombstones;
        
        // make sure it didn't cheat by calling exit(0) or something
        @assert_eq(expect_dot_count, count_end_of_line_dots(out.items()), "status=0 but didn't print enough dots");
    } else {
        #use("@/examples/testing.fr");
        "./c.out".three_trillion_dollars_does_not_buy_an_operating_system_that_works(); 
        
        each tests& { file, functions | 
            @print("%", f_pad(file, 40, .After));
            src := gen_test_program(file, functions[].items());
            ok, out, err := compile_and_run(vtable, src);
            (@if(ok, passed&, failed&))[] += 1;
            @print("[%]", if(ok, => "ok", => "failed run"));
            print(out.items());
            if !ok {
                print(err.items());
                "./c.out".three_trillion_dollars_does_not_buy_an_operating_system_that_works(); 
            };
            println("");
        };
        @assert_ne(failed, 0, "full test failed but all individual tests passed. \n%%", out.items(), err.items());
    };
    if failed == 0 {
        @println("\nAll is fine! (passed % tests)\n", passed);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
        exit(1);
    };
    
    ::import("@/examples/testing.fr");
    
    // TODO: it fails an assertion if you dont put this above the compile_only tests 
    //       if run_tests_main calls exit() which was infact a mistake but it's still a crippling compiler bug 
    //       -- Mar 24, 2025.  :FUCKED asdklasjd;ljas;ldja
    hello :: "examples/bf";
    files := collect_with_extension(hello, ".fr").unwrap();
    files&.unordered_retain(fn(it) => it[] != "README.fr");
    run_tests_main(Str, files.items(), fn(a) => a[]) { file | 
        ok, out, err := compile_and_run(vtable, @tfmt("#include_std(\"lib/core.fr\");#include_std(\"%/%\");", hello, file[]));
        (ok && out.items() == "Hello World!\n", out, err, "")
    };
    println("");
    
    {
        ok, out, err := compile_and_run(vtable, "#include_std(\"lib/core.fr\");#include_std(\"examples/kaleidoscope.fr\");");
        @assert(ok, "failed kaleidoscope\n%%", out.items(), err.items());
        @assert(out.items().ends_with("[ok]\n"), "kaleidoscope status=0 but didn't print '[ok]'");
        println("examples/kaleidoscope.fr [ok]");
    };
    
    run_tests_main(Str, compile_only, fn(a) => a[]) { file | 
        src := general_allocator().read_to_string_or_crash(file[]);
        src&.slowly_prepend_all("\n#include_std(\"lib/core.fr\");\n");
        compile(vtable, src.items());
        (true, list(u8, temp()), list(u8, temp()), "")
    };
    println("");
}

compile_only :: @const_slice(
    "examples/sudoku.fr",  // runs tests at comptime 
    "examples/raw_terminal.fr",  // interactive
    "examples/turing_art.fr", 
    // TODO: test it
    "examples/count.fr", 
    "examples/c_bindgen.fr", 
    "examples/dump_macho.fr", 
    "examples/macho_loader.fr", 
    "examples/dump_elf.fr",
    "examples/dump_wasm.fr",
    "backend/meta/dump_bin.fr",
    // has deps
    "tests/need_llvm/x64_encoding.fr", 
    // is driver
    // "examples/terminal.fr" "examples/farm_game.fr" "examples/default_driver.fr" "examples/60fps.fr"
    // interactive at comptime
    // "examples/soft_draw.fr" 
    
    "examples/toy/rot_cypher.fr",
    "examples/toy/pi.fr",
    // "examples/toy/where_am_i.fr", "examples/toy/hello.fr", irritating comptime print
    "examples/toy/predict.fr",
    
    "examples/repl.fr",
    
    // this are interactive so we just compile them. TODO: run one frame and show screen shot as a sanity check? 
    "examples/farm_game.fr",
    "examples/terminal.fr", // dep:stb  // TODO: doesn't work on x64 !!!
    "examples/app_events.fr",
    "examples/geo/main.fr",
    "examples/hello_triangle.fr",
    "examples/depth_test.fr",
    "examples/epicycles.fr",
    "examples/lambda.fr",
    
    // these we could run and just discard the output but it would be nice if i had a good way to actually test them
   
    // running jitted is clearly a bit fragile so this should be tested but it's really annoying spam. 
    "examples/view_image.fr",  // dep:wuffs
    
    "examples/ascii_table.fr",  // dep:stb
);

fn compile(vtable: *ImportVTable, src: Str) void = {
    chunks := compile_to_bytes(vtable, src, @slice(QbeOutputPurpose.Exe));
    outpath := "./c.out"; // TODO: don't hardcode this
    write_entire_file_or_crash(outpath, chunks[0]);
}

// returns one blob of bytes for each `goal` compiled in the same CompCtx but different QbeModule-s. 
fn compile_to_bytes(vtable: *ImportVTable, src: Str, goal: []QbeOutputPurpose) [][]u8 = {
    results := list([]u8, goal.len, general_allocator());
    mark := mark_temporary_storage();
    push_dynamic_context {
        opts := vtable.default_build_options();
        c := new_with_src(vtable, src, opts);
        c := vtable.with(c);
        
        for goal { goal |
            @assert(@is(goal, .Exe, .Cached, .CachedEarly), "compile_to_bytes: only exe/cached");
            m := zeroed QbeModule;
            a, os := (query_current_arch(), query_current_os());
            init_default_module_dyn(m&, c.vtable, (arch = a, os = os, type = goal));
            fid := or c.get_unique_named("main") {
                panic("expected exactly one function called 'main'")
            };
            chunks := {c.vtable.emit_qbe_included}(QbeModule.raw_from_ptr(m&), c&, @slice(fid), .WrapMain);
            bytes := concat(chunks&, general_allocator());
            drop(m&);

            if @is(goal, .Cached, .CachedEarly) {
                init_default_module_dyn(m&, c.vtable, (arch = a, os = os, type = .Exe));
                
                header: *Incremental.Header = check(bytes);
                compile_all_symbols(header, m&);
                chunks := {vtable.finish_qbe_module}(QbeModule.raw_from_ptr(m&));
                
                general_allocator().dealloc(u8, bytes);
                bytes = concat(chunks&, general_allocator());
                drop(m&);
            };
            
            results&.push(bytes);
        };
        {c.vtable.destroy_compiler}(c.data);
    };
    reset_temporary_storage(mark);
    results.items()
}

// runs it multiple times with different compilation strategies and returns the result of the first fail or different output. 
fn compile_and_run(vtable: *ImportVTable, src: Str) Ty(bool, List(u8), List(u8)) = {
    cases := @slice(QbeOutputPurpose.Exe, .Cached, .CachedEarly);
    chunks := compile_to_bytes(vtable, src, cases);
    
    write_entire_file_or_crash("./c.out", chunks[0]);
    ok0, out0, err0 := exec_and_catch("./c.out", empty(), todo_allocator);
    if ok0 {
        enumerate chunks.rest(1) { i, exe | 
            write_entire_file_or_crash("./c.out", exe[]);
            ok1, out1, err1 := exec_and_catch("./c.out", empty(), todo_allocator);
            
            ok1 = ok1 && out0.items() == out1.items();
            ok1 = ok1 && err0.items() == err1.items();
            @fmt(err1&, "\n>>> [compiler/test.fr] failed %", cases[i]);
            if(!ok1, => return(ok1, out1, err1));
        };
    };
    
    (ok0, out0, err0)
}

fn gen_test_program(file: Str, functions: []Str) Str = {
    src := u8.list(temp());
    @fmt(src&, """
        #include_std("lib/core.fr");
        #include_std("%");
        fn main() void = {
    """, file);
    gen_test_program_body(src&, functions);
    push_all(src&, "\n}");
    src.items()
}

fn gen_full_test_program(tests: *Tests) Ty(Str, i64) = {
    src := u8.list(temp());
    @fmt(src&, """#include_std("lib/core.fr");::FmtPad(Str);""");
    for_keys tests { k |
        @fmt(src&, "#include_std(\"%\");\n", k);
    };
    @fmt(src&, "fn main() void = {\n");
    count := 0;
    each tests { k, v |
        @fmt(src&, "  @print(\"\\n%[ok]\", f_pad(\"%\", 40, .After));\n", "%", k);
        gen_test_program_body(src&, v[].items());
        count += v.len;
    };
    push_all(src&, "\n}");
    (src.items(), count)
}

fn gen_test_program_body(src: *List(u8), functions: []Str) void = {
    for functions { name | 
        @fmt(src, "    %(@uninitialized); print(\".\"); \n", name);
    };
}

#use("@/lib/collections/map.fr");
Tests :: HashMap(Str, *List(Str));
fn collect_tests(vtable: *ImportVTable) Tests = {
    out: Tests = init(temp());
    push_dynamic_context {
        path: CStr = "tests";
        ::List(FatStmt);
        src := u8.list(temp());
        
        src&.push_all("#include_std(\"lib/core.fr\");\n");
        walk_directory(path) {entry|
            // TODO: recurse with another list if .Directory
            if entry.is(.File) && entry.name.ends_with(".fr") {
                @fmt(src&, "#include_std(\"%/%\");\n", path, entry.name);
            };
        };
        
        src1 := src.items().clone(temp()).items();
        opts := vtable.default_build_options();
        c := new_with_src(vtable, src1, opts);
        c := vtable.with(c);
        tests := c.get_tagged("test");
        sort :: quicksort(FuncId, fn(a, b) => a[].as_index() <= b[].as_index());
        sort(tests);
        
        for tests { f | 
            func  := c.get_function(f);
            name  := c.get_string(func.name);
            loc   := c.AstExternal'get_whole_line(func.loc);
            files := out&.get(loc.filename) || {
                l := temp().box(List(Str));
                l[] = list(temp());
                out&.insert(loc.filename, l);
                l
            };
            files.push(name);
        };
    };
    out
}

count_end_of_line_dots :: fn(out: Str) i64 = {
    found_dot_count := 0;
    i := 0;
    while => i < out.len {
        if out[i] == "]".ascii() {
            i += 1;
            while => i < out.len && out[i] != 10 {
                @assert(out[i] == ".".ascii());
                i += 1;
                found_dot_count += 1;
            }
        }
        i += 1;
    };
    found_dot_count
}

#use("@/lib/sys/subprocess.fr");
