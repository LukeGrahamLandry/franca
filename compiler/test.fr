AstExternal :: import("@/compiler/ast_external.fr");
#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");

// TODO: exec every time so you can run tests after the first compile error

fn driver(vtable: *ImportVTable) void = {
    franca_path := get_executable_path(temp());  // TODO: cli arg to set this 
    passed := 0;
    failed := 0;
    ::FmtPad(Str);
    tests := collect_tests(vtable);
    
    full := gen_full_test_program(tests&);
    ok, out, err := compile_and_run(vtable, full);
    if ok {
        passed = tests.raw.len_including_tombstones;
        println(out.items());
    } else {
        each tests& { file, functions | 
            @print("%", f_pad(file, 40, .After));
            src := gen_test_program(file, functions[].items());
            ok, out, err := compile_and_run(vtable, src);
            (@if(ok, passed&, failed&))[] += 1;
            @print("[%]", if(ok, => "ok", => "failed run"));
            print(out.items());
            if !ok {
                print(err.items());
            };
            println("");
        };
        @assert_ne(failed, 0, "full test failed but all individual tests passed.");
    };
    if failed == 0 {
        @println("\nAll is fine! (passed % tests)\n", passed);
    } else {
        @println("\n% of % tests failed.", failed, failed + passed);
        exit((failed != 0).int());
    };
    
    ::import("@/examples/testing.fr");
    
    run_tests_main(Str, compile_only, fn(a) => a[]) { file | 
        src := general_allocator().read_to_string_or_crash(file[]);
        src&.slowly_prepend_all("\n#include_std(\"lib/core.fr\");\n");
        compile(vtable, src.items());
        (true, list(u8, temp()), list(u8, temp()), "")
    };
}

compile_only :: @const_slice(
    "examples/sudoku.fr",  // runs tests at comptime 
    "examples/raw_terminal.fr",  // interactive
    // TODO: test it
    "examples/count.fr", "examples/c_bindgen.fr", 
    "examples/dump_macho.fr", "examples/macho_loader.fr", "examples/import_wasm/convert.fr",
    "examples/dump_elf.fr",
    "examples/dump_wasm.fr",
    // has deps
    "tests/need_llvm/x64_encoding.fr", 
    // is driver
    // "examples/edit.fr" "examples/farm_game.fr" "examples/default_driver.fr" "examples/60fps.fr"
    // interactive at comptime
    // "examples/soft_draw.fr" 
    
    "examples/bf/interpreter.fr", "examples/toy/rot_cypher.fr",
    // "examples/toy/where_am_i.fr", "examples/toy/hello.fr", irritating comptime print
    
    "examples/repl.fr",
);

fn compile(vtable: *ImportVTable, src: Str) void = {
    push_dynamic_context {
        opts := vtable.default_build_options();
        c := new_with_src(vtable, src, opts);
        c := vtable.with(c);
        
        m := zeroed QbeModule;
        a := query_current_arch();
        AstExternal'init_default_module_dyn(m&, c.vtable, (arch = a, os = query_current_os(), type = .Exe));
        fid := or c.get_unique_named("main") {
            panic("expected exactly one function called 'main'")
        };
        chunks := {c.vtable.emit_qbe_included}(QbeModule.raw_from_ptr(m&), c&, @slice(fid), .WrapMain);
        
        outpath := "./c.out"; // TODO: don't hardcode this
        outfile := fopen(outpath.maybe_borrow_cstr(temp()), "w");
        chunks := {m.target.finish_module}(m&);
        for chunks { chunk | 
            write(outfile, chunk);
        };
        fclose(outfile);
        drop(m&);
        {c.vtable.destroy_compiler}(c.data);
    };
}

fn compile_and_run(vtable: *ImportVTable, src: Str) Ty(bool, List(u8), List(u8)) = {
    compile(vtable, src);
    exec_and_catch("./c.out", empty(), todo_allocator)
}

fn gen_test_program(file: Str, functions: []Str) Str = {
    src := u8.list(temp());
    @fmt(src&, """
        #include_std("lib/core.fr");
        #include_std("%");
        fn main() void = {
    """, file);
    gen_test_program_body(src&, functions);
    push_all(src&, "\n}");
    src.items()
}

fn gen_full_test_program(tests: *Tests) Str = {
    src := u8.list(temp());
    @fmt(src&, """#include_std("lib/core.fr");::FmtPad(Str);""");
    for_keys tests { k |
        @fmt(src&, "#include_std(\"%\");\n", k);
    };
    @fmt(src&, "fn main() void = {\n");
    each tests { k, v |
        @fmt(src&, "  @print(\"\\n%[ok]\", f_pad(\"%\", 40, .After));\n", "%", k);
        gen_test_program_body(src&, v[].items());
    };
    push_all(src&, "\n}");
    src.items()
}

fn gen_test_program_body(src: *List(u8), functions: []Str) void = {
    for functions { name | 
        @fmt(src, "    %(@uninitialized); print(\".\"); \n", name);
    };
}

#use("@/lib/collections/map.fr");
Tests :: HashMap(Str, *List(Str));
fn collect_tests(vtable: *ImportVTable) Tests = {
    out: Tests = init(temp());
    push_dynamic_context {
        path := "tests".maybe_borrow_cstr(temp());
        ::List(FatStmt);
        src := u8.list(temp());
        
        src&.push_all("#include_std(\"lib/core.fr\");\n");
        walk_directory(path) {entry|
            // TODO: recurse with another list if .Directory
            is_file := (eq(@as(u8) entry.type, @as(u8) DirEntType.File));
            if is_file && entry.name.ends_with(".fr") {
                @fmt(src&, "#include_std(\"%/%\");\n", path, entry.name);
            };
        };
        
        src1 := src.items().clone(temp()).items();
        opts := vtable.default_build_options();
        c := new_with_src(vtable, src1, opts);
        c := vtable.with(c);
        tests := c.get_tagged("test");
        for tests { f | 
            func  := c.get_function(f);
            name  := c.get_string(func.name);
            loc   := c.AstExternal'get_whole_line(func.loc);
            files := out&.get(loc.filename) || {
                l := temp().box(List(Str));
                l[] = list(temp());
                out&.insert(loc.filename, l);
                l
            };
            files.push(name);
        };
    };
    out
}
