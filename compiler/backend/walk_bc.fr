// I'm not super thrilled about writing it this way but its really annoying to do the boring stack manipulation every time. 

// TODO: really need to fix this
#redirect(Ty(i64, i64), bool) fn eq(a: ProgramEntry, b: ProgramEntry) bool;


// TODO: traits
/*
Backend :: @trait fn($B: Type) = {
    // B.Val needs to be Copy.
    :: assert_eq(@type :: B.Val, Type); // TODO: better syntax for associated types? 
    
    fn new(comp: CompCtx, alloc: Alloc) B; 
    fn inst_call(self: *B, args: Slice(B.Val), sig: PrimSig, f: FuncId, tail: bool) Slice(B.Val);
    fn inst_trap(self: *B) void;
    fn inst_call_ptr(self: *B, args: Slice(B.Val), sig: PrimSig, ptr: B.Val) Slice(B.Val);
    fn inst_offset(self: *B, ptr: B.Val, bytes: u16) B.Val;
    fn inst_literal(self: *B, value: i64, ty: Prim) B.Val;
    fn inst_load(self: *B, addr: B.Val, ty: Prim) B.Val;
    fn inst_store(self: *B, addr: B.Val, value: B.Val, ty: Prim) void;
    fn inst_copy(self: *B, from: B.Val, to: B.Val, bytes: u16) void;
    fn inst_func_ref(self: *B, fid: FuncId) B.Val;
    fn inst_global(self: *B, id: BakedVarId) B.Val;
    fn inst_jump_if(self: *B, cond: B.Val, true: BbId, false: BbId, args: Slice(B.Val)) void;
    fn inst_jump(self: *B, always: BbId, args: Slice(B.Val)) void;
    fn inst_return(self: *B, args: Slice(B.Val)) void;
    fn move_to_block(self: *B, block: *BasicBlock, ip: BbId) Slice(B.Val);
    // - declare basic blocks
    // - declare stack slots for local variables
    fn setup(self: *B, body: *FnBody, vars_out: *List(B.Val)) void;
    fn inst_intrinsic(self: *B, op: Intrinsic, args: Slice(B.Val)) Slice(B.Val);
    fn inst_switch(self: *B, info: *RsVec(SwitchPayload), inspected: B.Val) void;
};
*/

fn walk_block();
fn emit_current_function();
fn add_pending_callees();

// Note: B.Val is the example usecase for const struct fields. 
fn CodeGen($B: Type, $zone_name: TraceZone) Type = {
    MAX_BLOCKS :: 512;
    Self :: @struct(
        program: *SelfHosted,
        backend: B,
        body: *FnBody,
        vars: List(B.Val),
        stack: List(B.Val),
        blocks_done: BitSet = empty(),
        funcs_done: BitSet = empty(),
        constants_needed: BitSet = empty(),
        max_const_id: i64 = 0,
        pending: List(FuncId),
        $emit := emit_program,
    );
    
    // TODO: they need to pass target arch for !asm functions. 
    emit_program :: fn(comp: CompCtx, alloc: Alloc, fns: [] FuncId, entry: ProgramEntry) BucketArray(u8) = {
        gen: Self = (
            program = comp.data.cast()[][],
            backend = new(comp, alloc),
            body = zeroed(*FnBody), // EVIL
            vars = list(20, temp()),
            stack = list(20, temp()),
            pending = fns.clone(temp()),
        );
        
        while(=> gen.pending.len.ne(0)){|
            continue :: local_return;
            fid := gen.pending&.pop().unwrap();
            if(gen.funcs_done&.get(fid.to_index().zext()), => continue()); // might have been added multiple times
            gen.funcs_done&.set(fid.to_index().zext(), temp());
            
            // Note: compile before checking callees!
            {comp.vtable.compile_func}(comp.data, fid, .Aot).unwrap(); 
            func := {comp.vtable.get_function}(comp.data, fid);
            gen&.add_pending_callees(func);
            // println(gen.program.pool.get(func.name));
            
            body := emit_bc(comp.data.cast(), fid, .Aot);
            body := body.unwrap();
            
            if body.func != fid {|
                // We just noticed its a duplicate.
                gen.pending&.push(body.func);
                continue();
            };
        
            zone := zone_begin(zone_name); // TODO: defer
            @if(ENABLE_TRACY) {
                real_name := get_string(comp.data, func.name);
                ___tracy_emit_zone_name(zone, real_name);
            };
            
            if(body.blocks.len.eq(0)){|
                success := gen.backend&.emit_special(func.body&, func, body, gen.pending&); 
                if !success {|
                    // TODO: pass in the arch
                    success = gen.backend&.emit_special_asm(func.body&, func, body, Arch.Aarch64); 
                };
                if !success {|
                    // TODO: should assert but debug_tag_corruption is confused. -- Jun 27
                    real_name := get_string(comp.data, func.name);
                    @eprintln("!!!! failed to emit speciai function: %", real_name);
                };
                //assert(success, "failed to emit speciai function");
                zone_end(zone);
                continue();
            };
            gen.body = body;
            gen.backend&.emit_function_husk(fid, body.signeture) {|
                gen&.emit_current_function();
            };
            
            zone_end(zone);
        };
        
        constants := 0;
        range(0, gen.max_const_id + 1) {i|
            if gen.constants_needed&.get(i) {|
                gen.backend&.emit_constant((id = i.trunc()));
                constants += 1;
            };
        };    
        
        gen&.emit_entry_points_and_debug_info(comp, fns, entry); // note: qbe hack needs this to be last
        
        // TODO: if alloc != temp { temp.reset(mark ? no but that wouldn't catch if they derived a new one from temp
        gen.backend.out
    }

    fn add_pending_callees(self: *Self, func: *Func) void = {
        for func.callees { c |
            if !self.funcs_done&.get(c.to_index().zext()) {|
                self.pending&.push(c);
            };
        };
        for func.mutual_callees { c |
            if !self.funcs_done&.get(c.to_index().zext()) {|
                self.pending&.push(c);
            };
        };
    }
   
    fn emit_current_function(self: *Self) void = {
        s := self.body.blocks.items();
        self.backend&.setup(self.body, self.vars&);
        self.walk_block((id = 0));
        self.vars&.clear();
        self.stack&.clear();
        self.blocks_done&.clear();
    }
    
    fn walk_block(self: *Self, b: BbId) void = {
        // TODO: you cant call pop unless its been instantiated but it cant be instantiated if the type doesn't exist.
        :: ?B.Val; ::?Slice(B.Val);
        block_index: i64 = b.id.zext();
        break :: return;
        if(self.blocks_done&.get(block_index), => break());
        self.blocks_done&.set(block_index, temp());
        
        block := self.body.blocks.items()[block_index]&;
        args := self.backend&.move_to_block(block, b);
        assert(args.len.ge(block.arg_prims.len), "missing block args");
        self.stack&.push_all(args);
        for(block.insts.items()){ inst |
            @match(inst){
                (fn Nop() => ());
                (fn SaveSsa(slot) => {
                    v := self.stack&.pop().expect("stack for SaveSsa");
                    self.vars[slot.id.zext()] = v;
                });
                (fn LoadSsa(slot) => {
                    v := self.vars[slot.id.zext()];
                    self.stack&.push(v);
                });
                (fn GetCompCtx() => {
                    f := self.program.get_function(self.body.func);
                    name := self.program.pool.get(f.name);
                    self.program.codemap.show_error_line(f.loc);
                    @panic("AOT bytecode for '%' should not use GetCompCtx", name);
                });
                (fn Intrinsic(op) => {
                    arg_count := op.arg_count();
                    args := self.stack.items().slice_last(arg_count).expect("enough args on stack for intrinsic");
                    ret := self.backend&.inst_intrinsic(args, op);
                    self.stack.len -= arg_count;
                    self.stack&.push_all(ret);
                });
                (fn CallDirect(call) => { //  f, tail, sig
                    f := self.program.follow_redirects(call.f); // HACK to fix redirects added by deduplication
                    self.pending&.push(f); // TODO: callees list from compiler should make this redundant but im afraid.
                    
                    arg_count: i64 = call.sig&.arg_slots();
                    args := self.stack.items().slice_last(arg_count).expect("enough args on stack for call");
                    ret := self.backend&.inst_call(args, call.sig, f, call.tail);
                    self.stack.len -= arg_count;
                    if(call.sig.no_return){|
                        self.backend&.inst_trap();
                        break();
                    };
                    if(call.tail){|
                        // TODO: do this properly
                        self.backend&.inst_return(ret);
                        break();
                    };
                    self.stack&.push_all(ret);
                });
                (fn CallFnPtr(call) => {
                    // TODO: better error message if you don't put the type annotation here. 
                    arg_count: i64 = call.sig&.arg_slots();
                    ptr := self.stack.items()[self.stack.len.sub(arg_count).sub(1)];
                    args := self.stack.items().slice_last(arg_count).expect("enough args on stack for call");
                    ret := self.backend&.inst_call_ptr(args, call.sig, ptr);
                    self.stack.len -= arg_count;
                    self.stack.len -= 1;
                    self.stack&.push_all(ret);
                });
                (fn PushConstant(c) => {
                    v := self.backend&.inst_literal(c.value, c.ty);
                    self.stack&.push(v);
                });
                (fn PushGlobalAddr(id) => {
                    self.add_constant(id);
                    v := self.backend&.inst_global(id);
                    self.stack&.push(v);
                });
                (fn JumpIf(jump) => { //  { true_ip, false_ip, slots }
                    cond := self.stack&.pop().expect("stack for jumpif");
                    args := self.stack.items().slice_last(jump.slots.zext()).expect("enough args on stack for JumpIf");
                    self.backend&.inst_jump_if(cond, jump.true_ip, jump.false_ip, args);
                    self.stack.len -= jump.slots.zext();
                    stack := self.stack.items().clone(temp());
                    self.walk_block(jump.true_ip);
                    self.stack = stack;
                    self.walk_block(jump.false_ip);
                    break();
                });
                (fn Goto(jump) => { // { ip, slots }
                    args := self.stack.items().slice_last(jump.slots.zext()).expect("enough args on stack for Jump");
                    self.backend&.inst_jump(jump.ip, args);
                    self.stack.len -= jump.slots.zext();
                    self.walk_block(jump.ip);
                    break();
                });
                (fn Ret0() => {
                    self.backend&.inst_return(empty());
                    break();
                });
                (fn Ret1(_) => {
                    args := self.stack.items().slice_last(1).expect("stack for ret1");
                    self.backend&.inst_return(args);
                    self.stack.len -= 1;
                    break();
                });
                (fn Ret2(_) => {
                    args := self.stack.items().slice_last(2).expect("stack for ret2");
                    self.backend&.inst_return(args);
                    self.stack.len -= 2;
                    break();
                });
                (fn GetNativeFnPtr(f) => {
                    f = self.program.follow_redirects(f);
                    self.pending&.push(f); // TODO: callees list from compiler should make this redundant but im afraid
                    v := self.backend&.inst_func_ref(f);
                    self.stack&.push(v);
                });
                (fn Load(ty) => {
                    addr := self.stack&.pop().unwrap();
                    v    := self.backend&.inst_load(addr, ty);
                    self.stack&.push(v);
                });
                (fn StorePost(ty) => {
                    assert(self.stack.len.ge(2), "StorePost: not enough args");
                    addr := self.stack&.pop().unwrap();
                    v    := self.stack&.pop().unwrap();
                    self.backend&.inst_store(addr, v, ty);
                });
                (fn StorePre(ty) => {
                    assert(self.stack.len.ge(2), "StorePre: not enough args");
                    v    := self.stack&.pop().unwrap();
                    addr := self.stack&.pop().unwrap();
                    self.backend&.inst_store(addr, v, ty);
                });
                (fn AddrVar(slot) => {
                    ptr := self.vars[slot.id.zext()];
                    self.stack&.push(ptr);
                });
                (fn IncPtrBytes(bytes) => {
                    ptr := self.stack&.pop().unwrap();
                    res := self.backend&.inst_offset(ptr, bytes);
                    self.stack&.push(res);
                }); // TODO: better error message if you forget this semi-colon
                (fn Unreachable() => {
                    self.backend&.inst_trap();
                    break();
                });
                (fn NoCompile() => {
                    panic("ICE: NoCompile");
                });
                (fn LastUse(_) => ());
                (fn PeekDup(skip) => {
                    i := self.stack.len().sub(skip.zext()).sub(1);
                    v := self.stack[i];
                    self.stack&.push(v);
                });
                (fn Snipe(skip) => {
                    index := self.stack.len().sub(skip.zext()).sub(1);
                    self.stack&.ordered_remove(index);
                });
                (fn CopyBytesToFrom(bytes) => {
                    from := self.stack&.pop().unwrap();
                    to := self.stack&.pop().unwrap();
                    self.backend&.inst_copy(from, to, bytes);
                });
                fn Switch(idx) => {
                    info := self.body.switch_payloads.index(idx);
                    value := self.stack&.pop().unwrap();
                    self.backend&.inst_switch(info, value);
                    for info { case |
                        stack := self.stack.items().clone(temp());
                        self.walk_block(case.block);
                        self.stack = stack;
                    };
                    break();
                }
            };
        };
    }
    
    // TODO: super dumb that i have to walk twice. 
    fn add_constant(self: *Self, id: BakedVarId) void = {
        index: i64 = id.id.zext();
        if(self.constants_needed&.get(index), => return());
        
        self.constants_needed&.set(index, temp());
        self.max_const_id = self.max_const_id.max(index);
        value := self.program.get_baked(id)[]._1&;
        
        @match(value) {
            (fn VoidPtrArray(parts) => {
                for(parts[].items()){inner|
                    @match(inner) {
                        (fn FnPtr(f) => self.pending&.push(f));
                        (fn AddrOf(v) => self.add_constant(v));
                        (fn Num(_) => ());
                    };
                };
            });
            @default => ();
        }
    }


    Self
}

fn arg_count(i: Intrinsic) i64 #inline = {
    if(i.raw() >= @run Intrinsic.BitNot.raw(), => 1, => 2)
}
