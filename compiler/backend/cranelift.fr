//! This is implemented in rust becuase its too much of a pain otherwise. 

fn get_backend_vtable() *BackendImportVTable = {
    vtable := @static(BackendImportVTable);
    vtable.get_jitted_function = fn(self: *SelfHosted, f: FuncId) ?rawptr = {
        self.aarch64&.get_fn_old(f)
    };
    vtable.put_jitted_function = put_jitted_function;
    vtable.get_jit_addr = fn(self: *SelfHosted, id: BakedVarId) rawptr = {
        val := self.get_baked(id); 
        val._0
    };
    vtable
}

BackendImportVTable :: @struct(
    get_jitted_function: @FnPtr(self: *SelfHosted, f: FuncId) ?rawptr,
    put_jitted_function: @FnPtr(self: *SelfHosted, f: FuncId, addr: rawptr) void,
    get_jit_addr: @FnPtr(self: *SelfHosted, id: BakedVarId) rawptr,
);

JittedCranelift :: @struct(ptr: rawptr);

fn franca_comptime_cranelift_init(
    data: *SelfHosted,
    vtable: *BackendImportVTable,
    dispatch_ptr: i64,
) JittedCranelift #import("comptime_cranelift");

fn franca_comptime_cranelift_emit(
    cl: JittedCranelift, 
    f: FuncId, 
    body: *FnBody,
    compile_ctx_ptr: CompilerRs,
    log_ir: bool,
) void #import("comptime_cranelift");

fn franca_comptime_cranelift_flush(
    cl: JittedCranelift, 
) void #import("comptime_cranelift");

fn flush_cranelift(self: *SelfHosted) void = {
    @if(INCLUDE_COMPTIME_CRANELIFT) {
        if self.cranelift { data |
            franca_comptime_cranelift_flush(data);
        };
    };
}
