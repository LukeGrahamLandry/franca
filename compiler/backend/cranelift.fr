//! This is implemented in rust becuase its too much of a pain otherwise. 

fn get_backend_vtable() *BackendImportVTable = {
    vtable := @static(BackendImportVTable);
    vtable.get_jitted_function = fn(self: *SelfHosted, f: FuncId) ?rawptr = {
        self.aarch64&.get_fn(f)
    };
    vtable.put_jitted_function = fn(self: *SelfHosted, f: FuncId, addr: rawptr) void = {
        self.aarch64&.extend_blanks(f);
        self.aarch64.dispatch[f.as_index()] = addr;
    };
    vtable.get_jit_addr = fn(self: *SelfHosted, id: BakedVarId) rawptr = {
        val := self.get_baked(id); 
        val._0
    };
    vtable
}

BackendImportVTable :: @struct(
    get_jitted_function: @FnPtr(self: *SelfHosted, f: FuncId) ?rawptr,
    put_jitted_function: @FnPtr(self: *SelfHosted, f: FuncId, addr: rawptr) void,
    get_jit_addr: @FnPtr(self: *SelfHosted, id: BakedVarId) rawptr,
);

JittedCranelift :: @struct(ptr: rawptr);

fn franca_comptime_cranelift_init(
    data: *SelfHosted,
    vtable: *BackendImportVTable,
    dispatch_ptr: i64,
) JittedCranelift #import("comptime_cranelift");

fn franca_comptime_cranelift_emit(
    cl: JittedCranelift, 
    f: FuncId, 
    body: *FnBody,
    compile_ctx_ptr: CompilerRs,
) void #import("comptime_cranelift");
