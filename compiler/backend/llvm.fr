//! https://llvm.org/docs/LangRef.html

// TODO: have a way of marking ones that should be imported instead of emitted so the driver program could do incremental compilation stuff. 
// TODO: move the top level loop to walk_bc because its probably the same on all backends. 
// TODO: not reserving enough
// TODO: implement !asm with Module-Level Inline Assembly
// TODO: only specfiy ccc if you take a pointer to the function? you want to use one that allows tail calls otherwise. 

// TODO: really need to fix this
#redirect(Ty(i64, i64), bool) fn eq(a: ProgramEntry, b: ProgramEntry) bool;

// Turn this on for profiling. 
// TODO: put function names in the exe so don't have to print them and look up by id. 
// TODO: make this a build option you pass to emit_llvm
RETAIN_FUNCTION_NAMES :: true;

// TODO: they need to pass target arch for !asm functions. 
fn emit_llvm(comp: CompCtx, alloc: Alloc, fns: [] FuncId, entry: ProgramEntry) BucketArray(u8) = {
    s: EmitLlvm = (comp = comp, out = init(16384, alloc), current = BbId.zeroed());
    gen: CodeGen(EmitLlvm) = (
        comp = comp,
        backend = s,
        body = zeroed(*FnBody), // EVIL
        vars = list(20, temp()),
        stack = list(20, temp()),
        pending = fns.clone(temp()),
    );
    
    // TODO: how the hell am i supposed to know these numbers without just compiling a c program with clang. 
    //       its not a big deal tho cause passing -target to clang overrides this. 
    gen.backend.out&.push_all("""
    target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
    target triple = "arm64-apple-macosx13.0.0"
    """);
    
    while(=> gen.pending.len.ne(0)){|
        continue :: local_return;
        fid := gen.pending&.pop().unwrap();
        if(gen.funcs_done&.get(fid.to_index().zext()), => continue()); // might have been added multiple times
        gen.funcs_done&.set(fid.to_index().zext(), temp());
        
        // Note: compile before checking callees!
        
        {comp.vtable.compile_func}(comp.data, fid, .Aot).unwrap(); 
        
        func := {comp.vtable.get_function}(comp.data, fid);
        
        for func.callees { c |
            if !gen.funcs_done&.get(c.to_index().zext()) {|
                gen.pending&.push(c);
            };
        };
        for func.mutual_callees { c |
            if !gen.funcs_done&.get(c.to_index().zext()) {|
                gen.pending&.push(c);
            };
        };
        body := emit_bc(comp.data.cast(), fid, .Aot);
        body := body.unwrap();
    
        zone := zone_begin(.EmitLlvm); // TODO: defer
        @if(ENABLE_TRACY) {
            real_name := get_string(comp.data, func.name);
            ___tracy_emit_zone_name(zone, real_name);
        };
        
        if(body.blocks.len.eq(0)){|
            success := gen.backend&.emit_special(func.body&, func, body&); 
            if !success {|
                // TODO: pass in the arch
                success = gen.backend&.emit_special_asm(func.body&, func, body&, Arch.Aarch64); 
            };
            if !success {|
                // TODO: should assert but debug_tag_corruption is confused. -- Jun 27
                println("!!!! failed to emit speciai function");
            };
            //assert(success, "failed to emit speciai function");
            zone_end(zone);
            continue();
        };
        gen.body = body&;
        if RETAIN_FUNCTION_NAMES {|
            gen.backend.out&.push_all("define ccc ");
        } else {|
            gen.backend.out&.push_all("define private ccc ");
        };
        name: List(u8) = list(temp());
        gen.backend&.fmt_fn_name(body.func, name&);
        gen.backend&.write_header(body.signeture, name.items()) {arg_index|
            s := @format("%arg%", "%", arg_index) temp();
            s.items()
        };
        //@println("emit %", get_string(comp.data, func.name));
        
        gen.backend.out&.current().push_all("{\n");
        gen&.emit_current_function();
        gen.backend.out&.current().push_all("}\n");
        
        zone_end(zone);
    };
    
    constants := 0;
    range(0, gen.max_const_id + 1) {i|
        if gen.constants_needed&.get(i) {|
            gen.backend&.emit_constant(comp, (id = i.trunc()));
            constants += 1;
        };
    };    
    
    @switch(entry) {
        @case(.TestRunnerMain) => {
            gen.backend.out&.push_all("define ccc i64 @main(){\n");
            i := 1;
            // TODO: warn if fns has duplicates
            for (fns) {f|
                gen.backend.out&.reserve(100);
                func := {comp.vtable.get_function}(comp.data, f);
                // note: this only works because void has a fixed typeid value
                if func.finished_arg.unwrap() == void {|
                    @fmt(gen.backend.out&.current(), "   call void @%()\n", (gen.backend&, f));
                } else {|
                    @fmt(gen.backend.out&.current(), "   %% = call i64 @%(i64 0)\n", "%", i, (gen.backend&, f));
                    i += 1;
                };
            };
            gen.backend.out&.push_all("ret i64 0\n}\n");
        };
        @case(.GiveMeTheCodeAndGiveItToMeRaw) => ();
        @case(.ExportWithNames) => {
            // TODO: warn if fns has duplicates
            for fns { fid |
                gen.backend&.write_export_bounce(fid);
            };
        };
    };
    
    // Note: even if its unreachable because RUNTIME_STACK_TRACE=false, the binary is bigger.
    // TODO: if RUNTIME_STACK_TRACE
    //gen.backend&.emit_debug_info(gen.funcs_done&);
    //       else
    gen.backend.out&.current().push_all("""
        @debug_names_len = private global i64 0
        @debug_names = private global [0 x ptr] []
    """);
    
    // TODO: if alloc != temp { temp.reset(mark ? no but that wouldn't catch if they derived a new one from temp
    gen.backend.out
}

// :BLOAT
fn emit_debug_info(self: *EmitLlvm, funcs_done: *BitSet) void = {
    // TODO: I really don't like this but you need to make sure this constant gets created at the very end which bake_value can't do. 
    // TODO: only do this if RUNTIME_STACK_TRACE
    // TODO: use funcs_done to only include the ones that are actually callable. 
    
    f_count := {self.comp.vtable.number_of_functions}(self.comp.data);
    constants: List(BakedVarId) = list(f_count, temp());
    range(0, f_count) { i|
        fid := (@as(u32) i.trunc()).funcid_from_index();
        func := {self.comp.vtable.get_function}(self.comp.data, fid);
        real_name := get_string(self.comp.data, func.name);
        // TODO: UNSAFE: giving rust an aliased vec!!! but also i know it has the right lifetime, should rework constants. 
        // TODO: check .baked.lookup
        v: BakedVar = (Bytes = (cap = real_name.len, ptr = real_name.ptr, len = real_name.len));
        id := put_baked(self.comp.data.cast()[][], v, .None);
        constants&.push(id);
        self.emit_constant(self.comp, id);
    };
    
    @fmt(self.out&.current(), """
        @debug_names_len = private global i64 %
        @debug_names = private global [% x ptr] [
    """, f_count, f_count);
    
    for constants {id|
        @fmt(self.out&.current(), "ptr @g%,", id.id);
    };
    self.pop_trailing_comma();
    self.out&.current().push_all("]\n");
}

// TODO: copy-paste from DynamicImport but reversed so its a pain. 
fn write_export_bounce(self: *EmitLlvm, fid: FuncId) void = {
    self.next_var = 0;
    values: List(LlvmVal) = list(temp());
    func := {self.comp.vtable.get_function}(self.comp.data, fid);
    import_name := get_string(self.comp.data, func.name);
    self.out&.push_all("define ccc ");
    f_ty := func.finished_ty().unwrap();
    cc := func.cc.unwrap();
    sig := self.comp.data.cast().prim_sig(f_ty, cc).unwrap();
    self.write_header(sig, import_name) {arg_index|
        ty: Prim = if(sig.first_arg_is_indirect_return){|
            if arg_index.eq(0) {|
                Prim.P64
            }{|
                sig.args[arg_index.sub(1)]
            }
        }{|
            sig.args[arg_index]
        };
        values&.push((ty = ty, id = arg_index));
        s := @format("%v%", "%", arg_index) temp();
        self.next_var += 1;
        s.items()
    };
    self.out&.push_all("{\n");
    ret := self.inst_call(values.items(), sig) {|
        @fmt(self.out&.current(), "@%", (self, fid));
    };
    self.inst_return(ret);
    self.out&.current().push_all("}\n");
}

fn emit_constant(self: *EmitLlvm, comp: CompCtx, id: BakedVarId) void = {
    self.out&.reserve(100);
    value := get_baked(comp.data, id);
    index: i64 = id.id.zext();
    
    @match(value&) {
        (fn Zeros(len) => {
            @fmt(self.out&.current(), "@g% = private global [% x i8] zeroinitializer\n", index, len[]);
        });
        (fn Bytes(bytes) => {
            // TODO: emit string as characters if they're in a sane range. 
            @fmt(self.out&.current(), "@g% = private global [% x i8] [", index, bytes.len + 1);
            for(bytes[].items()) {b|
                @fmt(self.out&.current(), " i8 %,", @as(i64) b.zext());
            };
            // self.pop_trailing_comma(); // add back when remove below
            self.out&.push_all("i8 0]\n"); // TODO: hack cause im to lazy to ask for debug names as cstr
        });
        (fn VoidPtrArray(parts) => {
            @fmt(self.out&.current(), "@g% = private global [% x ptr] [", index, parts.len);
            for(parts[].items()){inner|
                self.out&.reserve(20);
                @match(inner) {
                    (fn FnPtr(f) => {
                        @fmt(self.out&.current(), "ptr @%,", (self, f));
                        // TODO: make sure we emitted the function. 
                    });
                    (fn AddrOf(id) => {
                        @fmt(self.out&.current(), "ptr @g%,", @as(i64) id.id.zext());
                    });
                    (fn Num(v) => {
                        // TODO: small prims
                        @fmt(self.out&.current(), "ptr inttoptr (i64 % to ptr),", v.value);
                    });
                };
            };
            self.pop_trailing_comma();
            self.out&.push_all("]\n");
        });
    }
}

fn emit_special(self: *EmitLlvm, body: *FuncImpl, func: *Func, bc: *FnBody) bool = {
    comp := self.comp;
    @match(body) {
        fn Normal(_) => { panic("ICE: empty body but expr"); };
        fn Redirect(f) => {
            // TODO: assert that 'f' is flagged for being emitted?
            //       currently just trusting that emit_bc replaced all actual uses. 
            //       could also just have the front end check if body is redirect before adding to callees list. -- Jun 27
            return(true);
        }
        fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special(check, func, bc), => return(true));
            };
        }
        fn DynamicImport(name) => { 
            // TODO: do i need to hackily do the same for ComptimeAddr and hope for the best? ideally the forntend would handle that instead. 
            import_name := get_string(comp.data, name[]);
            self.forward_declare(bc.signeture, false, import_name);
            
            self.out&.push_all("define private ccc ");
            name := @format("%", (self, bc.func)) temp();
            values: List(LlvmVal) = list(temp());
            self.next_var = 0;
            self.write_header(bc.signeture, name.items()) {arg_index|
                ::if(Prim);
                // TODO: format this better. 
                ty: Prim = if(bc.signeture.first_arg_is_indirect_return){|
                    // TODO: only sokol tests this 
                    if arg_index.eq(0) {|
                        Prim.P64
                    }{|
                        bc.signeture.args[arg_index.sub(1)]
                    }
                }{|
                    bc.signeture.args[arg_index]
                };
                values&.push((ty = ty, id = arg_index));
                s := @format("%v%", "%", arg_index) temp();
                self.next_var += 1;
                s.items()
            };
            self.out&.reserve(50);
            self.out&.current().push_all("{\n");
            ret := self.inst_call(values.items(), bc.signeture) {|
                @fmt(self.out&.current(), "@%", import_name);
            };
            self.inst_return(ret);
            self.out&.current().push_all("}\n");
            return(true);
        }
        fn LlvmIr(code) => { 
            self.next_var = 0;
            ir := get_string(comp.data, code[]);
            self.out&.push_all("define private ccc ");
            name := @format("%", (self, bc.func)) temp();
            self.write_header(bc.signeture, name.items()) {arg_index|
                args := func.arg.bindings.items();
                arg := args[arg_index].name.Var.name;
                arg := get_string(comp.data, arg);
                arg := @format("%%", "%", arg) temp();
                self.next_var += 1;
                arg.items()
            };
            @fmt(self.out&.current(), "{\n%}\n", ir);
            return(true);
        }
        @default fn() void => return(false);
    };
    false
}

fn forward_declare(self: *EmitLlvm, sig: PrimSig, private: bool, name: Str) void = {
    self.out&.push_all("declare ccc ");
    if private {|
        self.out&.push_all("private ");
    };
    self.write_header(sig, name) {arg_index| (@format("%v%", "%", arg_index) temp()).items() };
    self.out&.push_all(";\n");
}

fn emit_special_asm(self: *EmitLlvm, body: *FuncImpl, func: *Func, bc: *FnBody, arch: Arch) bool = {
    comp := self.comp;
    @match(body) {
        (fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special_asm(check, func, bc, arch), => return(true));
            };
        });
        (fn JittedAarch64(code) => { 
            if(arch.ne(Arch.Aarch64), => { return(false); });
            name := @format("%", (self, bc.func)) temp();
            self.forward_declare(bc.signeture, false, name.items());
            
            @fmt(self.out&.current(), "module asm \"_%:\"\n", (self, bc.func));
            for code { inst |
                v := @as(i64) inst.zext();
                @fmt(self.out&.current(), "module asm \".word %\"\n", v);
            };
            
            return(true);
        });
        @default fn() void => return(false);
    };
    false
}

// TODO: better error mwssage if you use @enum instead of @tagged. -- Jun 14
LlvmVal :: @struct(
    ty: Prim,
    id: i64
);

EmitLlvm :: @struct(
    comp: CompCtx,
    out: BucketArray(u8),
    current: BbId,
    next_var: i64 = 0,
    $Val := LlvmVal, // TODO: const can't be first (doesn't parse).  -- Jun 14
);

fn write_header(self: *EmitLlvm, sig: PrimSig, name: Str, $get_arg_name: @Fn(idx: i64) Str) void = {
    self.out&.reserve(50);
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            @fmt(self.out&.current(), "%", llvm_pair_type(fst, snd));
        }{| // one
            @fmt(self.out&.current(), "%", fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("void");
    };
    @fmt(self.out&.current(), " @%(", name);
    
    // TODO: don't have two callsites for get_arg_name
    shift := if(sig.first_arg_is_indirect_return) {|
        size: i64 = sig.return_value_bytes.zext();
        // note: when calling through function pointers, you need to put the sret attribute there as well (large_struct_ret_return tests this).
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, get_arg_name(0));
        1
    }{| 0 };
    
    enumerate(sig.args) {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        @fmt(self.out&.current(), "% %,", ty[].llvm_type(), get_arg_name(i)); 
    };
    self.pop_trailing_comma();
    self.out&.current().push_all(")");
}

fn setup(self: *EmitLlvm, body: *FnBody, vars_out: *List(EmitLlvm.Val)) void = {
    self.out&.push_all("entry:\n");
    self.next_var = 0;
    // TODO: waste for ssa vars, they just get set to the value. -- Jun 14
    vars := body.vars.items();
    enumerate(vars) {i, ty|
        meta := {self.comp.vtable.get_type_meta}(self.comp.data, ty[]); // TODO: im not getting the right values. unless i add extra padding to the struct. so its using registers? 
        v := self.get_var(.P64);
        vars_out.push(v);
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   % = alloca i8, i32 %, align %\n", v, @as(i64) meta.stride_bytes.zext(), @as(i64) meta.align_bytes.zext()); // uhg % was a bad choice. 
    };
    // TODO: use phi nodes cause this is stupid but that's such a pain in the ass. 
    // I use these for block arguments. 
    max_args := 0;
    each(body.blocks.items()){b|
        max_args = max_args.max(b.arg_prims.len);
    };
    range(0, max_args) {i|
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   %a% = alloca i64\n", "%", i); // uhg % was a bad choice. 
    };
    shift := if body.signeture.first_arg_is_indirect_return {|
        @fmt(self.out&.current(), " store ptr %arg0, ptr %a0\n", "%", "%");
        1
    }{| 0 };
    enumerate body.signeture.args {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        // TODO: ty.llvm_type() error says it wants the raw type but found enum ptr when it should say wants the enum type
        @fmt(self.out&.current(), "   store % %arg% , ptr %a%\n", ty[].llvm_type(), "%", i, "%", i); 
    };
    self.out&.push_all("   br label %b0\n"); 
}

fn fmt_fn_name(self: *EmitLlvm, f: FuncId, out: *List(u8)) void = {
    if RETAIN_FUNCTION_NAMES {|
        func := {self.comp.vtable.get_function}(self.comp.data, f);
        real_name := get_string(self.comp.data, func.name);
        @fmt(out, "%__%", real_name, f.to_index());
    } else {|
        @fmt(out, "F%", f.to_index());
    }
}

fn display(self: Ty(*EmitLlvm, FuncId), out: *List(u8)) void = {
    self._0.fmt_fn_name(self._1, out)
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, f: FuncId, tail: bool) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        self.out&.current().push_all("@");
        self.fmt_fn_name(f, self.out&.current());
    }
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, $do_call: @Fn() void) Slice(EmitLlvm.Val) = {
    self.out&.reserve(30);
    
    out_vals: List(LlvmVal) = list(temp());
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            out_vals&.push(self.get_var(fst));
            out_vals&.push(self.get_var(snd));
            @fmt(self.out&.current(), "   %v% = call % ", "%", self.next_var, llvm_pair_type(fst, snd));
            self.next_var += 1;
        }{| // one
            v := self.get_var(fst);
            out_vals&.push(v);
            @fmt(self.out&.current(), "   % = call % ", v, fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("   call void ");
    };
    maybe_struct_out := self.next_var.sub(1);
    
    do_call();
    
    self.out&.push_all("(");
    shift := if(sig.first_arg_is_indirect_return) {|
        size: i64 = sig.return_value_bytes.zext();
        // note: the sret must match the declaration! not doing this breaks large_struct_ret_return and compiler driver dylib ffi. 
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, args[0]);
        1
    }{| 0 };
    @assert_eq(args.len, sig.args.len.add(shift));
    
    range(0, sig.args.len) {i|
        ty := sig.args[i];
        v := args[i.add(shift)];
        self.out&.reserve(30);
        ::assert_eq(Prim);
        //assert_eq(ty, v.ty); // TODO
        @fmt(self.out&.current(), " % %,", ty.llvm_type(), v);
    };
    self.pop_trailing_comma();
    
    self.out&.current().push_all(")\n");
    
    if(sig.ret2) {_| // two
        v1 := out_vals[0];
        v2 := out_vals[1];
        self.out&.reserve(30);
        p := llvm_pair_type(v1.ty, v2.ty);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 0\n", v1, p, "%", maybe_struct_out);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 1\n", v2, p, "%", maybe_struct_out);
    };
    
    out_vals.items()
}

fn pop_trailing_comma(self: *EmitLlvm) void = {
    // they don't allow trailing comma because they hate us personally 
    if(self.out&.current().items().ends_with(",")) {|
        // TODO: access fields on lvalues. `self.out&.current().len += 1` should work
        l := self.out&.current();
        l.len -= 1;
    };
}

fn inst_trap(self: *EmitLlvm) void = {
    // i think trap makes it crash instead of ub and it seems you need unreachable for it to believe the block is finished. 
    self.out&.push_all("   call void @llvm.trap()\n   unreachable\n");
}

fn inst_call_ptr(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, ptr: EmitLlvm.Val) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        @fmt(self.out&.current(), "%", ptr);
    }
}

fn inst_offset(self: *EmitLlvm, ptr: EmitLlvm.Val, bytes: u16) EmitLlvm.Val = {
    temp := self.get_var(.I64);
    new := self.get_var(.I64);
    done := self.get_var(.P64);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = ptrtoint ptr % to i64\n", temp, ptr); 
    @fmt(self.out&.current(), "   % = add i64 %, %\n", new, temp, @as(i64) bytes.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", done, new); 
    done
}

MAX_I64 :: 1.shift_left(32).sub(1);

fn inst_literal(self: *EmitLlvm, value: i64, ty: Prim) EmitLlvm.Val = {
    v := self.get_var(ty);
    self.out&.reserve(100);
    // TODO: use @switch here. 
    if(ty.eq(.F64)){|
        // for f64, llvm wants the bits as hex. 
        h := fmt_hex(value);
        @fmt(self.out&.current(), "   % = fadd double %, 0.0\n", v, h); 
    } {|
        if(ty.eq(.F32)){|
            // for f32, llvm wants an f64 as hex that happens to be exactly representable as f32. 
            // but we store it as an f32 on the bottom with the high bits zeroed. 
            assert(value.lt(MAX_I64), "ICE: too many bits for f32");
            value: u32 = value.trunc();    // the bits we want to load
            value: f32 = value.bitcast();  // the number we want to load
            value: f64 = value.cast();     // the same numerical value
            value: i64 = value.bitcast();  // the bits we need to give llvm
            // TODO: does it change if you try to print here??????
            h := fmt_hex(value);
            @fmt(self.out&.current(), "   % = fadd float %, 0.0\n", v, h); 
        } {|
            if(ty.eq(.P64)) {|
                @assert_eq(value, 0); // a literal pointer that isn't null doesn't make sense for AOT.
                @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, value); 
            } {|
                // TODO: better error message if you forget an argument
                // TODO: just track constants myself in Val? you can't just assign to a constsant int. 
                @fmt(self.out&.current(), "   % = add % %, 0\n", v, ty.llvm_type(), value); 
            }
        };
    };
    v
}

// TODO: need to sign extend sometimes. 
fn inst_load(self: *EmitLlvm, addr: EmitLlvm.Val, ty: Prim) EmitLlvm.Val = {
    value := self.get_var(ty);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = load %, ptr %\n", value, ty.llvm_type(), addr); 
    value
}

fn inst_store(self: *EmitLlvm, addr: EmitLlvm.Val, value: EmitLlvm.Val, ty: Prim) void = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   store % %, ptr %\n", ty.llvm_type(), value, addr); 
}

fn inst_copy(self: *EmitLlvm, from: EmitLlvm.Val, to: EmitLlvm.Val, bytes: u16) void = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   call void @llvm.memcpy.p0.p0.i32(ptr %, ptr %, i32 %, i1 false)\n", to, from, @as(i64) bytes.zext()); 
}

fn inst_func_ref(self: *EmitLlvm, fid: FuncId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @% to i64\n", temp, (self, fid));
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_global(self: *EmitLlvm, id: BakedVarId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @g% to i64\n", temp, @as(i64) id.id.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_jump_if(self: *EmitLlvm, cond: EmitLlvm.Val, true: BbId, false: BbId, args: Slice(EmitLlvm.Val)) void = {
    assert(args.len.eq(0), "i dont use this yet");
    self.out&.reserve(40);
    c := self.get_var(.I8);
    @fmt(self.out&.current(), "   % = trunc i8 % to i1\n", c, cond); 
    @fmt(self.out&.current(), "   br i1 %, label %b%, label %b%\n", c, "%", @as(i64) true.id.zext(), "%", @as(i64) false.id.zext()); 
}

fn inst_jump(self: *EmitLlvm, always: BbId, args: Slice(EmitLlvm.Val)) void = {
    enumerate(args){i, arg|
        self.out&.reserve(50);
        @fmt(self.out&.current(), "   store % %, ptr %a%\n", arg.ty.llvm_type(), arg[], "%", i); 
    };
    self.out&.reserve(20);
    @fmt(self.out&.current(), "   br label %b%\n", "%", @as(i64) always.id.zext()); 
}

fn inst_return(self: *EmitLlvm, args: Slice(EmitLlvm.Val)) void = {
    self.out&.reserve(100);
    @switch(args.len){
        @case(0) => {
            self.out&.current().push_all("   ret void\n");
        };
        @case(1) => {
            @fmt(self.out&.current(), "   ret % %\n", args[0].ty.llvm_type(), args[0]); 
        };
        @case(2) => {
            self.next_var += 2;
            pair := llvm_pair_type(args[0].ty, args[1].ty);
            @fmt(self.out&.current(), "   %v% = insertvalue % undef, % %, 0\n", "%", self.next_var.sub(2), pair, args[0].ty.llvm_type(), args[0]); 
            @fmt(self.out&.current(), "   %v% = insertvalue % %v%, % %, 1\n", "%", self.next_var.sub(1), pair, "%", self.next_var.sub(2), args[1].ty.llvm_type(), args[1]); 
            @fmt(self.out&.current(), "   ret % %v%\n", pair, "%", self.next_var.sub(1)); 
        };
        @default fn() => unreachable();
    };
}

fn move_to_block(self: *EmitLlvm, block: *BasicBlock, ip: BbId) Slice(EmitLlvm.Val) = {
    self.out&.reserve(100);
    @fmt(self.out&.current(), "b%:\n", @as(i64) ip.id.zext()); 
        
    self.current = ip;
    args: List(EmitLlvm.Val) = list(block.arg_prims.len, temp());
    
    enumerate(block.arg_prims) {i, ty| 
        self.out&.reserve(20);
        v := self.get_var(ty[]);
        args&.push(v);
        @fmt(self.out&.current(), "   % = load %, ptr %a%\n", v, ty[].llvm_type(), "%", i); 
    };
    args.items()
}

fn get_var(self: *EmitLlvm, ty: Prim) LlvmVal = {
    v: LlvmVal = (ty = ty, id = self.next_var);
    self.next_var += 1;
    v
}

fn display(self: LlvmVal, out: *List(u8)) void = {
    @fmt(out, "%v%", "%", self.id);
}
// TODO: this should be automatic from enum names
fn display(self: Prim, out: *List(u8)) void = {
    self.llvm_type().display(out);
}

// TODO: these are super clunky, you want to have 'or' in switch cases. 
fn llvm_type(ty: Prim) Str = @switch(ty) {
    @case(.I8) => "i8";
    @case(.I16) => "i16";
    @case(.I32) => "i32";
    @case(.I64) => "i64";
    @case(.F64) => "double";
    @case(.F32) => "float";
    @case(.P64) => "ptr";
};

fn llvm_pair_type(a: Prim, b: Prim) Str = {
    s := @format("{ %, % }", a.llvm_type(), b.llvm_type()) temp();
    s.items()
}
