// TODO: have a way of marking ones that should be imported instead of emitted so the driver program could do incremental compilation stuff. 
// TODO: move the top level loop to walk_bc because its probably the same on all backends. 

fn emit_llvm(comp: CompCtx, alloc: Alloc, fns: Slice(FuncId)) BucketArray(u8) = {
    s: EmitLlvm = (comp = comp, out = init(1024, alloc), current = BbId.zeroed());
    gen: CodeGen(EmitLlvm) = (
        comp = comp,
        backend = s,
        body = zeroed(*FnBody), // EVIL
        vars = list(20, temp()),
        stack = list(20, temp()),
    );
    
    pending: List(FuncId) = fns.clone(temp());
    
    while(=> pending.len.ne(0)){|
        continue :: @return;
        fid := pending&.pop().unwrap();
        if(gen.funcs_done&.get(fid.to_index().zext()), => continue()); // might have been added multiple times
        gen.funcs_done&.set(fid.to_index().zext(), temp());
        
        func := {comp.vtable.get_function}(comp.data, fid);
        for(func.callees.items()){c|
            if(not(gen.funcs_done&.get(c.to_index().zext()))){|
                pending&.push(c);
            };
        };
        for(func.mutual_callees.items()){c|
            if(not(gen.funcs_done&.get(c.to_index().zext()))){|
                pending&.push(c);
            };
        };
        
        body := {comp.vtable.emit_bc}(comp.data, fid, .Aot).unwrap();
        if(body.blocks.len.eq(0)){|
            // TODO: handle import
            continue();
        };
        {comp.vtable.debug_log_bc}(comp.data, body&);
        gen.body = body&;
        gen.backend&.define_func(body&);
        gen&.emit_current_function();
        gen.backend.out&.current().push_all("}\n");
    };
    
    // TODO: if alloc != temp { temp.reset(mark ?
    
    gen.backend.out
}

// TODO: better error mwssage if you use @enum instead of @tagged. -- Jun 14
LlvmVal :: @struct(
    ty: Prim,
    id: i64
);

EmitLlvm :: @struct(
    comp: CompCtx,
    out: BucketArray(u8),
    current: BbId,
    next_var: i64 = 0,
    const Val := LlvmVal, // TODO: const can't be first (doesn't parse).  -- Jun 14
);

fn define_func(self: *EmitLlvm, body: *FnBody) Unit = {
    ::if_opt(Prim, Unit);

    sig := body.signeture&;
    self.out&.push_all("define ");
    self.out&.reserve(50);
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            @fmt(self.out&.current(), "%", llvm_pair_type(fst, snd));
        }{| // one
            @fmt(self.out&.current(), "%", fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("void");
    };
    @fmt(self.out&.current(), " @F%(", body.func.to_index());
    
    shift := if(sig.first_arg_is_indirect_return) {|
        @fmt(self.out&.current(), " ptr %arg0,", "%");
        1
    }{| 0 };
    
    enumerate(sig.args) {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        @fmt(self.out&.current(), "% %arg%,", ty[].llvm_type(), "%", i); 
    };
    self.pop_trailing_comma();
    self.out&.current().push_all("){\n");
}

fn setup(self: *EmitLlvm, body: *FnBody, vars_out: *List(EmitLlvm.Val)) Unit = {
    self.out&.push_all("entry:\n");
    self.next_var = 0;
    // TODO: waste for ssa vars, they just get set to the value. -- Jun 14
    vars := body.vars.items();
    @println("There are % vars", vars.len);
    enumerate(vars) {i, ty|
        meta := {self.comp.vtable.get_type_meta}(self.comp.data, ty[]); // TODO: im not getting the right values. unless i add extra padding to the struct. so its using registers? 
        v := self.get_var(.P64);
        vars_out.push(v);
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   % = alloca i8, i32 %, align %\n", v, @as(i64) meta.stride_bytes.zext(), @as(i64) meta.align_bytes.zext()); // uhg % was a bad choice. 
    };
    // TODO: use phi nodes cause this is stupid but that's such a pain in the ass. 
    // I use these for block arguments
    // TODO: max(blocks[..].args, sig.arg_slots) so don't bother emitting text for functions that don't need that many. 
    range(0, 10) {i|
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   %a% = alloca i64\n", "%", i); // uhg % was a bad choice. 
    };
    shift := if(body.signeture.first_arg_is_indirect_return) {|
        @fmt(self.out&.current(), " store ptr %arg0, ptr %a0\n", "%", "%");
        1
    }{| 0 };
    enumerate(body.signeture.args) {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        // TODO: ty.llvm_type() error says it wants the raw type but found enum ptr when it should say wants the enum type
        @fmt(self.out&.current(), "   store % %arg% , ptr %a%\n", ty[].llvm_type(), "%", i, "%", i); 
    };
    self.out&.push_all("   br label %b0\n"); 
}

// clang puts the sret first, so
fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, f: FuncId, tail: bool) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        @fmt(self.out&.current(), "@F%", f.to_index());
    }
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, const do_call: @Fn() Unit) Slice(EmitLlvm.Val) = {
    self.out&.reserve(30);
    
    out_vals: List(LlvmVal) = list(temp());
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            out_vals&.push(self.get_var(fst));
            out_vals&.push(self.get_var(snd));
            @fmt(self.out&.current(), "   %v% = call % ", "%", self.next_var, llvm_pair_type(fst, snd));
            self.next_var += 1;
        }{| // one
            v := self.get_var(fst);
            out_vals&.push(v);
            @fmt(self.out&.current(), "   % = call % ", v, fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("   call void ");
    };
    maybe_struct_out := self.next_var.sub(1);
    
    do_call();
    
    self.out&.push_all("(");
    shift := if(sig.first_arg_is_indirect_return) {|
        @fmt(self.out&.current(), " ptr %,", args[0]);
        1
    }{| 0 };
    assert_eq(args.len, sig.args.len.add(shift));
    
    range(0, sig.args.len) {i|
        ty := sig.args[i];
        v := args[i.add(shift)];
        self.out&.reserve(30);
        ::assert_eq(Prim);
        assert_eq(ty, v.ty);
        @fmt(self.out&.current(), " % %,", ty.llvm_type(), v);
    };
    self.pop_trailing_comma();
    self.out&.current().push_all(")\n");
    
    if(sig.ret2) {_| // two
        v1 := out_vals[0];
        v2 := out_vals[1];
        self.out&.reserve(30);
        p := llvm_pair_type(v1.ty, v2.ty);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 0\n", v1, p, "%", maybe_struct_out);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 1\n", v2, p, "%", maybe_struct_out);
    };
    
    out_vals.items()
}

fn pop_trailing_comma(self: *EmitLlvm) Unit = {
    // they don't allow trailing comma because they hate us personally 
    if(self.out&.current().items().ends_with(",")) {|
        // TODO: access fields on lvalues. `self.out&.current().len += 1` should work
        l := self.out&.current();
        l.len -= 1;
    };
}

fn inst_trap(self: *EmitLlvm) Unit = {
    // i think trap makes it crash instead of ub and it seems you need unreachable for it to believe the block is finished. 
    self.out&.push_all("   call void @llvm.trap()\n   unreachable\n");
}

fn inst_call_ptr(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, ptr: EmitLlvm.Val) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        @fmt(self.out&.current(), "%", ptr);
    }
}

fn inst_offset(self: *EmitLlvm, ptr: EmitLlvm.Val, bytes: u16) EmitLlvm.Val = {
    temp := self.get_var(.I64);
    new := self.get_var(.I64);
    done := self.get_var(.P64);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = ptrtoint ptr % to i64\n", temp, ptr); 
    @fmt(self.out&.current(), "   % = add i64 %, %\n", new, temp, @as(i64) bytes.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", done, new); 
    done
}

fn inst_literal(self: *EmitLlvm, value: i64, ty: Prim) EmitLlvm.Val = {
    v := self.get_var(ty);
    self.out&.current().reserve(20);
    float := ty.eq(.F64).or(ty.eq(.F32));
    if(float){|
        @fmt(self.out&.current(), "   % = todo float\n", v); 
    } {|
        // TODO: better error message if you forget an argument
        // TODO: just track constants myself in Val? you can't just assign to a constsant int. 
        @fmt(self.out&.current(), "   % = add % %, 0\n", v, ty.llvm_type(), value); 
    };
    v
}

// TODO: need to sign extend sometimes. 
fn inst_load(self: *EmitLlvm, addr: EmitLlvm.Val, ty: Prim) EmitLlvm.Val = {
    value := self.get_var(ty);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = load %, ptr %\n", value, ty.llvm_type(), addr); 
    value
}

fn inst_store(self: *EmitLlvm, addr: EmitLlvm.Val, value: EmitLlvm.Val, ty: Prim) Unit = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   store % %, ptr %\n", ty.llvm_type(), value, addr); 
}

fn inst_copy(self: *EmitLlvm, from: EmitLlvm.Val, to: EmitLlvm.Val, bytes: u16) Unit = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   call void @llvm.memcpy.p0.p0.i32(ptr %, ptr %, i32 %)\n", to, from, @as(i64) bytes.zext()); 
}

fn inst_func_ref(self: *EmitLlvm, fid: FuncId) EmitLlvm.Val = {
    println("f");
    todo()
}

fn inst_global(self: *EmitLlvm, id: BakedVarId) EmitLlvm.Val = {
    //{self.comp.vtable.debug_log_baked_constant}(self.comp.data, id);
    v := self.get_var(.P64);
    self.out&.reserve(30);
    // TODO: LlvmVal should be a @tagged(Local, Global) so we dont give it extra work to do
    @fmt(self.out&.current(), "   % = call ptr @llvm.ssa.copy(ptr @g%)\n", v, @as(i64) id.id.zext()); 
    v
}

fn inst_jump_if(self: *EmitLlvm, cond: EmitLlvm.Val, true: BbId, false: BbId, args: Slice(EmitLlvm.Val)) Unit = {
    assert(args.len.eq(0), "i dont use this yet");
    self.out&.reserve(40);
    c := self.get_var(.I8);
    @fmt(self.out&.current(), "   % = trunc i8 % to i1\n", c, cond); 
    @fmt(self.out&.current(), "   br i1 %, label %b%, label %b%\n", c, "%", @as(i64) true.id.zext(), "%", @as(i64) false.id.zext()); 
}

fn inst_jump(self: *EmitLlvm, always: BbId, args: Slice(EmitLlvm.Val)) Unit = {
    enumerate(args){i, arg|
        self.out&.reserve(20);
        @fmt(self.out&.current(), "   store % %, ptr %a%\n", arg.ty.llvm_type(), arg[], "%", i); 
    };
    self.out&.reserve(20);
    @fmt(self.out&.current(), "   br label %b%\n", "%", @as(i64) always.id.zext()); 
}

fn inst_return(self: *EmitLlvm, args: Slice(EmitLlvm.Val)) Unit = {
    @switch(args.len){
        @case(0) => {
            self.out&.current().push_all("   ret void\n");
        };
        @case(1) => {
            @fmt(self.out&.current(), "   ret % %\n", args[0].ty.llvm_type(), args[0]); 
        };
        @case(2) => {
            self.next_var += 2;
            pair := llvm_pair_type(args[0].ty, args[1].ty);
            @fmt(self.out&.current(), "   %v% = insertvalue % undef, % %, 0\n", "%", self.next_var.sub(2), pair, args[0].ty.llvm_type(), args[0]); 
            @fmt(self.out&.current(), "   %v% = insertvalue % %v%, % %, 1\n", "%", self.next_var.sub(1), pair, "%", self.next_var.sub(2), args[1].ty.llvm_type(), args[1]); 
            @fmt(self.out&.current(), "   ret % %v%\n", pair, "%", self.next_var.sub(1)); 
        };
        @default fn(_: i64) => {
            unreachable();
        };
    };
}

fn move_to_block(self: *EmitLlvm, block: *BasicBlock, ip: BbId) Slice(EmitLlvm.Val) = {
    self.out&.reserve(20);
    @fmt(self.out&.current(), "b%:\n", @as(i64) ip.id.zext()); 
        
    self.current = ip;
    args: List(EmitLlvm.Val) = list(block.arg_prims.len, temp());
    
    enumerate(block.arg_prims) {i, ty| 
        self.out&.reserve(20);
        v := self.get_var(ty[]);
        args&.push(v);
        @fmt(self.out&.current(), "   % = load %, ptr %a%\n", v, ty[].llvm_type(), "%", i); 
    };
    args.items()
}

fn get_var(self: *EmitLlvm, ty: Prim) LlvmVal = {
    v: LlvmVal = (ty = ty, id = self.next_var);
    self.next_var += 1;
    v
}

fn display(self: LlvmVal, out: *List(u8)) Unit = {
    @fmt(out, "%v%", "%", self.id);
}
// TODO: this should be automatic from enum names
fn display(self: Prim, out: *List(u8)) Unit = {
    self.llvm_type().display(out);
}

// TODO: these are super clunky, you want to have 'or' in switch cases. 
fn llvm_type(ty: Prim) Str = @switch(ty) {
    @case(.I8) => "i8";
    @case(.I16) => "i16";
    @case(.I32) => "i32";
    @case(.I64) => "i64";
    @case(.F64) => "f64";
    @case(.F32) => "f32";
    @case(.P64) => "ptr";
};

fn llvm_pair_type(a: Prim, b: Prim) Str = {
    s := @format("{ %, % }", a.llvm_type(), b.llvm_type()) temp();
    s.items()
}
