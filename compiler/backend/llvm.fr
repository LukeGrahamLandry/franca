//! https://llvm.org/docs/LangRef.html

// TODO: have a way of marking ones that should be imported instead of emitted so the driver program could do incremental compilation stuff. 
// TODO: move the top level loop to walk_bc because its probably the same on all backends. 
// TODO: not reserving enough
// TODO: implement !asm with Module-Level Inline Assembly
// TODO: only specfiy ccc if you take a pointer to the function? you want to use one that allows tail calls otherwise. 

// https://llvm.org/docs/SourceLevelDebugging.html#dbg-declare
// they say the debug info intrinsics are deprecated and you should use records now... 
// but records don't seem to work, "expecte instruction opcode", and clang generates the intrinsics, and rustc generates the intrinsics...
// so i guess they're just lying out of spite???? 
// oh maybe its just super recent and doesn't exist yet and they don't bother to put dates on the docs? 
// this are like ~a month ago
// https://github.com/llvm/llvm-project/pulls?q=is%3Apr+RemoveDIs 
// yeah it looks like 18 exists now and they want to slowly make it possible to do the new thing during 19
// https://discourse.llvm.org/t/rfc-instruction-api-changes-needed-to-eliminate-debug-intrinsics-from-ir/68939/11
// tho this implies they should be able to parse it
// https://github.com/llvm/llvm-project/pull/79818

// TODO: better error mwssage if you use @enum instead of @tagged. -- Jun 14
LlvmVal :: @struct(
    ty: Prim,
    id: i64
);

EmitLlvm :: @struct(
    program: *SelfHosted,
    out: BucketArray(u8),
    current: BbId,
    next_var: i64 = 0,
    next_debug_info: i64 = 0,
    current_debug_info: i64 = 0,
    debug_info: List(u8),
    debug_unit: i64 = 0,
    debug_file: i64 = 0,
    debug_func_type: i64 = 0,
    debug_addr_type: i64 = 0,
    $Val := LlvmVal, // TODO: const can't be first (doesn't parse).  -- Jun 14
);

emit_llvm :: { T :: CodeGen(EmitLlvm, .EmitLlvm); T.emit }
    
// TODO: dependency problem so can't call this `init`
fn new(comp: CompCtx, alloc: Alloc) EmitLlvm #inline = {
    s: EmitLlvm = (program = comp.data.cast()[][], out = init(12, alloc), current = BbId.zeroed(), debug_info = list(alloc));
    
    // TODO: how the hell am i supposed to know these numbers without just compiling a c program with clang. 
    //       its not a big deal tho cause passing -target to clang overrides this. 
    s.out&.push_all("""
    target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
    target triple = "arm64-apple-macosx13.0.0"
    """);
    
    if s.program.get_build_options()[].debug_info {|
        s.debug_unit = s&.next_debug();
        s.debug_file = s&.next_debug();
        s.debug_func_type = s&.next_debug();
        s.debug_addr_type = s&.next_debug();
        debug_ident := s&.next_debug();
        // you can say language: 0, but then opt removes it and if you try to run it through again it complains theres no language
        template :: "!% = distinct !DICompileUnit(language: 0, producer: \"Franca\", emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None, file: !%, isOptimized: false, runtimeVersion: 0)\n";
        @fmt(s.debug_info&, template, s.debug_unit, s.debug_file);
        @fmt(s.debug_info&, "!% = !DIFile(filename: \"mandelbrot.fr\", directory: \"examples\")\n", s.debug_file);
        @fmt(s.debug_info&, "!llvm.dbg.cu = !{!%}\n", s.debug_unit);        
        @fmt(s.debug_info&, "!llvm.ident = !{!%}\n", debug_ident);        
        @fmt(s.debug_info&, "!% = !DISubroutineType(types: !{null})\n", s.debug_func_type);
        @fmt(s.debug_info&, "!% = !DIBasicType(name: \"ptr\", size: 64, align: 64, encoding: DW_ATE_address)\n", s.debug_addr_type);
        @fmt(s.debug_info&, "!% = !{!\"franca\"}\n", debug_ident);
    };
    s
}

fn next_debug(self: *EmitLlvm) i64 = {
    self.next_debug_info += 1;
    self.next_debug_info - 1
}

// TODO: my impression is unnamed_addr doesn't help size (even with -no-deduplication) so maybe take it out -- Aug 13
fn emit_function_husk(self: *EmitLlvm, fid: FuncId, signeture: PrimSig, $emit_body: @Fn() void) void = {
    if self.program.get_build_options()[].retain_function_names {|
        self.out&.push_all("define ccc ");
    } else {|
        self.out&.push_all("define private ccc ");
    };
    name: List(u8) = list(temp());
    self.fmt_fn_name(fid, name&);
    self.write_header(signeture, name.items()) {arg_index|
        s := @format("%arg%", "%", arg_index) temp();
        s.items()
    };
    
    self.out&.current().push_all(" unnamed_addr \"frame-pointer\"=\"all\" "); // must be before debug info!
    if self.program.get_build_options()[].debug_info {|
        self.current_debug_info = self.next_debug();
        @fmt(self.out&.current(), "!dbg !%", self.current_debug_info);
    };
   
    self.out&.current().push_all("{\n");
    emit_body();
    self.out&.current().push_all("}\n");
    
    if self.program.get_build_options()[].debug_info {|
        func := self.program.get_function(fid);
        source_name := self.program.pool.get(func.name); 
        template :: "!% = distinct !DISubprogram(name: \"%\", linkageName: \"%\", unit: !%, scope: !%, type: !%, spFlags: DISPFlagDefinition)\n";
        @fmt(self.out&.current(), template,  self.current_debug_info, source_name, name.items(), self.debug_unit, self.debug_file, self.debug_func_type);
    };
};

fn emit_entry_points_and_debug_info(gen: *CodeGen(EmitLlvm, .EmitLlvm), comp: CompCtx, fns: []FuncId, entry: ProgramEntry) void = {
    program := gen.backend.program;
    @switch(entry) {
        @case(.TestRunnerMain) => {
            gen.backend.out&.push_all("define ccc i64 @main(){\n");
            
            i := 1;
            // TODO: warn if fns has duplicates
            for fns { f |
                gen.backend.out&.reserve(100);
                f = program.follow_redirects(f);
                func := program.get_function(f);
                // note: this only works because void has a fixed typeid value
                if func.finished_arg.unwrap() == void {|
                    @fmt(gen.backend.out&.current(), "   call void @%()\n", (gen.backend&, f));
                } else {|
                    @fmt(gen.backend.out&.current(), "   %% = call i64 @%(i64 0)\n", "%", i, (gen.backend&, f));
                    i += 1;
                };
            };
            gen.backend.out&.push_all("ret i64 0\n}\n");
        };
        @case(.GiveMeTheCodeAndGiveItToMeRaw) => ();
        @case(.ExportWithNames) => {
            // TODO: warn if fns has duplicates
            for fns { fid |
                gen.backend&.write_export_bounce(fid);
            };
        };
    };
    
    // Note: even if its unreachable because RUNTIME_STACK_TRACE=false, the binary is bigger.
    // TODO: if RUNTIME_STACK_TRACE
    //gen.backend&.emit_debug_info(gen.funcs_done&);
    //       else
    gen.backend.out&.current().push_all("""
        @debug_names_len = private global i64 0
        @debug_names = private global [0 x ptr] []
    """);
    self := gen.backend&;
    if self.program.get_build_options()[].debug_info {|
        version := self.next_debug();
        d_version := self.next_debug();
        level := self.next_debug();
        
        @fmt(self.out&.current(), "!% =  !{i32 8, !\"PIC Level\", i32 2}\n", level); // no idea what that means, its what rustc does
        @fmt(self.out&.current(), "!% = !{i32 2, !\"Debug Info Version\", i32 3}\n", version);
        @fmt(self.out&.current(), "!% = !{i32 2, !\"Dwarf Version\", i32 2}\n", d_version);
        self.out&.push_bucket(self.debug_info);
        self.debug_info = List(u8).zeroed();
        @fmt(self.out&.current(), "!llvm.module.flags = !{!%, !%, !%}", version, d_version, level);
    };
}

fn emit_bounce_fn(self: *EmitLlvm, impl_name_callee: Str, fake_decl_name: Str, signeture: PrimSig, private: bool) void = {
    spec := if(private, => "define private ccc ", => "define ccc ");
    self.out&.push_all(spec);
    values: List(LlvmVal) = list(temp());
    self.next_var = 0;
    self.write_header(signeture, fake_decl_name) {arg_index|
        ::if(Prim);
        // TODO: format this better. 
        ty: Prim = if(signeture.first_arg_is_indirect_return){|
            // TODO: only sokol tests this 
            if arg_index.eq(0) {|
                Prim.P64
            }{|
                signeture.args[arg_index.sub(1)]
            }
        }{|
            signeture.args[arg_index]
        };
        values&.push((ty = ty, id = arg_index));
        s := @format("%v%", "%", arg_index) temp();
        self.next_var += 1;
        s.items()
    };
    self.out&.reserve(50);
    self.out&.current().push_all("{\n");
    self.current_debug_info = 0;
    ret := self.inst_call(values.items(), signeture) {|
        @fmt(self.out&.current(), "@%", impl_name_callee);
    };
    self.inst_return(ret);
    self.out&.current().push_all("}\n");
}

// :BLOAT
fn emit_debug_info(self: *EmitLlvm, funcs_done: *BitSet) void = {
    // TODO: I really don't like this but you need to make sure this constant gets created at the very end which bake_value can't do. 
    // TODO: only do this if RUNTIME_STACK_TRACE
    // TODO: use funcs_done to only include the ones that are actually callable. 
    
    f_count := self.program.functions.len;
    constants: List(BakedVarId) = list(f_count, temp());
    range(0, f_count) { i|
        fid := (@as(u32) i.trunc()).funcid_from_index();
        func := self.program.get_function(fid);
        real_name := self.program.pool.get(func.name);
        // TODO: UNSAFE: giving rust an aliased vec!!! but also i know it has the right lifetime, should rework constants. 
        // TODO: check .baked.lookup
        v: BakedVar = (Bytes = (cap = real_name.len, ptr = real_name.ptr, len = real_name.len));
        id := self.program.put_baked(v, .None);
        constants&.push(id);
        self.emit_constant(id);
    };
    
    @fmt(self.out&.current(), """
        @debug_names_len = private global i64 %
        @debug_names = private global [% x ptr] [
    """, f_count, f_count);
    
    for constants {id|
        @fmt(self.out&.current(), "ptr @g%,", id.id);
    };
    self.pop_trailing_comma();
    self.out&.current().push_all("]\n");
}

// TODO: copy-paste from DynamicImport but reversed so its a pain. 
fn write_export_bounce(self: *EmitLlvm, fid: FuncId) void = {
    func := self.program.get_function(fid);
    export_name := self.program.pool.get(func.name);
    internal_name: List(u8) = list(temp()); 
    self.fmt_fn_name(fid, internal_name&);
    
    f_ty := func.finished_ty().unwrap();
    cc := func.cc.unwrap();
    sig := self.program.prim_sig(f_ty, cc).unwrap();
    self.emit_bounce_fn(internal_name.items(), export_name, sig, false);
}

fn emit_constant(self: *EmitLlvm, id: BakedVarId) void = {
    self.out&.reserve(100);
    value := self.program.get_baked(id)[]._1;
    idx: i64 = id.id.zext();
    
    @match(value&) {
        (fn Zeros(len) => {
            @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i8] zeroinitializer\n", idx, len[]);
        });
        (fn Bytes(bytes) => {
            // TODO: emit string as characters if they're in a sane range. 
            @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x i8] [", idx, bytes.len + 1);
            for(bytes[].items()) {b|
                @fmt(self.out&.current(), " i8 %,", @as(i64) b.zext());
            };
            // self.pop_trailing_comma(); // add back when remove below
            self.out&.push_all("i8 0]\n"); // TODO: hack cause im to lazy to ask for debug names as cstr
        });
        (fn VoidPtrArray(parts) => {
            @fmt(self.out&.current(), "@g% = private unnamed_addr global [% x ptr] [", idx, parts.len);
            for(parts[].items()){inner|
                self.out&.reserve(20);
                @match(inner) {
                    (fn FnPtr(f) => {
                        f = self.program.follow_redirects(f);  // TODO: hack because of new deduplication
                        @fmt(self.out&.current(), "ptr @%,", (self, f));
                        // TODO: make sure we emitted the function. 
                    });
                    (fn AddrOf(id) => {
                        @fmt(self.out&.current(), "ptr @g%,", @as(i64) id.id.zext());
                    });
                    (fn Num(v) => {
                        // TODO: small prims
                        @fmt(self.out&.current(), "ptr inttoptr (i64 % to ptr),", v.value);
                    });
                };
            };
            self.pop_trailing_comma();
            self.out&.push_all("]\n");
        });
    }
}

fn emit_special(self: *EmitLlvm, body: *FuncImpl, func: *Func, bc: *FnBody, pending: *List(FuncId)) bool = {
    @match(body) {
        fn Normal(_) => { panic("ICE: empty body but expr"); };
        fn Redirect(f) => {
            // TODO: assert that 'f' is flagged for being emitted?
            //       currently just trusting that emit_bc replaced all actual uses. 
            //       could also just have the front end check if body is redirect before adding to callees list. -- Jun 27
            
            pending.push(f[]);
            return(true);
        }
        fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special(check, func, bc, pending), => return(true));
            };
        }
        fn DynamicImport(name) => { 
            // TODO: do i need to hackily do the same for ComptimeAddr and hope for the best? ideally the forntend would handle that instead. 
            import_name := self.program.pool.get(name[]);
            self.forward_declare(bc.signeture, false, import_name);
            name := @format("%", (self, bc.func)) temp();
            self.emit_bounce_fn(import_name, name.items(), bc.signeture, true);
            return(true);
        }
        fn LlvmIr(code) => { 
            self.next_var = 0;
            ir := self.program.pool.get(code[]);
            self.out&.push_all("define private ccc ");
            name := @format("%", (self, bc.func)) temp();
            self.write_header(bc.signeture, name.items()) {arg_index|
                args := func.arg.bindings.items();
                arg := args[arg_index].name.Var.name;
                arg := self.program.pool.get(arg);
                arg := @format("%%", "%", arg) temp();
                self.next_var += 1;
                arg.items()
            };
            @fmt(self.out&.current(), "{\n%}\n", ir);
            return(true);
        }
        @default fn() void => return(false);
    };
    false
}

fn forward_declare(self: *EmitLlvm, sig: PrimSig, private: bool, name: Str) void = {
    self.out&.push_all("declare ccc ");
    if private {|
        self.out&.push_all("private ");
    };
    self.write_header(sig, name) {arg_index| (@format("%v%", "%", arg_index) temp()).items() };
    self.out&.push_all(";\n");
}

fn emit_special_asm(self: *EmitLlvm, body: *FuncImpl, func: *Func, bc: *FnBody, arch: Arch) bool = {
    @match(body) {
        (fn Merged(parts) => { 
            each(parts[].items()) {check: *FuncImpl| 
                if(self.emit_special_asm(check, func, bc, arch), => return(true));
            };
        });
        (fn JittedAarch64(code) => { 
            if(arch.ne(Arch.Aarch64), => { return(false); });
            name := @format("%", (self, bc.func)) temp();
            self.forward_declare(bc.signeture, false, name.items());
            
            @fmt(self.out&.current(), "module asm \"_%:\"\n", (self, bc.func));
            for code { inst |
                v := @as(i64) inst.zext();
                @fmt(self.out&.current(), "module asm \".word %\"\n", v);
            };
            
            return(true);
        });
        @default fn() void => return(false);
    };
    false
}

fn write_header(self: *EmitLlvm, sig: PrimSig, name: Str, $get_arg_name: @Fn(idx: i64) Str) void = {
    self.out&.reserve(50);
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            @fmt(self.out&.current(), "%", llvm_pair_type(fst, snd));
        }{| // one
            @fmt(self.out&.current(), "%", fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("void");
    };
    @fmt(self.out&.current(), " @%(", name);
    
    // TODO: don't have two callsites for get_arg_name
    shift := if(sig.first_arg_is_indirect_return) {|
        size: i64 = sig.return_value_bytes.zext();
        // note: when calling through function pointers, you need to put the sret attribute there as well (large_struct_ret_return tests this).
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, get_arg_name(0));
        1
    }{| 0 };
    
    enumerate(sig.args) {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        @fmt(self.out&.current(), "% %,", ty[].llvm_type(), get_arg_name(i)); 
    };
    self.pop_trailing_comma();
    self.out&.current().push_all(")");
}

fn setup(self: *EmitLlvm, body: *FnBody, vars_out: *List(EmitLlvm.Val)) void = {
    self.out&.push_all("entry:\n");
    self.next_var = 0;
    // TODO: waste for ssa vars, they just get set to the value. -- Jun 14
    vars := body.vars.items();
    do_debug := self.program.get_build_options()[].debug_info;
    enumerate(vars) {i, ty|
        v := self.get_var(.P64);
        vars_out.push(v);
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   % = alloca i8, i32 %, align %\n", v, @as(i64) ty.size.zext(), @as(i64) ty.align.zext()); // uhg % was a bad choice. 
        if do_debug && body.var_names.len > i {|
            if body.var_names[i] { name | 
                name := self.program.pool.get(name.name);
                local := self.next_debug();
                location := self.next_debug();
                scope := self.current_debug_info;
                @fmt(self.debug_info&, "!% = !DILocalVariable(name: \"%\", scope: !%, file: !%, type: !%)\n",
                    local, name, scope, self.debug_file, self.debug_addr_type);
                @fmt(self.debug_info&, "!% = !DILocation(line: 1, column: 1, scope: !%)\n", location, scope);
                // because the hardest part of compilers is how few times you need to write the word "metadata" apparently 
                template :: "    call void @llvm.dbg.declare(metadata ptr %, metadata !%, metadata !DIExpression()), !dbg !%\n";
                @fmt(self.out&.current(), template, v, local, location);
            };
        };
    };
    // TODO: use phi nodes cause this is stupid but that's such a pain in the ass. 
    // I use these for block arguments. 
    max_args := 0;
    each(body.blocks.items()){b|
        max_args = max_args.max(b.arg_prims.len);
    };
    range(0, max_args) {i|
        self.out&.reserve(30); 
        @fmt(self.out&.current(), "   %a% = alloca i64\n", "%", i); // uhg % was a bad choice. 
    };
    shift := if body.signeture.first_arg_is_indirect_return {|
        @fmt(self.out&.current(), " store ptr %arg0, ptr %a0\n", "%", "%");
        1
    }{| 0 };
    enumerate body.signeture.args {i, ty|
        self.out&.reserve(20);
        i := i.add(shift);
        // TODO: ty.llvm_type() error says it wants the raw type but found enum ptr when it should say wants the enum type
        @fmt(self.out&.current(), "   store % %arg% , ptr %a%\n", ty[].llvm_type(), "%", i, "%", i); 
    };
    self.out&.push_all("   br label %b0\n"); 
}

fn fmt_fn_name(self: *EmitLlvm, f: FuncId, out: *List(u8)) void = {
    if self.program.get_build_options()[].retain_function_names {|
        func := self.program.get_function(f);
        real_name := self.program.pool.get(func.name);
        @fmt(out, "%__%", real_name, f.to_index());
    } else {|
        @fmt(out, "F%", f.to_index());
    }
}

fn display(self: Ty(*EmitLlvm, FuncId), out: *List(u8)) void = {
    self._0.fmt_fn_name(self._1, out)
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, f: FuncId, tail: bool) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        self.out&.current().push_all("@");
        self.fmt_fn_name(f, self.out&.current());
    }
}

// For float cmp, 
// - o=ordered: false if either is nan
// - u=unordered: true if either is nan
// Which is interesting because it means the NaN != NaN thing isn't real, they just all choose that for some reason. 
fn inst_intrinsic(self: *EmitLlvm, args: Slice(LlvmVal), op: Intrinsic) Slice(EmitLlvm.Val) = {
    bin :: fn(self: *EmitLlvm, args: Slice(LlvmVal), op: Str) Slice(EmitLlvm.Val) = {
        out := self.get_var(args[0].ty);
        @fmt(self.out&.current(), "   % = % %, %\n", out, op, args[0], args[1]);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    bin_cmp :: fn(self: *EmitLlvm, args: Slice(LlvmVal), op: Str) Slice(EmitLlvm.Val) = {
        temp_bool := self.get_var(.I8);
        out := self.get_var(.I8);
        @fmt(self.out&.current(), "   % = % %, %\n", temp_bool, op, args[0], args[1]);
        @fmt(self.out&.current(), "   % = zext i1 % to i8", out, temp_bool);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    cast :: fn(self: *EmitLlvm, args: Slice(LlvmVal), out: Prim, pre: Str, post: Str) Slice(EmitLlvm.Val) = {
        out := self.get_var(out);
        @fmt(self.out&.current(), "   % = % % %\n", out, pre, args[0], post);
        a := temp().alloc(LlvmVal, 1);
        a.ptr[] = out;
        a
    };
    
    @match(op) {
        fn Add() => self.bin(args, "add i64");
        fn Sub() => self.bin(args, "sub i64");
        fn Mul() => self.bin(args, "mul i64");
        fn Div() => self.bin(args, "sdiv i64");
        fn Eq() => self.bin_cmp(args, "icmp eq i64");
        fn Ne() => self.bin_cmp(args, "icmp ne i64");
        fn Le() => self.bin_cmp(args, "icmp sle i64");
        fn Ge() => self.bin_cmp(args, "icmp sge i64");
        fn Lt() => self.bin_cmp(args, "icmp slt i64");
        fn Gt() => self.bin_cmp(args, "icmp sgt i64");
        fn PtrToInt() => self.cast(args, .I64, "ptrtoint ptr", "to i64"); 
        fn IntToPtr() => self.cast(args, .P64, "inttoptr i64", "to ptr"); 
        fn ShiftLeft()            => self.bin(args, "shl i64");
        fn ShiftRightLogical()    => self.bin(args, "lshr i64");
        fn ShiftRightArithmetic() => self.bin(args, "ashr i64");
        fn BitOr()  => self.bin(args, "or i64");
        fn BitAnd() => self.bin(args, "and i64");
        fn BitXor() => self.bin(args, "xor i64");
        fn FAdd() => self.bin(args, "fadd double");
        fn FSub() => self.bin(args, "fsub double");
        fn FMul() => self.bin(args, "fmul double");
        fn FDiv() => self.bin(args, "fdiv double");
        fn FEq() => self.bin_cmp(args, "fcmp oeq double");
        fn FNe() => self.bin_cmp(args, "fcmp one double");
        fn FLe() => self.bin_cmp(args, "fcmp ole double");
        fn FGe() => self.bin_cmp(args, "fcmp oge double");
        fn FLt() => self.bin_cmp(args, "fcmp olt double");
        fn FGt() => self.bin_cmp(args, "fcmp ogt double");
        fn Trunc64To32() => self.cast(args, .I32, "trunc i64", "to i32"); 
        fn Trunc64To16() => self.cast(args, .I16, "trunc i64", "to i16"); 
        fn Trunc64To8()  => self.cast(args,  .I8, "trunc i64", "to i8"); 
        fn Trunc32To16() => self.cast(args, .I16, "trunc i32", "to i16"); 
        fn Trunc32To8()  => self.cast(args,  .I8, "trunc i32", "to i8"); 
        fn Trunc16To8()  => self.cast(args,  .I8, "trunc i16", "to i8"); 
        fn SignExtend32To64() => self.cast(args,  .I64, "sext i32", "to i64"); 
        fn ZeroExtend32To64() => self.cast(args,  .I64, "zext i32", "to i64"); 
        fn ZeroExtend16To64() => self.cast(args,  .I64, "zext i16", "to i64"); 
        fn ZeroExtend8To64()  => self.cast(args,  .I64, "zext i8", "to i64"); 
        fn ZeroExtend16To32() => self.cast(args,  .I32, "zext i16", "to i32"); 
        fn ZeroExtend8To32()  => self.cast(args,  .I32, "zext i8", "to i32"); 
        fn ZeroExtend8To16()  => self.cast(args,  .I16, "zext i8", "to i16"); 
        fn IntToFloatValue()  => self.cast(args,  .F64, "sitofp i64", "to double"); 
        fn FloatToIntValue()  => self.cast(args,  .I64, "fptosi double", "to i64"); 
        fn IntToFloatBits()   => self.cast(args,  .F64, "bitcast i64", "to double"); 
        fn FloatToIntBits()   => self.cast(args,  .I64, "bitcast double", "to i64"); 
        fn ShrinkFloat()      => self.cast(args,  .F32, "fptrunc double", "to float"); 
        fn GrowFloat()        => self.cast(args,  .F64, "fpext float", "to double"); 
        fn BitNot()           => self.cast(args,  .I64, "xor i64", ", -1"); 
        @default => @panic("ICE: unhandled LLVM inst_intrinsic");
    }
}

fn inst_call(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, $do_call: @Fn() void) Slice(EmitLlvm.Val) = {
    self.out&.reserve(30);
    
    out_vals: List(LlvmVal) = list(temp());
    if(sig.ret1) {fst: Prim|
        if(sig.ret2) {snd: Prim| // two
            out_vals&.push(self.get_var(fst));
            out_vals&.push(self.get_var(snd));
            @fmt(self.out&.current(), "   %v% = call % ", "%", self.next_var, llvm_pair_type(fst, snd));
            self.next_var += 1;
        }{| // one
            v := self.get_var(fst);
            out_vals&.push(v);
            @fmt(self.out&.current(), "   % = call % ", v, fst.llvm_type());
        };
    }{| // void or indirect
        self.out&.current().push_all("   call void ");
    };
    maybe_struct_out := self.next_var.sub(1);
    
    do_call();
    
    self.out&.push_all("(");
    shift := if(sig.first_arg_is_indirect_return) {|
        size: i64 = sig.return_value_bytes.zext();
        // note: the sret must match the declaration! not doing this breaks large_struct_ret_return and compiler driver dylib ffi. 
        @fmt(self.out&.current(), " ptr sret([% x i8]) %,", size, args[0]);
        1
    }{| 0 };
    @assert_eq(args.len, sig.args.len.add(shift));
    
    range(0, sig.args.len) {i|
        ty := sig.args[i];
        v := args[i.add(shift)];
        self.out&.reserve(30);
        ::assert_eq(Prim);
        //assert_eq(ty, v.ty); // TODO
        @fmt(self.out&.current(), " % %,", ty.llvm_type(), v);
    };
    self.pop_trailing_comma();
    
    self.out&.current().push_all(")");
    
    if self.program.get_build_options()[].debug_info && self.current_debug_info != 0 {|
        // TODO: line info
        // Fixes "inlinable function call in a function with debug info must have a !dbg location"
        location := self.next_debug();
        @fmt(self.debug_info&, "!% = !DILocation(line: 1, column: 1, scope: !%)\n", location, self.current_debug_info);
        @fmt(self.out&.current(), ", !dbg !%", location);
    };
    
    self.out&.current().push_all("\n");
    if(sig.ret2) {_| // two
        v1 := out_vals[0];
        v2 := out_vals[1];
        self.out&.reserve(30);
        p := llvm_pair_type(v1.ty, v2.ty);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 0\n", v1, p, "%", maybe_struct_out);
        @fmt(self.out&.current(), "   % = extractvalue % %v%, 1\n", v2, p, "%", maybe_struct_out);
    };
    
    out_vals.items()
}

fn pop_trailing_comma(self: *EmitLlvm) void = {
    // they don't allow trailing comma because they hate us personally 
    if(self.out&.current().items().ends_with(",")) {|
        // TODO: access fields on lvalues. `self.out&.current().len += 1` should work
        l := self.out&.current();
        l.len -= 1;
    };
}

fn inst_trap(self: *EmitLlvm) void = {
    // i think trap makes it crash instead of ub and it seems you need unreachable for it to believe the block is finished. 
    self.out&.push_all("   call void @llvm.trap()\n   unreachable\n");
}

fn inst_call_ptr(self: *EmitLlvm, args: Slice(LlvmVal), sig: PrimSig, ptr: EmitLlvm.Val) Slice(EmitLlvm.Val) = {
    self.inst_call(args, sig) {|
        @fmt(self.out&.current(), "%", ptr);
    }
}

fn inst_offset(self: *EmitLlvm, ptr: EmitLlvm.Val, bytes: u16) EmitLlvm.Val = {
    temp := self.get_var(.I64);
    new := self.get_var(.I64);
    done := self.get_var(.P64);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = ptrtoint ptr % to i64\n", temp, ptr); 
    @fmt(self.out&.current(), "   % = add i64 %, %\n", new, temp, @as(i64) bytes.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", done, new); 
    done
}

MAX_I32 :: 1.shift_left(32).sub(1);

fn inst_literal(self: *EmitLlvm, value: i64, ty: Prim) EmitLlvm.Val = {
    v := self.get_var(ty);
    self.out&.reserve(100);
    // TODO: use @switch here. 
    if(ty.eq(.F64)){|
        // for f64, llvm wants the bits as hex. 
        h := fmt_hex(value);
        @fmt(self.out&.current(), "   % = fadd double %, 0.0\n", v, h); 
    } {|
        if(ty.eq(.F32)){|
            // for f32, llvm wants an f64 as hex that happens to be exactly representable as f32. 
            // but we store it as an f32 on the bottom with the high bits zeroed. 
            assert(value.lt(MAX_I32), "ICE: too many bits for f32");
            value: u32 = value.trunc();    // the bits we want to load
            value: f32 = value.bitcast();  // the number we want to load
            value: f64 = value.cast();     // the same numerical value
            value: i64 = value.bitcast();  // the bits we need to give llvm
            // TODO: does it change if you try to print here??????
            h := fmt_hex(value);
            @fmt(self.out&.current(), "   % = fadd float %, 0.0\n", v, h); 
        } {|
            if(ty.eq(.P64)) {|
                @assert_eq(value, 0); // a literal pointer that isn't null doesn't make sense for AOT.
                @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, value); 
            } {|
                // TODO: better error message if you forget an argument
                // TODO: just track constants myself in Val? you can't just assign to a constsant int. 
                @fmt(self.out&.current(), "   % = add % %, 0\n", v, ty.llvm_type(), value); 
            }
        };
    };
    v
}

// TODO: need to sign extend sometimes. 
fn inst_load(self: *EmitLlvm, addr: EmitLlvm.Val, ty: Prim) EmitLlvm.Val = {
    value := self.get_var(ty);
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   % = load %, ptr %\n", value, ty.llvm_type(), addr); 
    value
}

fn inst_store(self: *EmitLlvm, addr: EmitLlvm.Val, value: EmitLlvm.Val, ty: Prim) void = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   store % %, ptr %\n", ty.llvm_type(), value, addr); 
}

fn inst_copy(self: *EmitLlvm, from: EmitLlvm.Val, to: EmitLlvm.Val, bytes: u16) void = {
    self.out&.reserve(30);
    @fmt(self.out&.current(), "   call void @llvm.memcpy.p0.p0.i32(ptr %, ptr %, i32 %, i1 false)\n", to, from, @as(i64) bytes.zext()); 
}

fn inst_func_ref(self: *EmitLlvm, fid: FuncId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @% to i64\n", temp, (self, fid));
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_global(self: *EmitLlvm, id: BakedVarId) EmitLlvm.Val = {
    v := self.get_var(.P64);
    self.out&.reserve(30);
    temp := self.get_var(.P64);
    @fmt(self.out&.current(), "   % = ptrtoint ptr @g% to i64\n", temp, @as(i64) id.id.zext()); 
    @fmt(self.out&.current(), "   % = inttoptr i64 % to ptr\n", v, temp); 
    v
}

fn inst_jump_if(self: *EmitLlvm, cond: EmitLlvm.Val, true: BbId, false: BbId, args: Slice(EmitLlvm.Val)) void = {
    assert(args.len.eq(0), "i dont use this yet");
    self.out&.reserve(40);
    c := self.get_var(.I8);
    @fmt(self.out&.current(), "   % = trunc i8 % to i1\n", c, cond); 
    @fmt(self.out&.current(), "   br i1 %, label %b%, label %b%\n", c, "%", @as(i64) true.id.zext(), "%", @as(i64) false.id.zext()); 
}

fn inst_jump(self: *EmitLlvm, always: BbId, args: Slice(EmitLlvm.Val)) void = {
    enumerate(args){i, arg|
        self.out&.reserve(50);
        @fmt(self.out&.current(), "   store % %, ptr %a%\n", arg.ty.llvm_type(), arg[], "%", i); 
    };
    self.out&.reserve(20);
    @fmt(self.out&.current(), "   br label %b%\n", "%", @as(i64) always.id.zext()); 
}

fn inst_switch(self: *EmitLlvm, info: *RsVec(SwitchPayload), inspected: LlvmVal) void = {
    (normal_branches, default) := info.decode_switch();
    @fmt(self.out&.current(), "   switch i64 %, label ", inspected); 
    
    assert(default.is_some(), "TODO: allow match with no default, no safety check?");
    if default { default_block |
        @fmt(self.out&.current(), "%b%", "%", @as(i64) default_block.id.zext()); 
    };
    
    self.out&.current().push_all("[");
    for normal_branches { case | 
        self.out&.reserve(20);
        @fmt(self.out&.current(), "i64 %, label %b%\n", case.value, "%", @as(i64) case.block.id.zext()); 
    };
    self.out&.current().push_all("]");
}
            
fn inst_return(self: *EmitLlvm, args: Slice(EmitLlvm.Val)) void = {
    self.out&.reserve(100);
    @switch(args.len){
        @case(0) => {
            self.out&.current().push_all("   ret void\n");
        };
        @case(1) => {
            @fmt(self.out&.current(), "   ret % %\n", args[0].ty.llvm_type(), args[0]); 
        };
        @case(2) => {
            self.next_var += 2;
            pair := llvm_pair_type(args[0].ty, args[1].ty);
            @fmt(self.out&.current(), "   %v% = insertvalue % undef, % %, 0\n", "%", self.next_var.sub(2), pair, args[0].ty.llvm_type(), args[0]); 
            @fmt(self.out&.current(), "   %v% = insertvalue % %v%, % %, 1\n", "%", self.next_var.sub(1), pair, "%", self.next_var.sub(2), args[1].ty.llvm_type(), args[1]); 
            @fmt(self.out&.current(), "   ret % %v%\n", pair, "%", self.next_var.sub(1)); 
        };
        @default fn() => unreachable();
    };
}

fn move_to_block(self: *EmitLlvm, block: *BasicBlock, ip: BbId) Slice(EmitLlvm.Val) = {
    self.out&.reserve(100);
    @fmt(self.out&.current(), "b%:\n", @as(i64) ip.id.zext()); 
        
    self.current = ip;
    args: List(EmitLlvm.Val) = list(block.arg_prims.len, temp());
    
    enumerate(block.arg_prims) {i, ty| 
        self.out&.reserve(20);
        v := self.get_var(ty[]);
        args&.push(v);
        @fmt(self.out&.current(), "   % = load %, ptr %a%\n", v, ty[].llvm_type(), "%", i); 
    };
    args.items()
}

fn get_var(self: *EmitLlvm, ty: Prim) LlvmVal = {
    v: LlvmVal = (ty = ty, id = self.next_var);
    self.next_var += 1;
    v
}

fn display(self: LlvmVal, out: *List(u8)) void = {
    @fmt(out, "%v%", "%", self.id);
}
::enum(Prim);

// TODO: these are super clunky, you want to have 'or' in switch cases. 
fn llvm_type(ty: Prim) Str = @switch(ty) {
    @case(.I8) => "i8";
    @case(.I16) => "i16";
    @case(.I32) => "i32";
    @case(.I64) => "i64";
    @case(.F64) => "double";
    @case(.F32) => "float";
    @case(.P64) => "ptr";
};

fn llvm_pair_type(a: Prim, b: Prim) Str = {
    s := @format("{ %, % }", a.llvm_type(), b.llvm_type()) temp();
    s.items()
}
