#include_std("compiler/emit_bc.fr");
#include_std("compiler/ast_external.fr");  
#include_std("compiler/backend/llvm.fr");
#include_std("compiler/backend/aarch64.fr");
#include_std("compiler/backend/x64.fr");  
#include_std("compiler/backend/jit.fr");  

BcBackend :: @struct(
    jitted: Jitted,
    bytecodes: BucketArray(FnBody),
    // TODO: just always use .Aot and make this a set?
    saved_bytecodes: HashMap(*FnBody, ExecStyle),
    free_bytecodes: List(*FnBody),
);
    
fn create(c: CompCtx) *BcBackend = {
    a := c.get_alloc();
    b := a.box(BcBackend);
    b[] = (
        // TODO: inline Jitted.new() here once this is the only place we call it. 
        jitted = new(1.shift_left(28)), // Its just virtual memory right? I really don't want to ever run out of space and need to change the address.
        bytecodes = init(10, a),
        saved_bytecodes = init(a),
        free_bytecodes = list(a),
    );
    b
}

fn destroy(self: *BcBackend, c: CompCtx) void = {
    page_allocator.dealloc(u32, self.jitted.mmapped);
}

// TODO: use #target_arch but that's not a thing yet.
fn jit_asm(self: *BcBackend, c: CompCtx, f: FuncId, body: *FnBody, comptime_arch: Arch) CRes(Ty([]u8, []FuncId)) = {
    (Ok = @match(comptime_arch) {
        fn aarch64() => {
            a: EmitArm64 = new(c.data.cast(), self, body);
            (a&.compile(f), a.forward_calls.items())
        }
        fn x86_64() => {
            a: EmitX64 = new(c.data.cast(), self, body);
            (a&.compile(f), a.forward_calls.items())
        }
        fn wasm32() => panic("unreachable: compiler doesn't support wasm yet");
    })
}

fn jit_shim(self: *BcBackend, c: CompCtx, fid: FuncId, handler: rawptr) CRes(*FnBody) = {
    create_jit_shim(c, self, fid, handler)
}

// get_fn_callable, get_fn_old
fn get_jitted(self: *BcBackend, c: CompCtx, f: FuncId, make_exec: bool) ?rawptr = {
    addr := get_already_jitted(self, c, f);
    if(make_exec && addr.is_some(), => self.jitted&.bump_dirty());
    addr
}

fn asm_bytes(bc: *BcBackend, c: CompCtx, fid: FuncId, bytes: []u8) rawptr = {
    bc.jitted&.mark_start(fid);
    bc.jitted&.push_bytes_asm(bytes);
    code := bc.jitted&.save_current(fid);
    u32.raw_from_ptr(code.ptr)
}

