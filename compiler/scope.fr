//! - TODO: destructuring vars get declared before the value is resolved so shadowing doesn't work properly. 

TRACK_SCOPES :: false;

/// Query interface /// 

fn put_constant(self: *Scopes, name: Var, value: FatExpr, ty: LazyType) void = {
    @debug_assert(name.kind == .Const);
    ptr := self.get_var_data(name);
    ptr.expr = value;
    ptr.set_type(ty);
    ptr.ready = true;
}

fn set_type(ptr: *VarData, ty: LazyType) void #inline = {
    ::ptr_utils(LazyType);
    if !@is(ty&, .Infer, .Finished) {
        if ptr.nullable_type.is_null() {
            ptr.nullable_type = current_comptime().get_alloc().box(LazyType);
        };
        ptr.nullable_type[] = ty;
    };
    @if_let(ty&) fn Finished(it) => {
        ptr.inferred = it[];
    };
    ptr.ready = true;
} 

fn get_var_data(self: *Scopes, name: Var) *VarData #inline = 
    self.variables&.nested_index(name.id.id.zext());

fn get_type(c: *VarData) Type = {
    c.inferred
}
    
fn get_var_type(self: *Scopes, v: Var) ?*VarData #inline = {
    c := self.get_var_data(v);
    @if(c.inferred == UnknownType, .None, (Some = c))
}

fn put_var_type(self: *Scopes, v: Var, ty: Type) bool = {
    slot := self.get_var_data(v);
    is_new := slot.inferred == UnknownType;
    slot.inferred = ty;
    is_new
}

fn get_constant(self: *Scopes, name: Var) ?*VarData #inline = {
    ::as_ref(VarData);
    @debug_assert(name.kind == .Const);
    c := self.get_var_data(name);
    @if(c.ready, (Some = c), .None)
}

// The #inline is important
fn maybe_stack_allocated_type(var: *VarData) *LazyType #inline = {
    type := var.nullable_type;
    ::ptr_utils(LazyType);
    if type.is_null() {
        storage: LazyType = @if(var.inferred == UnknownType, 
            .Infer, (Finished = var.inferred));
        type = storage&; 
    };
    type
}

/// Resolver Interface. Called lazily by the compiler when it first works on a new function. /// 

fn resolve_root(compiler: *SelfHosted, func: *Func, scope: ScopeId) PRes #once = {
    r: ResolveScope = new(compiler, scope, func.loc);
    
    zone := zone_begin(.Scope); // TODO: defer
    res := r&.resolve_func(func);
    zone_end(zone);
    res
}

fn resolve_sign(self: *SelfHosted, func: *Func) PRes #once = {
    s := func.resolve_scope;
    @debug_assert_ne(s, NOSCOPE, "function must have scope %", self.comp().log(func));
    r: ResolveScope = new(self, s, func.loc);
    zone := zone_begin(.Scope); // TODO: defer
    res := r&.resolve_func_args(func);
    zone_end(zone);
    res
}

fn resolve_body(compiler: *SelfHosted, func: *Func) PRes #once = {
    @debug_assert_ne(func.resolve_scope, NOSCOPE, "function must have scope");
    r: ResolveScope = new(compiler, func.resolve_scope, func.loc);
    
    zone := zone_begin(.Scope); // TODO: defer
    res := r&.resolve_func_body(func);
    zone_end(zone);
    res
}

/// Renumbering interface ///

fn dup_var(self: *Scopes, old: Var) Var = {
    new := old;
    new.id.id = self.variables.len.trunc();
    // EvilUninit
    dest := self.variables&.push_uninit();
    dest.slice(1).set_zeroed();  // TODO: bit odd that i dont have to clone if the old thing had a constant expr. 
    old_data := self.variables&.nested_index(old.id.id.zext());
    dest.took_address = old_data.took_address;
    dest.expr.loc = old_data.expr.loc;
    new
}

// For unquoting, initial will be None, but for inlining closures, it will be the return variable. 
fn renumber_expr(self: *SelfHosted, expr: *FatExpr, initial: ?Ty(Var, Var)) void = {
    mapping: RenumberResults = init();
    if initial& { i |
        mapping.vars&.insert(i._0, i._1);
    };
    renumber: RenumberVars = (scope = self.scopes, mapping = mapping&, compiler = self);
    renumber&.walk_expr(expr).unwrap();
}

/// Implementation /// 

// TODO: why does this have to be @rec only when targetting linux?? this feels like a bug?? -- Mar 13, 2025
Scopes :: @rec @struct(
    scopes: BucketArray(Scope),
    // Indexed by var id.
    // Invarient: all but last bucket are full. Never push_all since that might allocate a non full bucket and then indexes will be wrong. 
    // :push_type_when_create_new_var when i start creating new vars elsewhere, need to remember to push a none here! didn't have to in the old version because it was a hashmap.
    // now its hard to forget cause i use that len instead of self.next_var too.
    variables: BucketArray(VarData),
    // Used for not redundantly #include_std-ing. 
    // TODO: This will become a HashMap(Symbol, ScopeId) when I want to allow @import-ing a namespace. 
    //       so currently Lib :: @namespace { #include_std("name"); }; doesn't work unless its the only time which is kinda dumb. 
    //       but it didn't work in the rust version and i don't want to change too much at once. 
    already_loaded: HashSet(Symbol),
);

// 
// Sources of constants that will have a value in the expr field:
// - constant declarations (`name :: value`)
// - function return/local_return labels
// - overload sets
// - $const function parameter
// - default field value / constant field
// 
// VarIds are assigned early in scope.fr and expressions are hoisted later  
// by calling put_constant in sema.fr, so there's a window of time 
// where expr.is(Poison) and get_constant() will return None. 
// 
// Runtime variables (`name := value`), but not fields, have an entry that 
// stores their type (after it's infered) and declaration location but no 
// value and no LazyType (since they go through sema sequentially). 
// 

VarData :: @struct {
    // `expr.loc` is valid even when Poison
    expr: FatExpr;
    // `nullable_type` is null for Infer/Finished. use `inferred` instead.
    nullable_type: *LazyType;
    inferred: Type; // TODO: remove this. it should be the same as type.Finished
    took_address: bool;
    ready: bool;
};

Scope :: @struct(
    parent: ScopeId,
    vars: RawList(Var),
    lookup := zeroed RawHashMap(Symbol, Var),
    nullable_use: *UseScopes,
    visit := 0,
    loc: Span,
);

UseScopes :: @struct(
    parents: RawList(UseScopeEntry),
);

UseScopeEntry :: @struct(
    who: @tagged(
        Scope: ScopeId,
        PendingEval: Var,
    ),
    reexport: bool,
);

fn index(self: *Scopes, i: ScopeId) *Scope = {
    i := i.as_index();
    self.scopes&.nested_index(i)
}

fn as_index(i: ScopeId) i64 = {
    a := ptr_cast_unchecked(ScopeId, u32, i&)[];
    a.zext()
}

fn new_scope(self: *Scopes, parent: ScopeId, a: Alloc, loc: Span) ScopeId = {
    s: Scope = (
        vars = empty(), 
        parent = parent,
        nullable_use = UseScopes.ptr_from_int(0),
        loc = loc,
    );
    self.scopes&.push(s);
    scope_from_index(self.scopes.len.sub(1).trunc())
}

ResolveScope :: @struct(
    captures: List(Var),
    compiler: *SelfHosted,
    scope: ScopeId,
    top_level := false,
);

fn new(compiler: *SelfHosted, scope: ScopeId, last_loc: Span) ResolveScope = (
    captures = list(temp()),
    compiler = compiler,
    scope = scope,
);

fn resolve_func(self: *ResolveScope, func: *Func) PRes = {
    if(func.get_flag(.ResolvedBody).and(func.get_flag(.ResolvedSign)), => return(.Ok)); 
    
    // TODO: need to remember to update from this if we get one from the user (like they added it in a macro)?
    each func.annotations { a |
        @switch(a.name) {
            @case(Flag.generic.ident()) => func.set_flag(.Generic);  // TODO: could remove from func.annotations but it doesn't actually matter. 
            @case(Flag.where.ident()) => {
                func.set_flag(.Generic);
                func.set_flag(.UnboundGenerics);
            };
            @default => ();
        };
    };

    self.push_scope(func.loc);
    func.resolve_scope = self.scope;

    if func.get_flag(.AllowRtCapture) {
        @try(self.resolve_func_args(func)) return;
        @try(self.resolve_func_body(func)) return;
    } else {
        self.pop_scope();
    };

    .Ok
}

fn resolve_func_args(self: *ResolveScope, func: *Func) PRes = {
    if(func.get_flag(.ResolvedSign), => return(.Ok));
    @debug_assert_ne(func.resolve_scope, NOSCOPE, "function must have scope");
    self.scope = func.resolve_scope;
    
    has_use := false;
    each func.annotations { a |
        @switch(a.name) {
            @case(Flag.use.ident()) => @try(add_use(self, a, false)) return;
            @case(Flag.reexport.ident()) => @try(add_use(self, a, true)) return;
            @default => ();
        };
    };
    
    generic := func.get_flag(.Generic); // ret is allowed to depend on previous args.
    func.set_flag(.ResolvedSign);
    
    // TODO: maybe it's dumb to make you type #where if you want to auto-template the parameters for every call.
    //       could allow you to just not specify the parameter types and infer that as #where(=> true). 
    //       but then you need to make sure that works out to what you'd expect when it's a closure literal with a result location hint. 
    //       -- Mar 24, 2025
    if func.get_flag(.UnboundGenerics) {
        enumerate func.arg.bindings { i, b |
            if b.ty&.is(.Infer) { 
                name := self.compiler.pool.insert_borrowed(@tfmt("_%", i), self.compiler.get_alloc());
                b.ty = (UnboundGeneric = name);
            };
            @if_let(b.ty&) fn UnboundGeneric(name) => {
                var := @try(self.decl_var(name[], .Const, func.loc, .Generic)) return;
                b.ty = (Generic = var);
            };
        };
    };
    
    if generic {
        each func.arg.bindings { b |
            @try(self.declare_binding(b, func.loc, true)) return;
        };
    };
    
    each func.annotations { a | 
        @try(self.walk_expr(a.args&)) return;
    };
    
    each func.arg.bindings { b |
        @try(self.resolve_binding(b)) return;
    };
    @try(self.walk_type(func.ret&)) return;
    self.pop_block();
    // TODO: allow block exprs with consts in arg types but for now i dont use it and this is easier to think about. -- Apr 24
    .Ok
}

// save_scope_as is used for avoiding infinite recursion when we just made a new function for an import
fn value_to_scope(self: *SelfHosted, value: Values, type: Type, save_scope_as: ?Symbol) Res(ScopeId) = {
    // :get_or_create_type
    if type == ScopeId {
        return(Ok = ScopeId.assume_cast(value&)[]);
    };
    if type == Type {
        type := Type.assume_cast(value&)[];
        info := self.get_type(raw_type(self.comp(), type));
        @err_assert(info.is(.Struct), "can only #use structs, not %", self.log_type(type)) return;
        return(Ok = info.Struct.scope);
    };
    if type == FuncId || self.get_type(type).is(.Fn) {
        fid := FuncId.assume_cast(value&)[];
        use_func := self.get_function(fid);
        if use_func.use_scope == NOSCOPE {
            @try(self.resolve_sign(use_func)) return;
            @try(self.resolve_body(use_func)) return;
            @err_assert(use_func.body&.is(.Normal), "#use fn no body") return;
            e := use_func.body.Normal&;
            @err_assert(e.expr&.is(.Block), "#use fn non Block body %", self.comp().log(use_func)) return;
            @debug_assert(!(e.expr.Block.scope == NOSCOPE), "ICE: #use unresolved block"); 
            use_func.use_scope = e.expr.Block.scope;
            if save_scope_as { name |
                self.imports.insert(name, use_func.use_scope);
            };
            _ := @try(self.poll_in_place(void, => self.compile_body(fid))) return;
        };
        return(Ok = use_func.use_scope);
    };
    @err("invalid type for value_to_scope")
}

fn add_use(self: *ResolveScope, a: *Annotation, reexport: bool) PRes = {
    scope_with_use := self.scope;
    arg := @unwrap(a.non_void_arg(), "#use requires an argument") return;
    @if(TRACK_SCOPES) @eprintln("[S] Starting #use %", self.compiler.comp().log(arg));
    @try(self.walk_expr(arg)) return;
    
    each arg.items() { arg | 
        self.compiler.last_loc = arg.loc;
        @match(arg.expr&) {
            // currently this only works as a function tag because the identifier gets looked up in the outer scope
            // but the #use only affects the function body so there's no confusion about needing to resolve all #use's 
            // before being able to evaluate the argument of a #use. 
            fn GetVar(it) => add_use_pending(self.compiler, scope_with_use, it[], reexport);
            // implicitly wrap the string in import(), this is a hack so you can do it at top level 
            // more easily without it being super confusing about where you look to resolve the identifier for `import`
            fn String(it) => {
                scope := @try(self.compiler.import_as_scope(it[], arg.loc)) return;
                add_use(self.compiler, scope_with_use, scope, reexport);
            };
            @default => return(@err("#use is temporarily limited to GetVar or String expressions"));
        };
    };
    .Ok
}

fn add_use(self: *SelfHosted, scope_with_use: ScopeId, value: Values, type: Type, reexport: bool) Res(ScopeId) = {
    new_scope := @try(value_to_scope(self, value, type, .None)) return; 
    add_use(self, scope_with_use, new_scope, reexport);
    (Ok = new_scope)
}

fn add_use(self: *SelfHosted, scope_with_use: ScopeId, scope_being_used: ScopeId, reexport: bool) void = {
    use := get_use(self, scope_with_use);
    @if(TRACK_SCOPES) @println("[S] % done #use(%)", scope_with_use.id(), scope_being_used.id());
    use.parents&.push((who = (Scope = scope_being_used), reexport = reexport), self.get_alloc());
}

fn add_use_pending(self: *SelfHosted, scope_with_use: ScopeId, v: Var, reexport: bool) void = {
    use := get_use(self, scope_with_use);
    @if(TRACK_SCOPES) @println("[S] % save #use(%%%)", scope_with_use.id(), self.pool.get(v.name), "%", v.id);
    use.parents&.push((who = (PendingEval = v), reexport = reexport), self.get_alloc());
}

fn get_use(self: *SelfHosted, s: ScopeId) *UseScopes = {
    ::ptr_utils(UseScopes);
    scope := self.scopes.index(s);
    if scope.nullable_use.is_null() {
        scope.nullable_use = self.get_alloc().box_zeroed(UseScopes);
    };
    scope.nullable_use
}

fn resolve_func_body(self: *ResolveScope, func: *Func) PRes = {
    if(func.get_flag(.ResolvedBody), => return(.Ok));
    @debug_assert_ne(func.resolve_scope, NOSCOPE, "function must have scope");
    self.scope = func.resolve_scope;
    generic := func.get_flag(.Generic); // args and ret are allowed to depend on previous args.
    top_level := func.get_flag(.TopLevel) && !func.get_flag(.AnyConstArgs) && !generic;
    prev := self.top_level;
    self.top_level = top_level;
    
    self.push_scope(func.loc);

    if generic {
    } else {
        each func.arg.bindings { b |
            @try(self.declare_binding(b, func.loc, true)) return;
        };
    };
    self.push_scope(func.loc);
    func.set_flag(.ResolvedBody);
    
    @if_let(func.body&) fn Normal(expr) => {
        ::if(Flag);
        name := if(func.get_flag(.AllowRtCapture), => Flag.local_return, => Flag.return);
        var := @try(self.decl_var(name.ident(), .Const, func.loc, .Label_DidYouReturnOutsideABlockLikeInAnExprFunction)) return;
        func.return_var = (Some = var);
        @try(self.walk_expr(expr)) return;
        
        @if_let(expr.expr&) fn Block(b) => {
            func.use_scope = b.scope;
        };
    };
    self.top_level = prev;
    
    self.pop_block();
    self.pop_block();
    self.pop_scope();

    capures := self.captures;

    if func.get_flag(.AllowRtCapture) {
        // TODO: this is only needed for the error reporting below but involves a slow iteration (in find_var). 
        //       Track which scope you're capturing from the first time we get the var so don't have to look it up again? -- Jun 26
        // Now check which things we captured from *our* parent.
        // Remember this is in temp allocator! 
        //for self.captures { c |
        //    self.find_var(c.name); // This adds it back to self.captures if needed
        //};
    } else {
        // TODO: show the captured var use site and declaration site.
        // TODO: add a test that this error is reported
        @err_assert(capures.is_empty(), "Must use '=>' for closure '%' with captures", self.compiler.pool.get(func.name)) return;
    };
    self.captures&.clear();

    .Ok
}

fn scan_const_decls(self: *ResolveScope, stmt: *FatStmt) CRes(bool) = {
    loc := stmt.loc;
    self.compiler.last_loc = loc;
    @match(stmt.stmt&) {
        (fn Decl(f) => if f.name&.is(.Ident) {
            // kinda hack. just makes it easier to read logs when you do 'name :: fn() ...'
            @if_let(f.default.expr&) fn Closure(func) => {
                if func[].get_flag(.NoName) {
                    func.name = f.name.Ident;
                    func[].unset_flag(.NoName);
                };
            };
            
            if f.kind == .Const {
                new := @try(self.decl_var(f.name.Ident, f.kind, loc, .Unknown)) return;
                f.name = (Var = new);
                return(Ok = true);
            };
        });
        (fn DeclFunc(func) => {
            // Functions don't shadow, they just add to an overload group.
            if func.var_name.is_none() {
                v := self.find_var(func.name) || {
                    // defaulting to making all overload sets global and hoping you mostly add overloads for your own types. 
                    @try(self.compiler.decl_var(TOP_LEVEL_SCOPE, func.name, .Const, func.loc, .OverloadSet)) return
                };
                func.var_name = (Some = v);
            };
            return(Ok = true);
        });
        (fn Annotations(annotations) => {
            if annotations.len == 1 {
                a := annotations.index(0);
                if a.name == Flag.use.ident() {
                    @try(add_use(self, a, false)) return;
                };
                if a.name == Flag.reexport.ident() {
                    @try(add_use(self, a, true)) return;
                };
                stmt.stmt = .Noop;
            };
        });
        @default => ();
    };
    (Ok = false)
}

//! This (find_var/decl_var) is done in a dumb and slow way with a bunch of linear scans through all the variables in a scope,
//! but its only really a problem at the top level where i import everything in the universe,
//! and i dont have enough code written in this language to convincingly benchmark it.

fn find_var_in_scope(self: *SelfHosted, name: Symbol, s: ScopeId) ?Var = {
    @debug_assert(!(s == NOSCOPE), "find_var in NOSCOPE");
    self.scopes_generation += 1;
    find_var_in_scope_inner(self, name, s, false)
}

fn find_var_in_scope_inner(self: *SelfHosted, name: Symbol, s: ScopeId, for_use: bool) ?Var = {
    first := true;
    loop {
        continue :: local_return;
        scope := self.scopes[s]&;
        if for_use {
            if scope.visit == self.scopes_generation {
                return(.None);
            };
            scope.visit = self.scopes_generation;
        };
        
        found := scope.lookup&.get_ptr(name);
        if found { v | // TODO: it gets the arity wrong if not by pointer. 
            return(Some = v[]);
        };
        ::ptr_utils(UseScopes);
        use := scope.nullable_use;
        if !use.is_null() {
            prev := use.parents.len;
            found: ?Var = .None;
            each use.parents { the_use | 
                break :: local_return;
                @if(!for_use || the_use.reexport)
                loop {
                    @match(the_use.who&) {
                        fn Scope(it) => {
                            if find_var_in_scope_inner(self, name, it[], true) { v |
                                if found& { v2 | 
                                    if !(v == v2[]) {
                                        // TODO: really need to return an error here beacuse now you can keep looping and go to your parent when you should have got a conflict. 
                                        //       the thing i want to stop is shadowing twice at the same level
                                        println("conflicting #use");
                                        //return(@err("conflicting #use for variable %", self.pool.get(name)));
                                        return(.None);
                                    };
                                };
                                found = (Some = v);
                            };
                            break();
                        }
                        fn PendingEval(it) => {
                            // TODO: get this on the main event loop i guess?
                            T :: Ty(Values, Type);
                            @if(TRACK_SCOPES) @println("[S] % eval #use(%%%)", s.id(), self.pool.get(it.name), "%", it.id);
                            hack := self.poll_in_place(T, => self.find_const(it[], .None));
                            value, type := self.unwrap_report_error(T, hack);
                            @if(TRACK_SCOPES) @println("[S] #use(%)", log(value&, self, type));
                            hack := value_to_scope(self, value, type, .None);
                            new_scope := self.unwrap_report_error(ScopeId, hack);
                            the_use.who = (Scope = new_scope);
                            // continue
                        }
                    };
                };
            };
            @debug_assert_eq(use.parents.len, prev, "concurentmodificationexception");
            if found { v |
                return(Some = v)
            };
        };
        scope := self.scopes[s]&;
        
        if scope.parent == s || for_use { 
            return(.None);
        };
        s = scope.parent;
    };
    
    unreachable()
}

fn find_var(self: *ResolveScope, name: Symbol) ?Var = {
    find_var_in_scope(self.compiler, name, self.scope)
}

fn decl_var(self: *ResolveScope, name: Symbol, kind: VarType, loc: Span, placeholder: PlaceholderValue) Res(Var) = 
    decl_var(self.compiler, self.scope, name, kind, loc, placeholder);

fn decl_var(self: *SelfHosted, s: ScopeId, name: Symbol, kind: VarType, loc: Span, placeholder: PlaceholderValue) Res(Var) = {
    // Note: you can't shadow a let with a const either but that already works because consts are done first.

    scopes := self.scopes;
    scope := scopes[s]&;
    
    var: Var = (kind = kind, name = name, id = (id = scopes.variables.len.trunc()), scope = s);
    prev := scope.lookup&.insert(name, var, self.get_alloc());
    if prev { prev |
        if prev.kind == .Const {
            scope.lookup&.insert(name, prev, self.get_alloc());
            return(@err("Cannot shadow constant in the same scope: %", self.pool.get(name)));
        };
    };
    
    dest := scopes.variables&.push_uninit();
    dest.slice(1).set_zeroed();  // EvilUninit
    dest.expr.loc = loc;
    if kind == .Const {
        dest.expr.expr = (Poison = placeholder);
        dest.set_type(.Infer);
    };
    
    scope.vars&.push(var, self.get_alloc()); // includes constants!
    (Ok = var)
}

fn push_scope(self: *ResolveScope, loc: Span) void = {
    self.scope = self.compiler.scopes.new_scope(self.scope, self.compiler.get_alloc(), loc);
}

fn pop_scope(self: *ResolveScope) void = {
    scope := self.compiler.scopes[self.scope]&;
    self.scope = scope.parent;
}

fn pop_block(self: *ResolveScope) void = {
    self.pop_scope();
}

fn resolve_binding(self: *ResolveScope, binding: *Binding) PRes #once = {
    @try(self.walk_type(binding.ty&)) return;
    if binding.get_default() { expr |
        @try(self.walk_expr(expr)) return;
    };
    .Ok
}

fn declare_binding(self: *ResolveScope, binding: *Binding, loc: Span, is_args: bool) PRes = {
    @match(binding.name) {
        (fn Ident(name) => {
            ::if(PlaceholderValue);
            placeholder: PlaceholderValue = if(is_args, => .Argument, => .Unknown);
            var := @try(self.decl_var(name, binding.kind, loc, placeholder)) return;
            b: Binding = (
                name = (Var = var),
                ty = binding.ty,
                nullable_tag = binding.nullable_tag,  // TODO: resolve
                default = binding.default,
                kind = binding.kind,
            );
            binding[] = b;
        });
        (fn Var(_) => {
            return(@err("ICE: resolved args twice."));
        });
        (fn None() => ());
    };
    .Ok
}

:: WalkAst(ResolveScope, *CompileError);

fn handle_expr(self: *ResolveScope, expr: *FatExpr) Result(DoMore, *CompileError) #once = {
    loc := expr.loc;

    @match(expr.expr&) {
        fn GetParsed(index) => {
            index := index[];
            e := @try(self.compiler.parser.finish_pending(index)) return;
            if !self.top_level {
                z := zone_begin(.CloneExpr);
                @if(ENABLE_TRACY) ___tracy_emit_zone_name(z, @tfmt("%", index.id));
                expr[] = self.compiler.clone(e); // clone is important! you end up with multiple copies of the same pending parse. 
                zone_end(z);
            } else {
                expr[] = e[];
                //@println("%", self.compiler.comp().log(e&));
                //self.compiler.codemap.show_error_line(e.loc, true);
                self.compiler.parser.tasks[index.id].Expr.Ok.expr = (Poison = .TopLevelUsed);
            };
            @try(self.walk_expr(expr)) return;
            return(Ok = DoMore.Break);
        }
        fn Block(f) => {
            if f.block_resolved {
                return(Ok = .Break);
            };
            if f.scope == NOSCOPE {
                self.push_scope(expr.loc);
                f.scope = self.scope;
            } else {
                self.scope = f.scope;
            };
            
            // :SLOW this is unfortunate
            has_use_stmt := false;
            each f.body { stmt |
                @match(stmt.stmt&) {
                    fn DeclFunc(func) => {
                        // TODO:  && func.arg.bindings.len == 0 but instead need to check for unit
                        is_new_overloadset := func.body&.is(.Empty) && func.annotations.len == 0 && func.ret&.is(.Infer);
                        if is_new_overloadset {
                            v := @try(self.decl_var(func.name, .Const, func.loc, .OverloadSet)) return;
                            func.var_name = (Some = v);
                        };
                    }
                    fn Annotations(annotations) => {
                        if annotations.len == 1 {
                            n := annotations.items()[0].name;
                            if n == Flag.use.ident() || n == Flag.reexport.ident() {
                                has_use_stmt = true;
                            };
                        };
                    }
                    @default => ();
                };
            };
            if has_use_stmt {
                // suspend and come back latter
                self.pop_block();
                return(Ok = .Break);
            };
            @try(finish_resolving_block(self, f)) return;
            self.pop_block();
            
            // Needed to do that in the block, so took control of the walk order and now we're done.
            return(Ok = .Break);
        }
        // TODO: wastefully resolving on things like `.None` and `@symbol whatever`, that's why we have to allow missing vars here, they might just be used as symbols. 
        fn GetNamed(name) => {
            v := self.find_var(name[]);
            if v& { var |
                expr.expr = (GetVar = var[]);
            } else {
                expr.expr = (UndeclaredVar = (name = name[], scope = self.scope));
            }
        }
        @default => ();
    };
    (Ok = DoMore.Continue)
}

fn finish_resolving_block(self: *ResolveScope, f: *get_variant_type(Expr, .Block)) Res(void) = {
    @debug_assert(self.scope == f.scope, "block scope?");
    if true {
        break :: local_return;
        each f.body { stmt |
            @match(stmt.stmt&) {
                fn Annotations(annotations) => {
                    if annotations.len == 1 {
                        if annotations.items()[0].name == Flag.include_std.ident() {
                            stmts := f.body.assume_owned(self.compiler.get_alloc());
                            @try(self.slow_body(stmts&)) return;
                            f.body = stmts.as_raw();
                            break();
                        };
                    };
                };
                @default => ();
            };
            @try(self.scan_const_decls(stmt)) return;
        };
    };
    
    each f.body { stmt |
        @try(self.walk_stmt(stmt)) return;
    };
    @try(self.walk_expr(f.result)) return;
    f.block_resolved = true;
    .Ok
}

fn handle_stmt(self: *ResolveScope, stmt: *FatStmt) Result(DoMore, *CompileError) #once = {
    @match(stmt.stmt&) {
        fn Decl(f) => @if_let(f.name) fn Ident(name) => {
            @try(self.walk_type(f.ty&)) return;
            @try(self.walk_expr(f.default&)) return;
            
            new := @try(self.decl_var(name, f.kind, stmt.loc, .Unknown)) return;
            f.name = (Var = new);
            
            // We had to take control so exprs wouldn't be able to bind the name. 
            // Which is what you want for local variables, but not constant functions since they should be able to recurse, 
            // but that works out because constants were already handled in scan_const_decls.  -- Jun 27
            return(Ok = .Break);
        };
        fn DeclVarPattern(f) => {
            // TODO: this declares the new variables before resolving the types/values. which is wrong! -- Jul 1
            each f.binding.bindings { b |
                @try(self.declare_binding(b, stmt.loc, false)) return;
            };
        }
        @default => ();
    };
    (Ok = .Continue)
}

fn handle_func(self: *ResolveScope, func: *Func) Result(DoMore, *CompileError) #once = {
    @try(self.resolve_func(func)) return;
    (Ok = .Break)
}

fn handle_type(self: *ResolveScope, ty: *LazyType) Result(DoMore, *CompileError) #once = (Ok = .Continue);
fn handle_pattern(self: *ResolveScope, p: *Pattern) Result(DoMore, *CompileError) #once = (Ok = .Continue);

///////////////////
/// Renumbering ///

RenumberResults :: @struct(
    vars: HashMap(Var, Var),
    scopes: HashMap(ScopeId, ScopeId),
);

fn init() RenumberResults = (vars = init(temp()), scopes = init(temp()));

RenumberVars :: @struct(
    scope: *Scopes, 
    mapping: *RenumberResults, 
    compiler: *SelfHosted,
);

fn decl_new(self: *RenumberVars, name: *Var) void = {
    new := self.scope.dup_var(name[]);
    if self.mapping.scopes&.get(new.scope) { s |
        new.scope = s;
    };
    self.mapping.vars&.insert(name[], new);
    name[] = new;
}

fn decl(self: *RenumberVars, name: *Var) void = {
    if self.mapping.vars&.get_ptr(name[]) { new |
        name[] = new[];
        return();
    };
    log_it(name, "decl was new");
    // TODO: it kinda seems like this shouldn't happen because we have scopes now but clearly it does
    self.decl_new(name);
}

fn update(self: *RenumberVars, name: *Var) void #inline = {
    if self.mapping.vars&.get_ptr(name[]) { new |
        name[] = new[];
    };
}

SPAM_SCOPES :: false;

fn log_it(old: *Var, why: Str) void = {
    @if(!SPAM_SCOPES) return();
    self := current_comptime();
    it := self.scopes.get_var_data(old[]);
    @println("(%) %", why, self.log(old[]));
    self.codemap.show_error_line(it.expr.loc, false);
}

fn decl_scope(self: *RenumberVars, name: *ScopeId) void = {
    a := self.compiler.get_alloc();
    prev := name[];
    old_scope := self.scope[prev]&;
    parent := old_scope.parent;
    self.update(parent&);
    id := self.scope.new_scope(parent, a, old_scope.loc);
    self.mapping.scopes&.insert(name[], id);
    old_scope := self.scope[prev]&;
    new_vars: List(Var) = old_scope.vars&.items().clone(a);
    
    if SPAM_SCOPES {
        @println("decl_scope SCOPE");
        each new_vars { old | 
            @println("- % %", self.compiler.log(old[]), old.kind);
        };
        self.compiler.codemap.show_error_line(old_scope.loc, false);
    };
    
    new_constants := zeroed RawHashMap(Symbol, Var);
    each new_vars { old | 
        v := old;
        new := v[];
        self.decl_new(new&);
        if old.kind == .Var {
            log_it(old, "decl_scope");
        } else {
            v := self.scope.get_constant(v[]);
            v := v.expect("known const");
            expr := self.compiler.clone(v.expr&);
            ty := v.maybe_stack_allocated_type();
            ty := self.compiler.clone(ty);
            self.scope.put_constant(new, expr, ty);
        };
        old[] = new;
        new_constants&.insert(new.name, new, self.compiler.get_alloc());
    };
    new_scope := self.scope[id]&;
    new_scope.vars = new_vars.as_raw();
    new_scope.lookup = new_constants;
    name[] = id;
}

fn update(self: *RenumberVars, name: *ScopeId) void = {
    if self.mapping.scopes&.get_ptr(name[]) { new |
        name[] = new[];
    };
}

:: WalkAst(RenumberVars, void);

fn handle_expr(self: *RenumberVars, expr: *FatExpr) Result(DoMore, void) #once = {
    @match(expr.expr&) {
        fn GetVar(name) => self.update(name);
        fn Block(f) => {
            // f.block_resolved=false does not mean there will be no GetVar because of unquote. 
            // the quoted template is unresolved when you fill in placeholders with expressions that may already be resolved. 
            // because sema/compile_quote does not recurse until after filling placeholders.  
        
            if !(f.scope == NOSCOPE) {
                self.decl_scope(f.scope&);
            };
            each f.body { stmt |
                @match(stmt.stmt) {
                    fn Decl(f) => if f.kind == .Const {
                        @if_let(f.name&) fn Var(v) => self.decl(v);
                    };
                    @default => ();
                };
            };
        };
        fn UndeclaredVar(it) => self.update(it.scope&);
        @default => ();
    };
    (Ok = DoMore.Continue)
}

fn handle_stmt(self: *RenumberVars, stmt: *FatStmt) Result(DoMore, void) #once = {
    @match(stmt.stmt) {
        fn Decl(f) => if f.kind != .Const {
            @if_let(f.name&) fn Var(v) => {
                log_it(v, "handle_stmt");
                self.decl(v);
            };
        };
        @default => ();
    };

    (Ok = .Continue)
}

fn handle_func(self: *RenumberVars, func: *Func) Result(DoMore, void) #once = {
    if !(func.resolve_scope == NOSCOPE) {
        self.decl_scope(func.resolve_scope&);
    };
    if func.var_name& { old |
        self.update(old);
        // TODO: maybe you sometimes want `self.decl(func.var_name&);` if not in mapping.
        //       but most of the time you're just adding to an overload set.
        //       really the func should track which case it is so we can be sure to do the right thing  -- Jun 27
    };
    if func.return_var& { old |
        self.update(old);
    };
    
    (Ok = .Continue)
}

fn handle_type(self: *RenumberVars, ty: *LazyType) Result(DoMore, void) #once = {
    (Ok = .Continue)
}
fn handle_pattern(self: *RenumberVars, p: *Pattern) Result(DoMore, void) #once = {
    each p.bindings { b |
        @if_let(b.ty&) 
                fn Generic(v) => self.decl(v);
        @if_let(b.name&) 
            fn Var(v) => self.decl(v);
    };
    
    (Ok = .Continue)
}

fn log(s: *SelfHosted, e: *FatExpr) void = {
    out: List(u8) = list(temp());
    e.log(s.pool, out&, 0);
    println(out.items());
}

// most blocks aren't using #include_std.
// doing it this way means you scan_const_decls twice anything in a block before a #include_std, but that doesn't matter.
fn slow_body(self: *ResolveScope, body: *List(FatStmt)) PRes #once = {
    new_body: List(FatStmt) = list(body.len, body.gpa);
    dirty := true;
    while (=> dirty) {
        dirty = false;
        each body { stmt | 
            continue :: local_return;
            @if_let(stmt.stmt&) fn Annotations(annotations) => {
                if annotations.len == 1 && annotations.items()[0].name == Flag.include_std.ident() {
                    self.compiler.last_loc = stmt.loc;
                    msg :: "#include_std requires string argument";
                    arg_expr := annotations.items().index(0).non_void_arg().or() {
                        return(@err(msg))
                    };
                    loc := arg_expr.loc;
                    name := @match(arg_expr.expr) {
                        fn String(name) => name;
                        @default => return(@err(msg));
                    };
                    
                    // TODO: remove already_loaded once everything can use #use
                    if !self.compiler.scopes.already_loaded&.insert(name) {
                        name_s := self.compiler.pool.get(name);
                        :: ?WaitingParse;
                        file := self.compiler.get_include_std(name_s).or() {
                            return(@err("unknown path for #include_std %", name_s))
                        };
                        dirty = true;
                        stmts := @try(self.compiler.parser.finish_pending_stmts(file)) return;
                        new_body&.push_all(stmts.items());
                        // TODO: instead of that, convert it to #use(import(path));
                    };
                    continue();
                };
            };
            new_body&.push(stmt[]);
        };
        temp := body[];
        body[] = new_body;
        new_body = temp;
        new_body&.clear();
    };
    each body { stmt |
        @try(self.scan_const_decls(stmt)) return;
    };
    .Ok
}

import_literal_file_name :: "(import literal)";

fn import_as_scope(self: *SelfHosted, name: Symbol, _loc: Span) Res(ScopeId) = {
    name_s := self.pool.get(name);
    if self.imports.get(name) { s | 
        @err_assert(s != NOSCOPE, "unhandled recursive import: %", name_s) return;
        return(Ok = s);
    };
    self.imports.insert(name, NOSCOPE);
    @err_assert(name_s.len > 1, "empty import descriptor") return;
    selector := name_s[0];
    file := @switch(selector) {
        @case("@".ascii()) => {
            @err_assert(name_s.len > 2 && name_s[1] == "/".ascii(), "expected import descriptor to start with '@/'") return;
            @err_assert(!name_s[name_s.len - 1].is_ascii_whitespace(), "illegal trailing whitespace in import descriptor'") return;
            name_s := name_s.rest(2);
            @unwrap(self.get_include_std(name_s), "unknown path for #include_std %", name_s) return
        };
        @case("{".ascii()) => {
            file := self.codemap.add_file(import_literal_file_name, name_s);
            id := push_parse(self.parser, name_s, file);
            id
        };
        @case("F".ascii()) => {
            @if(DISABLE_IMPORT_FRC) return(@err("TODO: DISABLE_IMPORT_FRC because scoping when you import the compiler is messed up"));
            return(self.import_frc(name_s))
        };
        @default => return(@err("invalid selector (first character) of import(Str) %. expected @ or {", selector));
    };
    // TODO: better errors here
    stmts := @try(self.parser.finish_pending_stmts(file)) return;
    stmts&.ordered_retain(fn(s) => !s.stmt&.is(.Noop));
    if stmts.len == 1 && stmts[0].stmt&.is(.Eval) && stmts[0].stmt.Eval.expr&.is(.Block) {
        stmts = stmts[0].stmt.Eval.expr.Block.body; // TODO: assert no result
    };
    // TODO: think about what the parent scope should be here. 
    fake_fid := @try(make_function_scope(self, stmts.items(), name, TOP_LEVEL_SCOPE)) return;
    val := self.to_values(FuncId, fake_fid);
    scope := @try(value_to_scope(self, val, FuncId, (Some = name))) return;
    self.imports.insert(name, scope);  // redundant with save_scope_as since we know we just made the function
    (Ok = scope)
}

fn find_in_scope(self: *SelfHosted, s: ScopeId, name: Symbol, type: Type) Maybe(?Values) = {
    // TODO: this mapping doesn't use #use which seems bad 
    var := self.scopes[s].lookup&.get(name) || return(Ok = .None);
    @if(var.kind != .Const) return(Ok = .None);
    value, type_found := @check(self.find_const(var, (Specific = type))) return;
    if type != type_found {
        expr := synthetic_ty((Value = (bytes = value, coerced = false)), self.last_loc, type_found);
        // can't be @check because we just made a new expression. bleh. 
        value = @try(self.poll_in_place(Values, => self.immediate_eval_expr(expr&, type))) return;
    };
    (Ok = (Some = value))
}

fn add_to_scope(c: *SelfHosted, s: ScopeId, name: Symbol, type: LazyType, expr: FatExpr) Var = {
    scope := c.scopes.index(s);
    var   := scope.lookup&.get(name) || {
        res := c.decl_var(s, name, .Const, expr.loc, .Unknown);
        @assert(res&.is(.Ok));
        res.Ok
    };
    // TODO: if i keep this rule it needs to be a normal error not an assert. user code can get here. 
    @debug_assert(var.kind == .Const, "stomped var with const");
    c.scopes.put_constant(var, expr, type);
    var
}

fn get_include_std(c: *SelfHosted, name: Str) ?WaitingParse = {
    zone := zone_begin(.LoadFile); // TODO: defer
    src := get_include_std(c.get_alloc(), name) || return(.None);
    name := @if(name == "compiler", name, (@tfmt("@/%", name)).shallow_copy(c.get_alloc()));
    file := c.codemap.add_file(name, src);
    id := push_parse(c.parser, src, file);
    zone_end(zone);
    (Some = id)
}

// TODO: store this in SelfHosted instead of in a global -- Jul 5
STDLIB_PATH :: @static(?Str) (.None);

fn get_include_std(a: Alloc, name: Str) ?Str = {
    ::if(?Str);
    if name == "compiler" {
        code: List(u8) = list(a);
        fill_export_ffi(code&);
        (Some = code.items())
    } else {
        lib := STDLIB_PATH[].unwrap();
        check := @tfmt("%/%", lib, name);
        out := u8.list(a);
        if read_and_push(out&, check) {
            (Some = out.items())
        } else {
            if read_and_push(out&, name) {
                (Some = out.items())
            } else {
                .None
            }
        }
    }
}

// I like that users can put the lib somewhere and edit it for thier program. I dont want the compiler to just force its blessed version.
fn find_std_lib(a: Alloc) ?Str = {
    // :io_driver
    check :: fn(p: *List(u8)) bool = {
        p.push_path_segment("lib");
        p.push_path_segment("franca_stdlib_1.fr");
        // :UpdateBoot
        CRAZY_TOWN :: @if(IS_BOOTSTRAPPING, path_exists, file_exists);
        good := p.items().CRAZY_TOWN();
        p.pop_path_segment();
        p.pop_path_segment();
        good
    };

    // if a project wants to supply its own version, that should take priority.
    p := u8.list(a); p&.push_all("."); // get_working_directory(a);
    p := p&;
    if(check(p), => return(Some = p.items()));
    
    // TODO: this doesn't work if we're just using '.' ^
    // TODO: also check like ./vendor/franca
    range(0, 3) { _ |
        p.pop_path_segment();
        if(check(p), => return(Some = p.items()));
    };

    @if(is_linking_libc()) {
        // TODO: this doesn't work if its a symlink to the exe. need to follow that? 
        p := get_executable_path(a).assume_owned(a);
        p := p&;
        assert(p.pop_until_endswith("/"), "path should have slashes"); // we want our folder, not our exe. 
        
        p.push_path_segment("franca");
        if(check(p), => return(Some = p.items()));
        // exe might be in franca/target/release/franca or franca/target/debug/deps/compiler-21be1aa281dbe5d6, so go up
        range(0, 5) { _ |
            p.pop_path_segment();
            if(check(p), => return(Some = p.items()));
        };
        
        p.clear();
        if read_link("/usr/local/bin/franca", p) {
            range(0, 5) { _ |
                p.pop_path_segment();
                if(check(p), => return(Some = p.items()));
            };
        };
    };
    
    .None
}

fn update_global_stdlib_path() void = {
    :: ?Str; 
    if STDLIB_PATH.is_none() {
        // :io_driver
        a := find_std_lib(general_allocator());
        if a& { lst |
            STDLIB_PATH[] = (Some = lst[]);
        } else {
            panic("Could not find franca standard library."); // TODO: return error
        };
    };
}
