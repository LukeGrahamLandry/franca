#include_std("compiler/codemap.fr");
#include_std("compiler/lex.fr");
#include_std("compiler/pool.fr");
#include_std("compiler/parse.fr");
#include_std("compiler/backend/walk_bc.fr");
#include_std("compiler/backend/qbe.fr");
#include_std("compiler/backend/llvm.fr");
#include_std("compiler/backend/aarch64.fr");
#include_std("compiler/error_reporting.fr");
#include_std("compiler/scope.fr");
#include_std("compiler/walk_ast.fr");
#include_std("compiler/comptime.fr");
#include_std("compiler/values.fr");
#include_std("compiler/emit_bc.fr");
#include_std("compiler/profile.fr");
#include_std("compiler/lsp/lsp.fr"); 
#include_std("compiler/lsp/hooks.fr"); 
#include_std("compiler/v2/dispatch.fr"); 
#include_std("compiler/v2/sema.fr"); 
#include_std("compiler/v2/ast_boring.fr"); 

::?[]Prim; // TODO: why do i need this extra when lsp????? order of exports changed maybe??

// TODO: don't individually allocate all these. it just makes it easier to do rust ffi while not fully self hosted. 
SelfHosted :: @struct(
    pool: *StringPool,
    codemap: *CodeMap,
    parser: *Parser,
    ast_alloc: *ArenaAlloc,
    scopes: *Scopes,
    vtable: *ImportVTable,
    baked: *Baked,
    last_loc: Span,
    env: *ComptimeEnvironment,
    // NOTE: don't reorder the fields above this! Rust knows about them!
    // TODO: they should just be slices since they have to last forever anyway
    primitives: HashMap(PrimKey, RsVec(Prim)),
    index: ProgramIndex,
    functions: BucketArray(Func),  // TODO: have a version of this type that doesn't add gaps if you push_all because that will break the indexing
    aarch64: Jitted,
    bytecodes: BucketArray(FnBody),
    // TODO: just always use .Aot and make this a set?
    saved_bytecodes: HashMap(*FnBody, ExecStyle),
    free_bytecodes: List(*FnBody),
    types: BucketArray(TypeInfo),
    // TODO: decide if these are generally accessed at the same time so should be stored together.
    // TODO: have a OptionalBucketArray that stores a bit set at the beginning of each bucket? 
    type_extra: BucketArray(?TypeMeta), 
    type_lookup: HashMap(*TypeInfo, Type),
    // TODO: its dumb that deep is here and shallow is in typeinfo struct?  -- Jul 21
    finished_layout_deep: DynamicBitSet,
    dispatch: CompilerDispatch,
);

:: AutoHash(Ty(Type, u16, bool, bool), TrivialHasher);
:: AutoEq(Ty(Type, u16, bool, bool));

PRes :: Result(void, *ParseErr);

fn new_sema_init_vtable() *ImportVTable = {
    the_vtable :: @static(ImportVTable);
    vtable := the_vtable;
    vtable[] = ImportVTable.zeroed();
    
    // TODO: scan overload sets instead so you can skip all the groups with the same name. :SLOW
    vtable.find_unique_func = fn(c: Compiler, name: Symbol) ?FuncId = { 
        c := c.cast()[][];
        found: ?FuncId = .None;
        range(0, c.functions.len) { i |
            func := c.functions&.nested_index(i);
            if func.name == name {
                if(found.is_some(), => return(.None));
                found = (Some = (@as(u32) i.trunc()).funcid_from_index());
            };
        };
        found
    };
    
    vtable.get_jitted_ptr = fn(c: Compiler, f: FuncId) CRes(rawptr) = {
        self := c.cast()[][];
        vtable := the_vtable;
        ptr := or self.aarch64&.get_fn(f) {
            {vtable.compile_func}(c, f, .Jit);
            
            task: Task = (action = (Jit = f), waiting_for = list(self.get_alloc()), id = self.dispatch.next_task_id);
            self.dispatch.next_task_id += 1;
            self.dispatch.active_tasks&.push(task&);
            res := self.poll_tasks(); ::tagged(@type res);
            if res&.is(.Err) {
                garbage := res.Err.span.high == 0 && res.Err.span.low == 0;
                if garbage {
                    res.Err.span = self.last_loc;
                };
                self.codemap.show_error_line(res.Err.span);
                @panic("failed to jti func: %", res.Err.msg); // TODO: return the error!
            };
            
            ptr := self.aarch64&.get_fn(f);
            ptr.expect("compield function but not ready")
        };
        r: CRes(rawptr) = (Ok = ptr); // TODO: fix prims llvm. -- Jul 29
        r
    };
    
    vtable.init_compiler = fn(comptime_arch: Backend, options: *BuildOptions) Compiler = {
        vtable := the_vtable;
        mem := init_self_hosted(options);
        mem.vtable = vtable;
        mem.env.new_sema = true;
        mem.stable_compiler_context()
    };
    
    vtable.compile_func = fn(c: Compiler, f: FuncId, when: ExecStyle) CRes(void) = {
        c := c.cast()[][];
        task: Task = (action = (CompileBody = f), waiting_for = list(c.get_alloc()), id = c.dispatch.next_task_id);
        c.dispatch.next_task_id += 1;
        c.dispatch.function_in_progress&.set(f.as_index());
        c.dispatch.active_tasks&.push(task&);
       
        // TODO: have a version of poll that just goes until a specific task is done. 
        res := c.poll_tasks(); ::tagged(@type res);
        if res&.is(.Err) {
            garbage := res.Err.span.high == 0 && res.Err.span.low == 0;
            if garbage {
                res.Err.span = c.last_loc;
            };
            c.codemap.show_error_line(res.Err.span);
            @panic("failed to compile func: %", res.Err.msg);
            // TODO: return the error!
        };
        .Ok
    };
    
    vtable.get_compiler_builtins_source = fn() Str = {
        ""
    };
    
    vtable.make_and_resolve_and_compile_top_level = fn(cc: Compiler, body: Slice(FatStmt)) CRes(void) = {
        c := cc.cast()[][];
        f := c.make_top_level(body);
        f := f.unwrap();
        @try({the_vtable[].compile_func}(cc, f, .Jit)) return;
        .Ok
    };
    
    vtable.comptime_arch = fn() Ty(Arch, Os) = {
        // TODO
        (.Aarch64, .Macos)
    };
   
    // TODO: do this lazily and as part of the event loop. 
    vtable.check_for_new_aot_bake_overloads = fn(comp: Compiler) CRes(void) = {
        self := comp.cast()[][];
        os := self.env.bake_os.expect("cannot aot during bootstrapping.");
        overloads := self.dispatch.overloads&.nested_index(os.as_index());
        prev := overloads.ready.len();
        self.compute_new_overloads(overloads);
        // TODO: this will miss them if someone caused new things to resolve outside this function.
        //       so if you ever call bake_relocatable_value manually. :FUCKED -- Jun 19
        current := overloads.ready.len();
        new := overloads.ready.items().slice(prev, current).clone(temp());
        each new { f |
            continue :: local_return;
            func := self.get_function(f.func);
            args := func.arg.bindings&;
            if args.len() != 1 {
                continue();
            };
            
            value := self.poll_in_place(void) {()Maybe(void)|
                return :: local_return;
                arg_ty := @check(self.infer_arguments(f.func)) return;
                ret_ty := @check(self.infer_return(f.func)) return;
                .Ok
            };
            self.unwrap_report_error(void, value);
            f_ty := func.finished_ty().expect("bake overload fn type");
            info := self.get_type(f_ty.ret);
            if !info.is(.Struct) {
                continue();
            };
            fields := info.Struct.fields&;
            // TODO: make sure its actually a Slice(BakedEntry)
            if fields.len() != 2 {
                continue();
            };

            first := f_ty.arg; 
            ty := self.unptr_ty(first).or(=> continue());
            // TODO: you really want to do the compile lazily, so you only do it when you actually try to emit a type that needs it. 
            //       but EmitBc doesn't have mutable access to the compiler so its painful.
            //       but this is cripplingly stupid with the current model of eh fuck it just load all the code in the universe every time. 
            //       especially once i overload it for things in generics, currently slices are a magic special case.    -- Jun 19  :SLOW
            f := {the_vtable[].get_jitted_ptr}(comp, f.func).unwrap();
            f := assume_types_fn(rawptr, Slice(BakedEntry), f);
            self.save_bake_callback(ty, f).unwrap();
        };
        .Ok
    };
    the_vtable
}

make_top_level :: fn(c: *SelfHosted, body: Slice(FatStmt)) Res(FuncId) = {
    name := c.pool.insert_owned("@toplevel@");
    loc := body[0].loc;
    result := c.box(synthetic_ty((Value = (bytes = unit_value, coerced = false)), loc, void));
    result := synthetic_ty((Block = (body = body.rs(), result = result, ret_label = .None, hoisted_constants = false)), loc, void);
    bindings: List(Binding) = list(c.get_alloc());
    bindings&.if_empty_add_unit();
    arg: Pattern = (bindings = bindings.rs(), loc = loc);
    def: FnDef = (name = (Some = name), arg = arg, ret = (Finished = void), tags = list(temp()), loc = loc);
    func := make_func(def, (Some = result), false);
    r := c.resolve_root(func&, scope_from_index(0));  // TODO: more usable @try
    assert(r&.is_ok(), "failed to resolve top level");
    f := c.add_function(func);
    return(Ok = f)
};

fn stable_compiler_context(self: *SelfHosted) Compiler = {
    mem1 := libc_allocator.alloc(*SelfHosted, 1);
    mem1.ptr[] = self;
    erased := (*SelfHosted).raw_from_ptr(mem1.ptr);
    compiler := libc_allocator.alloc(CompilerValue, 1);
    compiler.ptr[] = (pointer_to_pointer_to_selfhosted = erased);
    compiler.ptr
}

fn update_global_stdlib_path() void = {
    :: ?Str; 
    if STDLIB_PATH.is_none() {
        // :io_driver
        a := find_std_lib(libc_allocator);
        if a& { (lst: *List(u8)) |  // TODO: why the fuck does this need the type annotation1!!@##@!
            STDLIB_PATH[] = (Some = lst.items());
        } else {
            panic("Could not find franca standard library."); // TODO: return error
        };
    };
}

fn self_hosted_main(vtable: *ImportVTable, use_new_sema: bool) void #compiler #no_trace = {
    :: by_the_way_you_are_compiling_the_compiler_right_now_just_a_helpful_hint();
    if RUNTIME_STACK_TRACE {
        get_panic_hook()[] = new_print_trace_and_abort;
        println(">>> Compiler running in slow mode.");
    };
    update_global_stdlib_path();
    
    args := cli_args();
    if args.len <= 1 {
        panic("Expected cli argument: a path to a franca file."); // or driver shared library
    };
    // TODO: allow loading driver function from shared library 
  
    filename := args[1].str();
    
    my_vtable := vtable[];
    my_vtable&.fill_driver_vtable();
    
    if filename == "-lsp" {
        @if(ENABLE_LSP, {
            lsp_main(my_vtable&);
            exit(0);
        }, panic("argument '-lsp' not supported by this build of the compiler"));
    };
    
    if filename == "-go-build-yo-self" {
        go_build_yo_self(my_vtable&);
        exit(0);
    };
    
    @match(run_franca_file(my_vtable&, filename, use_new_sema)) {
        (fn Ok(_) => exit(0));
        (fn Err(e) => exit(1));
    };
}

// This is a simplified copy-paste of first.fr/driver. 
// It exists so we have a precompiled version of the compiler's build script, 
// which allows making breaking abi changes to the driver program system (like the allocator vtable change). 
fn go_build_yo_self(vtable: *ImportVTable) void = {
    fn load_src(vtable: *ImportVTable) CompCtx = {
        src := temp().read_to_string("compiler/main.fr");
        @fmt(src&, ";ENABLE_TRACY :: false; ENABLE_LSP :: false; ENABLE_QBE_BACKEND :: false;\n");
        opts := default_build_options();
        opts.deduplicate_bytecode = true;
        opts.retain_function_names = false;
        opts.debug_info = false;
        args := cli_args();
        for args { extra |
            if extra.str() == "-no-deduplication" {
                opts.deduplicate_bytecode = false;
            };
            if extra.str() == "-keep-names" {
                opts.retain_function_names = true;
            };
            if extra.str() == "-debug-info" {
                opts.debug_info = true;
            };
        };
        
        comp := vtable.new_with_src(src.items(), opts);
        c := vtable.with(comp);
        c
    }

    // TODO: return result
    fn build_llvm(ir: BucketArray(u8), args: Slice(Str)) void = {
        out := open_temp_file();
        for(ir&){bucket|
            out.fd&.write(bucket);
        };
        @println("Write llvm ir to %", out&.s_name());   
        args: List(Str) = args.clone(temp());
        args&.push("-x"); // don't check the file extension of source files that follow. 
        args&.push("ir"); 
        args&.push("-g"); 
        args&.push(out&.s_name());
        @println("%", args.items());
        success := run_cmd_blocking(CLANG_PATH, args.items());
        assert(success, "ICE: generated invalid llvm ir");
        out.remove();
    }

    if !file_exists("compiler/main.fr") {
        panic("Working directory must be top level of the franca repository");
    };
    start := timestamp();
    c := load_src(vtable);
    
    do_build := true;
    do_replace := false;
    args := cli_args();
    use_new_entry_point := false;
    for args { arg |
        if arg.str() == "-replace-compiler" {
            do_replace = true;
        };
    };
    
    ::if([]FuncId);
    exports: []FuncId = c.get_tagged("compiler");
    
    ir_text := {c.vtable.emit_llvm}(c, temp(), exports, .ExportWithNames);
    @println("Emitted % bytes of llvm ir.", ir_text.len);  // useful to see when i start trying to deduplicate bytecode. 
    end := timestamp();

    start := timestamp();
    build_llvm(ir_text, @slice ("-o", "target/franca/libfranca.o", "-c", "-Os"));
    end := timestamp();
    @println("LLVM time: % ms.", end.sub(start)); 
    
    // build.rs needs this if it wants to build the binary (it won't take a .o file)
    run_cmd_blocking("/usr/bin/ar", @slice (
        "rc", "target/franca/libfranca.a", "target/franca/libfranca.o"
    )).assert("link failed");
    
    // TODO: should output then move cause i think it deletes if it fails. and save the old one for a bit cause its scary. 
    if do_replace {
        compiler_exe_path := "target/release/franca";
        save_temp_file := open_temp_file();
        rename(compiler_exe_path.maybe_borrow_cstr(temp()), save_temp_file&.c_name());
        args := @slice("target/release/libfranca.a", "target/franca/libfranca.o", "-o", compiler_exe_path, "-g");
        run_cmd_blocking(CLANG_PATH, args).assert("link failed");
        @println("Replaced your compiler at '%' with the new one. \nThe old one was saved at '%' (NOTE: THATS A TEMP FILE!)", compiler_exe_path, save_temp_file&.s_name());
    } else {
        println("SKIPPED REPLACING COMPILER");
    };
}

// TODO: store this in SelfHosted instead of in a global -- Jul 5
STDLIB_PATH :: @static(?Str) (None = unit);

fn load_file_in_compiler(vtable: *ImportVTable, path: Str, use_new_sema: bool) CRes(CompCtx) = {
    // :io_driver
    prelude := "#include_std(\"lib/core.fr\");";
    source: List(u8) = prelude.clone(libc_allocator);  // TODO: column number on error on first line will be wrong but i dont care. 
    source&.read_and_push(path);  // TODO: error handling
    
    comp := {vtable.init_compiler}(.Aarch64, default_build_options()); // TODO: comptime get the current arch
    c := vtable.with(comp);
    file := {c.vtable.add_file}(c.data, path, source.items());
    self := c.data.cast();
    self.env.new_sema = use_new_sema;
    
    id := self.parser.push_parse(source.items(), file);
    // TODO: handle error
    stmts := self.parser.finish_pending_stmts(id);
    stmts := self[][].unwrap_report_error(RsVec(FatStmt), stmts); // TODO: don't return RsVec -- Jun 29
    @try({c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts.items())) return;
    (Ok = c)
}

// TODO: print the error message!!! since this doesn't go through the rust side anymore. -- Jun 30
fn run_franca_file(vtable: *ImportVTable, path: Str, use_new_sema: bool) CRes(void) = {
    c := @try(vtable.load_file_in_compiler(path, use_new_sema)) return;
    
    mem_stats :: fn() => {
        bytes_per_mb :: 1024 * 1024;
        cc := c.data.cast()[][];
        @println("Compiler Memory Usage: %MB + %MB", cc.ast_alloc.current_allocated_size() / bytes_per_mb, __temp_alloc.current_allocated_size() / bytes_per_mb);
    };
    
    if c.get_unique_named("driver") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = callee);
        callee(vtable);
        mem_stats();
        exit(0);
    };
    
    if c.get_unique_named("main") {f|
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = void, Ret = void, ptr = callee);
        callee();
        mem_stats();
    };
    
    sym_test := c.intern_string("test");
    tests := c.data.get_fns_with_tag(sym_test);
    for tests { f |
        @println("===== [%] =====", c.get_string(c.get_function_name(f)));
        callee := c.get_jitted(f);
        callee := assume_types_fn(Arg = void, Ret = void, ptr = callee);
        callee();
    };
    
    yield_count := c.data.cast()[][].dispatch.yield_count;
    if yield_count != 0 {
        @println("[yield_count = %]", yield_count);
    };
    
    .Ok
}

fn dump_tasks(self: *SelfHosted) void = {
    @println("[% active tasks]", self.dispatch.active_tasks.len);
    out: List(u8) = list(temp());
    enumerate self.dispatch.active_tasks { i, task | 
        @fmt(out&, "- [%] ", i);
        task.action&.log(self, out&);
        out&.push_all("\n");
    };
    println(out.items());
}

// TODO: the vtable ones leak every time!
// TODO: this should be a driver program export instead
fn get_include_std(c: *SelfHosted, name: Str) ?WaitingParse = {
    // :io_driver
    zone := zone_begin(.LoadFile); // TODO: defer
    
    //@println("TODO: tried to import %", name);
    src := if name == "compiler" {() Str |
        code := {c.vtable.get_compiler_builtins_source}().clone(c.get_alloc());
        fill_export_ffi(code&);
        if c.env.new_sema {
            // TODO: sad that this will make the whole thing dynamically reachable but also its all going away so i don't really care. 
            new_sema_fill_export_ffi(code&);
        };
        code.items()
    }{
        lib := STDLIB_PATH[].unwrap();
        check := @format("%/%", lib, name) temp();
        // TODO: do this as one operation (error handling on read)
        if file_exists(check.items()) {
            c.get_alloc().read_to_string(check.items()).items()
        } {
            if file_exists(name) {
                c.get_alloc().read_to_string(name).items()
            } {
                zone_end(zone);
                return(.None);
                "unreahcable"
            }
        }
    };
    
    file := c.codemap.add_file(name, src);
    id := push_parse(c.parser, src, file);
    zone_end(zone);
    (Some = id)
}

// I'd rather include it in the binary but I do this so I don't have to wait for the compiler to recompile every time I change the lib
// (maybe include_bytes in a seperate crate would make it better)
// I also like that users can put the lib somewhere an edit it for thier program. I dont want the compiler to just force its blessed version.
// But I also don't want it to be like c where you just get whatever the system happens to have.
fn find_std_lib(a: Alloc) ?List(u8) = {
    // :io_driver
    check :: fn(p: *List(u8)) bool = {
        p.push_path_segment("lib");
        p.push_path_segment("franca_stdlib_1.fr");
        good := p.items().file_exists();
        p.pop_path_segment();
        p.pop_path_segment();
        good
    };

    // if a project wants to supply its own version, that should take priority.
    // check current directory first? 
    p := get_working_directory(a);
    p := p&;
    if(check(p), => return(Some = p[]));
    
    // TODO: also check like ./vendor/franca
    range(0, 3) { _ |
        p.pop_path_segment();
        if(check(p), => return(Some = p[]));
    };

    // TODO: this doesn't work if its a symlink to the exe. need to follow that? 
    p := get_executable_path(a).assume_owned(a);
    p := p&;
    assert(p.pop_until_endswith("/"), "path should have slashes"); // we want our folder, not our exe. 
    
    p.push_path_segment("franca");
    if(check(p), => return(Some = p[]));
    // exe might be in franca/target/release/franca or franca/target/debug/deps/compiler-21be1aa281dbe5d6, so go up
    range(0, 5) { _ |
        p.pop_path_segment();
        if(check(p), => return(Some = p[]));
    };
    .None
}

fn pop_until_endswith(self: *List(u8), suffix: []u8) bool = {
    while (=> !self.is_empty() && !self.items().ends_with(suffix)) {
        self.pop();
    };
    !self.is_empty()
}

// TODO: pass requested type through generic args so this isn't so clunky. -- Jun 23
fn init_self_hosted(build_options: *BuildOptions) *SelfHosted #compiler = {
    a: ArenaAlloc = init(page_allocator, 1.shift_left(23));
    arena := a&.borrow().boxed(ArenaAlloc, a);
    a := arena.borrow();
    pool: StringPool = init(a);
    pool := a.boxed(StringPool, pool);
    codemap: CodeMap = init(a);
    codemap := a.boxed(CodeMap, codemap);
    t: List(ParseTask) = list(a);
    parser: Parser = (pool = pool, lex = Lexer.zeroed(), tasks = a.boxed(List(ParseTask), t), alloc = a, last = Token.zeroed());
    
    s: Scopes = (
        scopes = list(a),
        types = init(10, a),
        constants = init(10, a),
        already_loaded = init(a),
    );
    s := a.boxed(Scopes, s);
    s.new_scope(scope_from_index(0), 0);
    
    b: Baked = (
        values = init(10, a),
        lookup = init(a),
        functions = init(a),
        custom_bake_constant = init(a),
    );
    b := a.boxed(Baked, b);
    
    // Sadly this can't use default fields, I think because it loads too early. 
    env: ComptimeEnvironment = (
        inject_function_header = .None,
        make_slice_t = .None,
        bake_os = .None,
        fat_expr_type = .None,
        intrinsic_type = .None,
        build_options = BuildOptions.raw_from_ptr(build_options),
        unquote_placeholders = .None,
        // TODO: i should be setting this to real memory will all the fields .None because rust will be looking at it
        //       i think this just happens to work because i always set it to something else in the driver program. 
        driver_vtable_ptr = 0.rawptr_from_int(),  
        driver_vtable_user_data = 0.rawptr_from_int(),
        new_sema = false,
    );
    env := a.boxed(ComptimeEnvironment, env);
    self: SelfHosted = (
        pool = pool,
        codemap = codemap,
        parser = a.boxed(Parser, parser),
        ast_alloc = arena,
        scopes = s,
        vtable = ImportVTable.ptr_from_int(0), // this gets filled in by the rust side.
        baked = b,
        last_loc = (low = 0, high = 0),
        env = env,
        primitives = init(a),
        index = init(a),
        functions = init(10, a),
        aarch64 = new(1.shift_left(27)), // Its just virtual memory right? I really don't want to ever run out of space and need to change the address.
        bytecodes = init(10, a),
        saved_bytecodes = init(a),
        free_bytecodes = list(a),
        types = init(10, a),
        type_extra = init(10, a), 
        type_lookup = init(a),
        finished_layout_deep = empty(a),
        dispatch = init(a),
    );
    self&.init_fixed_types();
    a.boxed(SelfHosted, self)
}

fn get_function(self: *SelfHosted, fid: FuncId) *Func #compiler = {
    self.functions&.nested_index(fid.to_index().zext())
}

fn add_function(self: *SelfHosted, f: Func) FuncId #compiler = {
    self.functions&.push(f);
    i: u32 = self.functions.len.sub(1).trunc();
    funcid_from_index(i)
}

fn get_alloc(self: *SelfHosted) Alloc = self.ast_alloc.borrow();
fn get_alloc(self: CompilerRs) Alloc = self.ast_alloc.borrow();

fn show_error_line(self: *CodeMap, span: Span) void #compiler = {
    line := self.get_whole_line(span);
    set_colour(250, 0, 0);
    @println("> At line %, col % in file %", line.line, line.col, line.filename);
    unset_colour();
    println(self.source_slice(line.line_text));
}

fn log_stmt(pool: *SelfHosted, s: *FatStmt) Str #compiler = FatStmt.export_log(pool, s);
fn log_expr(pool: *SelfHosted, s: *FatExpr) Str #compiler = FatExpr.export_log(pool, s);
fn log_pattern(pool: *SelfHosted, s: *Pattern) Str #compiler = Pattern.export_log(pool, s);
fn log_func(pool: *SelfHosted, s: *Func) Str #compiler = Func.export_log(pool, s);
fn log_lazy_type(pool: *SelfHosted, s: *LazyType) Str #compiler = LazyType.export_log(pool, s);

export_log :: fn($T: Type, pool: *SelfHosted, self: *T) Str #generic = {
    out: List(u8) = list(temp());
    self.log(pool, out&, 0);
    out.items()
}

fn clone(self: *SelfHosted, e: *FatExpr) FatExpr = {
    e.deep_clone(self.get_alloc())
}

fn clone(self: *SelfHosted, e: *LazyType) LazyType = {
    e.deep_clone(self.get_alloc())
}

::tagged(BakedEntry);
::DeriveFmt(get_variant_type(BakedEntry, BakedEntry.Tag().Num));
::DeriveFmt(BakedEntry);
::DeriveFmt(BakedVarId);
::display_slice(BakedEntry);
::enum(Prim);
