
:: add_compiler_hashers;
#use("@/compiler/codemap.fr");
#include_std("compiler/lex.fr");
#include_std("compiler/pool.fr");
#include_std("compiler/parse.fr");
#include_std("compiler/error_reporting.fr");
#include_std("compiler/scope.fr");
#include_std("compiler/walk_ast.fr");
#include_std("compiler/comptime.fr");
#include_std("compiler/values.fr");
#use("@/compiler/profile.fr");
#include_std("compiler/dispatch.fr"); 
#include_std("compiler/sema.fr"); 
#include_std("compiler/ast_boring.fr");
#use("@/compiler/ast_external.fr");  
DUMB_EMIT_IR :: Foreign.ENV.DUMB_EMIT_IR.get_environment_variable().is_some();
USE_VM :: false && abi_shift_native_to_easy;
EmitIr :: @if(abi_shift_native_to_easy, EmitIrB(), EmitIrA()); 
#include_std("compiler/emit_ir.fr");
#include_std("boot/src/dumb_emit.fr"); 
#include_std("compiler/jit.fr");
Incr :: import("@/compiler/incremental.fr");

#use("@/lib/collections/bit_set.fr");
#use("@/lib/collections/map.fr");
#use("@/lib/sys/process.fr");
#use("@/lib/sys/fs.fr");
#use("@/lib/collections/bucket_array.fr");
#use("@/backend/lib.fr");
HACK_PARSER_ALLOC :: false;
SPAM_DYN_CALL :: false;

Crash :: import("@/lib/crash_report.fr");
Vm :: import("@/boot/src/vm.fr");

// TODO: don't individually allocate all these. 
SelfHosted :: @rec @struct(
    env: *ComptimeEnvironment,
    pool: *StringPool,
    codemap: *CodeMap,
    parser: *Parser,
    ast_alloc: *Arena.Allocator,
    scopes: *Scopes,
    baked: *Baked,
    last_loc: Span,
    library_scope: ScopeId,
    functions: BucketArray(Func),  // TODO: have a version of this type that doesn't add gaps if you push_all because that will break the indexing
    types: BucketArray(TypeInfo),
    // TODO: decide if these are generally accessed at the same time so should be stored together.
    // TODO: have a OptionalBucketArray that stores a bit set at the beginning of each bucket? 
    type_extra: BucketArray(TypeMeta), 
    type_lookup: HashMap(*TypeInfo, Type),
    // TODO: its dumb that deep is here and shallow is in typeinfo struct?  -- Jul 21
    finished_layout_deep: DynamicBitSet,
    dispatch: CompilerDispatch,
    legacy_indirection: Compiler = Compiler.zeroed(),
    vtable: *ImportVTable,
    stack_base: i64,
    comptime_libraries: HashMap(Symbol, Dyn.Handle),
    comptime_codegen: *FrontendCodegen,
    dyncalls: HashMap(FnType, DynCallShim),
    call_depth := 0,
    where_memo: HashMap(WhereKey, FuncId),
    imports: *HashMap(Symbol, ScopeId),  // TODO: very very bad if this struct gets too big?? :FUCKED
    scopes_generation := 0,
    other_module: RawList(*QbeModule),
    stack_trace_last_callee: ?FuncId, // bleh
    backtrace_node: *Crash.LocationResolverNode,
    recycle_overloadattempt: List(*OverloadAttempt),
    debug_deny_jit_shim_calls := false,
    debug_deny_unfilled_jit_shim_calls := false,
    main_thread_tls: i64,
    stats := zeroed @struct {
        lit_fn: i64;
        ir_ops: i64;
        macro_calls: i64;
        spec_const_fn: i64;
        dyn_call: i64;
        shim_calls: i64;
        yield_count: i64;
        where_clause: i64;
        os_resolve: i64;
        os_resolve_iter: i64;
        os_resolve_add: i64;
    },
    expr_pair_type := UnknownType,
    debug := 0,
    log: List(u8),
    string_type: ?Type,
    comptime_prefer_syscalls: bool,  // need this inside a jit-shim where you might not have tls
    export_ffi := zeroed ExportFfi,
    threaded_jit_shim: @struct {
        kiki: u32 = 0;
        bouba: u32 = 0;
        slots := zeroed Array(WipJitShim, 32);
    } = (),
    have_jit_shim := @if(IS_BOOTSTRAPPING, (), zeroed(RawList(FuncId))),
    vm := @if(@run(!DUMB_EMIT_IR), (), zeroed(*Vm.Vm)),
);
ExportFfi :: @struct(src: Str, fns: []rawptr);
WipJitShim :: @struct {
    fid: FuncId;
    state: State;
    callable: rawptr;
    State :: @enum(u32) (Uninit, Claimed, Waiting, Working, Done);
};

OverloadKey :: @struct(arg: Type, req: Type);
WhereKey :: @struct(template: FuncId, arg: Values);

:: AutoHash(OverloadKey, TrivialHasher);
:: AutoEq(OverloadKey);
:: AutoEq(WhereKey);
:: AutoHash(WhereKey, TrivialHasher);

PRes :: Result(void, *CompileError);

fn load_file_in_compiler(vtable: *ImportVTable, path: Str, opts: *BuildOptions) CRes(CompCtx) = {
    // :io_driver
    // TODO: put this somewhere else? 
    //if source.len > prelude.len + 4 {
    //    maybe_magic := source.items().subslice(prelude.len, 4);
    //    check_magic :: fn(M: u32) => 
    //        maybe_magic.starts_with(ptr = ptr_cast_unchecked(u32, u8, M&), len = 4);
    //    // TODO: comment on architecture 
    //    @err_assert(!check_magic(import("@/backend/macho/bits.fr").macho_magic), "load_file_in_compiler: the bytes in '%' look like a Mach-O file, not source code.", path) return;
    //};
    
    comp := {vtable.init_compiler}(opts);
    c := vtable.with(comp);
    s := u8.list(c.get_alloc());
    @fmt(s&, """#include_std("lib/core.fr");#include_std("%");""", path);
    file := c.add_file("-", s.items());
    self := c.data.cast();
    stmts := c.data.parse_stmts(file&);
    // TODO: handle error
    stmts := self[][].unwrap_report_error([]FatStmt, stmts); 
    // TODO: you want to be able to return an error but they can't do anything with a CompileError because they don't have the compiler instance. 
    self[][].unwrap_report_error(void, {c.vtable.make_and_resolve_and_compile_top_level}(c.data, stmts));
    (Ok = c)
}

Dyn :: import("@/lib/dynamic_lib.fr");

fn run_franca_file(vtable: *ImportVTable, path: Str, no_cache: bool) CRes(void) = {
    no_cache = no_cache || DUMB_EMIT_IR;
    mark := mark_temporary_storage();
    F :: @FnPtr(*ImportVTable) void;
    callee: ?F = .None;
    cachepath := choose_cache_filename(path);
    
    a := general_allocator();
    to_free: ?Ty(*QbeModule, *Crash'LocationResolverNode) = .None;
    to_free_h: ?*Incremental.Header = .None;
    to_free_c: ?CompCtx = .None;
    
    if !path.ends_with(".fr") {
        if Dyn'open(path) { handle |
            ref := handle.get("driver") || 
                (handle.get("main") ||
                    @panic("opened '%' as shared library but failed to get symbol 'driver'", path));
            @eprintln("Loaded precompiled driver: %", path);
            callee = (Some = ptr_cast_unchecked(rawptr, F, ref&)[]);
        } else {
            // If they passed a .frc file explicitly, don't check that the hashes haven't changed. 
            // It's just treated as a precompiled program same as if they passed a .dylib. 
            // This is different from running it with backend/meta/qbe_frontend.fr 
            // because we pass *ImportVTable in case it's a driver. 
            @if(enable_incremental()) 
            if read_cached(a, path) { header |
                t := Incremental'pack_current_target();
                @assert_eq(header.arch_os.bit_and(t), t, ".frc was compiled for a different target");
                callee = (Some = compile_cached(header, to_free&));
                to_free_h = (Some = header);
                @eprintln("Loaded precompiled driver: %", path);
            };
        }
    } else {
        z := zone_begin(.CheckCache);
        @if(enable_incremental()) @if(!no_cache)
        if read_cached(a, cachepath) { header |
            break :: local_return;
            start := timestamp();
            t := Incremental'pack_current_target();
            to_free_h = (Some = header);
            if(header.arch_os.bit_and(t) != t, => break());

            // This is extra important since im using a very collidable file name in choose_cache_filename 
            // (just chopping out non _azAZ09 chars. i.e. `a b` and `a.b` become the same). 
            // TODO: it's unfortunate to have `a.out` not match `./a.out`,
            //       but that was a problem with the old way too (hash of file name). 
            if(header.entry_dep.off == Qbe.no_symbol, => break());
            entry_dep := header.get(header.entry_dep);
            if(header.get(entry_dep.filename) != @tfmt("@/%", path), => break());
            // don't try to use it if it's from import_module (ie. repl.fr has main and exports in the same file)
            // TODO: should go in seperate .frc files when that happens. 
            //       because right now repl.fr's cache file (the exe) will depend on 
            //       itself (!/examples_repl_fr.frc, the lib) and always (correctly) fail 
            //       when recursing in files_unchanged because the hash won't match 
            //       because it was overwritten by the exe. 
            @if(header.get(header.entry_source) != "") break();
            
            if(!files_unchanged(header, get_include_std, Incr.self_hash), => break());
            middle := timestamp();
            callee = (Some = compile_cached(header, to_free&));
            end := timestamp();
            if(show_backend_stats(), => @eprintln(">>> hit: %\n>>> check: %ms, compile: %ms", cachepath, middle-start, end-middle));
        };
        @if(callee.is_none()) if to_free_h { it |
            a.dealloc(u8, it.as_bytes());
        };
        zone_end(z);
    };
    
    if callee.is_none() {
        break :: local_return;
        safe :: safety_check_enabled(.DebugAssertions);
        start := timestamp();
        opts := vtable.default_build_options(); 
        opts.retain_function_names = true;
        
        // HACK: inherit safety mode just because it's really slow if running in the vm
        @if(DUMB_EMIT_IR && !@run safety_check_enabled(.DebugAssertions)) {
            it := opts.safety_checks&;
            it.insert(.Bounds, false);
            it.insert(.DebugAssertions, false);
            it.insert(.InvalidTag, false);
        };
        
        // this needs to be set based on the host. 
        // ie. if you build the compiler targetting an environment without a libc, 
        // we can't just produce a libc when loading a driver program. 
        opts.no_cache = no_cache;
        c := @try(vtable.load_file_in_compiler(path, opts)) return;
        env := c.get_comptime_env();
        @if(show_backend_stats())
        @eprintln(">>> compiler configuration: threads=%, debug_assertions=%, host = (%, %), nocache=%, syscalls=%", 
            use_threads, safe, current_arch(), current_os(), no_cache, prefer_syscalls());
        
        self := c.data.cast()[][];
        
        cache_it := !no_cache && enable_incremental();
        
        
        was_bootstrapping :: __driver_abi_version <= 1119;

            m := general_allocator().box_uninit(QbeModule);
            backend'init_module(m, (
                arch = query_current_arch(), 
                os = query_current_os(), 
                type = @if(cache_it, .Cached, .JitOnly),
                expecting_wx = was_bootstrapping,  // :UpdateBoot
                // note: not expecting_wx=true even when JitOnly, 
                // still compile everything up front and then make_exec() instead of using MAP_JIT. 
                // this means the callee program can use apple_thread_jit_write_protect if it wants. 
            ));
            self.other_module&.push(m, self.get_alloc());
            shared := init_codegen(m, self.get_alloc(), true);
        
        apple_thread_jit_write_protect(true);  // :JitMemProtect this thread wants to execute
        
        f := c.get_unique_named("driver") 
            || c.get_unique_named("main") 
            || panic("expected a function called main or driver.");
        
        name := c.fmt_fn_name(f);
        cc := zeroed rawptr;
            // no wrap_main so don't waste time compiling a new franca_runtime_init. 
            done := main_thread_pump(self.comp(), shared, @slice(f), false);
            self.debug_deny_jit_shim_calls = !DUMB_EMIT_IR;
            if no_cache {
                seal_debug_info(m, empty(), false, empty());
                each self.comptime_libraries& { _, lib |
                    Qbe'fill_pending_dynamic_imports(m, lib[]);
                };
                Qbe'seal_imports(m);
                m.make_exec();
                
                c_m := self.comptime_codegen.m;
                @if(DUMB_EMIT_IR) {
                    @if(IS_BOOTSTRAPPING) unreachable();
                    f := ();
                    while => self.have_jit_shim&.pop() { fid |
                        have_shim := false;
                        id := self.comptime_jit_symbol_id(fid);
                        use_symbol(c_m, id) { s |
                            @if(done&.get(fid.as_index()))
                            if m.get_addr(m.intern(s.name)) { addr, size |
                                s.jit_addr = addr;
                                s.size = size.trunc();
                                self.get_function(fid).set_flag(.RealAsmDone);
                            };
                            have_shim = identical(s.jit_addr, s.shim_addr);
                        };
                        
                        if have_shim {
                            res := self.poll_in_place(void, => self.compile_body(fid));
                            self.unwrap_report_error(void, res);
                            self.shallow_jit_func(fid);
                        };
                    };
                    self.debug_deny_unfilled_jit_shim_calls = true;
                    c_m.write_perfmap_symbols();
                };
            };
        
        if show_backend_stats() { // :TodoLinux
            frontend := clock_ms(MacosLibc.CLOCK_THREAD_CPUTIME_ID);
            code_count := m.segments&[.Code]&.len() - m.goal.commands_size_guess;
            @if(!cache_it)
            @eprintln(">>> jitted % bytes of code.", code_count);
            @eprintln(">>> compiled % in %ms", name, frontend);  // :WrongClockTime
        };
        
        @if(enable_incremental())
        if cache_it {
            // TODO: seal_debug_info properly
            //
            // matters on linux because of do_relocations_static_linux()
            seal_debug_info(m, empty(), false, empty());
            
            make_dirs_or_crash(cache_dir());
            header := write_cache(m, c, f, cachepath, path);
            to_free_h = (Some = header);
            drop(m);
            general_allocator().dealloc_one(QbeModule, m);
            c'vtable'destroy_compiler(c.data);

            // this doesn't re-read the files to check if they changed since you started compiling, that would feel a bit creepy. 
            z := zone_begin(.CheckCache);
            callee = (Some = compile_cached(header, to_free&));
            zone_end(z);
            break();
        };
        to_free_c = (Some = c);
            to_free = (Some = (m, zeroed(*Crash'LocationResolverNode)));
            cc = m.get_addr(name) || @panic("ICE: lost %", name);
        
        callee = (Some = assume_types_fn(Arg = *ImportVTable, Ret = void, ptr = cc));
    };
    
    callee := callee.unwrap();
    @if(abi_shift_native_to_easy, {
        callee := bit_cast_unchecked(@type callee, i64, callee);
        r, a := ((), init_driver_vtable(true));
        @assert(!abi_shift_easy_to_native, "wrap_vtable_with_native");
        self := to_free_c.unwrap();
        self := self.data.cast()[][];
        self.vm.eval(callee, void.cast_to_bytes(r&), cast_to_bytes(*ImportVTable, a&));
    }, {
        push_as_tls(.comptime, zeroed(rawptr)) {
            callee(vtable);
        };
    });
    
    if to_free { m, r |
        Crash'pop_resolver(r);
        drop(m);  // waste of time
        general_allocator().dealloc_one(QbeModule, m);
    };
    if to_free_h { it |
        a.dealloc(u8, it.as_bytes());
    };
    if to_free_c { it |
        it'vtable'destroy_compiler(it.data);
    };
    reset_temporary_storage(mark);
    .Ok
}

fn init_self_hosted(opts: *BuildOptions) *SelfHosted = {
    stack_base := 0;
    a: Arena.Allocator = init(page_allocator, 1.shift_left(23));
    arena := a&.borrow().box_uninit(Arena.Allocator);
    arena[] = a;
    a := arena.borrow();
    opts = a.boxed(BuildOptions, opts[]);
    pool: StringPool = init(a);
    pool := a.boxed(StringPool, pool);
    codemap: CodeMap = init(a);
    codemap := a.boxed(CodeMap, codemap);
    t: List(ParseTask) = list(a);
    parser: Parser = (pool = pool, lex = Lexer.zeroed(), tasks = a.boxed(List(ParseTask), t), alloc = a, last = Token.zeroed(), top_level = true);
    
    s: Scopes = (
        scopes = init(10, a),
        variables = init(10, a),
        already_loaded = init(a),
    );
    s := a.boxed(Scopes, s);
    s.new_scope(scope_from_index(0), a, Span.zeroed());
    s.variables&.push(zeroed(VarData));  // for good luck
    
    b: Baked = (
        vmem = init(a),
        values = init(10, a),
        custom_bake_constant = init(a),
    );
    b := a.boxed(Baked, b);
    b.values&.push(zeroed BakedValue); // skip one for good luck
    
    arch := query_current_arch();
    os := query_current_os();

    // Sadly this can't use default fields, I think because it loads too early. 
    env: ComptimeEnvironment = (
        make_slice_t = .None,
        bake_os = .None,
        fat_expr_type = .None,
        intrinsic_type = .None,
        build_options = BuildOptions.raw_from_ptr(opts),
        unquote_placeholders = .None,
        comptime_os = query_current_os(),
        os_type = .None,
        compile_error_pointer = .None,
        runtime_init = .None,
    );
    env := a.boxed(ComptimeEnvironment, env);
    opts.env = ComptimeEnvironment.raw_from_ptr(env);
    
    m := a.box_uninit(QbeModule);
    backend'init_module(m, (
        arch = arch, 
        os = os, 
        type = .JitOnly,
        expecting_wx = true,
        got_indirection_instead_of_patches = true,  // comptime needs to be more flexible with late bound references.
    ));
    
    self := a.box_uninit(SelfHosted);
    self[] = (
        pool = pool,
        codemap = codemap,
        parser = a.boxed(Parser, parser),
        ast_alloc = arena,
        scopes = s,
        baked = b,
        last_loc = (low = 0, high = 0),
        env = env,
        functions = init(10, a),
        types = init(10, a),
        type_extra = init(10, a), 
        type_lookup = init(a),
        finished_layout_deep = empty(a),
        dispatch = init(a),
        stack_base = i64.int_from_ptr(stack_base&),
        comptime_libraries = init(a),
        vtable = init_driver_vtable(false),
        comptime_codegen = init_codegen(m, a, false),
        dyncalls = init(a),
        where_memo = init(a),
        imports = a.boxed(HashMap(Symbol, ScopeId), init(a)),
        other_module = empty(),
        stack_trace_last_callee = .None,
        backtrace_node = push_resolver(SelfHosted, self, find_function_aa),
        recycle_overloadattempt = list(a),
        library_scope = NOSCOPE, // patched in make_top_level
        main_thread_tls = get_stack_base_for_tls(),
        string_type = .None,
        log = list(a),
        comptime_prefer_syscalls = prefer_syscalls(),
    );
    self.comptime_codegen.m.codemap = (Some = self.codemap);
    self.add_function(zeroed Func);  // just for good luck. life is better when FuncId=0 is invalid. 
    self.other_module&.push(self.comptime_codegen.m, self.get_alloc());
    
    self.init_fixed_types();
    self.pool.fill_fixed_flags();
    self.get_function(zeroed FuncId)[].name = self.pool.insert_owned("ThisIsThePlaceholderForFuncIdZeroYouShouldNotSeeThis");
    
    // :MultiDylibLibc HACK  TODO: need a first class way to talk about one logical library that's split into multiple files. 
    enumerate find_os_libc_dylib() { i, libc_path |
        if Dyn'open(libc_path[]) { libc |
            name := u8.list(self.get_alloc());
            name&.push_all("libc");
            range(0, i) { _ |
                name&.push_all("*");
            };
            libc_name := self.pool.insert_owned(name.items());
            self.comptime_libraries&.insert(libc_name, libc);
        };
    };
    
    c := tls(.comptime);
    @assert(c[].is_null(), "Cannot call init_self_hosted inside another compiler. push_context with comptime=null first.");
    c[] = SelfHosted.raw_from_ptr(self);
    self.export_ffi = fill_export_ffi(self);
    
    // TODO: allow not matching the compiler even when keeping the same abi
    opts.tls_stack_bits = franca_required_stack_bits;
    
    @if(abi_shift_native_to_easy) Vm'init_vm_and_tls(self);
    @if(abi_shift_easy_to_native) {
        // back to the real one 
        // TODO: allow changing stack_bits and also will have to get more compilated when boot isn't self hosted
        n := franca_required_stack_bits + 1;
        opts.tls_stack_bits = n;
    };
    
    stable_compiler_context :: fn(self: *SelfHosted) Compiler = {
        a := self.get_alloc();
        mem1 := a.boxed(*SelfHosted, self);
        erased := (*SelfHosted).raw_from_ptr(mem1);
        compiler := a.boxed(CompilerValue, 
            (pointer_to_pointer_to_selfhosted = erased));
        compiler
    };
    self.legacy_indirection = self.stable_compiler_context();
    
        d := self.debug;
        for opts.frontend_logging { c | 
            d = d.bit_or(1.shift_left(c.zext() - "A".ascii()));
        };
        self.debug = d;
        @if(d != 0) self.log&.reserve(1.shift_left(20));
    
    self
}

vm_backtracing_panic_handler :: fn(msg: Str) Never = {
    self := current_comptime();
    @if(!self.is_null()) self.vm.log_backtrace();
    Crash'backtracing_panic_handler(msg);
};

FrontendCodegen :: @struct {
    worker: *CodegenShared;
    m: *QbeModule;
    type_indices: HashMap(Type, i64);
    // index is BakedVarId
    constants_used: import("@/lib/collections/bit_set.fr").DynamicBitSet;
    frc_imports: RawList(Incr.FrcModuleInstance);
};

fn init_codegen(m: *Qbe.Module, a: Alloc, threaded: bool) *FrontendCodegen = {
    threaded := threaded && !abi_shift_native_to_easy;
    worker := init_codegen_worker(m, threaded);
    if abi_shift_native_to_easy {
        m.target.hack_builtin_memmove.len = 0;
        @if(USE_VM) {
            worker.enqueue = Vm'enqueue;
            worker.join = fn(_0) = ();
        };
    };
    @if(abi_shift_easy_to_native) {
        FR_hack_trace_module :: fn(m: *Qbe.Module) void #weak #libc;
        FR_hack_trace_module(m);
    };
    a.boxed(FrontendCodegen, (
        worker = worker,
        m = m,
        constants_used = empty(a),
        type_indices = init(a),
        frc_imports = init(a, 64),  // TODO: don't have a fixed size. need to use BucketArray or something tho
    ))
}

MainThreadPump :: @struct {
    comp: CompCtx;
    funcs_done: DynamicBitSet;
    funcs_seen: DynamicBitSet;
    work_stack: List(FuncId);
    pending: List(FuncId);
    enable_tracy: bool = @if(ENABLE_ENABLE_TRACY, ENABLE_TRACY, false);
};
fn main_thread_pump(comp: CompCtx, shared: *FrontendCodegen, fns: []FuncId, wrap_main: bool) DynamicBitSet = {
    main_thread_pump(comp, shared, fns, wrap_main, EmitIr)
}

// this will always emit everything callees reachable from `fns` (so no jit-shims will remain at the end). 
// so it's suitable for AOT compilation, but you can still use it for JIT if you want. 
// since there will be no shims, it's safe to use this when you want to set comptime=null 
// before calling the function (like for drivers in `run_franca_file`). 
fn main_thread_pump(comp: CompCtx, shared: *FrontendCodegen, fns: []FuncId, wrap_main: bool, $EmitIr: Type) DynamicBitSet = {
    a      := comp.get_alloc();
    env    := comp.get_comptime_env();
    opts   := comp.get_build_options();
    when := @if(IS_BOOTSTRAPPING && shared.m.goal.type == .JitOnly, ExecStyle.Jit, .Aot);
    // TODO: dynamiclib is kinda broken because i rely on being called in a stack with tls setup
    dynamiclib := shared.m.goal.type == .Dynamic;
    wrap_main := wrap_main && !dynamiclib;
    shared.m.codemap = (Some = comp'vtable'get_codemap(comp.data));
    
    for fns { f |
        id := shared.m.intern(comp.fmt_fn_name(f));
        use_symbol(shared.m, id) { s |
            s.referenced = true;
            if !dynamiclib && !wrap_main {
                s.export = true;
            };
        };
    };
    
    self: MainThreadPump = (funcs_done = empty(a), funcs_seen = empty(a), work_stack = list(a), pending = list(a), comp = comp);
    if wrap_main {
        rt_init := env.runtime_init.expect("declaration of franca_runtime_init (forgot to include lib/core.fr?)");
        self.work_stack&.push(rt_init);
    };
    self.work_stack&.push_all(fns);
    
    while => self.work_stack.len != 0 {
        continue :: local_return;
        fid := self.work_stack[self.work_stack.len - 1];
        fid_i: i64 = fid.to_index().zext();
        if self.funcs_done&.get(fid_i) {
            // might have been added multiple times
            self.work_stack&.pop();
            continue();
        };
        
        first_time := !self.funcs_seen&.get_set(fid_i);
        comp'vtable'report_aot_progress(comp.data, fid, true, 1 /*AotPump*/);
        func := comp.get_function(fid);
        // Note: compile before checking callees!
        xx := comp'vtable'compile_func(comp.data, fid, .Aot);
        or xx { err | 
            @println("failed compile %", comp.get_string(func.name));
            comp.report_error(err)
        };  // TODO: return error instead
        if self&.push_callees(func.callees&.items(), first_time) {
            // no pop
            continue();
        };
        
        emit_ir :: EmitIr.emit;
        xx := emit_ir(comp, shared, fid, when, self.pending&, false);
        or xx { err | 
            comp.report_error(err);
        };
        
        comp'vtable'report_aot_progress(comp.data, fid, false, 1 /*AotPump*/);
        current := self.work_stack&.pop().unwrap();
        @debug_assert_eq(current, fid, "order messed up");
        self&.add_work(self.pending&.items());  // HACK
        self.pending&.clear();
        self.funcs_done&.set(fid_i);
        self&.add_work(func.mutual_callees&.items());
    };
    
    @if(wrap_main) wrap_with_runtime_init(comp, shared.worker, fns[0]);
    
    @if(dynamiclib) for fns { f |
        emit_export_wrapper(comp, shared.worker, f);
    };
    
    c := comp.data.cast()[][];
    print(c.log.items()); 
    c.log&.clear();
    
    shared.join_codegen_thread();
    self.funcs_done
};

fn join_codegen_thread(it: *FrontendCodegen) void = 
    it.worker.join_codegen_thread();

fn enter_task(it: *FrontendCodegen, $body: @Fn(it: *CodegenEntry) void) void = 
    it.worker.enter_task(body);

// sort the functions to make sure we can inline calls to intrinsics
fn push_callees(self: *MainThreadPump, callees: []FuncId, first_time: bool) bool #once = {
    not_done_count := 0;
    for callees { f |
        continue :: local_return;
        if self.funcs_done&.get(f.to_index().zext()) {
            continue();
        };
        i := self.work_stack.items().index_of(f&) || {
            // fresh callee, always do it before the caller (to give it a chance to be inlined)
            self.work_stack&.push(f);
            not_done_count += 1;
            continue();
        };
        
        if self.enable_tracy {
            //       but otherwise the stack of zones gets messed up and you don't see anything
            continue();
        };
        
        // :CompileIntrinsicsFirst
        if !first_time && !self.comp.get_function(f).get_flag(.Intrinsic) {
            continue();
        };
        
        // another function has had the same callee before, still pull it forward, we want to let both inline it. 
        // only do this the first time processing the caller to avoid cycles (for mutual recursion). 
        self.work_stack&.unordered_remove(i);
        self.work_stack&.push(f);
        not_done_count += 1;
    };
    not_done_count > 0 
}

fn add_work(self: *MainThreadPump, new: []FuncId) void = {
    for new { c |
        done := self.funcs_done&.get(c.to_index().zext());
        // when using tracy, it's not ok to reorder the work stack because it messes up the profile zones. 
        safe_order := !self.enable_tracy || !self.work_stack.items().contains(c&);
        if !done && safe_order {
            self.work_stack&.push(c);
        };
    };
}

fn emit_export_wrapper(comp: CompCtx, shared: *CodegenShared, f: FuncId) void = {
    enter_task shared { entry |
        func := comp.get_function(f);
        real_name := comp.get_string(func.name);
        lnk := temp().boxed(Qbe.Lnk, (
            id = shared.m.intern(real_name),
            export = true,
        ));
        entry.task = (Bounce = (lnk = lnk, target = shared.m.intern(comp.fmt_fn_name(f))));
    };
}

// On macos, we want to save the arguments to the exe entry point. 
// On linux, franca_runtime_init does some extra stuff to grab them from the stack. 
fn wrap_with_runtime_init(comp: CompCtx, shared: *CodegenShared, user_main: FuncId) void = {
    env := comp.get_comptime_env();
    runtime_init := env.runtime_init.expect("declaration of franca_runtime_init (forgot to include lib/core.fr?)");
    enter_task shared { entry |
        f := temp().box_uninit(Qbe.Fn);
        f.default_init(shared.m);
        f.lnk.export = true;
        f.lnk.id = shared.m.intern("main");  // macho/emit looks for this specifically
        name := comp.fmt_fn_name(user_main);
        f.start = newblk();
        f.nblk = 1;
        argc := f.newtmp("argc", .Kl);
        argv := f.newtmp("argv", .Kl);
        envp := f.newtmp("envp", .Kl);
        sp := f.newtmp("sp", .Kl);
        // IMPORTANT: you can't use f.emit because threads. 
        b := f.start;
        push(b, .par, .Kl, argc, QbeNull, QbeNull);
        push(b, .par, .Kl, argv, QbeNull, QbeNull);
        push(b, .par, .Kl, envp, QbeNull, QbeNull);
        push(b, .alloc4, .Kl, sp, f.getcon(48), QbeNull);
        runtime_init := f.symcon(comp.fmt_fn_name(runtime_init));
        push(b, .arg, .Kl, QbeNull, argc, QbeNull);
        push(b, .arg, .Kl, QbeNull, argv, QbeNull);
        push(b, .arg, .Kl, QbeNull, f.symcon(name), QbeNull);
        push(b, .arg, .Kl, QbeNull, envp, QbeNull);
        push(b, .arg, .Kl, QbeNull, sp, QbeNull);
        push(b, .call, .Kw, QbeNull, runtime_init, QbeNull);
        f.start.jmp.type = .ret0;
        entry.task = (Func = f);
    };
}

fn get_log_types(comp: CompCtx, fid: FuncId) Str = {
    #use("@/compiler/ast_external.fr");
    func := comp.get_function(fid);
    if(!func.get_flag(.LogIr), => return(""));
    each func.annotations& { n | 
        if n.name == Flag.log_ir.ident() {
            if n.non_void_arg() { arg |
                return(@match(arg.expr&) {
                    fn String(arg) => comp.get_string(arg[]);
                    @default => {
                        @eprintln("TODO: non string literal #log_ir arg for %", comp.get_string(func.name));
                        "P"
                    };
                });
            };
            return("P");
        };
    };
    // You get here if you call set_flag(.LogIr) directly in comptime code. 
    // It's convient to just give you something cause it's a pain in the ass to add a tag for just a quick debugging. 
    "P"
}

fn get_function(self: *SelfHosted, fid: FuncId) *Func #inline = {
    self.functions&.nested_index(fid.to_index().zext())
}

fn add_function(self: *SelfHosted, f: Func) FuncId = {
    i := self.functions.len;
    self.functions&.push(f);
    from_index(i)
}

// For now you can't change this to an allocator that actually frees, 
// because user code is allowed to just copy Ast nodes around and give us back aliased trees.
// This might be something to address when i rework the macro system.  
fn get_alloc(self: *SelfHosted) Alloc = {
    @if(use_threads)
    @debug_assert_eq(get_stack_base_for_tls(), self.main_thread_tls, "ast_alloc is not thread safe");
    self.ast_alloc.borrow()
}

// TODO: these are garbage. make #where work better

fn clone(self: *SelfHosted, e: *FatExpr) FatExpr = {
    out := @uninitialized FatExpr;
    deep_clone(out&, e, self.get_alloc());
    out
}

fn clone(self: *SelfHosted, e: *LazyType) LazyType = {
    out := @uninitialized LazyType;
    deep_clone(out&, e, self.get_alloc());
    out
}

fn clone(self: *SelfHosted, e: *Func) Func = {
    out := @uninitialized Func;
    deep_clone(out&, e, self.get_alloc());
    out
}

fn clone(self: *SelfHosted, e: *Pattern) Pattern = {
    out := @uninitialized Pattern;
    deep_clone(out&, e, self.get_alloc());
    out
}

::DeriveFmt(get_variant_type(BakedEntry, BakedEntry.Tag().Num));
::DeriveFmt(BakedEntry);
::DeriveFmt(BakedVarId);
::display_slice(BakedEntry);
