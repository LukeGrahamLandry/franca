//! This is sizeable chunk of the most boring smooth brain code. 
//! But it's easier to reason about than using some parser generator thing and doesn't involve taking a hefty dependency. 
//! Exactly zero of the problems I've faced writing a self-hosted compiler were that the bootstrapping process was **too simple**. 

// For reference, the rust one was 1100 loc (without math operators).

// TODO: make the language less clunky
// - less verbose if let/let else? think about how to express with a macro. 
// - auto coerce payload to enum when branches aren't ambigous? maybe? thats a bit creepy. doing it for unit when you just forget to return something would be bad. 
// - default function arguments because 'self.parse_expr(Prec.None)' and symmetry with structs. 
// - its probably a bad thing that im choosing when to factor out functions based on "not enough bits to refer to all slots",
//   obviously a crippling compiler bug (my asm backend only) but perhaps implies a style problem on my part.
// - same problem i had in rust. its really annoying that you have to pass the pool to print things because it makes debugging that way more clunky.
//   could have an implicit context system? crippling that you can't just derive print normal things. 
// - track all the errors you hit when failing overloads. 
//
// - local_return and return implciitly rebinding is a bit confusing
//

// TODO: everywhere i @report_error(_)(_ self.last.span) after just peek not pop will have the error in the wrong place. -- Jun 25

// TODO: :SLOW im doing so many silly copies and also need to actually enforce tailcalls on llvm (right now i might be preventing them with ccc even on internal functions!).  -- Jun 21

ParseTask :: @tagged(
    Pending: @struct(src: Str, span: Span),
    Expr: Result(FatExpr, *CompileError),
);
Parser :: @struct(pool: *StringPool, lex: Lexer, tasks: *List(ParseTask), alloc: Alloc, last: Token);
Prec :: @struct(prec: PrecLevel, allow_trailing: bool = true);

Prec_None: Prec : (prec = .None);
fn reset(p: Prec) Prec = p.with(.None);
fn with(p: Prec, next: PrecLevel) Prec = 
    (prec = next, allow_trailing = p.allow_trailing);

PrecLevel :: @enum(i64) (
    None,
    LogicalOr, LogicalAnd, Logical,
    Equality,
    Comparison,
    AddSub,
    MulDiv,
    Neg,
    Suffix,
);
ParseRes :: Result(FatExpr, *CompileError);

// TODO: do the clone here instead of (on rust side + scope) so you don't have to remmeber.
fn finish_pending(self: *Parser, id: WaitingParse) ParseRes = {
    @match(self.tasks[id.id]&) {
        fn Pending(src_span) => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            
            zone := zone_begin(.Parse); // TODO: defer
            e := self.parse_expr(Prec_None);
            zone_end(zone);
    
            // TODO: clone here instead of needing to remember later.
            // TODO: save less often!
            self.tasks[id.id] = (Expr = e);
            e
        }
        fn Expr(e) => e[];
    }
}

fn finish_pending_stmts(self: *Parser, id: WaitingParse) Result(RsVec(FatStmt), *CompileError) = {
    T :: Result(RsVec(FatStmt), *CompileError);
    @match(self.tasks[id.id]&) {
        fn Pending(src_span) => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            zone := zone_begin(.Parse); // TODO: defer
            e := self.parse_block_until_squiggle(true);
            zone_end(zone);
            self.tasks[id.id] = (Expr = @err("ICE: WaitingParse id was stmts (which aren't reused)."));
            @match(e) {
                fn Ok(e) => (Ok = e.expr.Block.body);
                fn Err(e) => (Err = e);
            }
        }
        fn Expr(e) => @err("ICE: WaitingParse id wanted stmts found expr.");
    }
}

fn get_span(e: *ParseRes) Span = {
    @match(e) {
        fn Ok(e) => e.loc;
        fn Err(e) => e.span;
    }
}

fn push_parse(self: *Parser, src: Str, span: Span) WaitingParse = {
    self.tasks.push((Pending = (src = src, span = span)));
    (id = self.tasks.len.sub(1))
}

fn parse_stmt(self: *Parser) Result(FatStmt, *CompileError) = {
    tags := @try(self.parse_annotations()) return;
    stmt := @try(self.parse_stmt_inner(!tags.is_empty())) return;
    
    if !tags.is_empty() {
        @match(stmt.stmt&) {
            fn DeclFunc(f) => {
                if f.annotations.is_empty() {
                    f.annotations = tags.rs();
                } else {
                    f.annotations&.push_all(tags.items(), self.alloc);
                };
            }
            fn Noop() => {
                stmt.stmt = (Annotations = tags.rs());
            }
            @default => @report_error("#annotations can only go before functions or semicolons.") (return, self.last.span);
        };
    };
    
    (Ok = stmt)
}

fn parse_stmt_inner(self: *Parser, has_annotations: bool) Result(FatStmt, *CompileError) #once = {
    @match(self.peek()) {
        fn Fn() => {
            self.pop();
            loc := self.last.span;
            func := @try(self.parse_func(true)) return;
            (Ok = self.stmt((DeclFunc = self.box(func)), loc))
        }
        fn Symbol(name) => self.parse_decl_or_start_expr(name);
        fn Semicolon() => {
            self.pop();
            loc := self.last.span;
            if has_annotations || (@is(self.peek_tag(), .RightSquiggle, .Eof)) {
                // At the end of blocks, i use them for distingushing when to return trailing expression. :store_noop
                return(Ok = self.stmt(.Noop, loc))
            };
            self.parse_stmt()
        }
        @default => {
            e := @try(self.parse_prefix(Prec_None)) return;
            self.after_expr_stmt_prefix(e)
        };
    }
}

fn parse_decl_or_start_expr(self: *Parser, name: Symbol) Result(FatStmt, *CompileError) #once = {
    self.pop();
    @match(self.peek()) {
        fn DoubleColon() => {
            loc := self.last.span;
            self.pop();
            e := @try(self.parse_expr(Prec_None)) return;
            s: Stmt = (DeclNamed = (kind = .Const, value = e, ty = .Infer, name = name));
            if !self.maybe(.Semicolon) {
                // TODO: maybe i should allow it if its a function declaration because that feels better and i do it for overload set stmts. 
                //       but that's a slippery slope to macro calls for struct declations, which i don't want becuase it feels you might accidently use the two arg version of the macro. 
                @report_error("expected semicolon after declaration") (return, self.last.span);
            };
            return(Ok = self.stmt(s, loc))
        }
        fn Colon() => {
            loc := self.last.span;
            self.pop();
            ty: LazyType = if(self.peek_tag() == .Equals, => .Infer) {
                (PendingEval = @try(self.parse_expr(Prec_None)) return)
            };
            kind: VarType = @match(self.pop()) {
                fn Equals() => .Var;
                fn Colon()  => .Const;
                @default => @report_error("expected = or : after declaration of variable %", self.pool.get(name)) (return, self.last.span);
            };
            value  := @try(self.parse_expr(Prec_None)) return;
            s: Stmt = (DeclNamed = (kind = kind, value = value, ty = ty, name = name)); // TODO: the rust thing where you don't have to say the name if the expr is a var read that matches.
            if !self.maybe(.Semicolon) {
                @report_error("expected semicolon after declaration") (return, self.last.span);
            };
            return(Ok = self.stmt(s, loc))
        }
        fn Comma() => {
            // That was actually like `a, b := e;`, so we want to turn that name into an expression and then find some more identifiers. 
            self.pop();
            loc := self.last.span;
            idents := @try(self.list_of_names_decl(name)) return;
            pattern := @try(self.ident_list_to_pattern(idents&, loc)) return;
            value := @try(self.parse_expr(Prec_None)) return;
            if !self.maybe(.Semicolon) {
                @report_error("expected semicolon after declaration") (return, self.last.span);
            };
            return(Ok = self.stmt((DeclVarPattern = (binding = pattern, value = value)), loc))
        }
        @default => {
            e := @try(self.ident_expr_and_maybe_trailing(name, Prec_None, self.last.span)) return;
            return(self.after_expr_stmt_prefix(e))
        };
    }
}

fn list_of_names_decl(self: *Parser, name: Symbol) Result(RsVec(FatExpr), *CompileError) = {
    first := self.expr((GetNamed = name), self.last.span);
    exprs: List(FatExpr) = list(2, self.alloc);
    exprs&.push(first);
    loop {
        @match(self.pop()) {
            fn Symbol(name) => {
                e := self.expr((GetNamed = name), self.last.span);
                exprs&.push(e);
                if self.peek_tag() != .Colon {
                    @try(self.eat(.Comma, "destructuring statment expected ':=' or ',' (TODO: allow type annotation)")) return; 
                };
            }
            fn Colon() => {
                @try(self.eat(.Equals, "destructuring statment expected ':=' (TODO: allow type annotation. TODO: allow const)")) return; 
                return(Ok = exprs.rs());
            }
            @default => @report_error("expected ident or ':' in destructuring") (return, self.last.span);
        }
    }
}

fn after_expr_stmt_prefix(self: *Parser, e: FatExpr) Result(FatStmt, *CompileError) = {
    loc  := e.loc;
    // TOOD: allow_trailing?
    e    := @try(self.parse_infix(e, Prec_None)) return;
    stmt := @match(self.peek()) {
        fn Equals() => {
            self.pop();
            loc := self.last.span;
            value := @try(self.parse_expr(Prec_None)) return;
            // TODO: check if the left is a tuple/struct and warn because they maybe meant :=. 
            self.stmt((Set = (place = e, value = value)), loc)
        }
        fn Op(op) => {
            f: Flag = @match(op) {
                fn MinusEq() => .operator_minus_equal;
                fn PlusEq()  => .operator_plus_equal;
                fn StarEq()  => .operator_star_equal;
                fn SlashEq() => .operator_slash_equal;
                @default => @report_error("non-update-assingment operator after expression statement. this should be unreachable?") (return, self.last.span);
            };
            self.pop();
            delta := @try(self.parse_expr(Prec_None)) return;
            e := self.bin_named_macro(f, e, delta, loc);
            self.stmt((Eval = e), loc)
        }
        fn Colon() => { // TODO: double colon?
            self.pop();
            pattern := @match(e.expr&) {
                fn StructLiteralP(pattern) => pattern[];
                fn Tuple(idents) => @try(self.ident_list_to_pattern(idents, e.loc)) return;
                @default => @report_error("destructuring statment requires tuple or struct on the left. `(a, b) := <>` or (a: c, b: d) := <>` ") (return, self.last.span);
            };
            loc := self.last.span;
            @try(self.eat(.Equals, "destructuring statment expected ':=' (put type annotations on each name)")) return; // TODO: (a, b): (c, d) = <>;
            value := @try(self.parse_expr(Prec_None)) return;
            self.stmt((DeclVarPattern = (binding = pattern, value = value)), loc)
        }
        @default => self.stmt((Eval = e), loc);
    };
    
    if !(@is(self.peek_tag(), .Semicolon, .RightSquiggle, .Eof)) {
        @report_error("expected ';' (discard) or '}' (return from block) after expr stmt") (return, self.last.span);
    };
    
    (Ok = stmt)
}

/*
// TODO: all the parse errors should tell you what token they hit (rn i don't print lex errors which is dumb)
::DeriveFmt(TokenType);
::enum(TokenType.Tag());
::DeriveFmt(LexErr);
::DeriveFmt(get_variant_type(TokenType, .Quoted));
::DeriveFmt(BinNum);
fn display(s: *f64, out: *List(u8)) void = s[].display(out);
fn display(s: *Symbol, out: *List(u8)) void = s[].as_index().display(out);
    but found %", self.peek_type()
*/

fn peek_type(self: *Parser) *TokenType = {
    t := self.lex&.peek();
    t.type&
}

fn ident_list_to_pattern(self: *Parser, idents: *RsVec(FatExpr), loc: Span) Result(Pattern, *CompileError) = {
    bindings: List(Binding) = list(idents.len, self.alloc);
    each idents { expr | 
        @match(expr.expr&) {
            fn GetNamed(name) => bindings&.push((name = (Ident = name[]), ty = .Infer, default = .None, kind = .Var));
            @default => @report_error("destructuring statment requires tuple with all expressions being single identifier. ") (return, expr.loc);
        };
    };
    (Ok = (bindings = bindings.rs(), loc = loc))
}

fn can_start_quick_expr(t: TokenType) bool #once = {
    // this lets you do 'if !whatever {'
    @if_let(t) fn Op(it) => return(it == .Bang); 
    // FatRightArrow works because you can't use trailing calls in a return type expression, lets you do 'while => cond {'
    @is(t&, .Symbol, .At, .Quoted, .Number, .BinaryNum, .FatRightArrow)
}

fn ident_expr_and_maybe_trailing(self: *Parser, name: Symbol, prec: Prec, loc: Span) ParseRes /* #inline */ = {
    e := self.expr((GetNamed = name), loc);
    old := self.lex.old_line;
    if prec.allow_trailing.and(=> can_start_quick_expr(self.peek())) {
        if old != self.lex.line {
            // this is a rule because i typo leave junk in files too often.
            @report_error("identifier '%' must be on the same line as quick expr.\nor you can add a semicolon if you wanted a noop expression stmt.", self.pool.get(name)) (return, loc);
        };
        first_arg := @try(self.parse_expr(prec = .None, allow_trailing = false)) return;
        // TODO: make sure this doesn't alias e -- Jun 21
        e = self.expr_call(e, first_arg);
    };
    
    (Ok = e)
}

fn parse_expr(self: *Parser, prec: Prec) ParseRes = {
    self.lex&.peek();
    // TODO: can't access field on rvalue. 
    // TODO: you can't return a pair at comptime if its not a pair of ints. (u32, u32) gives back 16 bytes from ffi::c and then compiler::jit crashes on it for being the wrong size. 
    e := @try(self.parse_prefix(prec)) return;
    self.parse_infix(e, prec)
}

fn parse_prefix(self: *Parser, prec: Prec) ParseRes = {
    @match(self.peek()) {
        fn Op(op) => {
            // TODO: @switch warning or handle like @match if you typo call the wrong one. 
            f: Flag = @match(op) {
                fn Minus() => .neg;
                fn Bang()  => .not;
                fn Star()  => .operator_star_prefix;
                @default => @report_error("expected begin expression found non-prefix operator ") (return, self.last.span);
            };
            self.named_call(prec, f)
        }
        fn LeftSquiggle() => {
            self.pop();
            self.parse_block_until_squiggle(false)
        }
        fn LeftParen() => {
            // we're a prefix, so this is NOT a call. 
            self.pop();
            e := @try(self.parse_tuple()) return;
            (Ok = e)
        }
        fn FatRightArrow() => {
            self.pop();
            self.quick_lambda(prec.with(.None))
        }
        fn DoubleColon() => {
            self.pop();
            loc := self.last.span;
            arg := @try(self.parse_expr(prec.with(.Neg))) return;
            e   := self.expr((ConstEval = self.box(arg)), loc);
            (Ok = e)
        }
        fn Amp() => @report_error("'&' is not a prefix operator. if you meant to take the address of a variable, use it as a suffix.") (return, self.last.span)
        fn At()  => self.parse_at(prec);
        fn BinaryNum(b)   => {
            self.pop();
            (Ok = self.expr((FromBitLiteral = (value = b.value.bitcast(), bit_count = b.bit_count.zext())), self.last.span))
        }
        fn Question()     => self.named_call(prec, Flag.operator_question_prefix);
        fn DoubleSquare() => self.named_call(prec, Flag.operator_squares_prefix);
        fn Fn() => {
            self.pop();
            self.func_expr()
        }
        fn Number(n) => {
            self.pop();
            loc := self.last.span;
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = i64;
            (Ok = e)
        }
        fn Float(n) => {
            self.pop();
            loc := self.last.span;
            n: i64 = n.bitcast();
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = f64;
            (Ok = e)
        }
        fn Dot() => {
            self.pop();
            loc := self.last.span;
            name := @try(self.pop_name("after leading dot")) return;
            (Ok = self.expr((ContextualField = name), loc))
        }
        // TODO: its a waste to intern these since you want to deduplicate before putting in an aot exe anyway since they might be computed. 
        fn Quoted(s) => {
            self.pop();
            loc := self.last.span;
            e := self.expr((String = s.s), loc);
            if s.escapes {
                f := self.box(self.get_named(.__string_escapes, loc));
                e = self.expr((Call = (f = f, arg = self.box(e))), loc);
            };
            (Ok = e)
        }
        fn Symbol(name) => {
            self.pop();
            loc := self.last.span;
            self.ident_expr_and_maybe_trailing(name, prec, loc)
        }
        @default => {
            self.pop();
            loc := self.last.span;
            @match(self.last.type) {
                fn Error(e) => {
                    ::tagged(LexErr);
                    @match(e) {
                        fn Unexpected(c) => @report_error("Expected begin expression, found unexpected byte %", c) (return, self.last.span);
                        @default => @report_error("Expected begin expression, found %", e&.tag()) (return, self.last.span);
                    };
                }
                @default => @report_error("Expected begin expression, found %", self.last.type&.tag()) (return, self.last.span);
            }
        };
    }
}

fn quick_lambda(self: *Parser, prec: Prec) ParseRes = {
    loc := self.last.span;
    body := @try(self.parse_expr(prec)) return;
    // TODO: this is kinda dumb (would be better not to force unit being an arg) but makes it consistant with elsewhere
    bindings := empty_binding().single(self.alloc).rs();
    fn_def: FnDef = (name = .None, arg = (bindings = bindings, loc = loc), ret = (Infer = ()), tags = list(self.alloc), loc = loc);
    func := make_func(fn_def, (Some = body), true);
    (Ok = self.expr((Closure = self.box(func)), loc))
}

fn func_expr(self: *Parser) ParseRes = {
    func := @try(self.parse_func(false)) return;
    (Ok = self.expr((Closure = self.box(func)), func.loc))
}

fn parse_func(self: *Parser, allow_empty: bool) Result(Func, *CompileError) = {
    loc := self.last.span;
    fn_def := @try(self.fn_def_signeture(loc, true)) return;
    
    // TODO: do i want to allow without body in expression context?
    may_capture := @match(self.peek()) {
        fn Equals()         => false;
        fn FatRightArrow()  => true;
        fn Semicolon() => {
            if !allow_empty && fn_def.tags.len == 0 {
                @report_error("Function expression requires body ") (return, loc);
            };
            return(Ok = make_func(fn_def, .None, false))
        }
        @default => @report_error("expected '=' or '=>' or ';' after function decl ") (return, self.last.span);
    };
    self.pop();
    
    if !may_capture {
        @if_let(self.peek()) fn LeftSquiggle() => {
            src, span := self.lex&.skip_to_closing_squigle();
            self.pop(); // TODO: why do i need this? -- Jun 22
            id := self.push_parse(src, span);
            body := self.expr((GetParsed = id), loc);
            return((Ok = make_func(fn_def, (Some = body), may_capture)));
        };
    };
    
    body := @try(self.parse_expr(Prec_None)) return;
    (Ok = make_func(fn_def, (Some = body), may_capture))
}

fn named_call(self: *Parser, prec: Prec, name: Flag) ParseRes = {
    self.pop();
    loc := self.last.span;
    arg := self.box(@try(self.parse_expr(prec.with(.Neg))) return);
    f   := self.box(self.get_named(name, loc));
    (Ok  = self.expr((Call = (f = f, arg = arg)), loc))
}

fn parse_at(self: *Parser, prec: Prec) ParseRes = {
    self.pop(); 
    loc := self.last.span;
    handler := @match(self.peek()) {
        fn LeftSquare() => {
            self.pop();
            loc = self.last.span;
            e := @try(self.parse_expr(Prec_None)) return;
            @try(self.eat(.RightSquare, "close unquote")) return;
            return(Ok = self.expr((Unquote = self.box(e)), self.last.span))
        }
        fn LeftParen() => {
            self.pop();
            loc = self.last.span;
            handler := @try(self.parse_expr(prec.reset())) return;
            @try(self.eat(.RightParen, "close macro expression")) return;
            handler
        }
        fn Symbol(name) => {
            self.pop();
            loc = self.last.span;
            self.expr((GetNamed = name), self.last.span)
        }
        fn LeftSquiggle() => {
            self.pop();
            loc := self.last.span;
            e := @try(self.parse_block_until_squiggle(false)) return;
            return(Ok = self.expr((Quote = self.box(e)), loc))
        }
        @default => {
            self.pop(); // TODO: have lex.next:span
            @report_error("@ must be followed by @[ast_expr] or @(macro_expr) or @macro_name ") (return, self.last.span)
        };
    };
    
    ::if(*FatExpr);
    arg := if self.maybe(.LeftParen) {
        self.box(@try(self.parse_tuple()) return)
    } else {
        self.box(self.raw_unit(loc))
    };
    target := if (@is(self.peek_tag(), .Semicolon, .Comma, .RightParen, .RightSquiggle, .RightSquare, .Dot, .Equals)) {
        self.raw_unit(loc)
    } else {
        @try(self.parse_expr(prec.reset())) return
    };
    (Ok = self.expr((PrefixMacro = (handler = self.box(handler), arg = arg, target = self.box(target))), loc))
}

fn parse_infix(self: *Parser, prev: FatExpr, prec: Prec) ParseRes = {
    loc := self.last.span;
    parsed: ParseRes = @match(self.peek()) {
        fn Op(op)      => return(self.parse_bin_op(op, prev, prec));
        fn LeftParen() => {
            // We're an infix, so this is a call, not a free-standing tuple/struct. 
            if self.lex.line != self.lex.old_line {
                @report_error("call expression cannot span multiple lines. the function and the left paren must be on the same line.") (return, self.last.span);
            };
            self.pop();
            arg := @try(self.parse_tuple()) return;
            call := self.expr_call(prev, arg);
            self.parse_infix(call, prec.with(.Suffix))
        }
        fn Dot() => {
            start_line := self.lex.line;
            self.pop();
            end_line := self.lex.line;
            name := @try(self.pop_name("e.<NAME>")) return;
            if start_line != end_line {
                // TODO: this doesn't even help against the thing i actually wanted to stop. 
                @report_error("expr.field cannot span multiple lines. it just feels like an easy typo to mean something else.") (return, self.last.span);
            };
            loc := self.last.span;
            e := self.expr((FieldAccess = (container = self.box(prev), name = name)), loc);
            self.parse_infix(e, prec.with(.Suffix))
        }
        fn LeftSquiggle() => {
            if(prec.allow_trailing.not(), => return(Ok = prev));
            self.parse_squiggle(prev, prec)
        }
        fn DoubleSquare() => {
            self.pop();
            e := self.expr((Deref = self.box(prev)), self.last.span);
            self.parse_infix(e, prec.with(.Suffix))
        }
        fn Amp() => {
            self.pop();
            e := self.expr((Addr = self.box(prev)), self.last.span);
            self.parse_infix(e, prec.with(.Suffix))
        }
        fn LeftSquare() => {
            loc := self.last.span;
            self.pop();
            index := @try(self.parse_expr(Prec_None)) return;
            
            closing := self.pop();
            if !closing&.is(.RightSquare) {
                @report_error("expected ']' after index expression ") (return, self.last.span);
            };
            
            // This was the same speed but i think its uglier. 
            // e := self.bin_named_macro(Flag.operator_index, prev, index, loc);
            
            e := self.bin_call(Flag.operator_index, self.last.span, prev, index);
            e := self.expr((Deref = self.box(e)), self.last.span);
            self.parse_infix(e, prec.with(.Suffix))
        }
        @default => return(Ok = prev);
    };
    prev = @try(parsed) return;
    // You can chain a bunch of the same level. 
    self.parse_infix(prev, prec) // TODO: tail
}

fn parse_squiggle(self: *Parser, prev: FatExpr, prec: Prec) ParseRes #once = {  
    old_line := self.lex.line;
    self.pop();
    new_line := self.lex.line;
    loc := self.last.span;
    ::if(FnDef);
    fn_def: FnDef = if new_line == old_line {
        fn_def := @try(self.fn_def_signeture(loc, false)) return;
        @try(self.eat(.Pipe, "trailing lambda")) return;
        fn_def
    } else {
        // If the next token is on a new line, assume theres no pipe annotation. 
        // this lets you do ifs that look normal, like `if foo {` instead of `if foo {|`
        bindings := empty_binding().single(self.alloc).rs();
        (name = .None, arg = (bindings = bindings, loc = loc), ret = (Infer = ()), tags = list(self.alloc), loc = loc)
    };
    
    body := @try(self.parse_block_until_squiggle(false)) return;
    func := make_func(fn_def, (Some = body), true);
    callback := self.expr((Closure = self.box(func)), loc);
    self.push_arg(prev&, callback);
    
    @if_let(self.peek()) 
        fn Symbol(name) => {
            if self.lex.line != self.lex.old_line {|
                @report_error("trailing lambda chained named arg cannot be on a new line") (return, self.last.span);
            };
            // TODO: actually use this as a named argument! rework the call into a StructLiteralP as needed. 
            //       currently i just ignore and assume you got the name right. 
            self.pop();
            if self.peek_tag() != .LeftSquiggle {
                self.pop();
                @report_error("Expected trailing lambda after named arg '%' (did you forget a semicolon after this expression?)", self.pool.get(name)) (return, self.last.span);
            };
        };
    // This is only called in parse_infix and that does the chaining for us. 
    (Ok = prev)
}

::if(ParseRes);
// TODO: this seems to use the wrong loc
fn parse_bin_op(self: *Parser, op: Operator, prev: FatExpr, prec: Prec) ParseRes #once = {
    next_prec, callee := @match(op) {
        fn Plus()      => (PrecLevel.AddSub,     Flag.add);
        fn Minus()     => (PrecLevel.AddSub,     Flag.sub);
        fn Star()      => (PrecLevel.MulDiv,     Flag.mul);
        fn Slash()     => (PrecLevel.MulDiv,     Flag.div);
        fn Less()      => (PrecLevel.Comparison, Flag.lt);
        fn Greater()   => (PrecLevel.Comparison, Flag.gt);
        fn LessEq()    => (PrecLevel.Comparison, Flag.le);
        fn GreaterEq() => (PrecLevel.Comparison, Flag.ge);
        fn BangEq()    => (PrecLevel.Equality,   Flag.ne);
        fn EqEq()      => (PrecLevel.Equality,   Flag.eq);
        fn AmpAmp()   => return(self.logical_operator(prev, prec, .and, .LogicalAnd, .LogicalOr));
        fn PipePipe() => return(self.logical_operator(prev, prec, .or, .LogicalOr, .LogicalAnd));
        @default => {
            // update assignment operator. hopefully we're in a statement and that will handle it.
            return(Ok = prev)
        };
    };
    if prec.prec < next_prec {
        self.pop();
        loc := self.last.span;
        rhs := @try(self.parse_expr(prec.with(next_prec))) return;
        call := self.bin_call(callee, loc, prev, rhs);
        self.parse_infix(call, prec) // TODO: tail
    } else {
        (Ok = prev)
    }
}

fn logical_operator(self: *Parser, prev: FatExpr, prec: Prec, name: Flag, this: PrecLevel, other: PrecLevel) ParseRes #inline = {
    if prec.prec < .Logical {
        self.pop();
        if prec.prec == other {
            @report_error("Use parens to seperate && and || clauses.") (return, self.last.span);
        };
        loc := self.last.span;
        rhs := @try(self.quick_lambda(prec.with(this))) return;
        f := self.box(self.get_named(name, loc));
        arg := self.box(self.pair(prev, rhs, loc));
        call := self.expr((Call = (f = f, arg = arg)), loc);
        return(self.parse_infix(call, prec.with(this))) // TODO: tail
    } else {
        return(Ok = prev)
    }
}

fn bin_call(self: *Parser, func_name: Flag, loc: Span, lhs: FatExpr, rhs: FatExpr) FatExpr #inline = {
    f := self.box(self.get_named(func_name, loc));
    arg := self.box(self.pair(lhs, rhs, loc));
    self.expr((Call = (f = f, arg = arg)), loc)
}

fn expr_call(self: *Parser, f: FatExpr, arg: FatExpr) FatExpr = {
    // TODO: let else would be nice.
    @match(f.expr) {
        fn FieldAccess(ff) => {
            // Dot call syntax sugar.
            // TODO: I want this to just call push_arg
            f := self.expr((GetNamed = ff.name), f.loc);
            @match(arg.expr&) {
                // Tuple parser eagerly flattened single tuples so we have to undo that here.
                // TODO: have it work with named arguments. Need to support mixing named and positional.
                fn Tuple(parts) => {
                    parts.insert(0, ff.container[], self.alloc);
                    return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc));
                }
                // Parser flattened empty tuples.
                fn Value(v) => {
                    if v.bytes.is_unit() {
                        return(self.expr((Call = (f = self.box(f), arg = ff.container)), f.loc));
                    };
                    // fallthrough
                }
                // TODO: if the arg is a struct pattern, merge it with f instead of of just appending them.
                //       but this old parser didn't allow mixed named and positional so it doesn't matter yet. :SYNTAX -- Jun 21 
                @default => (); // fallthrough
            };
            arg := self.expr((Tuple = (@list(ff.container[], arg) self.alloc).rs()), f.loc);
            return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc))
        }
        @default => return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc));
    }
}

fn push_arg(self: *Parser, call: *FatExpr, callback: FatExpr) void = {
    // TODO: let else would be nice.
    @match(call.expr&) {
        fn Call(f) => {
            @match(f.arg.expr&) {
                // TODO: have it work with named arguments. Need to support mixing named and positional.
                fn Tuple(parts) => {
                    parts.push(callback, self.alloc);
                }
                // Parser flattened empty tuples.
                fn Value(v) => {
                    if v.bytes.is_unit() {
                        f.arg[] = callback;
                    } else {  
                        f.arg[] = self.pair(f.arg[], callback, call.loc);
                    };
                }
                @default => {
                    f.arg = self.box(self.pair(f.arg[], callback, call.loc));
                };
            };
        }
        @default => {
            // It might just be a function access. like 'while {| _ } {| _ }' should be valid.
            call[] = self.expr((Call = (f = self.box(call[]), arg = self.box(callback))), call.loc);
        };
    };
}

:: ?FatExpr;
fn make_func(def: FnDef, body: ?FatExpr, may_capture: bool) Func = {
    // TODO: derive fn default with allocator
    ::if_opt(FatExpr, FuncImpl);
    f: Func = (
        annotations = def.tags.rs(),
        callees = empty(),
        mutual_callees = empty(),
        // TODO: deconstruct_values doesn't work on @tagged so can't have default struct fields be .None-- Jun 21
        var_name = .None,
        finished_arg = .None,
        finished_ret = .None,
        cc = .None,
        return_var = .None,
        scope = .None,
        body = if(body, fn(body) => (Normal = body), => (Empty = ())),
        arg = def.arg,
        ret = def.ret,
        // TODO: use the body text based on compiler flag. also should an option use file+line? 
        name = def.name || Flag.Anon.ident(),
        loc = def.loc,
    );
    
    f&.set_flag(.NotEvilUninit);
    if(may_capture, => f&.set_flag(.AllowRtCapture));
    f
}

fn is_unit(self: Values) bool #inline = {
    ::tagged(Values);
    self&.is(.Small) && self.Small._1 == 0
}

// This starts out with comma seperated expressions and switches to a struct pattern if it hits a colon/equals. 
// So you don't have to know if you're in a struct literal or if a function call uses named arguments ahead of time. 
// TODO: allow 'const' at the beginning to quickly switch to named args cause you must be in a struct definition. 
fn parse_tuple(self: *Parser) ParseRes = {
    loc := self.last.span;
    if self.maybe(.RightParen) {
        return(Ok = self.raw_unit(loc));
    };
    parts: List(FatExpr) = list(self.alloc);
    
    (=> {
        break :: local_return;
        loop {
            parts&.push(@try(self.parse_expr(Prec_None)) return);
            @match(self.peek()) {
                fn RightParen() => { 
                    self.pop(); 
                    break();
                }
                fn Comma() => {
                    self.pop();
                    if(self.maybe(.RightParen), => break());
                }
                fn Colon() => {
                    self.pop();
                    ty: LazyType = @match(self.peek()) {
                        fn Equals() => .Infer;
                        @default => {
                            e := @try(self.parse_expr(Prec_None)) return;
                            (PendingEval = e)
                        };
                    };
                    return(self.switch_to_parsing_named(parts, ty, loc));
                }
                fn DoubleColon() => return(self.switch_to_parsing_named(parts, .Infer, loc));
                fn Equals()      => return(self.switch_to_parsing_named(parts, .Infer, loc));
                @default => @report_error("Expected ',' or ':' or '=' or ')' after tuple element % (unmached parens?)", "") (return, self.last.span);
            };
        };
    })();
    
    // TODO: not sure we want to do this but its what the rust one does. -- Jun 21
    //       (it means you have to do extra work to undo it for dot calls)
    res := @switch(parts.len) {
        @case(0) => self.raw_unit(loc);
        @case(1) => {
            // TODO: defer
            e := parts[0];
            parts&.drop();
            e
        };
        @default => self.expr((Tuple = parts.rs()), loc);
        // TODO: if you forget that semicolon it doesn't see the default and crashes at runtime if you ever hit it. :FUCKED
    };
    
    (Ok = res)
}

// TODO: allow 'name :: value' in @struct. :SYNTAX

fn switch_to_parsing_named(self: *Parser, parts: List(FatExpr), ty: LazyType, loc: Span) ParseRes = {
    // Decided the last thing was actually a name for a named argument
    // TODO: let else
    ident_expr := parts&.pop().unwrap();
    name := @match(ident_expr.expr) {
        fn GetNamed(name) => name;
        @default => @report_error("Expected Ident before ':'/'=' in argument pattern. ") (return, ident_expr.loc);
    };
    
    ::if(?FatExpr);
    kind := VarType.Var;
    default: ?FatExpr = if self.maybe(.Equals) {
        e := @try(self.parse_expr(Prec_None)) return;
        (Some = e)
    } else {
        if self.maybe(.DoubleColon) {
            kind = .Const;
            e := @try(self.parse_expr(Prec_None)) return;
            (Some = e)
        } else {
            (None = unit)
        }
    };
    
    bindings := Binding.list(parts.len + 1, self.alloc);
    for parts { e |
        // Allow mixed named and positional for function calls. 
        anon: Binding = (name = .None, ty = .Infer, default = (Some = e), kind = .Var);
        bindings&.push(anon);
    };
    first_named: Binding = (name = (Ident = name), ty = ty, default = default, kind = kind);
    bindings&.push(first_named);
    
    self.maybe(.Comma);
    @try(self.parse_pattern(bindings&)) return;
    @try(self.eat(.RightParen, "')' to end argument list")) return;
    return(Ok = self.expr((StructLiteralP = (bindings = bindings.rs(), loc = loc)), loc))
};

fn if_empty_add_unit(self: *List(Binding)) void = {
    if(self.len != 0, => return());
    self.push(empty_binding());
}

fn empty_binding() Binding = {
    (
        name = .None,
        ty = (Finished = void),
        default = .None,
        kind = .Var,
    )
}
    
fn parse_args(self: *Parser) Result(Pattern, *CompileError) = {
    loc := self.last.span;
    bindings: List(Binding) = list(self.alloc);
    @try(self.parse_pattern(bindings&)) return;
    bindings&.if_empty_add_unit();
    (Ok = (bindings = bindings.rs(), loc = loc))
}

fn parse_pattern(self: *Parser, out: *List(Binding)) Result(void, *CompileError) = {
    loop {
        // TODO: no comma allowed here
        // TODO: shouldnt have to put the type annotations everywhere. 
        //       before switching nested ifs to switch, you didn't need it. -- Jul 28
        T :: Ty(Symbol, VarType);
        name, kind := @match(self.peek()) {
            fn RightParen() => return(.Ok);
            fn Dollar() => {
                self.pop();
                // TODO: better let else.
                name: Symbol = @try(self.pop_name("after '$'")) return;
                (name, VarType.Const)
            }
            fn Symbol(name) T => {
                self.pop();
                (name, VarType.Var)
            }
            // TODO: moving this up crashes????? :FUCKED
            //       but also we dont need this here for now. 
            //(fn Pipe() => return(.Ok));
            fn Semicolon() => {
                self.pop();
                @report_error("Semicolon while parsing pattern. unmatched brackets? ") (return, self.last.span)
            }
            @default => @report_error("Expected Ident or '$' before pattern entry. (positional args cannot follow named) ") (return, self.last.span);
        };
        
        ::if(?FatExpr); ::if(LazyType);
        default_: ?FatExpr = .None; // TODO: "shadows" the magic @default
        ty := LazyType.Infer;
        
        @match(self.peek()) {
            fn Colon() => {
                self.pop();
                if self.peek_tag() != .Equals {
                    e := @try(self.parse_expr(Prec_None)) return;
                    ty = (PendingEval = e);
                };
                if self.maybe(.Equals) {
                    e := @try(self.parse_expr(Prec_None)) return;
                    default_ = (Some = e);
                };
            }
            fn DoubleColon() => {
                self.pop();
                kind = .Const;
                e := @try(self.parse_expr(Prec_None)) return;
                default_ = (Some = e);
            }
            fn Equals() => {
                self.pop();
                e := @try(self.parse_expr(Prec_None)) return;
                default_ = (Some = e);
            }
            @default => ();
        };
        
        b: Binding = (name = (Ident = name), ty = ty, default = default_, kind = kind);
        out.push(b);
        if !self.maybe(.Comma) {
            return(.Ok);
        };
    }
}

fn pop_name(self: *Parser, msg: Str) Result(Symbol, *CompileError) = {
    (Ok = @match(self.pop()) {
        fn Symbol(name) => name;
        @default => @report_error("Expected Ident %", msg) (return, self.last.span);
    })
}

FnDef :: @struct(name: ?Symbol, arg: Pattern, ret: LazyType, tags: List(Annotation), loc: Span);
fn fn_def_signeture(self: *Parser, loc: Span, allow_name: bool) Result(FnDef, *CompileError) = {
    ::if(?Symbol);
    name: ?Symbol = if(not(allow_name), => .None) {
        @match(self.peek()) {
            fn Symbol(name) => {
                self.pop();
                loc = self.last.span;  // if there's a name, use that as the loc for the function because that's nicer for the ide. 
                (Some = name)
            }
            @default => .None;
        }
    };
    cant_start_return_expression :: fn(t: TokenType) bool = {
        @is(t&, .Equals, .Semicolon, .Pipe, .FatRightArrow, .Hash)
    };
    no_paren := false;
    disallow_return := false;
    ::if(Pattern);
    arg: Pattern = if self.maybe(.LeftParen) {
        a := @try(self.parse_args()) return;
        @try(self.eat(.RightParen, "')' to end argument list")) return;
        a
    } else {
        no_paren = true;
        if allow_name.or(cant_start_return_expression(self.peek())) {
            (bindings = empty(), loc = self.last.span)
        } else {
            disallow_return = true;
            @try(self.parse_args()) return
        }
    };

    if no_paren && !cant_start_return_expression(self.peek()) {
        @report_error("'fn <Expr> =' can't treat Expr as ret type. pls specify name or args. forgot '|' before lambda body? tried to use `fn` as an identifier?") (return, self.last.span);
    };

    ret: LazyType = if !cant_start_return_expression(self.peek()) {
        // Note: no trailing means you can use '=>' as a quick expression so `while => e {| b}` and the trailing binds to the while not the e. 
        (PendingEval = @try(self.parse_expr((prec = .None, allow_trailing = false))) return)
    } else {
        .Infer
    };
    tags := @try(self.parse_annotations()) return;

    (Ok = (name = name, arg = arg, ret = ret, tags = tags, loc = loc))
}

// Consumes '}'
fn parse_block_until_squiggle(self: *Parser, allow_eof: bool) ParseRes = {
    loc := self.last.span;
    stmts: List(FatStmt) = list(self.alloc);
    
    while => !self.maybe(.RightSquiggle) && (!allow_eof || !self.maybe(.Eof)) {
        if self.maybe(.Eof) {
            @report_error("unexpected end of file ") (return, self.last.span);
        };
        s := @try(self.parse_stmt()) return;
        stmts&.push(s);
    };
    
    ::if_opt(FatStmt, FatExpr);
    result: FatExpr = if stmts&.pop() { stmt |
        @match(stmt.stmt) {
            fn Eval(e) => e;
            @default => {
                // block might end with a func decl with no semicolon.
                stmts&.push(stmt);
                self.raw_unit(self.last.span)
            };
        }
    } else {
        self.raw_unit(self.last.span)
    };
    
    e := self.expr((Block = (body = stmts.rs(), result = self.box(result), ret_label = .None, hoisted_constants = false)), loc);
    (Ok = e)
}

::if(?FatExpr);
fn parse_annotations(self: *Parser) Result(List(Annotation), *CompileError) = {
    tags: List(Annotation) = list(self.alloc);
    while => self.maybe(.Hash) {
        name := @try(self.pop_name("ident after '#'")) return;
        arg: ?FatExpr = if self.maybe(.LeftParen) {
            (Some = @try(self.parse_tuple()) return)
        } {| .None };
        tags&.push((name = name, args = arg));
    };
    (Ok = tags)
}

// TODO: be able to eq on tagged
fn maybe(self: *Parser, type: TokenType.Tag()) bool = {
    yes := self.peek_tag() == type;
    if yes {
        self.pop(); 
    };
    yes
}

fn eat(self: *Parser, type: TokenType.Tag(), msg: Str) Result(void, *CompileError) = {
    if !self.maybe(type) {
        @report_error("Expected % for %", type, msg) (return, self.last.span);
    };
    .Ok
}

unit_value: Values : (Small = (0, 0));
fn raw_unit(self: *Parser, loc: Span) FatExpr = {
    e := self.expr((Value = (bytes = unit_value, coerced = false)), loc);
    e.ty = void; // :get_or_create_type
    e
}

fn get_named(self: *Parser, name: Flag, loc: Span) FatExpr = 
    self.expr((GetNamed = name.ident()), loc);

fn bin_named_macro(self: *Parser, name: Flag, arg: FatExpr, target: FatExpr, loc: Span) FatExpr #inline = {
    handler := self.box(self.get_named(name, loc));
    self.expr((PrefixMacro = (handler = handler, arg = self.box(arg), target = self.box(target))), loc)
}

fn expr(self: *Parser, e: Expr, loc: Span) FatExpr = 
    (expr = e, loc = loc, ty = UnknownType, done = false);

fn stmt(self: *Parser, e: Stmt, loc: Span) FatStmt = 
    (stmt = e, loc = loc);
    
fn box();
fn PBox($T: Type) void = {
    fn box(self: *Parser, e: T) *T = {
        out := self.alloc.alloc(T, 1);
        out.ptr[] = e;
        out.ptr
    }
}
::PBox(FatExpr); ::PBox(Func);

fn pair(self: *Parser, lhs: FatExpr, rhs: FatExpr, loc: Span) FatExpr = {
    out := self.alloc.alloc(FatExpr, 2);
    out[0] = lhs;
    out[1] = rhs;
    self.expr((Tuple = (cap = 2, ptr = out.ptr, len = 2)), loc)
}

fn pop(self: *Parser) TokenType = {
    self.last = self.lex&.peek()[];
    self.lex&.pop();
    self.last.type
}

fn peek(self: *Parser) TokenType = {
    token := self.lex&.peek()[];
    token.type
}

fn peek_tag(self: *Parser) TokenType.Tag() = {
    token := self.lex&.peek()[];
    token.type&.tag()
}

fn report_error(fmt_args: FatExpr, ret_loc: FatExpr) FatExpr #macro = {
    @if(BOOTSTRAP_ONLY_MODE) {
        fmt_args = @{"---"};
    };
    @assert_eq(ret_loc.expr&.tag(), Expr.Tag().Tuple);
    args := ret_loc.expr.Tuple.items();
    result := @{
        lst := @format(@[fmt_args]) temp();
        mem := libc_allocator.alloc(CompileError, 1);
        mem.ptr[] = (Parse = (span = @[args[1]], msg = lst.items()));
        @[args[0]](Err = mem.ptr);
        unreachable()
    };
    result
}

fn int(self: PrecLevel) i64 = @as(i64) self;
::Ord(PrecLevel);
