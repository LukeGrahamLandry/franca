ParseTask :: @tagged(
    Pending: @struct(src: Str, span: Span),
    Expr: Ast.FatExpr,
    Stmt: Ast.FatStmt,
    Err: ParseErr, 
);
Parser :: @struct(lex: Lexer, tasks: *List(ParseTask), alloc: Alloc, last: Token);
ParseErr :: @struct(span: Ast.Span, msg: Str);
Prec :: @enum(i64) (
    None,
    TypeModifier,
    Equality,
    Comparison,
    AddSub,
    MulDiv,
    Neg,
    Suffix,
    Primary,
);
ParseRes :: Result(Ast.FatExpr, ParseErr);

// TODO: non-existant field name for @tagged is a panic because its in a mut_replace. 
fn parse_expr(self: *Parser, id: i64) ParseRes = {
    println("c");
    // TODO: can't access field on rvalue. 
    // TODO: you can't return a pair at comptime if its not a pair of ints. (u32, u32) gives back 16 bytes from ffi::c and then compiler::jit crashes on it for being the wrong size. 
    self.parse_prefix(.None)
}

fn parse_prefix(self: *Parser, prec: Prec) ParseRes = {
    return :: @return;
    println("b");
    @match(self.pop()) {
        @default => {
            println("a");
            @report_error("Expected begin expression %", 1) (return, self.last.span);
        };
    };
    ParseRes.unreachable_hack()
}

fn parse_infix(self: *Parser, prev: Ast.FatExpr, prec: Prec) ParseRes = {
    return :: @return;
}

fn pop(self: *Parser) TokenType = {
    self.last = self.lex&.pop()[];
    self.last.type
}

#macro fn report_error(fmt_args: FatExpr, ret_loc: FatExpr) FatExpr = {
    assert_eq(ret_loc.expr&!tag[], tag_value(Expr, @symbol Tuple));
    args := FatExpr.slice_from_tuple(ret_loc.expr.Tuple);
    result := '{
        lst := @format @[fmt_args]; // LEAK
        res: ParseRes = (Err = (span = @[args[1]], msg = lst.items()));
        @[args[0]](res);
        ParseRes.unreachable_hack();
    }';
    result
}
//(Ok = (expr = (GetNamed = (id = 0.trunc())), loc = fuck, ty = UnknownType, done = true))

#test fn parser_doesnt_crash() = {
    println("e");
    pool: StringPool = init(libc_allocator);
    codemap: CodeMap = init(libc_allocator);
    src := "a + 1";
    span := codemap&.add_file("name", src);
    tasks: List(ParseTask) = list(libc_allocator);
    ctx: Parser = (lex = init(pool&, span, src), tasks = tasks&, alloc = libc_allocator, last = Token.zeroed());
    tasks&.push((Pending = (src = src, span = span)));
    res := ctx&.parse_expr(0);
    @match(res) {
        (fn Ok(t) => println("parsed!"));
        (fn Err(e) Unit => @println("err! %", e.msg));
    };
}
