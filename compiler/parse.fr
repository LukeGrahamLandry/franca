// 
// Converts a stream of tokens into an AST. 
// No fancy parser generator, just some tedious code to solve the problem directly. 
// The magic words are "recursive descent" and "precidence climbing" if you're into that sort of thing. 
// 
// New tokens are lexed lazily and not dynamically allocated. 
// It only moves forward along the token stream, there's no back tracking. 
// However, my grammar is definitely not in the blessed in the formal language sense. 
// There are some constructs where I guess an ast node before actually knowing if it will be correct. 
// In those cases, there's still no backtracking in the tokens, when it hits a token that 
// shows it made a mistake, it just restructures the ast a bit and keeps going. 
// You still only look at each token once and you that restructuring never kicks off a recursive 
// chain, so i claim it's still linear in the length of input. 
// It has the only property that I believe matters: you can parse independently of sema. 
// 
// Speed doesn't really matter here yet. The ~40k line compiler+backend compiles in one second (wall time) 
// and <5% of that is lex+parse, and that's with it running on the main thread. You could 
// parse each file on a seperate thread when becomes the limiting factor. 
// 
// There's one trick to help smaller programs that include a large prelude but don't use most of it. 
// When it hits a non-capturing function declaration with a block body, it skips ahead to the matching 
// curly brace and assigns that range a `WaitingParse` id, which is finished lazily when the function is
// referenced. 
// 

// TODO: everywhere i @report_error(_)(_ self.last.span) after just peek not pop will have the error in the wrong place. -- Jun 25
// TODO: :SLOW im doing so many silly copies and also need to actually enforce tailcalls on llvm (right now i might be preventing them with ccc even on internal functions!).  -- Jun 21

ParseTask :: @tagged(
    Pending: @struct(src: Str, span: Span),
    Expr: Result(*FatExpr, *CompileError),
);
Parser :: @struct(pool: *StringPool, lex: Lexer, tasks: *List(ParseTask), alloc: Alloc, last: Token, top_level: bool);
Prec :: @struct(prec: PrecLevel, allow_trailing: bool = true);

Prec_None: Prec : (prec = .None);
fn reset(p: Prec) Prec = p.with(.None);
fn with(p: Prec, next: PrecLevel) Prec = 
    (prec = next, allow_trailing = p.allow_trailing);

PrecLevel :: @enum(i64) (
    None,
    LogicalOr, LogicalAnd, Logical,
    Equality,
    Comparison,
    AddSub,
    MulDiv,
    Neg,
    Suffix,
);
ParseRes :: Result(*FatExpr, *CompileError);

// TODO: do the clone here instead of (on rust side + scope) so you don't have to remmeber.
fn finish_pending(self: *Parser, id: WaitingParse) ParseRes = {
    @match(self.tasks[id.id]&) {
        fn Pending(src_span) => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            
            zone := zone_begin(.Parse); // TODO: defer
            
            prev := self.top_level;
            self.top_level = false;
            e := self.parse_expr(Prec_None);
            self.top_level = prev;
            zone_end(zone);
    
            // TODO: clone here instead of needing to remember later.
            // TODO: save less often!
            self.tasks[id.id] = (Expr = e);
            e
        }
        fn Expr(e) => e[];
    }
}

fn finish_pending_stmts(self: *Parser, id: WaitingParse) Result(RawList(FatStmt), *CompileError) = {
    T :: Result(RawList(FatStmt), *CompileError);
    @match(self.tasks[id.id]&) {
        fn Pending(src_span) => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            zone := zone_begin(.Parse); // TODO: defer
            e := self.parse_block_until_squiggle(true);
            zone_end(zone);
            if self.lex.current != src_span.span.len() {
                return(@report_error("parse did not consume whole span (mismatched '}'? missing ';' after decl?)")(return, self.last.span));
            };
            self.tasks[id.id] = (Expr = @err("ICE: WaitingParse id was stmts (which aren't reused)."));
            @match(e) {
                fn Ok(e) => (Ok = e.expr.Block.body);
                fn Err(e) => (Err = e);
            }
        }
        fn Expr(e) => @err("ICE: WaitingParse id wanted stmts found expr.");
    }
}

fn get_span(e: *ParseRes) Span = {
    @match(e) {
        fn Ok(e) => e.loc;
        fn Err(e) => e.span;
    }
}

fn push_parse(self: *Parser, src: Str, span: Span) WaitingParse = {
    self.tasks.push((Pending = (src = src, span = span)));
    (id = self.tasks.len.sub(1))
}

fn parse_stmt(self: *Parser) Result(FatStmt, *CompileError) = {
    tags := @try(self.parse_annotations()) return;
    stmt := @try(self.parse_stmt_inner(!tags.is_empty())) return;
    
    add :: fn(f: **Func) => {
        if f.annotations.is_empty() {
            f.annotations = tags.as_raw();
        } else {
            f.annotations&.push_all(tags.items(), self.alloc);
        };
    };
    
    if !tags.is_empty() {
        @match(stmt.stmt&) {
            fn DeclFunc(f) => add(f);
            fn Decl(f) => {
                @match(f.default.expr&) {
                    fn Closure(ff) => add(ff);
                    @default => @report_error("#annotations can only go before functions or semicolons.\n(this declaration was not obviously a function expression)") (return, self.last.span);
                };
            }
            fn Noop() => {
                stmt.stmt = (Annotations = tags.as_raw());
            }
            @default => @report_error("#annotations can only go before functions or semicolons.") (return, self.last.span);
        };
    };
    
    (Ok = stmt)
}

fn parse_stmt_inner(self: *Parser, has_annotations: bool) Result(FatStmt, *CompileError) #once = {
    @match(self.peek()) {
        fn Fn() => {
            self.pop();
            loc := self.last.span;
            func := @try(self.parse_func()) return;
            (Ok = self.stmt((DeclFunc = func), loc))
        }
        fn Symbol(name) => self.parse_decl_or_start_expr(name);
        fn Semicolon() => {
            self.pop();
            loc := self.last.span;
            if has_annotations || (@is(self.peek_tag(), .RightSquiggle, .Eof)) {
                // At the end of blocks, i use them for distingushing when to return trailing expression. :store_noop
                return(Ok = self.stmt(.Noop, loc))
            };
            self.parse_stmt()
        }
        @default => {
            e := @try(self.parse_prefix(Prec_None)) return;
            self.after_expr_stmt_prefix(e)
        };
    }
}

fn parse_decl_or_start_expr(self: *Parser, name: Symbol) Result(FatStmt, *CompileError) #once = {
    self.pop();
    tok := self.peek_tag();
    if (@is(tok, .DoubleColon, .Colon)) {
        loc := self.last.span;
        b := self.alloc.box_uninit(Binding);
        @try(self.parse_binding_after_name(name, .Var, b)) return;
        s: Stmt = (Decl = b);
        // :HackFakeSquiggle
        if !self.maybe(.Semicolon) && !self.last.type&.is(.RightSquiggle) {
            // TODO: maybe i should allow it if its a function declaration because that feels better and i do it for overload set stmts. 
            //       but that's a slippery slope to macro calls for struct declations, which i don't want becuase it feels you might accidently use the two arg version of the macro. 
            @report_error("expected semicolon after declaration") (return, self.last.span);
        };
        return(Ok = self.stmt(s, loc))
    };
    
    @match(self.peek()) {
        fn Comma() => {
            // That was actually like `a, b := e;`, so we want to turn that name into an expression and then find some more identifiers. 
            self.pop();
            loc := self.last.span;
            idents := @try(self.list_of_names_decl(name)) return;
            pattern := @try(self.ident_list_to_pattern(idents&, loc)) return;
            value := @try(self.parse_expr(Prec_None)) return;
            if !self.maybe(.Semicolon) {
                @report_error("expected semicolon after declaration") (return, self.last.span);
            };
            return(Ok = self.stmt((DeclVarPattern = (binding = pattern, value = value[])), loc))
        }
        @default => {
            e := @try(self.ident_expr_and_maybe_trailing(name, Prec_None, self.last.span)) return;
            return(self.after_expr_stmt_prefix(e))
        };
    }
}

fn list_of_names_decl(self: *Parser, name: Symbol) Result(RawList(FatExpr), *CompileError) = {
    first := self.expr((GetNamed = name), self.last.span);
    exprs: List(FatExpr) = list(2, self.alloc);
    exprs&.push(first[]);
    loop {
        @match(self.pop()) {
            fn Symbol(name) => {
                e := self.expr((GetNamed = name), self.last.span);
                exprs&.push(e[]);
                if self.peek_tag() != .Colon {
                    @try(self.eat(.Comma, "destructuring statment expected ':=' or ',' (TODO: allow type annotation)")) return; 
                };
            }
            fn Colon() => {
                @try(self.eat(.Equals, "destructuring statment expected ':=' (TODO: allow type annotation. TODO: allow const)")) return; 
                return(Ok = exprs.as_raw());
            }
            @default => @report_error("expected ident or ':' in destructuring") (return, self.last.span);
        }
    }
}

fn after_expr_stmt_prefix(self: *Parser, e: *FatExpr) Result(FatStmt, *CompileError) = {
    loc  := e.loc;
    // TOOD: allow_trailing?
    e    := @try(self.parse_infix(e, Prec_None)) return;
    stmt := @match(self.peek()) {
        fn Equals() => {
            self.pop();
            loc := self.last.span;
            value := @try(self.parse_expr(Prec_None)) return;
            // TODO: check if the left is a tuple/struct and warn because they maybe meant :=. 
            self.stmt((Set = (place = e[], value = value[])), loc)
        }
        fn Op(op) => {
            f: Flag = @match(op) {
                fn MinusEq() => .operator_minus_equal;
                fn PlusEq()  => .operator_plus_equal;
                fn StarEq()  => .operator_star_equal;
                fn SlashEq() => .operator_slash_equal;
                // TODO: if c { b } !c gets here
                @default => @report_error("non-update-assingment operator after expression statement. this should be unreachable?") (return, self.last.span);
            };
            self.pop();
            delta := @try(self.parse_expr(Prec_None)) return;
            e := self.bin_named_macro(f, e, delta, loc);
            self.stmt((Eval = e[]), loc)
        }
        fn Colon() => { // TODO: double colon?
            self.pop();
            pattern := @match(e.expr&) {
                fn StructLiteralP(pattern) => pattern[];
                fn Tuple(idents) => @try(self.ident_list_to_pattern(idents, e.loc)) return;
                @default => @report_error("destructuring statment requires tuple or struct on the left. `(a, b) := <>` or (a: c, b: d) := <>` ") (return, self.last.span);
            };
            loc := self.last.span;
            @try(self.eat(.Equals, "destructuring statment expected ':=' (put type annotations on each name)")) return; // TODO: (a, b): (c, d) = <>;
            value := @try(self.parse_expr(Prec_None)) return;
            self.stmt((DeclVarPattern = (binding = pattern, value = value[])), loc)
        }
        @default => self.stmt((Eval = e[]), loc);
    };
    
    if !(@is(self.peek_tag(), .Semicolon, .RightSquiggle, .Eof)) && self.last.type&.tag() != .RightSquiggle {
        @report_error("expected ';' (discard) or '}' (return from block) after expr stmt") (return, self.last.span);
    };
    
    (Ok = stmt)
}

/*
// TODO: all the parse errors should tell you what token they hit (rn i don't print lex errors which is dumb)
::DeriveFmt(TokenType);
::enum(TokenType.Tag());
::DeriveFmt(LexErr);
::DeriveFmt(get_variant_type(TokenType, .Quoted));
::DeriveFmt(BinNum);
fn display(s: *f64, out: *List(u8)) void = s[].display(out);
fn display(s: *Symbol, out: *List(u8)) void = s[].as_index().display(out);
    but found %", self.peek_type()
*/

fn peek_type(self: *Parser) *TokenType = {
    t := self.lex&.peek();
    t.type&
}

fn ident_list_to_pattern(self: *Parser, idents: *RawList(FatExpr), loc: Span) Result(Pattern, *CompileError) = {
    bindings: List(Binding) = list(idents.len, self.alloc);
    each idents { expr | 
        @match(expr.expr&) {
            fn GetNamed(name) => bindings&.push((name = (Ident = name[]), ty = .Infer, nullable_tag = zeroed(*Annotations), default = binding_missing_default(loc), kind = .Var));
            @default => @report_error("destructuring statment requires tuple with all expressions being single identifier. ") (return, expr.loc);
        };
    };
    (Ok = (bindings = bindings.as_raw(), loc = loc))
}

fn can_start_quick_expr(t: TokenType) bool #once = {
    // this lets you do 'if !whatever {'
    @if_let(t) fn Op(it) => return(it == .Bang); 
    // FatRightArrow works because you can't use trailing calls in a return type expression, lets you do 'while => cond {'
    @is(t&, .Symbol, .At, .Quoted, .Number, .BinaryNum, .FatRightArrow)
}

// this is for `if foo == bar {` but it also allows `return foo == bar;` which is kinda nice actually. 
fn ident_expr_and_maybe_trailing(self: *Parser, name: Symbol, prec: Prec, loc: Span) ParseRes /* #inline */ = {
    e := self.expr((GetNamed = name), loc);
    old := self.lex.old_line;
    if prec.allow_trailing && can_start_quick_expr(self.peek()) {
        if old != self.lex.line {
            // this is a rule because i typo leave junk in files too often.
            @report_error("identifier '%' must be on the same line as quick expr.\nor you can add a semicolon if you wanted a noop expression stmt.", self.pool.get(name)) (return, loc);
        };
        first_arg := @try(self.parse_expr(prec = .None, allow_trailing = false)) return;
        @if_let(first_arg.expr&) fn Closure(it) => it[].set_flag(.WasLambdaLiteral);
        // TODO: make sure this doesn't alias e -- Jun 21
        e = self.expr_call(e, first_arg);
    };
    
    (Ok = e)
}

fn parse_expr(self: *Parser, prec: Prec) ParseRes = {
    self.lex&.peek();
    // TODO: can't access field on rvalue. 
    e := @try(self.parse_prefix(prec)) return;
    self.parse_infix(e, prec)
}

fn parse_prefix(self: *Parser, prec: Prec) ParseRes = {
    @match(self.peek()) {
        fn Op(op) => {
            // TODO: @switch warning or handle like @match if you typo call the wrong one. 
            f: Flag = @match(op) {
                fn Minus() => .neg;
                fn Bang()  => .not;
                fn Star()  => .operator_star_prefix;
                @default => @report_error("expected begin expression found non-prefix operator ") (return, self.last.span);
            };
            self.named_call(prec, f)
        }
        fn LeftSquiggle() => {
            self.pop();
            self.parse_block_until_squiggle(false)
        }
        fn LeftParen() => {
            // we're a prefix, so this is NOT a call. 
            self.pop();
            e := @try(self.parse_tuple(.RightParen)) return;
            (Ok = e)
        }
        fn FatRightArrow() => {
            self.pop();
            self.quick_lambda(prec.with(.None))
        }
        fn DoubleColon() => {
            self.pop();
            loc := self.last.span;
            arg := @try(self.parse_expr(prec.with(.Neg))) return;
            e   := self.expr((ConstEval = arg), loc);
            (Ok = e)
        }
        fn Amp() => @report_error("'&' is not a prefix operator. if you meant to take the address of a variable, use it as a suffix.") (return, self.last.span)
        fn At()  => self.parse_at(prec);
        fn BinaryNum(b)   => {
            self.pop();
            (Ok = self.expr((FromBitLiteral = (value = b.value.bitcast(), bit_count = b.bit_count.zext())), self.last.span))
        }
        fn Question()     => self.named_call(prec, Flag.operator_question_prefix);
        fn DoubleSquare() => self.named_call(prec, Flag.operator_squares_prefix);
        fn Fn() => {
            self.pop();
            self.func_expr()
        }
        fn Number(n) => {
            self.pop();
            loc := self.last.span;
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = i64;
            (Ok = e)
        }
        fn Float(n) => {
            self.pop();
            loc := self.last.span;
            n: i64 = n.bitcast();
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = f64;
            (Ok = e)
        }
        fn Dot() => {
            self.pop();
            loc := self.last.span;
            name := @try(self.pop_name("after leading dot")) return;
            (Ok = self.expr((ContextualField = name), loc))
        }
        // TODO: its a waste to intern these since you want to deduplicate before putting in an aot exe anyway since they might be computed. 
        fn Quoted(s) => {
            self.pop();
            loc := self.last.span;
            e := self.expr((String = s.s), loc);
            if s.escapes {
                f := self.get_named(.__string_escapes, loc);
                e = self.expr((Call = (f = f, arg = e)), loc);
            };
            (Ok = e)
        }
        fn Symbol(name) => {
            self.pop();
            loc := self.last.span;
            self.ident_expr_and_maybe_trailing(name, prec, loc)
        }
        fn DotDot() => {
            self.pop();
            loc := self.last.span;
            if(prec.prec != .None, => @report_error("..spread operator cannot be used inside an infix expression") (return, loc));
            arg := if self.peek_tag() == .LeftParen || can_start_quick_expr(self.peek()) {
               @try(self.parse_expr(Prec_None)) return
            } else {
                self.raw_unit(loc)
            };
            (Ok = self.expr((Spread = arg), loc))
        }
        @default => {
            self.pop();
            loc := self.last.span;
            @match(self.last.type) {
                fn Error(e) => {
                    ::tagged(LexErr);
                    @match(e) {
                        fn Unexpected(c) => @report_error("Expected begin expression, found unexpected byte %", c) (return, self.last.span);
                        @default => @report_error("Expected begin expression, found %", e&.tag()) (return, self.last.span);
                    };
                }
                @default => @report_error("Expected begin expression, found %", self.last.type&.tag()) (return, self.last.span);
            }
        };
    }
}

fn quick_lambda(self: *Parser, prec: Prec) ParseRes = {
    loc := self.last.span;
    body := @try(self.parse_expr(prec)) return;
    // TODO: this is kinda dumb (would be better not to force unit being an arg) but makes it consistant with elsewhere
    fn_def: FnDef = (name = .None, arg = self.alloc.empty_pattern(loc), ret = (Infer = ()), tags = list(self.alloc), loc = loc);
    //fn_def.line = self.pool.insert_borrowed(@tfmt("AnonL%", self.lex.line), general_allocator());
    func := make_func(fn_def, (Some = body), true, self.top_level);
    (Ok = self.expr((Closure = self.box(func)), loc))
}

fn func_expr(self: *Parser) ParseRes = {
    func := @try(self.parse_func()) return;
    (Ok = self.expr((Closure = func), func.loc))
}

fn parse_func(self: *Parser) Result(*Func, *CompileError) = {
    loc := self.last.span;
    fn_def := @try(self.fn_def_signeture(loc, true)) return;
    //fn_def.line = self.pool.insert_borrowed(@tfmt("AnonL%", self.lex.line), general_allocator());
    
    // TODO: do i want to allow without body in expression context?
    may_capture := @match(self.peek()) {
        fn Equals()         => false;
        fn FatRightArrow()  => true;
        fn Semicolon() => return(Ok = self.box(make_func(fn_def, .None, false, self.top_level)))
        @default => @report_error("expected '=' or '=>' or ';' after function decl ") (return, self.last.span);
    };
    self.pop();
    
    if !may_capture {
        @if_let(self.peek()) fn LeftSquiggle() => { 
            src, span := or self.lex&.skip_to_closing_squigle() {
                @report_error("unterminated block (mismatched '{')") (return, self.last.span)
            };
            self.pop(); // TODO: why do i need this? -- Jun 22
            id := self.push_parse(src, span);
            body := self.expr((GetParsed = id), loc);
            self.last.type = .RightSquiggle; // :HackFakeSquiggle
            return(Ok = self.box(make_func(fn_def, (Some = body), may_capture, self.top_level)));
        };
    };
    
    prev := self.top_level;
    self.top_level = false;
    body := @try(self.parse_expr(Prec_None)) return;
    self.top_level = prev;
    (Ok = self.box(make_func(fn_def, (Some = body), may_capture, self.top_level)))
}

fn named_call(self: *Parser, prec: Prec, name: Flag) ParseRes = {
    self.pop();
    loc := self.last.span;
    arg := @try(self.parse_expr(prec.with(.Neg))) return;
    f   := self.get_named(name, loc);
    (Ok  = self.expr((Call = (f = f, arg = arg)), loc))
}

fn parse_at(self: *Parser, prec: Prec) ParseRes = {
    self.pop(); 
    loc := self.last.span;
    handler := @match(self.peek()) {
        fn LeftSquare() => {
            self.pop();
            loc = self.last.span;
            e := @try(self.parse_expr(Prec_None)) return;
            @try(self.eat(.RightSquare, "close unquote")) return;
            return(Ok = self.expr((Unquote = e), self.last.span))
        }
        fn LeftParen() => {
            self.pop();
            loc = self.last.span;
            handler := @try(self.parse_expr(prec.reset())) return;
            @try(self.eat(.RightParen, "close macro expression")) return;
            handler
        }
        fn Symbol(name) => {
            self.pop();
            loc = self.last.span;
            self.expr((GetNamed = name), self.last.span)
        }
        fn LeftSquiggle() => {
            self.pop();
            loc := self.last.span;
            e := @try(self.parse_block_until_squiggle(false)) return;
            return(Ok = self.expr((Quote = e), loc))
        }
        @default => {
            self.pop(); // TODO: have lex.next:span
            @report_error("@ must be followed by @[ast_expr] or @(macro_expr) or @macro_name ") (return, self.last.span)
        };
    };
    
    ::if(*FatExpr);
    
    was_trailing := false;
    have_arg := self.maybe(.LeftParen);
    arg := if have_arg {
        @try(self.parse_tuple(.RightParen)) return
    } else {
        unit := self.raw_unit(loc);
        //if prec.allow_trailing && can_start_quick_expr(self.peek()) {
        //    //@println("%", self.lex.line);
        //    a := self.box(@try(self.parse_expr(prec = .None, allow_trailing = false)) return);
        //    if self.peek_tag() != .LeftSquiggle {
        //        return(Ok = self.expr((PrefixMacro = (handler = self.box(handler), arg = unit, target = a)), loc));
        //    };
        //    //panic("what!"); // :FUCEKD
        //    // :FUCKED this has got to be a compiler bug. this code clearly is not executing. 
        //    // i can't put anything else here. a print in @report_error's result doesn't happen when self compiling,
        //    @report_error("This should work but it does not (trailing lambda @macro without brackets)") (return, self.last.span);
        //    was_trailing = true;
        //    prec.allow_trailing = false;
        //    have_arg = true;
        //    a
        //} else {
            unit
        //}
    };
    
    // `if @is(a, b) {` === `if (@is(a, b)) {`
    deny_target := have_arg && !prec.allow_trailing && self.peek_tag() == .LeftSquiggle && !was_trailing;
    no_target   := @is(self.peek_tag(), .Semicolon, .Comma, .RightParen, .RightSquiggle, .RightSquare, .Dot, .Equals);
    target := if deny_target || no_target {
        self.raw_unit(loc)
    } else {
        p := @if(have_arg, prec.reset(), (prec = .Suffix, allow_trailing = false));
        @try(self.parse_expr(p)) return
    };
    (Ok = self.expr((PrefixMacro = (handler = handler, arg = arg, target = target)), loc))
}

fn parse_infix(self: *Parser, prev: *FatExpr, prec: Prec) ParseRes = {
    loop {
        loc := self.last.span;
        parsed: ParseRes = @match(self.peek()) {
            fn Op(op)      => {
                next_prec, callee := @match(op) {
                    fn Plus()      => (PrecLevel.AddSub,     Flag.add);
                    fn Minus()     => (PrecLevel.AddSub,     Flag.sub);
                    fn Star()      => (PrecLevel.MulDiv,     Flag.mul);
                    fn Slash()     => (PrecLevel.MulDiv,     Flag.div);
                    fn Less()      => (PrecLevel.Comparison, Flag.lt);
                    fn Greater()   => (PrecLevel.Comparison, Flag.gt);
                    fn LessEq()    => (PrecLevel.Comparison, Flag.le);
                    fn GreaterEq() => (PrecLevel.Comparison, Flag.ge);
                    fn BangEq()    => (PrecLevel.Equality,   Flag.ne);
                    fn EqEq()      => (PrecLevel.Equality,   Flag.eq);
                    fn AmpAmp()   => return(self.logical_operator(prev, prec, .and, .LogicalAnd, .LogicalOr));
                    fn PipePipe() => return(self.logical_operator(prev, prec, .or, .LogicalOr, .LogicalAnd));
                    @default => {
                        // update assignment operator. hopefully we're in a statement and that will handle it.
                        return(Ok = prev)
                    };
                };
                if prec.prec >= next_prec {
                    return(Ok = prev);
                };
                self.pop();
                loc := self.last.span;
                rhs := @try(self.parse_expr(prec.with(next_prec))) return;
                call := self.bin_call(callee, loc, prev, rhs);
                (Ok = call)
            }
            fn LeftParen() => {
                // We're an infix, so this is a call, not a free-standing tuple/struct. 
                if self.lex.line != self.lex.old_line {
                    @report_error("call expression cannot span multiple lines. the function and the left paren must be on the same line.") (return, self.last.span);
                };
                self.pop();
                arg := @try(self.parse_tuple(.RightParen)) return;
                arg.items().each(fn(it) => @if_let(it.expr&) fn Closure(it) => it[].set_flag(.WasLambdaLiteral));
                call := self.expr_call(prev, arg);
                self.parse_infix(call, prec.with(.Suffix))
            }
            fn Dot() => {
                start_line := self.lex.line;
                self.pop();
                end_line := self.lex.line;
                name := @try(self.pop_name("e.<NAME>")) return;
                if start_line != end_line {
                    // TODO: this doesn't even help against the thing i actually wanted to stop. 
                    @report_error("expr.field cannot span multiple lines. it just feels like an easy typo to mean something else.") (return, self.last.span);
                };
                loc := self.last.span;
                e := self.expr((FieldAccess = (container = prev, name = name, no_dot_call = false)), loc);
                self.parse_infix(e, prec.with(.Suffix))
            }
            fn Tick() => {
                self.pop();
                name := @try(self.pop_name("e.<NAME>")) return;
                loc := self.last.span;
                e := self.expr((FieldAccess = (container = prev, name = name, no_dot_call = true)), loc);
                self.parse_infix(e, prec.with(.Suffix))
            }
            fn LeftSquiggle() => {
                if(prec.allow_trailing.not(), => return(Ok = prev));
                self.parse_squiggle(prev, prec)
            }
            fn DoubleSquare() => {
                self.pop();
                e := self.expr((Deref = prev), self.last.span);
                self.parse_infix(e, prec.with(.Suffix))
            }
            fn Amp() => {
                self.pop();
                e := self.expr((Addr = prev), self.last.span);
                self.parse_infix(e, prec.with(.Suffix))
            }
            fn LeftSquare() => {
                loc := self.last.span;
                self.pop();
                index := @try(self.parse_tuple(.RightSquare)) return;
                
                // This was the same speed but i think its uglier. 
                // e := self.bin_named_macro(Flag.operator_index, prev, index, loc);
                
                e := self.bin_call(Flag.operator_index, self.last.span, prev, index);
                e := self.expr((Deref = e), self.last.span);
                self.parse_infix(e, prec.with(.Suffix))
            }
            @default => return(Ok = prev);
        };
        prev = @try(parsed) return;
        // manual tail call to ourself.
        // Since my backend doesn't do tail call elimination, you need this to cope with pathological cases,
        // like generated code with 1000 term expressions or whatever. 
        // It doesn't come up in real code but it's kinda embarasing to crash trying to parse 1k of 1+1+1+1+1+1+1+1+1+1+1+1, etc. 
    };
}

fn parse_squiggle(self: *Parser, prev: *FatExpr, prec: Prec) ParseRes #once = {  
    old_line := self.lex.line;
    self.pop();
    new_line := self.lex.line;
    loc := self.last.span;
    ::if(FnDef);
    fn_def: FnDef = if new_line == old_line {
        fn_def := @try(self.fn_def_signeture(loc, false)) return;
        @try(self.eat(.Pipe, "trailing lambda")) return;
        fn_def
    } else {
        // If the next token is on a new line, assume theres no pipe annotation. 
        // this lets you do ifs that look normal, like `if foo {` instead of `if foo {|`
        (name = .None, arg = self.alloc.empty_pattern(loc), ret = (Infer = ()), tags = list(self.alloc), loc = loc)
    };
    //fn_def.line = self.pool.insert_borrowed(@tfmt("AnonL%", self.lex.line), general_allocator());
    
    body := @try(self.parse_block_until_squiggle(false)) return;
    func := make_func(fn_def, (Some = body), true, self.top_level);
    func&.set_flag(.WasLambdaLiteral);
    callback := self.expr((Closure = self.box(func)), loc);
    self.push_arg(prev, callback);
    
    if self.lex.line != self.lex.old_line { 
        return(Ok = prev);
    };
    
    @if_let(self.peek()) 
        fn Symbol(name) => {
            if self.lex.line != self.lex.old_line {|
                @report_error("trailing lambda chained named arg cannot be on a new line") (return, self.last.span);
            };
            // TODO: actually use this as a named argument! rework the call into a StructLiteralP as needed. 
            //       currently i just ignore and assume you got the name right. 
            self.pop();
            if self.peek_tag() != .LeftSquiggle {
                self.pop();
                @report_error("Expected trailing lambda after named arg '%' (did you forget a semicolon after this expression?)", self.pool.get(name)) (return, self.last.span);
            };
        };
    // This is only called in parse_infix and that does the chaining for us. 
    (Ok = prev)
}

::if(ParseRes);

fn logical_operator(self: *Parser, prev: *FatExpr, prec: Prec, name: Flag, this: PrecLevel, other: PrecLevel) ParseRes #inline = {
    if prec.prec < .Logical {
        self.pop();
        if prec.prec == other {
            @report_error("Use parens to seperate && and || clauses.") (return, self.last.span);
        };
        loc := self.last.span;
        rhs := @try(self.quick_lambda(prec.with(this))) return;
        @debug_assert(rhs.expr&.is(.Closure));
        rhs.expr.Closure.set_flag(.WasLambdaLiteral);
        f := self.get_named(name, loc);
        arg := self.pair(prev, rhs, loc);
        call := self.expr((Call = (f = f, arg = arg)), loc);
        return(self.parse_infix(call, prec.with(this))) // TODO: tail
    } else {
        return(Ok = prev)
    }
}

fn bin_call(self: *Parser, func_name: Flag, loc: Span, lhs: *FatExpr, rhs: *FatExpr) *FatExpr #inline = {
    f := self.get_named(func_name, loc);
    arg := self.pair(lhs, rhs, loc);
    self.expr((Call = (f = f, arg = arg)), loc)
}

fn expr_call(self: *Parser, f: *FatExpr, arg: *FatExpr) *FatExpr = {
    // TODO: let else would be nice.
    @if_let(f.expr&)
        fn FieldAccess(ff) => {
            break :: local_return;
            // Dot call syntax sugar.
            
            root_f  := f;
            ff_expr := root_f;
            was_no_dot_call := ff.no_dot_call;
            if was_no_dot_call {
                while => was_no_dot_call && ff.container.expr&.is(.FieldAccess) {
                    ff_expr = ff.container;
                    ff = ff.container.expr.FieldAccess&;
                    was_no_dot_call = ff.no_dot_call;
                };
                if was_no_dot_call {  // `a'b'c(d)`
                    break();
                };
            };
            first_arg := ff.container;
            ff_expr[] = self.expr((GetNamed = ff.name), f.loc)[];
            ff := 0;
            f := root_f[];
            
            // `a.b'c(d)` -> (first_arg = a, f = b.c, arg -> d)
            // `a.b.c(d)` -> (first_arg = a.b, f = c, arg -> d)
            // `a'b.c(d)` -> (first_arg = a.b, f = c, arg -> d)
            
            // TODO: I want this to just call push_arg
            @match(arg.expr&) {
                // Tuple parser eagerly flattened single tuples so we have to undo that here.
                // TODO: have it work with named arguments. Need to support mixing named and positional.
                fn Tuple(parts) => {
                    parts.insert(0, first_arg[], self.alloc);
                    return(self.expr((Call = (f =  self.box(f), arg =arg)), f.loc));
                }
                // Parser flattened empty tuples.
                fn Value(v) => {
                    if v.bytes.is_unit() {
                        return(self.expr((Call = (f = self.box(f), arg = first_arg)), f.loc));
                    };
                    // fallthrough
                }
                // TODO: if the arg is a struct pattern, merge it with f instead of of just appending them.
                //       but this old parser didn't allow mixed named and positional so it doesn't matter yet. :SYNTAX -- Jun 21 
                @default => (); // fallthrough
            };
            
            arg := self.pair(first_arg, arg, f.loc);
            return(self.expr((Call = (f = self.box(f), arg = arg)), f.loc));
        };
    (self.expr((Call = (f = f, arg = arg)), f.loc))
}

fn push_arg(self: *Parser, call: *FatExpr, callback: *FatExpr) void = {
    if !call.expr&.is(.Call) {
        // It might just be a function access. like 'while {| _ } {| _ }' should be valid.
        call[] = self.expr((Call = (f = self.box(call[]), arg = callback)), call.loc)[];
        return();
    };
    f := call.expr.Call&;
    @match(f.arg.expr&) {
        // TODO: have it work with named arguments. Need to support mixing named and positional.
        fn Tuple(parts) => {
            parts.push(callback[], self.alloc);
        }
        // Parser flattened empty tuples.
        fn Value(v) => {
            if v.bytes.is_unit() {
                f.arg = callback;
            } else {  
                f.arg = self.pair(f.arg, callback, call.loc);
            };
        }
        @default => {
            f.arg = self.pair(f.arg, callback, call.loc);
        };
    };
}

:: ?FatExpr;
fn make_func(def: FnDef, body: ?*FatExpr, may_capture: bool, top_level: bool) Func = {
    // TODO: derive fn default with allocator
    ::if_opt(*FatExpr, FuncImpl);
    f: Func = (
        annotations = def.tags.as_raw(),
        callees = empty(),
        mutual_callees = empty(),
        // TODO: deconstruct_values doesn't work on @tagged so can't have default struct fields be .None-- Jun 21
        var_name = .None,
        finished_arg = .None,
        finished_ret = .None,
        return_var = .None,
        body = if(body, fn(body) => (Normal = body[]), => (Empty = ())),
        arg = def.arg,
        ret = def.ret,
        // TODO: use the body text based on compiler flag. also should an option use file+line? 
        name = def.name || def.line,
        loc = def.loc,
    );
    
    if(may_capture, => f&.set_flag(.AllowRtCapture));
    if(top_level, => f&.set_flag(.TopLevel));
    if(def.name.is_none(), => f&.set_flag(.NoName));
    f
}

fn is_unit(self: Values) bool #inline = {
    ::tagged(Values);
    self&.is(.Small) && self.Small._1 == 0
}

// This starts out with comma seperated expressions and switches to a struct pattern if it hits a colon/equals. 
// So you don't have to know if you're in a struct literal or if a function call uses named arguments ahead of time. 
// TODO: allow 'const' at the beginning to quickly switch to named args cause you must be in a struct definition. 
fn parse_tuple(self: *Parser, terminator: TokenType.Tag()) ParseRes = {
    loc := self.last.span;
    if self.maybe(terminator) {
        return(Ok = self.raw_unit(loc));
    };
    parts: List(FatExpr) = list(self.alloc);
    
    (=> {
        break :: local_return;
        loop {
            e := @try(self.parse_expr(Prec_None)) return;
            parts&.push(e[]);
            t := self.peek();
            @match(t) {
                fn Comma() => {
                    self.pop();
                    if(self.maybe(terminator), => break());
                }
                fn Colon() => {
                    self.pop();
                    ty: LazyType = @match(self.peek()) {
                        fn Equals() => .Infer;
                        @default => {
                            e := @try(self.parse_expr(Prec_None)) return;
                            (PendingEval = e[])
                        };
                    };
                    return(self.switch_to_parsing_named(parts, ty, loc, terminator));
                }
                fn DoubleColon() => return(self.switch_to_parsing_named(parts, .Infer, loc, terminator));
                fn Equals()      => return(self.switch_to_parsing_named(parts, .Infer, loc, terminator));
                @default => {
                    if(self.maybe(terminator), => break());
                    // TODO: fix error message
                    @report_error("Expected ',' or ':' or '=' or ')' after tuple element % (unmached parens?)", "") (return, self.last.span);
                };
            };
        };
    })();
    
    // TODO: not sure we want to do this but its what the rust one does. -- Jun 21
    //       (it means you have to do extra work to undo it for dot calls)
    res := @switch(parts.len) {
        @case(0) => self.raw_unit(loc);
        @case(1) => {
            ::if(*FatExpr);
            if self.peek_tag() == .LeftParen && parts[0].expr&.is(.FieldAccess) {
                self.expr(new_block(empty(), parts.index(0)), loc)  // prevent dot call
            } else {
                parts.index(0)
            }
        };
        @default => self.expr((Tuple = parts.as_raw()), loc);
        // TODO: if you forget that semicolon it doesn't see the default and crashes at runtime if you ever hit it. :FUCKED
    };
    
    (Ok = res)
}

// TODO: allow 'name :: value' in @struct. :SYNTAX

fn switch_to_parsing_named(self: *Parser, parts: List(FatExpr), ty: LazyType, loc: Span, terminator: TokenType.Tag()) ParseRes = {
    // Decided the last thing was actually a name for a named argument
    // TODO: let else
    ident_expr := parts&.pop().unwrap();
    name := @match(ident_expr.expr) {
        fn GetNamed(name) => name;
        @default => @report_error("Expected Ident before ':'/'=' in argument pattern. ") (return, ident_expr.loc);
    };
    
    ::if(FatExpr);
    ::if(*FatExpr);
    kind := VarType.Var;
    default: *FatExpr = if self.maybe(.Equals) {
        @try(self.parse_expr(Prec_None)) return
    } else {
        if self.maybe(.DoubleColon) {
            kind = .Const;
            @try(self.parse_expr(Prec_None)) return
        } else {
            @ref binding_missing_default(ident_expr.loc)
        }
    };
    
    bindings := Binding.list(parts.len + 1, self.alloc);
    for parts { e |
        // Allow mixed named and positional for function calls. 
        anon: Binding = (name = .None, ty = .Infer, nullable_tag = zeroed(*Annotations), default = e, kind = .Var);
        bindings&.push(anon);
    };
    
    ann := @try(self.parse_nullable_annotations()) return;
    first_named: Binding = (name = (Ident = name), ty = ty, nullable_tag = ann, default = default[], kind = kind);
    bindings&.push(first_named);
    
    if self.maybe(.Comma) {
        @try(self.parse_pattern(bindings&, terminator)) return;
    };
    @try(self.eat(terminator, "end of argument list")) return;
    return(Ok = self.expr((StructLiteralP = (bindings = bindings.as_raw(), loc = loc)), loc))
};

fn if_empty_add_unit(self: *List(Binding)) void = {
    if(self.len != 0, => return());
    self.push(empty_binding(zeroed Span));
}

fn empty_pattern(a: Alloc, loc: Span) Pattern = 
    (bindings = empty_binding(loc).single(a).as_raw_list(), loc = loc);

fn empty_binding(loc: Span) Binding #inline = {
    (
        name = .None,
        ty = (Finished = void),
        nullable_tag = zeroed(*Annotations),
        default = binding_missing_default(loc),
        kind = .Var,
    )
}
    
fn parse_args(self: *Parser) Result(Pattern, *CompileError) = {
    loc := self.last.span;
    bindings: List(Binding) = list(self.alloc);
    @try(self.parse_pattern(bindings&, .RightParen)) return;
    bindings&.if_empty_add_unit();
    (Ok = (bindings = bindings.as_raw(), loc = loc))
}

fn parse_pattern(self: *Parser, out: *List(Binding), terminator: TokenType.Tag()) Result(void, *CompileError) = {
    loop {
        // TODO: no comma allowed here
        // TODO: shouldnt have to put the type annotations everywhere. 
        //       before switching nested ifs to switch, you didn't need it. -- Jul 28
        T :: Ty(Symbol, VarType);
        t := self.peek();
        name, kind := @match(t) {
            fn Dollar() => {
                self.pop();
                // TODO: better let else.
                name: Symbol = @try(self.pop_name("after '$'")) return;
                (name, VarType.Const)
            }
            fn Symbol(name) T => {
                self.pop();
                (name, VarType.Var)
            }
            fn Semicolon() => {
                self.pop();
                @report_error("Semicolon while parsing pattern. unmatched brackets? did you mean to use a comma?") (return, self.last.span)
            }
            @default => {
                if t&.tag() == terminator {
                    return(.Ok);
                };
                @report_error("Expected Ident or '$' before pattern entry. (positional args cannot follow named) ") (return, self.last.span);
            };
        };
        
        @try(self.parse_binding_after_name(name, kind, out.push_uninit())) return;
        if !self.maybe(.Comma) {
            return(.Ok);
        };
    }
}

fn parse_binding_after_name(self: *Parser, name: Symbol, kind: VarType, out: *Binding) CRes(void) = {
    ::if(?FatExpr); ::if(LazyType);
    default_: ?*FatExpr = .None;
    ty := LazyType.Infer;
    ann := zeroed(*Annotations);
    @match(self.peek()) {
        fn Colon() => {
            self.pop();
            if self.maybe(.Squiggle) {
                name: Symbol = @try(self.pop_name("after '~'")) return;
                ty = (UnboundGeneric = name);
                ann = @try(self.parse_nullable_annotations()) return;
            } else {
                if self.peek_tag() != .Equals {
                    e := @try(self.parse_expr(Prec_None)) return;
                    ty = (PendingEval = e[]);
                    ann = @try(self.parse_nullable_annotations()) return;
                };
                
                if self.maybe(.Equals) {
                    e := @try(self.parse_expr(Prec_None)) return;
                    default_ = (Some = e);
                } else {
                    if self.maybe(.Colon) {
                        e := @try(self.parse_expr(Prec_None)) return;
                        default_ = (Some = e);
                        kind = .Const;
                    };
                };
            };
        }
        fn DoubleColon() => {
            self.pop();
            kind = .Const;
            e := @try(self.parse_expr(Prec_None)) return;
            default_ = (Some = e);
        }
        fn Equals() => {    
            self.pop();
            e := @try(self.parse_expr(Prec_None)) return;
            default_ = (Some = e);
        }
        @default => {   // ie: `callee { arg #ann | body }`
            ann = @try(self.parse_nullable_annotations()) return;
        };
    };
    
    default_ := default_ || @ref binding_missing_default(self.last.span); // TODO: "shadows" the magic @default
    out[] = (name = (Ident = name), ty = ty, nullable_tag = ann, default = default_[], kind = kind);
    .Ok
}

fn parse_nullable_annotations(self: *Parser) Result(*Annotations, *CompileError) #inline = {
    ann := zeroed(*Annotations);
    if self.peek_tag() == .Hash {
        ann = self.alloc.box_uninit(Annotations);
        ann[] = as_raw(@try(self.parse_annotations()) return);
    };
    (Ok = ann)
}

fn pop_name(self: *Parser, msg: Str) Result(Symbol, *CompileError) = {
    s := self.pop();
    (Ok = @match(s) {
        fn Symbol(name) => name;
        @default => @report_error("Expected Ident % (found %)", msg, s&.tag()) (return, self.last.span);
    })
}

FnDef :: @struct(name: ?Symbol, arg: Pattern, ret: LazyType, tags: List(Annotation), loc: Span, line := Flag.Anon.ident());
fn fn_def_signeture(self: *Parser, loc: Span, allow_name: bool) Result(FnDef, *CompileError) = {
    name: ?Symbol = .None;
    @if(allow_name) @if_let(self.peek()) fn Symbol(n) => {
        self.pop();
        loc = self.last.span;  // if there's a name, use that as the loc for the function because that's nicer for the ide. 
        name = (Some = n)
    };
    
    cant_start_return_expression :: fn(t: TokenType) bool #inline = {
        @is(t&, .Equals, .Semicolon, .Pipe, .FatRightArrow, .Hash)
    };
    no_paren := false;
    disallow_return := false;
    ::if(Pattern);
    arg: Pattern = if self.maybe(.LeftParen) {
        a := @try(self.parse_args()) return;
        @try(self.eat(.RightParen, "end of argument list")) return;
        a
    } else {
        no_paren = true;
        if allow_name.or(cant_start_return_expression(self.peek())) {
            (bindings = empty(), loc = self.last.span)
        } else {
            disallow_return = true;
            @try(self.parse_args()) return
        }
    };

    if no_paren && !cant_start_return_expression(self.peek()) {
        @report_error("'fn <Expr> =' can't treat Expr as ret type. pls specify name or args. forgot '|' before lambda body? tried to use `fn` as an identifier?") (return, self.last.span);
    };

    ::if(LazyType);
    ret: LazyType = if !cant_start_return_expression(self.peek()) {
        // Note: no trailing means you can use '=>' as a quick expression so `while => e {| b}` and the trailing binds to the while not the e. 
        e := @try(self.parse_expr((prec = .None, allow_trailing = false))) return;
        (PendingEval = e[])
    } else {
        .Infer
    };
    tags := @try(self.parse_annotations()) return;

    (Ok = (name = name, arg = arg, ret = ret, tags = tags, loc = loc))
}

// Consumes '}'
fn parse_block_until_squiggle(self: *Parser, allow_eof: bool) ParseRes = {
    loc := self.last.span;
    stmts: List(FatStmt) = list(self.alloc);
    
    while => !self.maybe(.RightSquiggle) && (!allow_eof || !self.maybe(.Eof)) {
        if self.maybe(.Eof) {
            @report_error("unexpected end of file ") (return, self.last.span);
        };
        s := @try(self.parse_stmt()) return;
        stmts&.push(s);
    };
    
    ::if_opt(FatStmt, *FatExpr);
    result: *FatExpr = if stmts&.pop() { stmt |
        @match(stmt.stmt) {
            fn Eval(e) => self.box(e);
            @default => {
                // block might end with a func decl with no semicolon.
                stmts&.push(stmt);
                self.raw_unit(self.last.span)
            };
        }
    } else {
        self.raw_unit(self.last.span)
    };
    
    e := self.expr(new_block(stmts.as_raw(), result), loc);
    (Ok = e)
}

fn new_block(body: RawList(FatStmt), result: *FatExpr) Expr = (Block = (
    body = body, 
    result = result, 
    ret_label = .None, 
    flags = 0,
    scope = NOSCOPE
));

::if(?FatExpr);
fn parse_annotations(self: *Parser) Result(List(Annotation), *CompileError) = {
    tags: List(Annotation) = list(self.alloc);
    while => self.maybe(.Hash) {
        name := @try(self.pop_name("after '#'")) return;
        ::if(*FatExpr);
        arg: *FatExpr = if self.maybe(.LeftParen) {
            @try(self.parse_tuple(.RightParen)) return
        } else {
            self.raw_unit(self.last.span)
        };
        tags&.push(name = name, args = arg[]);
    };
    (Ok = tags)
}

// TODO: be able to eq on tagged
fn maybe(self: *Parser, type: TokenType.Tag()) bool = {
    yes := self.peek_tag() == type;
    if yes {
        self.pop(); 
    };
    yes
}

fn eat(self: *Parser, type: TokenType.Tag(), msg: Str) Result(void, *CompileError) = {
    if !self.maybe(type) {
        @report_error("Expected % for %", type, msg) (return, self.last.span);
    };
    .Ok
}

unit_value: Values : (Small = (0, 0));
fn raw_unit(self: *Parser, loc: Span) *FatExpr = {
    e := self.expr((Value = (bytes = unit_value, coerced = false)), loc);
    e.ty = void; // :get_or_create_type
    e
}

fn get_named(self: *Parser, name: Flag, loc: Span) *FatExpr = 
    self.expr((GetNamed = name.ident()), loc);

fn bin_named_macro(self: *Parser, name: Flag, arg: *FatExpr, target: *FatExpr, loc: Span) *FatExpr #inline = {
    handler := self.get_named(name, loc);
    self.expr((PrefixMacro = (handler = handler, arg = arg, target = target)), loc)
}

fn expr(self: *Parser, e: Expr, loc: Span) *FatExpr #inline = 
    self.box(expr = e, loc = loc, ty = UnknownType, done = false);

fn stmt(self: *Parser, e: Stmt, loc: Span) FatStmt #inline = 
    (stmt = e, loc = loc);
    
fn PBox($T: Type) void = {
    fn box(self: *Parser, e: T) *T = 
        self.alloc.boxed(T, e);
}
::PBox(FatExpr); ::PBox(Func);

fn pair(self: *Parser, lhs: *FatExpr, rhs: *FatExpr, loc: Span) *FatExpr = {
    out := self.alloc.alloc_uninit(FatExpr, 2);
    out[0] = lhs[];
    out[1] = rhs[];
    self.expr((Tuple = (cap = 2, ptr = out.ptr, len = 2)), loc)
}

fn pop(self: *Parser) TokenType = {
    self.last = self.lex&.peek()[];
    self.lex&.pop();
    self.last.type
}

fn peek(self: *Parser) TokenType = {
    token := self.lex&.peek()[];
    token.type
}

fn peek_tag(self: *Parser) TokenType.Tag() = {
    token := self.lex&.peek()[];
    token.type&.tag()
}

fn report_error(fmt_args: FatExpr, ret_loc: FatExpr) FatExpr #macro = {
    @assert_eq(ret_loc.expr&.tag(), Expr.Tag().Tuple, "expected tuple");
    args := ret_loc.expr.Tuple.items();
    result := @{
        msg := @tfmt(@[fmt_args]);  // TODO: this is sketchy
        a := @if(HACK_PARSER_ALLOC, general_allocator(), current_comptime().get_alloc());
        mem := a.boxed(CompileError, (Parse = (span = @[args[1]], msg = msg)));
        @[args[0]](Err = mem);
        unreachable()
    };
    result
}

fn int(self: PrecLevel) i64 = @as(i64) self;
::Ord(PrecLevel);
