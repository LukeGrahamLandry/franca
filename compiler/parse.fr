//! This is sizeable chunk of the most boring smooth brain code. 
//! But it's easier to reason about than using some parser generator thing and doesn't involve taking a hefty dependency. 
//! Exactly zero of the problems I've faced writing a self-hosted compiler were that the bootstrapping process was **too simple**. 

// For reference, the rust one was 1100 loc (without math operators).

// TODO: make the language less clunky
// - have @tagged give you a Tag(E) enum type so you can do 'tagged.is(.Name)'
// - destructure multiple return values. 'a, b := f(); f :: fn() Ty(A, B); '
// - less verbose if let/let else? think about how to express with a macro. 
// - equivilent of matches!(e, .A | .B | .C) more terse than @switch
//   @or(A, B, C) could work if you don't need to capture any payload. 
// - auto coerce payload to enum when branches aren't ambigous? maybe? thats a bit creepy. doing it for unit when you just forget to return something would be bad. 
// - really need to fix unreachable_hack
// - default function arguments because 'self.parse_expr(Prec.None)' and symmetry with structs. 
// - its probably a bad thing that im choosing when to factor out functions based on "not enough bits to refer to all slots",
//   obviously a crippling compiler bug (my asm backend only) but perhaps implies a style problem on my part. 
// - move this version of @try to lib. 
// - get rid of backpassing syntax. i never use it anyway. 
// - same problem i had in rust. its really annoying that you have to pass the pool to print things because it makes debugging that way more clunky.
//   could have an implicit context system? crippling that you can't just derive print normal things. 
//
// - make const a contextual keyword? 
// - local_return and return implciitly rebinding is a bit confusing
//

// TODO: :SLOW im doing so many silly copies and also need to actually enforce tailcalls on llvm (right now i might be preventing them with ccc even on internal functions!).  -- Jun 21

ParseTask :: @tagged(
    Pending: @struct(src: Str, span: Span),
    Expr: Result(FatExpr, ParseErr),
);
Parser :: @struct(pool: *StringPool, lex: Lexer, tasks: *List(ParseTask), alloc: Alloc, last: Token);
ParseErr :: @struct(span: Span, msg: Str);
Prec :: @struct(prec: PrecLevel, allow_trailing: bool = true);

Prec_None: Prec : (prec = .None);
fn reset(p: Prec) Prec = p.with(.None);
fn with(p: Prec, next: PrecLevel) Prec = 
    (prec = next, allow_trailing = p.allow_trailing);

PrecLevel :: @enum(i64) (
    None,
    Equality,
    Comparison,
    AddSub,
    MulDiv,
    Neg,
    Suffix,
);
ParseRes :: Result(FatExpr, ParseErr);

fn finish_pending(self: *Parser, id: WaitingParse) ParseRes #compiler = {
    @match(self.tasks[id.id]&) {
        (fn Pending(src_span) ParseRes => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            e := self.parse_expr(Prec_None);
            // TODO: clone! :FUCKED
            // TODO: save less often!
            self.tasks[id.id] = (Expr = e);
            e
        });
        (fn Expr(e) ParseRes => { 
            // TODO: clone! :FUCKED
            e[]
        });
    }
}

fn finish_pending_stmts(self: *Parser, id: WaitingParse) Result(RsVec(FatStmt), ParseErr) #compiler = {
    T :: Result(RsVec(FatStmt), ParseErr);
    @match(self.tasks[id.id]&) {
        (fn Pending(src_span) T => {
            self.lex = init(self.pool, src_span.span, src_span.src);
            e := self.parse_block_until_squiggle(true);
            
            
            
            // TODO: clone! :FUCKED
            // TODO: save less often!
            self.tasks[id.id] = (Expr = e);
            self.finish_pending_stmts(id) // TODO: im lazy
        });
        (fn Expr(e) T => { 
            // TODO: clone! :FUCKED
            @match(e) {
                (fn Ok(e) T => (Ok = e.expr.Block.body));
                (fn Err(e) T => (Err = e[]));
            }
        });
    }
}

fn push_parse(self: *Parser, src: Str, span: Span) WaitingParse #compiler = {
    self.tasks.push((Pending = (src = src, span = span)));
    (id = self.tasks.len.sub(1))
}

fn parse_stmt(self: *Parser) Result(FatStmt, ParseErr) = {
    tags := @try(self.parse_annotations()) return;
    stmt := @try(self.parse_stmt_inner()) return;
    stmt.annotations = tags.rs();
    (Ok = stmt)
}

fn parse_stmt_inner(self: *Parser) Result(FatStmt, ParseErr) = {
    loc := self.last.span;
    @match(self.peek()) {
        (fn Fn() => {
            self.pop();
            func := @try(self.parse_func(true)) return;
            return(Ok = self.stmt((DeclFunc = self.box(func)), loc));
        });
        (fn Symbol(name) => {
            return(self.parse_decl_or_start_expr(name));
        });
        (fn Semicolon() => {
            self.pop();
            // TODO: dont do this. why waste space storing these?
            //       but i use them for distingushing when to return trailing expression. 
            //       :dont_store_noop
            return(Ok = self.stmt((.Noop), loc));
        });
        @default => {
            e := @try(self.parse_prefix(Prec_None)) return;
            return(self.after_expr_stmt_prefix(e));
        };
    };
    Result(FatStmt, ParseErr).unreachable_hack()
}

fn parse_decl_or_start_expr(self: *Parser, name: Symbol) Result(FatStmt, ParseErr) = {
    self.pop();
    loc := self.last.span;
    @match(self.peek()) {
        (fn DoubleColon() => {
            self.pop();
            loc := self.last.span;
            e := @try(self.parse_expr(Prec_None)) return;
            s: Stmt = (DeclNamed = (kind = .Const, value = e, ty = (Infer = unit), name = name));
            return(Ok = self.stmt(s, loc));
        });
        (fn Colon() => {
            self.pop();
            ::if(LazyType);
            ty: LazyType = if (self.next_is_equals(), => (Infer = unit)) {|
                e := @try(self.parse_expr(Prec_None)) return;
                (PendingEval = e)
            };
            kind := @match(self.pop()) {
                (fn Equals() => VarType.Var);
                (fn Colon() => VarType.Const);
                @default => @report_error("expected = or : after declaration of variable %", self.pool.get(name)) (return, self.last.span);
            };
            loc := self.last.span;
            value := @try(self.parse_expr(Prec_None)) return;
            s: Stmt = (DeclNamed = (kind = kind, value = value, ty = ty, name = name)); // TODO: the rust thing where you don't have to say the name if the expr is a var read that matches.
            return(Ok = self.stmt(s, loc));
        });
        @default => {
            e := @try(self.ident_expr_and_maybe_trailing(name, Prec_None, loc)) return;
            return(self.after_expr_stmt_prefix(e));
        };
    };
    Result(FatStmt, ParseErr).unreachable_hack()
}
fn next_is_equals(self: *Parser) bool = {
    t := self.peek();
    eq(t&!tag[], tag_value(TokenType, @symbol Equals))
}

fn after_expr_stmt_prefix(self: *Parser, e: FatExpr) Result(FatStmt, ParseErr) = {
    loc  := e.loc;
    // TOOD: allow_trailing?
    e    := @try(self.parse_infix(e, Prec_None)) return;
    stmt := @match(self.peek()) {
        (fn Equals() => {
            self.pop();
            loc := self.last.span;
            value := @try(self.parse_expr(Prec_None)) return;
            self.stmt((Set = (place = e, value = value)), loc)
        });
        (fn Op(op) => {
            f := @switch(op) {
                @case(.MinusEq) => Flag.operator_minus_equal;
                @case(.PlusEq) => Flag.operator_plus_equal;
                @case(.StarEq) => Flag.operator_star_equal;
                @case(.SlashEq) => Flag.operator_slash_equal;
                @default fn(_: Operator) => @report_error("non-update-assingment operator after expression statement. this should be unreachable? %", "") (return, self.last.span);
            };
            self.pop();
            delta := @try(self.parse_expr(Prec_None)) return;
            e := self.bin_named_macro(f, e, delta, loc);
            self.stmt((Eval = e), loc)
        });
        @default => {
            self.stmt((Eval = e), loc)
        };
    };
    
    @match(self.peek()) {
        (fn Semicolon() => ());
        (fn RightSquiggle(_) => ());
        (fn Eof() => ());
        @default => @report_error("';' (discard) or '}' (return) after expr stmt %", "") (return, self.last.span);
    };
    
    (Ok = stmt)
}

fn can_start_quick_expr(t: TokenType) bool = {
    @match(t) {
        (fn Symbol(_) => true);
        (fn At() => true);
        (fn Quoted(_) => true);
        (fn Number(_) => true);
        (fn BinaryNum(_) => true);
        (fn Op(op) bool => @switch(op){
            // TODO: you want this to be true so you can do 'if !whatever' but then it breaks 'Type!builtin'. -- Jun 23
            //       just prefer the quick expr one. bring back "expected trailing lambda after quick expres"
            @case(Operator.Bang) => false;
            @default fn(_: Operator) => false;
        });
        @default => false;
    }
}

fn ident_expr_and_maybe_trailing(self: *Parser, name: Symbol, prec: Prec, loc: Span) ParseRes = {
    e := self.expr((GetNamed = name), loc);
    
    // TODO: .and(allow_trailing)
    if prec.allow_trailing.and(=> can_start_quick_expr(self.peek())) {|
        first_arg := @try(self.parse_expr(@as(Prec) (prec = .None, allow_trailing = false))) return;
        t := self.last.type;
        cond := not(eq(t&!tag[], ::tag_value(TokenType, @symbol LeftSquiggle)));
        //if cond {|
        //    @report_error("expected trailing lambda after quick expression. like <ident> <expr> { <args> | <body> } %", "") (return, self.last.span);
        //};
        // TODO: make sure this doesn't alias e -- Jun 21
        e2 := self.expr_call(e, first_arg);
        e = e2;
    };
    
    (Ok = e)
}

// TODO: non-existant field name for @tagged is a panic because its in a mut_replace. 
fn parse_expr(self: *Parser, prec: Prec) ParseRes = {
    self.lex&.peek();
    // TODO: can't access field on rvalue. 
    // TODO: you can't return a pair at comptime if its not a pair of ints. (u32, u32) gives back 16 bytes from ffi::c and then compiler::jit crashes on it for being the wrong size. 
    e := @try(self.parse_prefix(prec)) return;
    self.parse_infix(e, prec)
}

fn parse_prefix(self: *Parser, prec: Prec) ParseRes = {
    loc := self.last.span;
    @match(self.peek()) {
        (fn Op(op) => {
            f := @switch(op) {
                @case(.Minus) => Flag.neg;
                @case(.Bang) => Flag.not;
                @case(.Star) => Flag.operator_star_prefix;
                // TODO: don't require the arg or have better error message. -- Jun 18
                @default fn(_: Operator) Flag => {
                    @report_error("expected begin expression found non-prefix operator %", "") (return, self.last.span);
                    Flag.unreachable_hack()
                };
            };
            self.pop();
            return(self.named_call(prec, f));
        });
        (fn LeftSquiggle() => {
            self.pop();
            return(self.parse_block_until_squiggle(false));
        });
        (fn LeftParen() => {
            // we're a prefix, so this is NOT a call. 
            self.pop();
            e := @try(self.parse_tuple()) return;
            return(Ok = e);
        });
        (fn At() => {
            self.pop();
            return(self.parse_at(prec));
        });
        (fn FatRightArrow() => {
            return(self.quick_lambda());
        });
        (fn DoubleColon() => {
            self.pop();
            e := self.bang(.const_eval, @try(self.parse_expr(prec.with(.Neg))) return, self.last.span);
            return (Ok = e);
        });
        (fn Amp() => {
            @report_error("'&' is not a prefix operator. if you meant to take the address of a variable, use it as a suffix.%", "") (return, self.last.span);
        });
        (fn Question() => {
            self.pop();
            return(self.named_call(prec, Flag.operator_question_prefix));
        });
        (fn Fn() => {
            self.pop();
            return(self.func_expr());
        });
        (fn SingleQuote() => {
            self.pop();
            e := @try(self.parse_expr(Prec_None)) return;
            @try(self.eat(@symbol SingleQuote, "end quoted expression")) return;
            return(Ok = self.bang(.quote, e, loc));
        });
        (fn Number(n) => {
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = i64;
            self.pop();
            return(Ok = e);
        });
        (fn Float(n) => {
            n: i64 = n.bitcast();
            e := self.expr((Value = (bytes = (Small = (n, 8)), coerced = false)), loc);
            e.ty = f64;
            self.pop();
            return(Ok = e);
        });
        (fn BinaryNum(n) => {
            self.pop();
            return(Ok = self.bin_num(n));
        });
        (fn Dot() => {
            self.pop();
            loc := self.last.span;
            name := @try(self.pop_name("after leading dot")) return;
            prev := self.expr((GetNamed = name), self.last.span);
            return(Ok = self.bang(.contextual_field, prev, loc));
        });
        // TODO: its a waste to intern these since you want to deduplicate before putting in an aot exe anyway since they might be computed. 
        (fn Quoted(s) => {
            e := self.expr((String = s.s), loc);
            if s.escapes {|
                f := self.box(self.get_named(.__string_escapes, loc));
                e = self.expr((Call = (f = f, arg = self.box(e))), loc);
            };
            self.pop();
            return(Ok = e);
        });
        (fn Symbol(name) => {
            self.pop();
            return(self.ident_expr_and_maybe_trailing(name, prec, loc));
        });
        @default => {
            self.pop();
            @report_error("Expected begin expression %", "") (return, self.last.span);
        };
    };
    ParseRes.unreachable_hack()
}

fn quick_lambda(self: *Parser) ParseRes = {
    self.pop();
    loc := self.last.span;
    body := @try(self.parse_expr(Prec_None)) return;
    // FnDef :: @struct(name: ?Symbol, arg: Pattern, ret: LazyType, tags: List(Annotation));
    fn_def: FnDef = (name = .None, arg = (bindings = empty(), loc = loc), ret = (Infer = ()), tags = list(self.alloc));
    func := self.make_func(fn_def, (Some = body), loc, true);
    (Ok = self.expr((Closure = self.box(func)), loc))
}

fn func_expr(self: *Parser) ParseRes = {
    func := @try(self.parse_func(false)) return;
    (Ok = self.expr((Closure = self.box(func)), func.loc))
}

fn parse_func(self: *Parser, allow_empty: bool) Result(Func, ParseErr) = {
    loc := self.last.span;
    fn_def := @try(self.fn_def_signeture(loc, true)) return;
    
    may_capture := @match(self.pop()) {
        (fn Equals() => false);
        (fn FatRightArrow() => true);
        (fn Semicolon() bool => {
            if not(allow_empty) {|
                @report_error("Function expression requires body %", "") (return, self.last.span);
            };
            return(Ok = self.make_func(fn_def, .None, loc, false))
        });
        @default => @report_error("expected '=' or '=>' or ';' after function decl %", "") (return, self.last.span);
    };
    
    if not(may_capture) {|
        @match(self.peek()) {
            (fn LeftSquiggle() => {
                src_span := self.lex&.skip_to_closing_squigle();
                //self.last = self.lex&.peek()[];
                self.pop(); // TODO: why do i need this? -- Jun 22
                id := self.push_parse(src_span._0, src_span._1);
                body := self.expr((GetParsed = id), loc);
                return((Ok = self.make_func(fn_def, (Some = body), loc, may_capture)));
            });
            @default => ();
        };
    };
    
    body := @try(self.parse_expr(Prec_None)) return;
    (Ok = self.make_func(fn_def, (Some = body), loc, may_capture))
}

// TODO: this is dumb. just admit there are more ast nodes? but then you have to deal with it everywhere. 
fn bin_num(self: *Parser, b: BinNum) FatExpr = {
    loc := self.last.span;
    v := self.expr((Value = (
        bytes = (Small = (b.value.bitcast(), 8)),
        coerced = false,
    )), loc);
    v.ty = i64; // this is hardcoded. 
    bits := self.expr((Value = (
        bytes = (Small = (b.bit_count.zext(), 8)),
        coerced = false,
    )), loc);
    bits.ty = i64;
    self.bang(.from_bit_literal, self.pair(bits, v, loc), loc)
}

fn named_call(self: *Parser, prec: Prec, name: Flag) ParseRes = {
    loc := self.last.span;
    arg := self.box(@try(self.parse_expr(prec.with(.Neg))) return);
    f := self.box(self.get_named(name, loc));
    (Ok = self.expr((Call = (f = f, arg = arg)), loc))
}

fn parse_at(self: *Parser, prec: Prec) ParseRes = {
    loc := self.last.span;
    
    handler := @match(self.peek()) {
        (fn LeftSquare() FatExpr => {
            self.pop();
            e := @try(self.parse_expr(Prec_None)) return;
            @try(self.eat(@symbol RightSquare, "close unquote")) return;
            return(Ok = self.bang(.unquote, e, self.last.span));
            FatExpr.unreachable_hack()
        });
        (fn LeftParen() FatExpr => {
            self.pop();
            handler := @try(self.parse_expr(prec.reset())) return;
            @try(self.eat(@symbol RightParen, "close macro expression")) return;
            handler
        });
        (fn Symbol(name) FatExpr => {
            self.pop();
            // TODO: HACK. if i want this to parse differently, admit its a different thing. 
            //       kinda ties into getting rid of !macros.
            if name.eq(Flag.return.ident()) {|
                return(Ok = self.expr((GetNamed = Flag.__return.ident()), self.last.span));
            };
            
            self.expr((GetNamed = name), self.last.span)
        });
        @default fn() FatExpr => {
            @report_error("@ must be followed by @[ast_expr] or @(macro_expr) or @macro_name %", "") (return, self.last.span);
            FatExpr.unreachable_hack()
        };
    };
    
    ::if(*FatExpr);
    arg := if self.maybe(@symbol LeftParen) {|
        self.box(@try(self.parse_tuple()) return)
    }{|
        self.box(self.raw_unit(loc))
    };
    // TODO: fuck
    target := @match(self.peek()) {
        (fn Semicolon() => self.raw_unit(loc));
        (fn Comma() => self.raw_unit(loc));
        (fn RightParen() => self.raw_unit(loc));
        (fn RightSquiggle() => self.raw_unit(loc));
        (fn RightSquare() => self.raw_unit(loc));
        (fn Dot() => self.raw_unit(loc));
        (fn Equals() => self.raw_unit(loc));
        @default => @try(self.parse_expr(prec.reset())) return;
    };
    (Ok = self.expr((PrefixMacro = (handler = self.box(handler), arg = arg, target = self.box(target))), loc))
}

fn parse_infix(self: *Parser, prev: FatExpr, prec: Prec) ParseRes = {
    loc := self.last.span;
    parsed: ParseRes = @match(self.peek()) {
        (fn Op(op) ParseRes => {
            return(self.parse_bin_op(op, prev, prec));
            ParseRes.unreachable_hack()
        });
        (fn LeftParen() => {
            // We're an infix, so this is a call, not a free-standing tuple/struct. 
            self.pop();
            arg := @try(self.parse_tuple()) return;
            call := self.expr_call(prev, arg);
            self.parse_infix(call, prec.with(.Suffix))
        });
        (fn Dot() => {
            self.pop();
            name := @try(self.pop_name("e.<NAME>")) return;
            e := self.expr((FieldAccess = (container = self.box(prev), name = name)), loc);
            self.parse_infix(e, prec.with(.Suffix))
        });
        (fn LeftSquiggle() => {
            if(prec.allow_trailing.not(), => return(Ok = prev));
            self.parse_squiggle(prev, prec)
        });
        (fn DoubleSquare() => {
            self.pop();
            e := self.bang(.deref, prev, self.last.span);
            self.parse_infix(e, prec.with(.Suffix))
        });
        (fn Amp() => {
            self.pop();
            e := self.bang(.addr, prev, self.last.span);
            self.parse_infix(e, prec.with(.Suffix))
        });
        (fn LeftSquare() => {
            loc := self.last.span;
            self.pop();
            index := @try(self.parse_expr(Prec_None)) return;
            
            closing := self.pop();
            // TODO: have a less ass shorthand for this. 
            @match(closing) {
                (fn RightSquare() => ());
                @default => {
                    @report_error("expected ']' after index expression %", "") (return, self.last.span)
                };
            };
            
            e := self.bin_named_macro(Flag.operator_index, prev, index, loc);
            self.parse_infix(e, prec.with(.Suffix))
        });
        @default fn()void => return(Ok = prev);
    };
    prev = @try(parsed) return;
    // You can chain a bunch of the same level. 
    self.parse_infix(prev, prec) // TODO: tail
}

fn parse_squiggle(self: *Parser, prev: FatExpr, prec: Prec) ParseRes = {
    self.pop();
    loc := self.last.span;
    fn_def := @try(self.fn_def_signeture(loc, false)) return;
    @try(self.eat(@symbol Pipe, "trailing lambda")) return;
    
    body := @try(self.parse_block_until_squiggle(false)) return;
    func := self.make_func(fn_def, (Some = body), loc, true);
    callback := self.expr((Closure = self.box(func)), loc);
    self.push_arg(prev&, callback);
    // TODO: do i want allow extra after this??
    self.parse_infix(prev, prec.with(.Suffix))
}

// TODO: this seems to use the wrong loc
fn parse_bin_op(self: *Parser, op: Operator, prev: FatExpr, prec: Prec) ParseRes = {
    // TODO: destructuring: `prec, name := @switch ...`
    next := @switch(op) {
        @case(.Plus) => (PrecLevel.AddSub, Flag.add);
        @case(.Minus) => (PrecLevel.AddSub, Flag.sub);
        @case(.Star) => (PrecLevel.MulDiv, Flag.mul);
        @case(.Slash) => (PrecLevel.MulDiv, Flag.div);
        @case(.Less) => (PrecLevel.Comparison, Flag.lt);
        @case(.Greater) => (PrecLevel.Comparison, Flag.gt);
        @case(.LessEq) => (PrecLevel.Comparison, Flag.le);
        @case(.GreaterEq) => (PrecLevel.Comparison, Flag.ge);
        @case(.BangEq) => (PrecLevel.Equality, Flag.ne);
        @case(.EqEq) => (PrecLevel.Equality, Flag.eq);
        @case(.Bang) => {
            self.pop();
            loc := self.last.span;
            // no <not> bit op. its e!name...
            name := @try(self.pop_name("macro name after '!'")) return;
            e := self.expr((SuffixMacro = (name = name, arg = self.box(prev))), loc);
            return(self.parse_infix(e, prec)); // TODO: tail
            unreachable()
        };
        @default fn(_: Operator) => {
            // update assignment operator. hopefully we're in a statement and that will handle it.
            return(Ok = prev);
            unreachable()
        };
    };
    if(prec.prec.lt(next._0)) {|
        self.pop();
        loc := self.last.span;
        rhs := @try(self.parse_expr(prec.with(next._0))) return;
        f := self.box(self.get_named(next._1, loc));
        arg := self.box(self.pair(prev, rhs, loc));
        call := self.expr((Call = (f = f, arg = arg)), loc);
        return(self.parse_infix(call, prec)); // TODO: tail
    }{|
        return(Ok = prev);  
    };
    ParseRes.unreachable_hack()
}

fn expr_call(self: *Parser, f: FatExpr, arg: FatExpr) FatExpr = {
    // TODO: let else would be nice.
    @match(f.expr) {
        (fn FieldAccess(ff) => {
            // Dot call syntax sugar.
            // TODO: I want this to just call push_arg
            f := self.expr((GetNamed = ff.name), f.loc);
            @match(arg.expr&) {
                // Tuple parser eagerly flattened single tuples so we have to undo that here.
                // TODO: have it work with named arguments. Need to support mixing named and positional.
                (fn Tuple(parts) => {
                    // this goes away when we're fully self hosted. 
                    p := parts[].assume_owned(self.alloc);
                    p&.insert(0, ff.container[]);
                    parts[] = p.rs();
                    return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc));
                });
                // Parser flattened empty tuples.
                (fn Value(v) => {
                    if v.bytes.is_unit() {|
                        return(self.expr((Call = (f = self.box(f), arg = ff.container)), f.loc));
                    };
                    // fallthrough
                });
                // TODO: if the arg is a struct pattern, merge it with f instead of of just appending them.
                //       but this old parser didn't allow mixed named and positional so it doesn't matter yet. :SYNTAX -- Jun 21 
                @default => (); // fallthrough
            };
            arg := self.expr((Tuple = (@list(ff.container[], arg) self.alloc).rs()), f.loc);
            return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc));
        });
        @default => {
            return(self.expr((Call = (f = self.box(f), arg = self.box(arg))), f.loc));
        };
    };
    unreachable()
}

fn push_arg(self: *Parser, call: *FatExpr, callback: FatExpr) void = {
    // TODO: let else would be nice.
    @match(call.expr&) {
        (fn Call(f) => {
            @match(f.arg.expr&) {
                // TODO: have it work with named arguments. Need to support mixing named and positional.
                (fn Tuple(parts) => {
                    // this goes away when we're fully self hosted. 
                    p := parts[].assume_owned(self.alloc);
                    p&.push(callback);
                    parts[] = p.rs();
                });
                // Parser flattened empty tuples.
                (fn Value(v) => {
                    if v.bytes.is_unit() {|
                        f.arg[] = callback;
                    }{|  
                        f.arg[] = self.pair(f.arg[], callback, call.loc);
                    };
                });
                @default => {
                    f.arg = self.box(self.pair(f.arg[], callback, call.loc));
                };
            };
        });
        @default => {
            // It might just be a function access. like 'while {| _ } {| _ }' should be valid.
            call[] = self.expr((Call = (f = self.box(call[]), arg = self.box(callback))), call.loc);
        };
    };
}

:: ?FatExpr;
fn make_func(self: *Parser, def: FnDef, body: ?FatExpr, loc: Span, may_capture: bool) Func = {
    // TODO: derive fn default with allocator
    ::if_opt(FatExpr, FuncImpl);
    f: Func = (
        annotations = def.tags.rs(),
        capture_vars = empty(),
        callees = empty(),
        mutual_callees = empty(),
        // TODO: deconstruct_values doesn't work on @tagged so can't have default struct fields be .None-- Jun 21
        var_name = .None,
        finished_arg = .None,
        finished_ret = .None,
        cc = .None,
        return_var = .None,
        scope = .None,
        body = if(body, fn(body) => (Normal = body), => (Empty = ())),
        arg = def.arg,
        ret = def.ret,
        // TODO: use the body text based on compiler flag. also should an option use file+line? 
        name = def.name.or(=> Flag.Anon.ident()),
        loc = loc,
    );
    
    f&.set_flag(.NotEvilUninit);
    if(may_capture, => f&.set_flag(.AllowRtCapture));
    
    f
}

fn set_flag(self: *Func, flag: FnFlag) void = {
    mask := 1.shift_left(@as(i64) flag);
    new := (@as(i64) self.flags.zext()).bit_or(mask);
    self.flags = new.trunc();
}

fn is_unit(self: Values) bool = {
    @match(self) {
        (fn Small(v_len) bool => v_len._1.eq(0));
        (fn Big() => false);
    }
}

// This starts out with comma seperated expressions and switches to a struct pattern if it hits a colon/equals. 
// So you don't have to know if you're in a struct literal or if a function call uses named arguments ahead of time. 
// TODO: allow 'const' at the beginning to quickly switch to named args cause you must be in a struct definition. 
fn parse_tuple(self: *Parser) ParseRes = {
    loc := self.last.span;
    if self.maybe(@symbol RightParen) {|
        return(Ok = self.raw_unit(loc));
    };
    parts: List(FatExpr) = list(self.alloc);
    
    (=> {
        break :: local_return;
        loop {|
            parts&.push(@try(self.parse_expr(Prec_None)) return);
            @match(self.peek()) {
                (fn RightParen() => { self.pop(); break(); });
                (fn Comma() => {
                    self.pop();
                    if(self.maybe(@symbol RightParen), => break());
                });
                (fn Colon() => {
                    self.pop();
                    e := @try(self.parse_expr(Prec_None)) return;
                    return(self.switch_to_parsing_named(parts, @as(LazyType) (PendingEval = e), loc));
                });
                (fn Equals() => {
                    return(self.switch_to_parsing_named(parts, @as(LazyType) (Infer = unit), loc));
                });
                @default => @report_error("Expected ',' or ':' or '=' or ')' after tuple element %", "") (return, self.last.span);
            };
        };
    })();
    
    // TODO: not sure we want to do this but its what the rust one does. -- Jun 21
    //       (it means you have to do extra work to undo it for dot calls)
    res := @switch(parts.len) {
        @case(0) => self.raw_unit(loc);
        @case(1) fn() FatExpr => {
            // TODO: defer
            e := parts[0];
            parts&.drop();
            e
        };
        @default fn(_: i64) => self.expr((Tuple = parts.rs()), loc);
        // TODO: if you forget that semicolon it doesn't see the default and crashes at runtime if you ever hit it. :FUCKED
    };
    
    (Ok = res)
}

// TODO: allow 'name :: value' in @struct. :SYNTAX

fn switch_to_parsing_named(self: *Parser, parts: List(FatExpr), ty: LazyType, loc: Span) ParseRes = {
    // Decided the last thing was actually a name for a named argument
    // TODO: let else
    ident_expr := parts&.pop().unwrap();
    name: Symbol = @match(ident_expr.expr) {
        (fn GetNamed(name: Symbol) Symbol => { name });
        @default => @report_error("Expected Ident before ':'/'=' in argument pattern. %", "") (return, ident_expr.loc);
    };
    
    ::if(?FatExpr);
    default: ?FatExpr = if (self.maybe(@symbol Equals)) {|
        e := @try(self.parse_expr(Prec_None)) return;
        (Some = e)
    } {|
        (None = unit)
    };
    
    bindings: List(Binding) = list(parts.len().add(1), self.alloc);
    for parts {e|
        // Allow mixed named and positional for function calls. 
        anon: Binding = (name = .None, ty = (Infer = unit), default = (Some = e), kind = .Var);
        bindings&.push(anon);
    };
    first_named: Binding = (name = (Ident = name), ty = ty, default = default, kind = .Var);
    bindings&.push(first_named);
    
    self.maybe(@symbol Comma);
    @try(self.parse_pattern(bindings&)) return;
    @try(self.eat(@symbol RightParen, "')' to end argument list")) return;
    return(Ok = self.expr((StructLiteralP = (bindings = bindings.rs(), loc = loc)), loc))
};

fn if_empty_add_unit(self: *List(Binding)) void = {
    if self.len.eq(0) {|
        b: Binding = (
            name = .None,
            ty = (Finished = void),
            default = .None,
            kind = .Let,
        );
        self.push(b);
    }
}
    
fn parse_args(self: *Parser) Result(Pattern, ParseErr) = {
    loc := self.last.span;
    bindings: List(Binding) = list(self.alloc);
    @try(self.parse_pattern(bindings&)) return;
    bindings&.if_empty_add_unit();
    (Ok = (bindings = bindings.rs(), loc = loc))
}

fn parse_pattern(self: *Parser, out: *List(Binding)) Result(void, ParseErr) = {
    loop {|
        // TODO: no comma allowed here
        // TODO: destructuring
        // TODO: shouldnt have to put the type annotations everywhere. 
        T :: Ty(Symbol, VarType);
        name_kind: T = @match(self.peek()) {
            (fn RightParen() T => {
                return(.Ok)
            });
            (fn Const() T => {
                self.pop();
                // TODO: better let else.
                name: Symbol = @try(self.pop_name("after 'const'")) return;
                (name, VarType.Const)
            });
            (fn Symbol(name) T => {
                self.pop();
                (name, VarType.Var)
            });
            // TODO: moving this up crashes????? :FUCKED
            //       but also we dont need this here for now. 
            //(fn Pipe() T => return(.Ok));
            @default => @report_error("Expected Ident or 'const' before pattern entry. (positional args cannot follow named) %", "") (return, self.last.span);
        };
        
        ::if(LazyType);
        ty: LazyType = if self.maybe(@symbol Colon) {|
            // deal with := 
            @match(self.peek()) {
                (fn Equals() LazyType => (Infer = unit));
                @default fn() LazyType => {
                    e := @try(self.parse_expr(Prec_None)) return;
                    (PendingEval = e)
                };
            }
        } {|
            (Infer = unit)
        };
        
        ::if(?FatExpr);
        default: ?FatExpr = if self.maybe(@symbol Equals) {|
            e := @try(self.parse_expr(Prec_None)) return;
            (Some = e)
        } {|
            (None = unit)
        };
        b: Binding = (name = (Ident = name_kind._0), ty = ty, default = default, kind = name_kind._1);
        out.push(b);
        if not(self.maybe(@symbol Comma)) {|
            return(.Ok);
        };
    };
    unreachable()
}

fn pop_name(self: *Parser, msg: Str) Result(Symbol, ParseErr) = {
    n := @match(self.peek()) {
        (fn Symbol(name) Symbol => {
            self.pop();
            name
        });
        @default => @report_error("Expected Ident %", msg) (return, self.last.span);
    };
    (Ok = n)
}

FnDef :: @struct(name: ?Symbol, arg: Pattern, ret: LazyType, tags: List(Annotation));
fn fn_def_signeture(self: *Parser, loc: Span, allow_name: bool) Result(FnDef, ParseErr) = {
    ::if(?Symbol);
    name: ?Symbol = if(not(allow_name), => (None = unit)) {|
        @match(self.peek()) {
            (fn Symbol(name) ?Symbol => {
                self.pop();
                (Some = name)
            });
            @default fn() ?Symbol => (None = unit);
        }
    };
    cant_start_return_expression :: fn(t: TokenType) bool = {
        @match(t) {
            (fn Equals() => true);
            (fn Semicolon() => true);
            (fn Pipe() => true);
            (fn FatRightArrow() => true);
            (fn Hash() => true);
            @default => false;
        }
    };
    no_paren := false;
    disallow_return := false;
    ::if(Pattern);
    arg: Pattern = if self.maybe(@symbol LeftParen) {|
        a := @try(self.parse_args()) return;
        @try(self.eat(@symbol RightParen, "')' to end argument list")) return;
        a
    } {|
        no_paren = true;
        if allow_name.or(cant_start_return_expression(self.peek())) {|
            (bindings = empty(), loc = self.last.span)
        } {|
            disallow_return = true;
            @try(self.parse_args()) return
        }
    };

    if no_paren.and(not(cant_start_return_expression(self.peek()))) {|
        @report_error("'fn <Expr> =' can't treat Expr as ret type. pls specify name or args. %", "") (return, self.last.span);
    };

    ret: LazyType = if not(cant_start_return_expression(self.peek())) {|
        (PendingEval = @try(self.parse_expr(Prec_None)) return)
    } {|
        (Infer = unit)
    };
    tags := @try(self.parse_annotations()) return;

    (Ok = (name = name, arg = arg, ret = ret, tags = tags))
}

// Consumes '}'
fn parse_block_until_squiggle(self: *Parser, allow_eof: bool) ParseRes = {
    loc := self.last.span;
    stmts: List(FatStmt) = list(self.alloc);
    
    while(=> not(self.maybe(@symbol RightSquiggle)).and(not(allow_eof).or(=> not(self.maybe(@symbol Eof)))) ) {|
        if self.maybe(@symbol Eof) {|
            @report_error("unexpected end of file %", "") (return, self.last.span);
        };
        s := @try(self.parse_stmt()) return;
        stmts&.push(s);
    };
    
    // TODO: :dont_store_noop
    ::if_opt(FatStmt, FatExpr);
    result: FatExpr = if(stmts&.pop()) {stmt|
        @match(stmt.stmt) {
            (fn Eval(e) FatExpr => e);
            (fn Noop() => {
                // It might be #include_std
                if stmt.annotations.len.ne(0) {|
                    stmts&.push(stmt);
                };
                self.raw_unit(self.last.span)
            
            });
            @default => {
                // block might end with a func decl with no semicolon.
                stmts&.push(stmt);
                self.raw_unit(self.last.span)
            };
        }
    }{|
        self.raw_unit(self.last.span)
    };
    
    e := self.expr((Block = (body = stmts.rs(), result = self.box(result), ret_label = .None, hoisted_constants = false)), loc);
    (Ok = e)
}

::if(?FatExpr);
fn parse_annotations(self: *Parser) Result(List(Annotation), ParseErr) = {
    tags: List(Annotation) = list(self.alloc);
    while(=> self.maybe(@symbol Hash)) {|
        name := @try(self.pop_name("ident after '#'")) return;
        arg: ?FatExpr = if self.maybe(@symbol LeftParen) {|
            (Some = @try(self.parse_tuple()) return)
        } {| .None };
        tags&.push((name = name, args = arg));
    };
    (Ok = tags)
}

// TODO: be able to eq on tagged
fn maybe(self: *Parser, const type: Symbol) bool = {
    t := self.peek();
    v :: tag_value(TokenType, type);
    yes := t&!tag[].eq(v);
    if(yes, => { self.pop(); });
    yes
}

fn eat(self: *Parser, const type: Symbol, msg: Str) Result(void, ParseErr) = {
    t := self.peek();
    if not(self.maybe(type)) {|
        s :: type.str();
        @report_error("Expected % for %", s, msg) (return, self.last.span);
    };
    (Ok = unit)
}

fn raw_unit(self: *Parser, loc: Span) FatExpr = {
    e := self.expr((Value = (bytes = (Small = (0, 0)), coerced = false)), loc);
    e.ty = void;
    e
}

fn get_named(self: *Parser, name: Flag, loc: Span) FatExpr = 
    self.expr((GetNamed = name.ident()), loc);

fn bang(self: *Parser, name: Flag, arg: FatExpr, loc: Span) FatExpr = 
    self.expr((SuffixMacro = (name = name.ident(), arg = self.box(arg))), loc);

fn bin_named_macro(self: *Parser, name: Flag, arg: FatExpr, target: FatExpr, loc: Span) FatExpr = {
    handler := self.box(self.get_named(name, loc));
    self.expr((PrefixMacro = (handler = handler, arg = self.box(arg), target = self.box(target))), loc)
}

fn expr(self: *Parser, e: Expr, loc: Span) FatExpr = 
    (expr = e, loc = loc, ty = UnknownType, done = false);

fn stmt(self: *Parser, e: Stmt, loc: Span) FatStmt = 
    (stmt = e, annotations = RsVec(Annotation).zeroed(), loc = loc);
    
fn box();
fn PBox(const T: Type) void = {
    fn box(self: *Parser, e: T) *T = {
        out := self.alloc.alloc(T, 1);
        out.ptr[] = e;
        out.ptr
    }
}
::PBox(FatExpr); ::PBox(Func);

fn pair(self: *Parser, lhs: FatExpr, rhs: FatExpr, loc: Span) FatExpr = {
    out := self.alloc.alloc(FatExpr, 2);
    out[0] = lhs;
    out[1] = rhs;
    self.expr((Tuple = (cap = 2, ptr = out.ptr, len = 2)), loc)
}

fn pop(self: *Parser) TokenType = {
    self.last = self.lex&.peek()[];
    self.lex&.pop();
    self.last.type
}

fn peek(self: *Parser) TokenType = {
    token := self.lex&.peek()[];
    token.type
}

fn report_error(fmt_args: FatExpr, ret_loc: FatExpr) FatExpr #macro = {
    assert_eq(ret_loc.expr&!tag[], tag_value(Expr, @symbol Tuple));
    args := FatExpr.slice_from_tuple(ret_loc.expr.Tuple);
    result := '{
        lst := @format(@[fmt_args]) temp();
        println(lst.items());
        res: ParseErr = (span = @[args[1]], msg = lst.items());
        @[args[0]](Err = res);
        unreachable()
    }';
    result
}

// TODO: you need from_residual so you can have it work when different ok types but the same error type. 
// TOOD: this doesn't even have to be a macro cause i have non-local returns... if i had better polymorphism. 
fn try(maybe: FatExpr, ret: FatExpr) FatExpr #macro= '{
    m := @[maybe];
    if(m&.is_err(), => @[ret](Err = m.unwrap_err()));
    m.unwrap()
}';

fn parser_doesnt_crash() #test = {
    pool: StringPool = init(temp());
    
    codemap: CodeMap = init(temp());
    src := (
        "a + 1;", 
        "a[] + b[] * c;",
        "a[] * c + b[];",
        "-a + b;",
        "a + -b == c[123];",
        "a - -b > -c&[] != !true;",
        "a <= c == b >= d;",
        "hello&;",
        "a :: hello + world;",
        "a := b;",
        "a: b = c",
        "a: b : c",
        "(a, b + c);",
        "();",
        "(a = b, c = d);",
        "(a, b, c = d);",
        "{ a; b };",
        "{ a; };",
        "a(b, c);",
        "a();",
        "a(b, c = d);",
        "a(b = c);",
        "a.f(b);",
        "a.f(b = c);", // TODO: this kinda parses wrong. it gives f(a, (b = c)) instead of f(a, b = c).
        "a.f();",
        "a + ::b * c;", // TODO: add weird precidence test
        "a = b;",
        "a[] = b;",
        "a[b] = c;",
        "{ a += b; c -= d; e *= f; g /= h };",
        ".None;",
        "'a + @[b]';",
        "@a(b) c;",
        "@a(b);",
        "@a b;",
        "@(a(d))(b) c;",
        "a(f, g) { (b: c) d| e };",
        "a(!b(c)) {| d };",
        "a !b(c) {| d };",
        "a(b(c) {| d });",
        "a() + b() * c();",
        "a() * b() + c();",
        "?a(b) + c;",
        "a.b;",
        "*T;",
        "a&!tag[] + b;",
        "0xABC + 0b10101;",
        "(fn hello(a: b) c => d);",
        "fn hi(a: b) c #d #e(f);",
        "a(=> b);",
    )!slice;
    
    // TODO: if you make the stack slice too large it segfaults.. sometimes ?? in rust debug mode it just miscompiles ?SA?EQ@?QW#F>FKLQW? :FUCKED -- Jun 22
    src := src.clone(temp());
    
    src&.push_all((
        "{ fn a() b = { c }; d };",
        "a :: @struct(a: @struct(e: f), c: d);",
        "a :: @struct(b: B, c: C, d: D);",
        "for parts {e| a };",
        "#macro fn a() b = c;",
        "1.2;",
        "fn neg(a: f64) f64 = sub(0.0, a);",
        "fn hello(const a: T) b;",
        "TermConstants :: @struct(_parsehack: void, const ICANON := 256, const ECHO := 8);",
        "@[@literal(as)];",
        "'@(@[@literal(as)])(@[@literal(T)]) @[expr]';",
        "Type :: Type!builtin;", 
    )!slice);
    
    //s := temp().read_to_string("parse.fr");
    //s&.insert(0, "{".ascii());
    //s&.push_all("\n};");
    //src&.push(s.items());
    
    //s := temp().read_to_string("../lib/math.fr");
    //s&.insert(0, "{".ascii());
    //s&.push_all("\n};");
    //src&.push(s.items());
    
    failed := false;
    for src {src|
        span := codemap&.add_file("name", src);
        tasks: List(ParseTask) = list(temp());
        lex: Lexer = init(pool&, span, src); // TODO: shadow
        ctx: Parser = (pool = pool&, lex = lex, tasks = tasks&, alloc = temp(), last = Token.zeroed());
        tasks&.push((Pending = (src = src, span = span)));
        res := ctx&.parse_stmt();
        @match(res) {
            (fn Ok(t) => {
                out: List(u8) = list(temp());
                t&.log(pool&, out&, 0);
                println(codemap&.source_slice(t.loc));
                println(out.items());
                next_token := ctx.lex&.pop(); // TODO: i think this should just be peek once i consume semicolons? 
                if next_token.type&!tag[].eq(tag_value(TokenType, @symbol Eof)).not() {|
                    failed = true;
                    println("parser did not consume all input.");
                };
            });
            (fn Err(e) void => {
                //place: Span = (low = e.span.low.sub(10), high = e.span.high.add(10));
                place := e.span;
                @println("err! % at:\n%", e.msg, codemap&.source_slice(place));
                failed = true;
            });
        };
    };
    assert(not(failed), "parse failed");
}

fn int(self: PrecLevel) i64 = @as(i64) self;
::Ord(PrecLevel);
