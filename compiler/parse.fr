ParseTask :: @tagged(
    Pending: @struct(src: Str, span: Span),
    Expr: FatExpr,
    Stmt: FatStmt,
    Err: ParseErr, 
);
Parser :: @struct(lex: Lexer, tasks: *List(ParseTask), alloc: Alloc, last: Token);
ParseErr :: @struct(span: Span, msg: Str);
Prec :: @enum(i64) (
    None,
    TypeModifier,
    Equality,
    Comparison,
    AddSub,
    MulDiv,
    Neg,
    Suffix,
);
ParseRes :: Result(FatExpr, ParseErr);

// TODO: non-existant field name for @tagged is a panic because its in a mut_replace. 
fn parse_expr(self: *Parser, id: i64) ParseRes = {
    self.lex&.peek();
    // TODO: can't access field on rvalue. 
    // TODO: you can't return a pair at comptime if its not a pair of ints. (u32, u32) gives back 16 bytes from ffi::c and then compiler::jit crashes on it for being the wrong size. 
    self.parse_prefix()
}

fn parse_prefix(self: *Parser) ParseRes = {
    return :: @return;
    @match(self.peek()) {
        (fn Op(op) => {
            todo();
        });
        (fn LeftSquiggle() => {
            todo();
        });
        (fn LeftParen() => {
            todo();
        });
        (fn At() => @match(self.pop()) {
            (fn LeftSquare() => {
                todo();
            });
            (fn LeftParen() => {
                todo();
            });
            (fn Symbol(name) => {
                todo();
            });
            @default => {
                @report_error("@ must be followed by @[ast_expr] or @(macro_expr) or @macro_name %", "") (return, self.last.span);
            };
        });
        (fn FatRightArrow() => {
            todo();
        });
        (fn DoubleColon() => {
            todo();
        });
        (fn Amp() => {
            todo();
        });
        (fn Question() => {
            todo();
        });
        (fn Fn() => {
            todo();
        });
        (fn SingleQuote() => {
            todo();
        });
        (fn Number(n) => {
            todo();
        });
        (fn BinaryNum(n) => {
            todo();
        });
        (fn Dot() => {
            todo();
        });
        (fn Quoted(s) => {
            todo();
        });
        (fn Symbol(name) => {
            @report_error("An identifier! %", self.lex.pool.get(name)) (return, self.last.span);
        });
        @default => {
            @report_error("Expected begin expression %", 1) (return, self.last.span);
        };
    };
    ParseRes.unreachable_hack()
}

fn parse_infix(self: *Parser, prev: FatExpr, prec: Prec) ParseRes = {
    return :: @return;
    @match(self.peek()) {
        (fn Op(op) => {
            todo();
        });
        (fn EqOp(op) => {
            todo();
        });
        (fn LeftParen() => {
            todo();
        });
        (fn Dot() => {
            todo();
        });
        (fn Bang() => {
            todo();
        });
        (fn LeftSquiggle() => {
            todo();
        });
        (fn DoubleSquare() => {
            todo();
        });
        (fn Amp() => {
            todo();
        });
        (fn LeftSquare() => {
            todo();
        });
        @default => return(prev);
    };
    ParseRes.unreachable_hack()
}

fn pop(self: *Parser) TokenType = {
    self.last = self.lex&.peek()[];
    self.lex&.pop();
    self.last.type
}

fn peek(self: *Parser) TokenType = {
    token := self.lex&.peek()[];
    token.type
}

#macro fn report_error(fmt_args: FatExpr, ret_loc: FatExpr) FatExpr = {
    assert_eq(ret_loc.expr&!tag[], tag_value(Expr, @symbol Tuple));
    args := FatExpr.slice_from_tuple(ret_loc.expr.Tuple);
    result := '{
        lst := @format @[fmt_args]; // LEAK
        res: ParseRes = (Err = (span = @[args[1]], msg = lst.items()));
        @[args[0]](res);
        ParseRes.unreachable_hack();
    }';
    result
}
//(Ok = (expr = (GetNamed = (id = 0.trunc())), loc = fuck, ty = UnknownType, done = true))

#test fn parser_doesnt_crash() = {
    pool: StringPool = init(temp());
    codemap: CodeMap = init(temp());
    src := "a + 1";
    span := codemap&.add_file("name", src);
    tasks: List(ParseTask) = list(temp());
    ctx: Parser = (lex = init(pool&, span, src), tasks = tasks&, alloc = temp(), last = Token.zeroed());
    tasks&.push((Pending = (src = src, span = span)));
    res := ctx&.parse_expr(0);
    @match(res) {
        (fn Ok(t) => println("parsed!"));
        (fn Err(e) Unit => @println("err! %", e.msg));
    };
}

fn int(self: Prec) i64 = @as(i64) self;
::Ord(Prec);

fn Ord(const T: Type) Unit = {
    fn eq(lhs: T, rhs: T) bool = lhs.int().eq(rhs.int());
    fn ne(lhs: T, rhs: T) bool = lhs.int().ne(rhs.int());
    fn lt(lhs: T, rhs: T) bool = lhs.int().lt(rhs.int());
    fn le(lhs: T, rhs: T) bool = lhs.int().le(rhs.int());
    fn gt(lhs: T, rhs: T) bool = lhs.int().gt(rhs.int());
    fn ge(lhs: T, rhs: T) bool = lhs.int().ge(rhs.int());
}
