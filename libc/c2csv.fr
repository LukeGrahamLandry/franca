C   :: import("@/examples/import_c/lib.fr");
Ffi :: import("@/examples/import_c/ffi.fr");
#include_std("backend/lib.fr");
#include_std("compiler/worker.fr");
#use("@/lib/sys/fs.fr");

//input_path :: "/Users/luke/Downloads/cosmopolitan-master/libc/nt/errors.h";
input_path :: "cosmo.txt";
//driver :: eval_and_dump_defined_numbers;
driver :: count_token_bytes;

count_token_bytes :: fn(vtable: *ImportVTable) void = {
    a := general_allocator();
    src := read_to_string_or_crash(a, input_path).items();
    m := a.box(QbeModule);
    c := a.box_zeroed(C'Compile.Ctx);
    init_default_module_dyn(m, vtable, (arch = .aarch64, os = .macos, type = .JitOnly));
    C'init_ctx(c, m);
    c.track_blanks = true;
    
    new_src := u8.list(src.len, a);
    old_src := src.shallow_copy(a);
    defines_csv := u8.list(a);
    comment_bytes := 0;
    blank_bytes := 0;
    includes := 0;
    defines := 0;
    total_bytes := 0;
    licenses: HashMap(Str, i64) = init(a);
    
    result := catch_call(c, void) {
        tok := c.tokenize_string("import_cTODO", src);
        while => tok.kind != .TK_EOF {
            if equal(tok, "#") && equal(tok.next, "define") {
                name  := tok.next.next;
                while(=> name.kind == .TK_BLANK, => { name = name.next; });
                value := name.next;
                while(=> value.kind == .TK_BLANK, => { value = value.next; });
                if value.next.at_bol {
                    @fmt(defines_csv&, "%, %\n", name.str(), value.str());
                    defines += 1;
                }
            }
            
            if equal(tok, "#") && equal(tok.next, "include") {
                name := tok.next.next;
                while(=> name.kind == .TK_BLANK, => { name = name.next; });
                if name.next.at_bol {
                    includes += 1;
                }
            }

            s := tok.str();
            @if(tok.kind == .TK_BLANK)
            if s.starts_with("/") {
                comment_bytes += s.len();
                if s.contains("Copyright") {
                    get_or_insert(licenses&, s, => 0)[] += 1;
                }
            } else {
                blank_bytes += tok.str().len();
            }
            
            if tok.at_bol {
                new_src&.push_all("\n");
                blank_bytes += 1;
            }
            new_src&.push_all(s);
            
            tok = tok.next;
        };
    };
    or(result, fn(e) => panic(e));
    
    license_bytes := 0;
    each licenses& { text, count |
        @println("# % * % bytes", count, text.len);
        license_bytes += count[] * text.len;
        println(text);
    };
    
    @eprint("% includes\n% simple defines\n% bytes total\n- % bytes comments\n - % bytes licenses\n- % bytes whitespace\n", 
        includes, defines, new_src.len, comment_bytes, license_bytes, blank_bytes);
    
    // starts with at_bol=true so there's an incorrect new line at the beginning
    new_src := new_src.items().rest(1);
    if new_src != old_src {
        @panic("import_c/tokenize was not lossless");
    }
    
    // write_entire_file("b2.txt", new_src); 
    // print(defines_csv.items());
}

eval_and_dump_defined_numbers :: fn(vtable: *ImportVTable) void = {
    eval_and_dump_defined_numbers_impl(vtable);
};

eval_and_dump_defined_numbers_impl :: fn(vtable: *ImportVTable) void = {
    a := general_allocator();
    src := read_to_string_or_crash(a, input_path).items();
    m := a.box(QbeModule);
    c := a.box_zeroed(C'Compile.Ctx);
    init_default_module_dyn(m, vtable, (arch = query_current_arch(), os = query_current_os(), type = .JitOnly));
    C'init_ctx(c, m);
    
    out := u8.list(a);
    @fmt(out&, "int printf(char*, ...);\nvoid main() {\n");
    result := catch_call(c, void) {
        tok := c.tokenize_string("phase1", src);
        names := collect_defined_names(tok);
        tok  = c.C'Preprocess'preprocess(tok);
        
        names = names.slice(0, 1); // TODO: remove me!
        // not just doing `each c.macros& { name, _ |` because i want to preserve order 
        for names { name | 
            @fmt(out&, "%, \"%\", %);\n", """printf("%s,%d\n" """, name, name);
        };
        @fmt(out&, "}\n");
        print(out.items());
        tok := c.tokenize_string("phase2", out.items());
        tok  = c.C'Preprocess'preprocess(tok);
        obj := c.parse(tok);
        codegen_thread_main := ptr_cast_unchecked(@type vtable.codegen_thread_main, CodegenWorker, vtable.codegen_thread_main&)[];
        ctx: *CodegenShared = init(m, a, codegen_thread_main, false);
        emit_the_code(c, ctx, obj);
        //join_codegen_thread(ctx);
        
        //printf :: fn(fmt: CStr) void #c_variadic #libc;
        //use_symbol(m, m.intern("printf")) { symbol |
        //    it: rawptr = printf;
        //    m.do_fixups(it, symbol);
        //};
        //puts :: fn(fmt: CStr) void #libc;
        //use_symbol(m, m.intern("puts")) { symbol |
        //    m.do_fixups(@as(rawptr) puts, symbol);
        //};
        
        @if(is_linking_libc()) import("@/backend/meta/qbe_frontend.fr")'fill_from_libc(m);

        m.make_exec();
        f, _ := m.get_addr(m.intern("main")) 
            || @panic("missing function main()");
        f := assume_types_fn(Arg = void, Ret = void, ptr = f);
        f();
    };
    or(result, fn(e) => panic(e));
}

collect_defined_names :: fn(tok: *C'Tokens'Token) []Str #inline = {
    names := Str.list(temp());
    while => !tok.is_null() && tok.kind != .TK_EOF {
        if equal(tok, "#") && equal(tok.next, "define") {
            name  := tok.next.next;
            while(=> name.kind == .TK_BLANK, => { name = name.next; });
            // Skip if no value
            if !name.next.at_bol && name.str() != "#" {
                names&.push(name.str());
            }
        }
        tok = tok.next;
    };
    names.items()
}
