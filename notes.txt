
## Value Repr

A tuple is a value type. Some range of memory on the stack/heap. 
Passing a tuple to a function is always conceptually a memcpy from the old location into the callees's stackframe. 
Some types are Move but not Copy so passing by value invalidates the original data (Drop will not be called on the original). 
Move is a semantic construction, it doesn't actually change the calling convention. 
Structs have the same repr as tuples, just with syntax for accessing named fields. 
All scalars (numbers, ptrs) in the interpreter take one Stack Slot, a tuple is a range of stack slots. 

## Variables 

runtime cvar capture is by just inlining the function.
comptime var capture is by copying it into the function object (always immutable). 
const means constant to the function's compilation. 
comptime functions can still have let/var. 
types and closures fns can only be in consts or in comptime variables. 

## Other Notes

// opt: pass by &const if not mutated. Have some way to assert that in the function def so you don't accidently cause copies. 
//      But I don't like Zig's way of forcing you to writing a whole line assigning to a new variable. 
//      LAMO https://github.com/ziglang/zig/issues/16343
//      Maybe like rust where you just write 'mut' on the arg but don't add a keyword. 
//      Distinguish between wanting to mutate the caller's value (explicit pass ptr), 
//      and wanting to mutate your copy. Make sure you can't make the mistake of taking address to mutate and getting caller's. 
//      Distinguish logical mutation (like through a pointer) and reassignment (where you change what's in the stack slot)? 
