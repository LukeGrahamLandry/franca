
## Value Repr

A tuple is a value type. Some range of memory on the stack/heap. 
Passing a tuple to a function is always conceptually a memcpy from the old location into the callees's stackframe. 
Some types are Move but not Copy so passing by value invalidates the original data (Drop will not be called on the original). 
Move is a semantic construction, it doesn't actually change the calling convention. 
Structs have the same repr as tuples, just with syntax for accessing named fields. 
All scalars (numbers, ptrs) in the interpreter take one Stack Slot, a tuple is a range of stack slots. 

## Variables 

runtime cvar capture is by just inlining the function.
comptime var capture is by copying it into the function object (always immutable). 
const means constant to the function's compilation. 
comptime functions can still have let/var. 
types and closures fns can only be in consts or in comptime variables. 

## Other Notes

// opt: pass by &const if not mutated. Have some way to assert that in the function def so you don't accidently cause copies. 
//      But I don't like Zig's way of forcing you to writing a whole line assigning to a new variable. 
//      LAMO https://github.com/ziglang/zig/issues/16343
//      Maybe like rust where you just write 'mut' on the arg but don't add a keyword. 
//      Distinguish between wanting to mutate the caller's value (explicit pass ptr), 
//      and wanting to mutate your copy. Make sure you can't make the mistake of taking address to mutate and getting caller's. 
//      Distinguish logical mutation (like through a pointer) and reassignment (where you change what's in the stack slot)? 

// Goal: I want to not need the linker. 
//       If you don't want to interact with other languages you should be able to run my compiler and then have a program. 
//       Go's compiler stuff seems pretty good, that might be a good one to steal. 
//       https://www.youtube.com/watch?v=KINIAgRpkDA&list=PLtLJO5JKE5YCcdJGpmMqB8L4C4VNFN7gY
//       If I use their stuff, be careful about too many calls between rust and go...
//           But I assume c abi is only slow if you're trying to use goroutines which I don't care about. 
//           - https://shane.ai/posts/cgo-performance-in-go1.21/
//           - https://www.reddit.com/r/golang/comments/12nt2le/when_dealing_with_c_when_is_go_slow/
//       I need to be very careful about sharing common work between similar backends if I want to pull off having so many. 

// I want to keep the interpreter using fully linear types in debug mode, 
// but have them happen to work out as a normal stack so you can have a fast mode that just skips the redundant stuff. 
// I wonder if I would then be easy to do wasm since that's also stack based. 
// I'd be fine with tweaking my bytecode a bit to make that work better.
